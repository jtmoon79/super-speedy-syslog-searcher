Linux host 5.15.167.4-microsoft-standard-WSL2 #1 SMP Tue Nov 5 00:21:55 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux
71d1a55a HEAD -> main, origin/main, origin/HEAD
super_speedy_syslog_searcher 0.7.76
valgrind-3.23.0

--------------------------------------------------------------------------------
Profile data file './callgrind.out' (creator: callgrind-3.23.0)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 80011288
Trigger: Program termination
Profiled target:  ./target/valgrind/s4 -a 20000101T000000 -b 20000101T080000 ./logs/other/tests/gen-1000-3-foobar.log (PID 243060, part 1)
Events recorded:  Ir Ge sysCount sysTime
Events shown:     Ir Ge sysCount sysTime
Event sort order: Ir Ge sysCount sysTime
Thresholds:       99 0 0 0
Include dirs:     ./src/
                  ./src/data/
                  ./src/tests/
                  ./src/libload/
                  ./src/bindings/
                  ./src/debug/
                  ./src/bin/
                  ./src/readers/
                  ./src/printer/
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                   Ge               sysCount     sysTime        
--------------------------------------------------------------------------------
347,460,469 (100.0%) 810,187 (100.0%) 324 (100.0%) 1,377 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                  Ge               sysCount     sysTime      file:function
--------------------------------------------------------------------------------

45,722,938 (13.16%)  11,102 ( 1.37%)  75 (23.15%)  1 ( 0.07%)  < ./malloc/./malloc/malloc.c:malloc (192,052x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
13,040,321 ( 3.75%)  21,698 ( 2.68%)  81 (25.00%)  .           < ./malloc/./malloc/malloc.c:_int_realloc (25,120x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   213,961 ( 0.06%)     277 ( 0.03%)   .           .           < ./malloc/./malloc/malloc.c:calloc (1,327x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    31,691 ( 0.01%)       .            .           .           < ./malloc/./malloc/malloc.c:_int_memalign (121x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
       629 ( 0.00%)       0            2 ( 0.62%)  .           < ./malloc/./malloc/malloc.c:tcache_init.part.0 (3x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
45,418,738 (13.07%)   8,083 ( 1.00%)   .           .           *  ./malloc/./malloc/malloc.c:_int_malloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
11,952,466 ( 3.44%)  24,990 ( 3.08%)   .           .           >   ./malloc/./malloc/malloc.c:malloc_consolidate (2,499x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 1,618,890 ( 0.47%)       .            .           .           >   ./malloc/./malloc/malloc.c:unlink_chunk.constprop.0 (66,838x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    19,446 ( 0.01%)       4 ( 0.00%) 158 (48.77%)  1 ( 0.07%)  >   ./malloc/./malloc/malloc.c:sysmalloc (157x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

35,187,937 (10.13%) 261,143 (32.23%)   .           .           < ./malloc/./malloc/malloc.c:free (386,127x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 2,445,913 ( 0.70%)   2,102 ( 0.26%)   .           .           < ./malloc/./malloc/malloc.c:_int_realloc (28,259x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    41,422 ( 0.01%)     721 ( 0.09%)   .           .           < ./malloc/./malloc/malloc.c:__malloc_arena_thread_freeres (381x)
    13,546 ( 0.00%)      91 ( 0.01%)   .           .           < ./malloc/./malloc/malloc.c:_int_memalign (170x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
34,786,765 (10.01%) 262,137 (32.36%)   .           .           *  ./malloc/./malloc/malloc.c:_int_free [/usr/lib/x86_64-linux-gnu/libc.so.6]
 2,719,333 ( 0.78%)   1,920 ( 0.24%)   .           .           >   ./malloc/./malloc/malloc.c:malloc_consolidate (192x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   177,705 ( 0.05%)       .            .           .           >   ./malloc/./malloc/malloc.c:unlink_chunk.constprop.0 (7,174x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

68,158,577 (19.62%) 393,828 (48.61%)  75 (23.15%)  1 ( 0.07%)  < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/alloc.rs:__rdl_alloc (402,406x)
     3,714 ( 0.00%)      22 ( 0.00%)   7 ( 2.16%)  .           < ./malloc/./malloc/malloc.c:realloc (6x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     2,226 ( 0.00%)       2 ( 0.00%)   3 ( 0.93%)  .           < ???:0x0000000004898380 (4x) [???]
20,331,141 ( 5.85%) 382,734 (47.24%)   .           .           *  ./malloc/./malloc/malloc.c:malloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
45,722,938 (13.16%)  11,102 ( 1.37%)  75 (23.15%)  1 ( 0.07%)  >   ./malloc/./malloc/malloc.c:_int_malloc (192,052x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     2,960 ( 0.00%)      16 ( 0.00%)   9 ( 2.78%)  .           >   ./malloc/./malloc/malloc.c:tcache_init.part.0 (3x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 8,709,129 ( 2.51%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:alloc::vec::Vec<T,A>::extend_with (669,933x)
 5,344,444 ( 1.54%)       .            .           .           < ???:0x0000000004898620 (25,139x) [???]
   773,760 ( 0.22%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::translate::TranslatorI::push_char (48,360x)
   264,180 ( 0.08%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::Hir::concat (15,408x)
   254,160 ( 0.07%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (8,472x) [./target/valgrind/s4]
   223,949 ( 0.06%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::literal::Extractor::cross (13,790x)
   191,190 ( 0.06%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (6,373x)
   189,060 ( 0.05%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (6,302x) [./target/valgrind/s4]
   182,954 ( 0.05%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x)
   169,440 ( 0.05%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (5,648x) [./target/valgrind/s4]
   169,440 ( 0.05%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op (5,648x) [./target/valgrind/s4]
   167,610 ( 0.05%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (5,587x)
   155,904 ( 0.04%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::nfa::thompson::builder::Builder::build (12,029x)
   149,644 ( 0.04%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (2,824x)
   129,570 ( 0.04%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (4,319x)
    84,720 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (2,824x)
    84,720 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op (2,824x)
    82,740 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (2,758x) [./target/valgrind/s4]
    82,590 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (2,753x)
    82,590 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (2,753x) [./target/valgrind/s4]
    82,590 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (2,753x)
    69,914 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:<T as alloc::vec::spec_from_elem::SpecFromElem>::from_elem (5,378x)
    68,970 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,299x)
    56,690 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add (4,122x)
    50,625 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::new (405x) [./target/valgrind/s4]
    41,720 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::literal::Extractor::extract'2 (2,411x)
    38,848 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::literal::PreferenceTrie::insert (2,611x)
    35,609 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::meta::reverse_inner::flatten'2 (2,071x)
    29,938 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:<alloc::string::String as core::fmt::Write>::write_str (1,871x)
    27,643 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:<alloc::vec::Vec<T,A> as core::clone::Clone>::clone (1,589x)
    24,523 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:aho_corasick::packed::pattern::Patterns::add (1,394x)
    19,963 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (980x)
    18,407 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:<alloc::string::String as core::clone::Clone>::clone (1,189x)
    16,604 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,318x)
    15,360 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (512x)
    11,440 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::interval::IntervalSet<I>::union (903x)
    11,375 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build (175x) [./target/valgrind/s4]
    11,363 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x)
    11,282 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend (81x)
    11,214 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex::builders::Builder::build_one_bytes (80x)
    11,136 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (144x) [./target/valgrind/s4]
    10,638 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (773x)
     9,120 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:aho_corasick::nfa::noncontiguous::Builder::build (96x)
     9,097 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (586x)
     9,097 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::util::captures::GroupInfo::new (586x)
     8,533 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/pool.rs:regex_automata::util::pool::inner::Pool<T,F>::get_slow (53x) [./target/valgrind/s4]
     6,967 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::Edge>::insert_recursing (531x)
     6,890 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::meta::wrappers::Hybrid::create_cache (106x)
     6,006 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_automata::util::prefilter::teddy::Teddy::new (78x)
     6,006 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/prefilter/mod.rs:regex_automata::util::prefilter::Choice::new (78x) [./target/valgrind/s4]
     5,353 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::create_cache (53x) [./target/valgrind/s4]
     5,353 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_automata::meta::wrappers::Hybrid::create_cache (53x)
     5,330 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::OnePass::new (82x) [./target/valgrind/s4]
     5,250 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::hybrid::dfa::Builder::new (175x)
     5,250 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/start.rs:regex_automata::hybrid::dfa::Builder::build_from_nfa (175x)
     5,250 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/alphabet.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x)
     5,250 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Builder::build_from_nfa (175x) [./target/valgrind/s4]
     4,914 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:alloc::collections::btree::remove::<impl alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::KV>>::remove_leaf_kv (354x)
     4,860 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::meta::strategy::new (162x)
     3,796 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::util::determinize::state::State::dead (292x)
     3,696 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (48x) [./target/valgrind/s4]
     3,670 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/clap_builder-4.2.1/src/builder/arg.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (55x)
     3,003 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:regex_automata::util::prefilter::teddy::Teddy::new (39x)
     2,999 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_automata::util::prefilter::Prefilter::from_choice (39x)
     2,626 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/strategy.rs:regex_automata::meta::strategy::new (26x) [./target/valgrind/s4]
     2,626 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::new (26x) [./target/valgrind/s4]
     2,544 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/prefilter.rs:aho_corasick::nfa::noncontiguous::Compiler::new (48x)
     2,544 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::new (48x) [./target/valgrind/s4]
     2,445 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (57x)
     2,445 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (57x)
     2,445 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (57x) [./target/valgrind/s4]
     2,430 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::BoundedBacktracker::new (81x)
     2,430 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_automata::meta::regex::RegexInfo::new (81x)
     2,430 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::dfa::onepass::Builder::new (81x)
     2,430 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::hybrid::dfa::DFA::builder (81x)
     2,430 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::PikeVM::new (81x)
     2,400 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-1.11.1/src/builders.rs:regex::regex::bytes::Regex::new (80x)
     2,232 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (174x)
     2,192 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/clap_builder-4.2.1/src/builder/command.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (27x)
     2,130 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (71x)
     1,892 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:aho_corasick::util::remapper::Remapper::remap (48x)
     1,785 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:clap_builder::util::flat_map::FlatMap<K,V>::remove_entry (30x)
     1,771 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/strategy.rs:<regex_automata::meta::strategy::ReverseInner as regex_automata::meta::strategy::Strategy>::create_cache (11x) [./target/valgrind/s4]
     1,688 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (96x)
     1,658 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:<clap_builder::builder::styled_str::StyledStr as core::convert::From<&str>>::from (40x)
     1,560 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:alloc::collections::btree::node::BalancingContext<K,V>::merge_tracking_child_edge (120x)
     1,513 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:clap_builder::builder::command::Command::arg_internal (17x)
     1,440 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::byte_classes (48x) [./target/valgrind/s4]
     1,386 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/ahocorasick.rs:aho_corasick::ahocorasick::AhoCorasickBuilder::build (18x) [./target/valgrind/s4]
     1,365 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::builder::x86_64::FatAVX2<3_usize>::new_unchecked (21x)
     1,361 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:aho_corasick::packed::teddy::builder::x86_64::FatAVX2<3_usize>::new_unchecked (21x)
     1,313 ( 0.00%)       .            .           .           < ???:regex_automata::meta::strategy::new (13x)
     1,294 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::meta::reverse_inner::extract (13x)
     1,278 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:aho_corasick::ahocorasick::AhoCorasickBuilder::build (18x)
     1,122 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (48x)
     1,122 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:aho_corasick::packed::api::Builder::build (48x)
       951 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:alloc::collections::vec_deque::VecDeque<T,A>::grow (69x)
       865 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:core::slice::sort::merge_sort (15x)
       715 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::create_cache (11x) [./target/valgrind/s4]
       715 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::meta::wrappers::ReverseHybrid::create_cache (11x)
       693 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:aho_corasick::ahocorasick::AhoCorasickBuilder::build (9x)
       681 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::interval::IntervalSet<I>::negate (61x)
       649 ( 0.00%)       .            .           .           < src/readers/syslinereader.rs:s4lib::readers::syslinereader::SyslineReader::new (3x) [./target/valgrind/s4]
       591 ( 0.00%)       .            .           .           < src/readers/linereader.rs:s4lib::readers::linereader::LineReader::new (3x) [./target/valgrind/s4]
       586 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x)
       521 ( 0.00%)       .            .           .           < src/bin/s4.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (8x) [./target/valgrind/s4]
       515 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (9x)
       510 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:s4lib::data::datetime::bytes_to_regex_to_datetime (30x)
       452 ( 0.00%)       .            .           .           < src/bin/s4.rs:s4::processing_loop (6x) [./target/valgrind/s4]
       447 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:<std::io::stdio::StdoutLock as std::io::Write>::write (33x)
       445 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:crossbeam_channel::flavors::array::Channel<T>::send (5x)
       445 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crossbeam-channel-0.5.14/src/flavors/array.rs:crossbeam_channel::channel::read (5x)
       445 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:crossbeam_channel::select::SelectedOperation::recv (5x)
       443 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:crossbeam_channel::channel::read (5x)
       396 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::meta::reverse_inner::flatten (34x)
       390 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::nfa::thompson::compiler::Compiler::new (13x)
       370 ( 0.00%)       .            .           .           < src/bin/s4.rs:s4::exec_fileprocessor_thread (2x) [./target/valgrind/s4]
       340 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:alloc::collections::btree::node::BalancingContext<K,V>::bulk_steal_right (24x)
       337 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:std::sys::unix::os_str::Slice::to_owned (24x)
       332 ( 0.00%)       .            .           .           < src/readers/summary.rs:s4lib::readers::summary::Summary::new (6x) [./target/valgrind/s4]
       269 ( 0.00%)       .            .           .           < src/readers/syslogprocessor.rs:s4lib::readers::syslogprocessor::SyslogProcessor::new (1x) [./target/valgrind/s4]
       269 ( 0.00%)       .            .           .           < src/readers/blockreader.rs:s4lib::readers::blockreader::BlockReader::new (7x) [./target/valgrind/s4]
       150 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:alloc::collections::btree::node::BalancingContext<K,V>::do_merge (12x)
       118 ( 0.00%)       .            .           .           < src/readers/syslogprocessor.rs:s4lib::readers::syslogprocessor::SyslogProcessor::summary_complete (2x) [./target/valgrind/s4]
       117 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:hashbrown::map::HashMap<K,V,S,A>::insert (2x)
       101 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/clap_builder-4.2.1/src/builder/command.rs:clap_builder::builder::command::Command::get_matches_from (1x) [./target/valgrind/s4]
        85 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:std::env::args_os (6x)
        78 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:s4lib::printer::printers::PrinterLogMessage::print_sysline_color (6x)
        77 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<4_usize>::new_unchecked (1x)
        77 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/sync.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<4_usize>::new_unchecked (1x)
        75 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::Hir::alternation (6x)
        65 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (1x) [./target/valgrind/s4]
        63 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::dfa::remapper::Remapper::remap (1x)
        60 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/fs.rs:std::sys::unix::fs::stat (2x) [./target/valgrind/s4]
        59 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:std::env::_var_os (4x)
        54 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:<&mut W as core::fmt::Write>::write_str (4x)
        34 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:std::sys::unix::fs::stat (2x)
        34 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:std::sys::unix::fs::canonicalize (2x)
        30 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/ctrlc-3.4.5/src/platform/unix/mod.rs:ctrlc::init_and_set_handler (1x)
        30 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:chrono::offset::local::inner::Source::new (1x)
        30 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:std::sys::common::thread_local::lazy::LazyKeyInner<T>::initialize (1x)
        30 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/fs.rs:std::sys::unix::fs::lstat (1x) [./target/valgrind/s4]
        30 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-1.11.1/src/builders.rs:regex::regex::string::Regex::new (1x)
        30 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:s4::processing_loop (1x)
        30 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex::builders::Builder::build_one_string (1x)
        30 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/array/mod.rs:core::array::drain::drain_array_with (1x)
        30 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:<F as clap_builder::builder::value_parser::TypedValueParser>::parse_ref (2x)
        30 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:nix::sys::signal::sigaction (1x)
        30 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:core::ops::function::FnOnce::call_once (2x)
        30 ( 0.00%)       .            .           .           < /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/map.rs:hashbrown::map::HashMap<K,V,S,A>::remove (1x) [./target/valgrind/s4]
        30 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/mem/manually_drop.rs:core::array::drain::drain_array_with (1x)
        30 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:std::fs::File::metadata (1x)
        30 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/fs.rs:std::fs::File::metadata (1x)
        28 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/thread.rs:std::sys::unix::thread::Thread::set_name (2x) [./target/valgrind/s4]
        26 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:crossbeam_channel::waker::SyncWaker::notify (2x)
        26 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:s4::process_dt_exit (2x)
        18 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:clap_builder::builder::command::Command::get_matches_from (1x)
        18 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:s4lib::readers::filepreprocessor::pathbuf_to_filetype_impl (1x)
        15 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:<&str as alloc::ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl (1x)
        13 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:std::fs::read::inner (1x)
        13 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:std::sys::unix::os::getenv::{{closure}} (1x)
        13 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:std::sys::unix::fs::lstat (1x)
        12 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:std::fs::OpenOptions::_open (1x)
        11 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:s4lib::readers::helpers::basename (1x)
18,370,925 ( 5.29%)       .            .           .           *  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms [/usr/lib/x86_64-linux-gnu/libc.so.6]

11,952,466 ( 3.44%)  24,990 ( 3.08%)   .           .           < ./malloc/./malloc/malloc.c:_int_malloc (2,499x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 2,719,333 ( 0.78%)   1,920 ( 0.24%)   .           .           < ./malloc/./malloc/malloc.c:_int_free (192x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
11,396,190 ( 3.28%)  26,910 ( 3.32%)   .           .           *  ./malloc/./malloc/malloc.c:malloc_consolidate [/usr/lib/x86_64-linux-gnu/libc.so.6]
 3,275,609 ( 0.94%)       .            .           .           >   ./malloc/./malloc/malloc.c:unlink_chunk.constprop.0 (145,332x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

47,909,474 (13.79%) 261,138 (32.23%)   1 ( 0.31%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/alloc.rs:__rdl_dealloc (386,109x) [./target/valgrind/s4]
     1,725 ( 0.00%)       5 ( 0.00%)   .           .           < ???:0x0000000004898370 (19x) [???]
       142 ( 0.00%)       2 ( 0.00%)   .           .           < ./malloc/./malloc/malloc.c:__malloc_arena_thread_freeres (1x)
        89 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/fs.rs:std::sys::unix::fs::canonicalize (1x) [./target/valgrind/s4]
 8,494,837 ( 2.44%)       .            .           .           *  ./malloc/./malloc/malloc.c:free [/usr/lib/x86_64-linux-gnu/libc.so.6]
35,187,937 (10.13%) 261,143 (32.23%)   .           .           >   ./malloc/./malloc/malloc.c:_int_free (386,127x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        35 ( 0.00%)       2 ( 0.00%)   1 ( 0.31%)  .           >   ./malloc/./malloc/malloc.c:munmap_chunk (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 4,724,559 ( 1.36%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::pikevm::ActiveStates::reset (318x)
   557,477 ( 0.16%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (66x)
   325,436 ( 0.09%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (350x)
   284,952 ( 0.08%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::builder::Builder::build (175x)
   272,774 ( 0.08%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (324x)
   243,187 ( 0.07%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::util::sparse_set::SparseSets::new (468x)
    77,168 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (1,066x)
    65,552 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:s4lib::readers::blockreader::BlockReader::read_block_File (1x)
    13,904 ( 0.00%)       .            .           .           < ???:0x0000000004898670 (227x) [???]
     4,164 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash (347x)
     2,096 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::meta::regex::Regex::create_captures (86x)
     1,013 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_automata::meta::strategy::Core as regex_automata::meta::strategy::Strategy>::create_cache (43x)
       279 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_automata::meta::strategy::ReverseInner as regex_automata::meta::strategy::Strategy>::create_cache (11x)
       199 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/backtrack.rs:regex_automata::nfa::thompson::backtrack::BoundedBacktracker::search_imp (9x) [./target/valgrind/s4]
       156 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:hashbrown::raw::RawTable<T,A>::fallible_with_capacity (13x)
        78 ( 0.00%)       .            .           .           < src/bin/s4.rs:s4::processing_loop (1x) [./target/valgrind/s4]
        60 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:s4::processing_loop (5x)
        48 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:<lru::LruCache<K,V,S> as core::ops::drop::Drop>::drop (4x)
        48 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:hashbrown::raw::RawTableInner::fallible_with_capacity (4x)
        38 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::DFA::try_search_slots_imp (2x) [./target/valgrind/s4]
        26 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::backtrack::BoundedBacktracker::search_imp (1x)
 6,573,214 ( 1.89%)       .            .           .           *  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms [/usr/lib/x86_64-linux-gnu/libc.so.6]

 3,275,609 ( 0.94%)       .            .           .           < ./malloc/./malloc/malloc.c:malloc_consolidate (145,332x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 1,618,890 ( 0.47%)       .            .           .           < ./malloc/./malloc/malloc.c:_int_malloc (66,838x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   177,705 ( 0.05%)       .            .           .           < ./malloc/./malloc/malloc.c:_int_free (7,174x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    88,894 ( 0.03%)       .            .           .           < ./malloc/./malloc/malloc.c:_int_realloc (3,391x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 5,161,098 ( 1.49%)       .            .           .           *  ./malloc/./malloc/malloc.c:unlink_chunk.constprop.0 [/usr/lib/x86_64-linux-gnu/libc.so.6]

61,722,136 (17.76%) 148,841 (18.37%)  22 ( 6.79%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (71,256x) [./target/valgrind/s4]
 4,651,923 ( 1.34%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post [./target/valgrind/s4]
24,777,622 ( 7.13%)  51,488 ( 6.36%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (15,786x) [./target/valgrind/s4]
 8,265,058 ( 2.38%)  33,587 ( 4.15%)   3 ( 0.93%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::TranslatorI::push_char (48,360x) [./target/valgrind/s4]
 6,432,565 ( 1.85%)   2,381 ( 0.29%)   6 ( 1.85%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (512x) [./target/valgrind/s4]
 2,109,901 ( 0.61%)   9,536 ( 1.18%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class (3,873x) [./target/valgrind/s4]
 1,025,515 ( 0.30%)   2,240 ( 0.28%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple (1,120x) [./target/valgrind/s4]
   317,853 ( 0.09%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> (35,317x) [./target/valgrind/s4]
   183,220 ( 0.05%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::SimpleCaseFolder::overlaps (1,120x) [./target/valgrind/s4]
    85,074 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::HirFrame::unwrap_expr (2,578x) [./target/valgrind/s4]
    65,950 ( 0.02%)      52 ( 0.01%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:<alloc::string::String as core::clone::Clone>::clone (586x) [./target/valgrind/s4]
    57,501 ( 0.02%)     160 ( 0.02%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::TranslatorI::push (1,120x) [./target/valgrind/s4]
     3,020 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (20x) [./target/valgrind/s4]

30,577,223 ( 8.80%) 144,990 (17.90%)  81 (25.00%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/alloc.rs:__rdl_realloc (60,797x)
     4,229 ( 0.00%)      22 ( 0.00%)   7 ( 2.16%)  .           < ???:0x00000000048983b0 (7x) [???]
 4,618,970 ( 1.33%) 121,190 (14.96%)   .           .           *  ./malloc/./malloc/malloc.c:realloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
24,624,476 ( 7.09%)  23,800 ( 2.94%)  81 (25.00%)  .           >   ./malloc/./malloc/malloc.c:_int_realloc (60,798x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     3,714 ( 0.00%)      22 ( 0.00%)   7 ( 2.16%)  .           >   ./malloc/./malloc/malloc.c:malloc (6x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 4,228,621 ( 1.22%)       .            .           .           *  ./malloc/./malloc/arena.c:free

70,504,119 (20.29%) 152,032 (18.77%)  26 ( 8.02%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::Translator::translate (81x) [./target/valgrind/s4]
 6,089,860 ( 1.75%)     304 ( 0.04%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::NestLimiter<P>::check (81x) [./target/valgrind/s4]
 3,902,728 ( 1.12%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit [./target/valgrind/s4]
61,722,136 (17.76%) 148,841 (18.37%)  22 ( 6.79%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (71,256x) [./target/valgrind/s4]
 2,518,325 ( 0.72%)   1,297 ( 0.16%)   4 ( 1.23%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre (71,256x) [./target/valgrind/s4]
 1,969,692 ( 0.57%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:<regex_syntax::ast::parse::NestLimiter<P> as regex_syntax::ast::visitor::Visitor>::visit_pre (71,256x) [./target/valgrind/s4]
 1,618,106 ( 0.47%)   1,570 ( 0.19%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (4,916x) [./target/valgrind/s4]
   130,648 ( 0.04%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:<regex_syntax::ast::parse::NestLimiter<P> as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre (4,916x) [./target/valgrind/s4]
    65,027 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre (4,916x) [./target/valgrind/s4]
     6,237 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::finish (81x) [./target/valgrind/s4]

 3,684,933 ( 1.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:alloc::vec::Vec<T,A>::extend_with

24,624,476 ( 7.09%)  23,800 ( 2.94%)  81 (25.00%)  .           < ./malloc/./malloc/malloc.c:realloc (60,798x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 3,655,818 ( 1.05%)       .            .           .           *  ./malloc/./malloc/malloc.c:_int_realloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
13,040,321 ( 3.75%)  21,698 ( 2.68%)  81 (25.00%)  .           >   ./malloc/./malloc/malloc.c:_int_malloc (25,120x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 5,393,530 ( 1.55%)       .            .           .           >   ???:0x0000000004898620 (25,082x) [???]
 2,445,913 ( 0.70%)   2,102 ( 0.26%)   .           .           >   ./malloc/./malloc/malloc.c:_int_free (28,259x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    88,894 ( 0.03%)       .            .           .           >   ./malloc/./malloc/malloc.c:unlink_chunk.constprop.0 (3,391x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

61,112,902 (17.59%) 143,418 (17.70%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::Parser::parse (81x) [./target/valgrind/s4]
 3,549,073 ( 1.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments [./target/valgrind/s4]
 9,354,277 ( 2.69%)   1,198 ( 0.15%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (2,753x) [./target/valgrind/s4]
 7,648,664 ( 2.20%)  26,574 ( 3.28%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (15,929x) [./target/valgrind/s4]
 6,090,265 ( 1.75%)     304 ( 0.04%)   1 ( 0.31%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::NestLimiter<P>::check (81x) [./target/valgrind/s4]
 4,627,593 ( 1.33%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (220,401x) [./target/valgrind/s4]
 4,414,633 ( 1.27%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (49,607x) [./target/valgrind/s4]
 1,560,256 ( 0.45%)     673 ( 0.08%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_group (713x) [./target/valgrind/s4]
 1,289,898 ( 0.37%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (71,661x) [./target/valgrind/s4]
   922,317 ( 0.27%)   2,302 ( 0.28%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x) [./target/valgrind/s4]
   822,584 ( 0.24%)   1,237 ( 0.15%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition (1,713x) [./target/valgrind/s4]
   248,159 ( 0.07%)     134 ( 0.02%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (172x) [./target/valgrind/s4]
    82,590 ( 0.02%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    27,645 ( 0.01%)     132 ( 0.02%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group_end (81x) [./target/valgrind/s4]

 4,627,593 ( 1.33%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (220,401x) [./target/valgrind/s4]
 3,882,480 ( 1.12%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (184,846x) [./target/valgrind/s4]
   334,509 ( 0.10%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (15,929x) [./target/valgrind/s4]
   267,648 ( 0.08%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (12,720x) [./target/valgrind/s4]
   237,222 ( 0.07%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open (11,298x) [./target/valgrind/s4]
   198,960 ( 0.06%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item (9,360x) [./target/valgrind/s4]
   148,491 ( 0.04%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::maybe_parse_ascii_class (7,071x) [./target/valgrind/s4]
   143,766 ( 0.04%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (6,846x) [./target/valgrind/s4]
    75,129 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range (3,549x) [./target/valgrind/s4]
    74,718 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition (3,558x) [./target/valgrind/s4]
    67,704 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape (3,224x) [./target/valgrind/s4]
    59,304 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x) [./target/valgrind/s4]
    59,268 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (2,824x) [./target/valgrind/s4]
    45,303 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (2,159x) [./target/valgrind/s4]
    33,789 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (1,609x) [./target/valgrind/s4]
    15,855 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (755x) [./target/valgrind/s4]
    14,961 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_group (713x) [./target/valgrind/s4]
    14,553 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x) [./target/valgrind/s4]
     4,410 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_flags (210x) [./target/valgrind/s4]
       420 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_flag (20x) [./target/valgrind/s4]
       315 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_perl_class (15x) [./target/valgrind/s4]
 3,435,328 ( 0.99%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char [./target/valgrind/s4]

40,913,723 (11.78%) 179,434 (22.15%)  82 (25.31%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (149,359x) [./target/valgrind/s4]
23,465,943 ( 6.75%)  86,666 (10.70%)  20 ( 6.17%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle (51,547x) [./target/valgrind/s4]
       354 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::ffi::c_str::CString::_from_vec_unchecked (2x)
 3,395,253 ( 0.98%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::finish_grow [./target/valgrind/s4]
29,777,298 ( 8.57%) 154,446 (19.06%)  21 ( 6.48%)  .           >   ???:__rust_alloc (156,689x) [./target/valgrind/s4]

 3,349,866 ( 0.96%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:alloc::vec::Vec<T,A>::extend_with
 8,709,129 ( 2.51%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (669,933x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

10,696,691 ( 3.08%)  49,166 ( 6.07%)  10 ( 3.09%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add (29,149x)
 9,025,691 ( 2.60%)  44,346 ( 5.47%)  14 ( 4.32%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile (37,448x)
 5,503,764 ( 1.58%)  28,829 ( 3.56%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (18,495x)
 3,379,462 ( 0.97%)   5,098 ( 0.63%)  25 ( 7.72%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::add (1,376x)
 2,842,228 ( 0.82%)   4,966 ( 0.61%)  10 ( 3.09%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (17,779x)
 2,400,726 ( 0.69%)   3,724 ( 0.46%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::concat (16,418x)
 1,651,291 ( 0.48%)   8,696 ( 1.07%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::patch (5,355x)
 1,546,713 ( 0.45%)   5,033 ( 0.62%)   6 ( 1.85%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::PreferenceTrie::insert (2,014x)
 1,264,275 ( 0.36%)   4,023 ( 0.50%)   8 ( 2.47%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::nfa::Inner::add (1,275x)
 1,063,519 ( 0.31%)     330 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (81x)
   839,962 ( 0.24%)   4,453 ( 0.55%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (1,445x)
   568,395 ( 0.16%)   1,812 ( 0.22%)   3 ( 0.93%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::translate::TranslatorI::push_char (221x)
   543,588 ( 0.16%)   2,134 ( 0.26%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::build (1,033x)
   521,235 ( 0.15%)   2,240 ( 0.28%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple (1,120x)
   461,876 ( 0.13%)   2,548 ( 0.31%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::dfa::DFA::set_matches (1,835x)
   441,813 ( 0.13%)     866 ( 0.11%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (2,914x)
   438,434 ( 0.13%)   1,230 ( 0.15%)   1 ( 0.31%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state (384x)
   360,701 ( 0.10%)     881 ( 0.11%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from (1,901x)
   322,591 ( 0.09%)   1,297 ( 0.16%)   4 ( 1.23%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre (297x)
   254,712 ( 0.07%)     279 ( 0.03%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (1,978x)
   246,714 ( 0.07%)     911 ( 0.11%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::packed::pattern::Patterns::add (360x)
   184,327 ( 0.05%)     752 ( 0.09%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::packed::api::Builder::build (733x)
   122,950 ( 0.04%)     330 ( 0.04%)   1 ( 0.31%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::visitor::visit (486x)
   119,436 ( 0.03%)     609 ( 0.08%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (221x)
   117,496 ( 0.03%)     437 ( 0.05%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::add_capture_start (308x)
   116,126 ( 0.03%)     545 ( 0.07%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::util::captures::GroupInfo::new (227x)
   114,509 ( 0.03%)     443 ( 0.05%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (243x)
    94,698 ( 0.03%)     260 ( 0.03%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push (211x)
    92,865 ( 0.03%)     316 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::Builder::build (324x)
    85,121 ( 0.02%)     305 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::add_match (144x)
    83,655 ( 0.02%)     336 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (167x)
    77,021 ( 0.02%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::range_trie::RangeTrie::add_empty (674x)
    71,948 ( 0.02%)     306 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/vec_deque/mod.rs:alloc::collections::vec_deque::VecDeque<T,A>::grow (180x) [./target/valgrind/s4]
    65,360 ( 0.02%)     177 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (406x)
    61,742 ( 0.02%)     332 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x)
    47,671 ( 0.01%)     251 ( 0.03%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next (123x)
    46,306 ( 0.01%)     140 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::meta::regex::Builder::build (162x)
    41,200 ( 0.01%)     172 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (154x)
    39,976 ( 0.01%)     108 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::util::captures::GroupInfoInner::add_first_group (243x)
    38,324 ( 0.01%)      78 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::Extractor::extract'2 (125x)
    35,613 ( 0.01%)     177 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::interval::IntervalSet<I>::negate (81x)
    28,291 ( 0.01%)     160 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::translate::TranslatorI::push (30x)
    26,636 ( 0.01%)      74 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (175x)
    19,533 ( 0.01%)     136 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::util::determinize::add_nfa_states (62x)
    15,204 ( 0.00%)      68 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (34x)
    13,338 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::hybrid::dfa::Lazy::init_cache (117x)
    12,847 ( 0.00%)      18 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::meta::regex::RegexInfo::new (81x)
    10,798 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_group (91x)
     9,335 ( 0.00%)      30 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::alternation (24x)
     9,153 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (81x)
     8,936 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:clap_builder::parser::matches::matched_arg::MatchedArg::append_val (36x)
     8,346 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (78x)
     8,165 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (71x)
     7,638 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::new (67x)
     7,596 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:clap_builder::parser::arg_matcher::ArgMatcher::start_custom_arg (30x)
     4,633 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::util::determinize::epsilon_closure (41x)
     3,711 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:clap_builder::parser::arg_matcher::ArgMatcher::add_index_to (15x)
     2,485 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:clap_builder::util::flat_map::Entry<K,V>::or_insert (6x)
     2,260 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_flags (20x)
     1,510 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:clap_builder::builder::command::Command::arg_internal (4x)
     1,484 ( 0.00%)       6 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::backtrack::BoundedBacktracker::search_imp (4x)
     1,293 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (6x)
       822 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:clap_builder::builder::command::Command::_build_self (3x)
       819 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<alloc::string::String as core::fmt::Write>::write_char (2x)
       516 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:clap_builder::parser::arg_matcher::ArgMatcher::start_custom_group (2x)
       487 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::alternation'2 (2x)
       486 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:clap_builder::parser::parser::Parser::get_matches_with (3x)
       483 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:clap_builder::builder::command::Command::unroll_arg_requires (3x)
       372 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:clap_builder::util::flat_map::FlatMap<K,V>::extend_unchecked (2x)
       325 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:clap_builder::mkeymap::MKeyMap::_build (1x)
       115 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open (1x)
       114 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:crossbeam_channel::waker::SyncWaker::register (1x)
       114 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::Extractor::extract (1x)
 3,071,195 ( 0.88%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push [./target/valgrind/s4]
40,913,723 (11.78%) 179,434 (22.15%)  82 (25.31%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::finish_grow (149,359x) [./target/valgrind/s4]

 3,470,874 ( 1.00%)   2,720 ( 0.34%)   4 ( 1.23%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (41,209x)
 1,436,189 ( 0.41%)     866 ( 0.11%)  10 ( 3.09%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile (17,526x) [./target/valgrind/s4]
 1,319,234 ( 0.38%)     576 ( 0.07%)   9 ( 2.78%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile (16,950x)
   554,049 ( 0.16%)     314 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (5,376x)
   227,494 ( 0.07%)      94 ( 0.01%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (693x)
   180,819 ( 0.05%)      80 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (3,283x) [./target/valgrind/s4]
   103,353 ( 0.03%)      46 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (773x)
    78,698 ( 0.02%)     188 ( 0.02%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter (1,078x)
    54,218 ( 0.02%)      52 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add_capture_start (774x) [./target/valgrind/s4]
    35,605 ( 0.01%)      52 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (526x) [./target/valgrind/s4]
    24,572 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (252x)
    16,477 ( 0.00%)      36 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::new (126x)
    15,165 ( 0.00%)      44 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::compile (65x)
    10,831 ( 0.00%)      12 ( 0.00%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (175x)
    10,592 ( 0.00%)       4 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::c (112x)
     7,072 ( 0.00%)      12 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap (81x)
     6,704 ( 0.00%)       2 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (134x)
     5,311 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c (113x)
       460 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least'2 (10x)
        46 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (1x) [./target/valgrind/s4]
 2,768,343 ( 0.80%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add [./target/valgrind/s4]

85,436,813 (24.59%) 199,882 (24.67%)  87 (26.85%)  1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (1,386x) [./target/valgrind/s4]
82,889,700 (23.86%) 191,126 (23.59%)  90 (27.78%)  1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (2,840x) [./target/valgrind/s4]
24,278,612 ( 6.99%)  28,313 ( 3.49%)  22 ( 6.79%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (12,493x) [./target/valgrind/s4]
21,098,019 ( 6.07%)  14,557 ( 1.80%)  26 ( 8.02%)  1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter (6,614x) [./target/valgrind/s4]
 1,286,072 ( 0.37%)     544 ( 0.07%)   2 ( 0.62%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (142x) [./target/valgrind/s4]
   980,027 ( 0.28%)      54 ( 0.01%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least'2 (10x) [./target/valgrind/s4]
   317,829 ( 0.09%)     878 ( 0.11%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_concat (580x) [./target/valgrind/s4]
   292,111 ( 0.08%)     917 ( 0.11%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (526x) [./target/valgrind/s4]
 2,639,307 ( 0.76%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 [./target/valgrind/s4]
86,151,395 (24.79%) 201,207 (24.83%)  88 (27.16%)  1 ( 0.07%)  >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (1,386x) [./target/valgrind/s4]
24,278,612 ( 6.99%)  28,313 ( 3.49%)  22 ( 6.79%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (12,493x) [./target/valgrind/s4]
23,663,451 ( 6.81%)  80,011 ( 9.88%)  12 ( 3.70%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add (26,711x) [./target/valgrind/s4]
22,587,538 ( 6.50%)  16,536 ( 2.04%)  26 ( 8.02%)  1 ( 0.07%)  >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter (538x) [./target/valgrind/s4]
17,664,602 ( 5.08%)     642 ( 0.08%)  40 (12.35%)  1 ( 0.07%)  >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::new (126x) [./target/valgrind/s4]
16,880,561 ( 4.86%)  46,080 ( 5.69%)  33 (10.19%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile (495x) [./target/valgrind/s4]
 2,640,779 ( 0.76%)   5,841 ( 0.72%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (39,782x) [./target/valgrind/s4]
 1,356,033 ( 0.39%)     758 ( 0.09%)   2 ( 0.62%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (142x) [./target/valgrind/s4]
   984,177 ( 0.28%)      54 ( 0.01%)   1 ( 0.31%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least'2 (10x) [./target/valgrind/s4]
   920,256 ( 0.26%)   1,420 ( 0.18%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::add (1,179x) [./target/valgrind/s4]
   722,748 ( 0.21%)   2,041 ( 0.25%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (134x) [./target/valgrind/s4]
   402,767 ( 0.12%)     251 ( 0.03%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next (3,756x) [./target/valgrind/s4]
   395,455 ( 0.11%)     374 ( 0.05%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/map.rs:regex_automata::nfa::thompson::map::Utf8SuffixMap::clear (127x) [./target/valgrind/s4]
   247,118 ( 0.07%)     618 ( 0.08%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_concat (210x) [./target/valgrind/s4]
   217,294 ( 0.06%)     406 ( 0.05%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::finish (126x) [./target/valgrind/s4]
   180,819 ( 0.05%)      80 ( 0.01%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (3,283x) [./target/valgrind/s4]
   169,250 ( 0.05%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::kind (84,625x) [./target/valgrind/s4]
   141,817 ( 0.04%)     420 ( 0.05%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs:regex_syntax::utf8::Utf8Sequences::new (1,386x) [./target/valgrind/s4]
    91,463 ( 0.03%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next (16,182x) [./target/valgrind/s4]
    45,786 ( 0.01%)     188 ( 0.02%)   .           .           >   ???:__rust_alloc (495x) [./target/valgrind/s4]
    39,403 ( 0.01%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::ClassUnicode::is_ascii (5,629x) [./target/valgrind/s4]
    22,516 ( 0.01%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::ClassUnicode::iter (5,629x) [./target/valgrind/s4]
    21,330 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs:regex_syntax::utf8::Utf8Sequence::as_slice (2,370x) [./target/valgrind/s4]
    21,106 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicodeRange::end (10,553x) [./target/valgrind/s4]
    21,106 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicodeRange::start (10,553x) [./target/valgrind/s4]
    16,128 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::ClassBytes::ranges (5,376x) [./target/valgrind/s4]

 4,414,633 ( 1.27%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (49,607x) [./target/valgrind/s4]
 1,417,681 ( 0.41%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (15,929x) [./target/valgrind/s4]
   627,895 ( 0.18%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::maybe_parse_ascii_class (7,055x) [./target/valgrind/s4]
   304,647 ( 0.09%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (3,423x) [./target/valgrind/s4]
   286,491 ( 0.08%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape (3,219x) [./target/valgrind/s4]
   251,442 ( 0.07%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open (2,826x) [./target/valgrind/s4]
   251,336 ( 0.07%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x) [./target/valgrind/s4]
   223,455 ( 0.06%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (2,511x) [./target/valgrind/s4]
   173,833 ( 0.05%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item (1,937x) [./target/valgrind/s4]
   152,457 ( 0.04%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition (1,713x) [./target/valgrind/s4]
    61,677 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x) [./target/valgrind/s4]
    21,360 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (240x) [./target/valgrind/s4]
    21,271 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (239x) [./target/valgrind/s4]
    15,308 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_and_bump_space (172x) [./target/valgrind/s4]
     2,670 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_flags (30x) [./target/valgrind/s4]
       445 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_perl_class (5x) [./target/valgrind/s4]
 2,495,421 ( 0.72%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump [./target/valgrind/s4]
 3,882,480 ( 1.12%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (184,846x) [./target/valgrind/s4]

 2,477,136 ( 0.71%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/alphabet.rs:regex_automata::nfa::thompson::nfa::Inner::add

 2,415,404 ( 0.70%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/alloc.rs:__rdl_alloc
68,158,577 (19.62%) 393,828 (48.61%)  75 (23.15%)  1 ( 0.07%)  >   ./malloc/./malloc/malloc.c:malloc (402,406x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    65,491 ( 0.02%)     329 ( 0.04%)   .           .           >   ./malloc/./malloc/malloc.c:posix_memalign (121x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 7,160,456 ( 2.06%)   4,023 ( 0.50%)   8 ( 2.47%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build (64,414x) [./target/valgrind/s4]
 2,301,962 ( 0.66%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add [./target/valgrind/s4]

 2,236,646 ( 0.64%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:aho_corasick::dfa::Builder::finish_build_one_start

 2,106,350 ( 0.61%)       .            .           .           *  ./malloc/./malloc/arena.c:malloc
     1,128 ( 0.00%)       0            1 ( 0.31%)  .           >   ./malloc/./malloc/arena.c:ptmalloc_init.part.0 (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

19,010,900 ( 5.47%)  32,738 ( 4.04%)  11 ( 3.40%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::compile (175x) [./target/valgrind/s4]
 2,074,315 ( 0.60%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build [./target/valgrind/s4]
 7,160,456 ( 2.06%)   4,023 ( 0.50%)   8 ( 2.47%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (64,414x) [./target/valgrind/s4]
 1,610,640 ( 0.46%)   1,255 ( 0.15%)   1 ( 0.31%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x) [./target/valgrind/s4]
 1,236,667 ( 0.36%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::remap (175x) [./target/valgrind/s4]
    11,375 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 2,044,817 ( 0.59%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler>

11,570,144 ( 3.33%)  38,013 ( 4.69%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/strategy.rs:regex_automata::meta::strategy::new (175x) [./target/valgrind/s4]
    49,791 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::meta::wrappers::Hybrid::new (243x)
    16,597 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::meta::wrappers::PikeVM::new (81x)
    16,597 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::meta::wrappers::OnePass::new (81x)
    16,597 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::meta::wrappers::BoundedBacktracker::new (81x)
     2,657 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::meta::wrappers::ReverseHybrid::new (13x)
 2,038,824 ( 0.59%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> [./target/valgrind/s4]
 5,542,985 ( 1.60%)  33,310 ( 4.11%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (674x) [./target/valgrind/s4]

 2,009,072 ( 0.58%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:alloc::raw_vec::finish_grow

 5,028,015 ( 1.45%)  29,391 ( 3.63%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (27,518x)
 1,048,761 ( 0.30%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::into_parts (38,843x)
     1,836 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::concat (68x)
     1,504 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (4x)
       665 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::alternation'2 (5x)
       351 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::into_kind (13x)
       299 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::meta::reverse_inner::extract (13x)
       135 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::alternation (5x)
 1,942,898 ( 0.56%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> [./target/valgrind/s4]
 3,838,353 ( 1.10%)  28,817 ( 3.56%)   .           .           >   ???:__rust_dealloc (30,129x) [./target/valgrind/s4]
    74,002 ( 0.02%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind>'2 (2,726x) [./target/valgrind/s4]
    68,050 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop'2 (2,722x) [./target/valgrind/s4]
       100 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (4x) [./target/valgrind/s4]

 1,969,692 ( 0.57%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (71,256x) [./target/valgrind/s4]
 1,921,796 ( 0.55%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:<regex_syntax::ast::parse::NestLimiter<P> as regex_syntax::ast::visitor::Visitor>::visit_pre [./target/valgrind/s4]

 1,863,306 ( 0.54%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

16,880,561 ( 4.86%)  46,080 ( 5.69%)  33 (10.19%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (495x) [./target/valgrind/s4]
 1,711,010 ( 0.49%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile [./target/valgrind/s4]
 1,436,189 ( 0.41%)     866 ( 0.11%)  10 ( 3.09%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (17,526x) [./target/valgrind/s4]

 2,518,325 ( 0.72%)   1,297 ( 0.16%)   4 ( 1.23%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (71,256x) [./target/valgrind/s4]
 1,702,793 ( 0.49%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre [./target/valgrind/s4]

 2,640,779 ( 0.76%)   5,841 ( 0.72%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (39,782x) [./target/valgrind/s4]
   966,416 ( 0.28%)   1,829 ( 0.23%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (13,228x) [./target/valgrind/s4]
   223,553 ( 0.06%)     810 ( 0.10%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (1,712x) [./target/valgrind/s4]
    98,360 ( 0.03%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (2,671x) [./target/valgrind/s4]
    74,025 ( 0.02%)     216 ( 0.03%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (504x) [./target/valgrind/s4]
    49,896 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (1,386x) [./target/valgrind/s4]
     8,496 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_concat (236x) [./target/valgrind/s4]
     7,950 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::compile (175x) [./target/valgrind/s4]
     6,300 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (175x)
     5,877 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap (162x) [./target/valgrind/s4]
     2,840 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least'2 (20x) [./target/valgrind/s4]
 1,688,918 ( 0.49%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch [./target/valgrind/s4]

24,777,622 ( 7.13%)  51,488 ( 6.36%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (15,786x) [./target/valgrind/s4]
   255,514 ( 0.07%)     239 ( 0.03%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::extract (39x) [./target/valgrind/s4]
   168,287 ( 0.05%)     325 ( 0.04%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (83x) [./target/valgrind/s4]
    47,535 ( 0.01%)      76 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten (29x) [./target/valgrind/s4]
     7,453 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (6x) [./target/valgrind/s4]
 1,628,807 ( 0.47%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat [./target/valgrind/s4]
 8,066,965 ( 2.32%)  29,389 ( 3.63%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::into_parts (20,550x) [./target/valgrind/s4]
 2,381,543 ( 0.69%)      12 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::literal (15,406x) [./target/valgrind/s4]
        88 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/converts.rs:core::str::converts::from_utf8 (2x) [./target/valgrind/s4]

16,767,779 ( 4.83%)  99,842 (12.32%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop (71,256x) [./target/valgrind/s4]
   350,488 ( 0.10%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (2,578x) [./target/valgrind/s4]
 1,585,654 ( 0.46%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 [./target/valgrind/s4]
11,896,747 ( 3.42%)  94,299 (11.64%)   .           .           >   ???:__rust_dealloc (90,718x) [./target/valgrind/s4]
 1,517,772 ( 0.44%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop'2 (73,834x) [./target/valgrind/s4]
 1,386,817 ( 0.40%)   2,942 ( 0.36%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSet> (2,753x) [./target/valgrind/s4]
   350,488 ( 0.10%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (2,578x) [./target/valgrind/s4]

 1,524,308 ( 0.44%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::visitor::visit
   122,950 ( 0.04%)     330 ( 0.04%)   1 ( 0.31%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (486x) [./target/valgrind/s4]

 1,289,898 ( 0.37%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (71,661x) [./target/valgrind/s4]
   179,406 ( 0.05%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (9,967x) [./target/valgrind/s4]
    63,882 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range (3,549x) [./target/valgrind/s4]
    50,868 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open (2,826x) [./target/valgrind/s4]
    12,834 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (713x) [./target/valgrind/s4]
     4,320 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (240x) [./target/valgrind/s4]
     4,302 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (239x) [./target/valgrind/s4]
     3,096 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_and_bump_space (172x) [./target/valgrind/s4]
 1,519,239 ( 0.44%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space [./target/valgrind/s4]

 1,517,772 ( 0.44%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (73,834x) [./target/valgrind/s4]
 1,517,772 ( 0.44%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop'2 [./target/valgrind/s4]

12,128,986 ( 3.49%)  54,584 ( 6.74%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (224x) [./target/valgrind/s4]
   971,075 ( 0.28%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::into_parts (38,843x)
   865,056 ( 0.25%)   4,090 ( 0.50%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::meta::reverse_inner::extract (13x)
     1,700 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::concat (68x)
       325 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::into_kind (13x)
       136 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (4x)
       125 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::alternation (5x)
       125 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::alternation'2 (5x)
       100 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (4x) [./target/valgrind/s4]
        25 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir>'2 (1x) [./target/valgrind/s4]
 1,500,758 ( 0.43%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop [./target/valgrind/s4]
 1,530,852 ( 0.44%)   2,000 ( 0.25%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_extend.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend (2,604x) [./target/valgrind/s4]
   139,107 ( 0.04%)       2 ( 0.00%)   .           .           >   ???:__rust_alloc (2,722x) [./target/valgrind/s4]

 1,475,712 ( 0.42%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/validations.rs:regex_syntax::ast::parse::ParserI<P>::char

 1,471,370 ( 0.42%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/mod.rs:regex_syntax::ast::parse::ParserI<P>::char

23,663,451 ( 6.81%)  80,011 ( 9.88%)  12 ( 3.70%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (26,711x) [./target/valgrind/s4]
 1,444,898 ( 0.42%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add [./target/valgrind/s4]

 1,135,082 ( 0.33%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_syntax::hir::literal::Extractor::union (51,690x)
   115,108 ( 0.03%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_syntax::hir::literal::Extractor::cross (5,251x)
    78,870 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (3,659x)
    43,283 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_automata::util::prefilter::prefixes (1,941x)
    30,525 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert (1,394x)
    23,863 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (1,059x)
     6,891 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:hashbrown::map::HashMap<K,V,S,A>::insert (360x)
     3,170 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_syntax::hir::literal::Extractor::extract'2 (317x)
     1,576 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_automata::util::prefilter::suffixes (88x)
     1,235 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_automata::util::captures::Captures::get_group_by_name (65x)
     1,040 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (51x)
       436 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::parser::arg_matcher::ArgMatcher::check_explicit (22x)
       433 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::parser::validator::Validator::validate (22x)
       351 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::parser::parser::Parser::push_arg_values (18x)
       351 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::parser::arg_matcher::ArgMatcher::add_index_to (18x)
       307 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::util::flat_map::FlatMap<K,V>::remove_entry (16x)
       281 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::parser::parser::Parser::start_custom_arg (14x)
       212 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::parser::validator::gather_direct_conflicts (11x)
       136 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::parser::validator::Conflicts::gather_conflicts (7x)
       110 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:chrono::format::parse::parse_internal (11x)
       104 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::parser::arg_matcher::ArgMatcher::start_custom_group (5x)
        76 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::parser::parser::Parser::get_matches_with (4x)
        66 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::util::flat_map::FlatMap<K,V>::remove (3x)
        66 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::parser::arg_matcher::ArgMatcher::start_custom_arg (3x)
        66 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::parser::parser::Parser::add_defaults (3x)
        57 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::builder::command::Command::unroll_arg_requires (3x)
        57 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::builder::command::Command::_build_self (3x)
        57 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::parser::parser::Parser::resolve_pending (3x)
        44 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_automata::util::captures::GroupInfo::new (2x)
        38 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:clap_builder::builder::possible_value::PossibleValue::matches (2x)
        20 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:chrono::offset::local::tz_info::parser::Cursor::read_tag (2x)
        10 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:core::str::iter::SplitInternal<P>::next_back (1x)
        10 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:<regex_syntax::hir::Hir as core::cmp::PartialEq>::eq (1x)
        10 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_syntax::hir::literal::Extractor::extract (1x)
 1,443,941 ( 0.42%)       .            .           .           *  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe [/usr/lib/x86_64-linux-gnu/libc.so.6]

 6,452,372 ( 1.86%)     908 ( 0.11%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (39x) [./target/valgrind/s4]
 1,353,557 ( 0.39%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::finish_build_one_start [./target/valgrind/s4]
   251,252 ( 0.07%)     908 ( 0.11%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::DFA::set_matches (953x) [./target/valgrind/s4]

 1,342,331 ( 0.39%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push

 1,334,292 ( 0.38%)       .            .           .           *  ./malloc/./malloc/arena.c:realloc

 1,315,537 ( 0.38%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/validations.rs:core::str::converts::from_utf8

 1,282,625 ( 0.37%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

 1,193,878 ( 0.34%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::visitor::visit

 6,432,565 ( 1.85%)   2,381 ( 0.29%)   6 ( 1.85%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (512x) [./target/valgrind/s4]
   582,137 ( 0.17%)     250 ( 0.03%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten (55x) [./target/valgrind/s4]
   179,874 ( 0.05%)      66 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (12x) [./target/valgrind/s4]
 1,189,494 ( 0.34%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation [./target/valgrind/s4]
 4,715,984 ( 1.36%)     956 ( 0.12%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::into_parts (18,288x) [./target/valgrind/s4]
    15,320 ( 0.00%)      28 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::union (57x) [./target/valgrind/s4]
     7,718 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/debug.rs:regex_syntax::debug::utf8_decode (454x) [./target/valgrind/s4]
     7,453 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (6x) [./target/valgrind/s4]
     4,930 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation'2 (1x) [./target/valgrind/s4]
       156 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::new (1x) [./target/valgrind/s4]

 5,750,455 ( 1.65%)  30,845 ( 3.81%)   2 ( 0.62%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add (19,750x)
 4,665,535 ( 1.34%)     922 ( 0.11%)   6 ( 1.85%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::pikevm::ActiveStates::reset (318x)
 3,930,752 ( 1.13%)   1,427 ( 0.18%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop (270x)
 3,634,164 ( 1.05%)  30,798 ( 3.80%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::translate::TranslatorI::push_char (15,399x)
 2,821,056 ( 0.81%)  12,622 ( 1.56%)   2 ( 0.62%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::literal::PreferenceTrie::insert (8,722x)
 1,248,056 ( 0.36%)   3,243 ( 0.40%)   1 ( 0.31%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend (833x)
   956,783 ( 0.28%)     833 ( 0.10%)   2 ( 0.62%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (290x)
   461,208 ( 0.13%)   1,048 ( 0.13%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (525x)
   367,133 ( 0.11%)   1,002 ( 0.12%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::builder::Builder::build (175x)
   314,783 ( 0.09%)     796 ( 0.10%)   6 ( 1.85%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:aho_corasick::nfa::noncontiguous::Compiler::densify (314x)
   279,647 ( 0.08%)     825 ( 0.10%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<alloc::string::String as core::fmt::Write>::write_str (1,865x)
   176,563 ( 0.05%)     457 ( 0.06%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::hybrid::dfa::Lazy::init_cache (468x)
   139,200 ( 0.04%)     574 ( 0.07%)   1 ( 0.31%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (428x)
   138,455 ( 0.04%)     342 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::interval::IntervalSet<I>::union (903x)
   133,018 ( 0.04%)     486 ( 0.06%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::util::sparse_set::SparseSets::new (468x)
   127,399 ( 0.04%)     190 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (243x)
    53,685 ( 0.02%)     164 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (162x)
    47,769 ( 0.01%)      68 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (34x)
    32,412 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::util::determinize::state::State::dead (292x)
     5,391 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<clap_builder::builder::styled_str::StyledStr as core::convert::From<&str>>::from (20x)
     4,551 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x)
     3,035 ( 0.00%)      14 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::util::determinize::epsilon_closure (7x)
     1,640 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (6x)
     1,440 ( 0.00%)      10 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:s4lib::readers::syslinereader::SyslineReader::parse_datetime_in_line_cached (5x)
     1,081 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<T,I>>::from_iter (2x)
       542 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:clap_builder::builder::command::Command::_build_self (2x)
       270 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:clap_builder::mkeymap::MKeyMap::_build (1x)
       218 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<F as clap_builder::builder::value_parser::TypedValueParser>::parse_ref (1x)
       113 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<regex_automata::meta::strategy::Core as regex_automata::meta::strategy::Strategy>::create_cache (1x)
       113 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::backtrack::BoundedBacktracker::search_imp (1x)
       108 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::Hir::alternation (1x)
 1,141,564 ( 0.33%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle [./target/valgrind/s4]
23,465,943 ( 6.75%)  86,666 (10.70%)  20 ( 6.17%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::finish_grow (51,547x) [./target/valgrind/s4]

   981,596 ( 0.28%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments
    82,590 ( 0.02%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   980,746 ( 0.28%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_syntax::ast::parse::ParserI<P>::char

   980,244 ( 0.28%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_syntax::ast::parse::ParserI<P>::char

   963,455 ( 0.28%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   948,318 ( 0.27%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop
 4,418,157 ( 1.27%)  33,379 ( 4.12%)   .           .           >   ???:__rust_dealloc (34,540x) [./target/valgrind/s4]
     1,504 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (4x) [./target/valgrind/s4]
       136 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (4x) [./target/valgrind/s4]
         6 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<core::fmt::Error> (6x) [./target/valgrind/s4]

   936,665 ( 0.27%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add
10,696,691 ( 3.08%)  49,166 ( 6.07%)  10 ( 3.09%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (29,149x) [./target/valgrind/s4]

   924,958 ( 0.27%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

 8,379,527 ( 2.41%)  17,655 ( 2.18%)   8 ( 2.47%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:alloc::vec::Vec<T,A>::retain_mut (16,878x)
   896,672 ( 0.26%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::PreferenceTrie::insert [./target/valgrind/s4]

   829,775 ( 0.24%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post
 2,842,228 ( 0.82%)   4,966 ( 0.61%)  10 ( 3.09%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (17,779x) [./target/valgrind/s4]

 8,265,058 ( 2.38%)  33,587 ( 4.15%)   3 ( 0.93%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (48,360x) [./target/valgrind/s4]
   789,928 ( 0.23%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::TranslatorI::push_char [./target/valgrind/s4]

   719,567 ( 0.21%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (27,518x)
    68,050 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (2,722x) [./target/valgrind/s4]
   787,617 ( 0.23%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop'2 [./target/valgrind/s4]

 7,648,664 ( 2.20%)  26,574 ( 3.28%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (15,929x) [./target/valgrind/s4]
   770,554 ( 0.22%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate [./target/valgrind/s4]
 3,736,537 ( 1.08%)  22,017 ( 2.72%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (15,929x) [./target/valgrind/s4]
 1,417,681 ( 0.41%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (15,929x) [./target/valgrind/s4]
   334,509 ( 0.10%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (15,929x) [./target/valgrind/s4]

   770,525 ( 0.22%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/alphabet.rs:regex_automata::hybrid::dfa::Builder::build_from_nfa

   763,175 ( 0.22%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/alphabet.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa
     5,250 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   746,657 ( 0.21%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile
 9,025,691 ( 2.60%)  44,346 ( 5.47%)  14 ( 4.32%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (37,448x) [./target/valgrind/s4]

   729,564 ( 0.21%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/alloc.rs:__rdl_realloc
30,577,223 ( 8.80%) 144,990 (17.90%)  81 (25.00%)  .           >   ./malloc/./malloc/malloc.c:realloc (60,797x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 7,483,848 ( 2.15%)   3,482 ( 0.43%)   7 ( 2.16%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:regex_automata::util::prefilter::teddy::Teddy::new (39x)
 1,858,676 ( 0.53%)     948 ( 0.12%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/ahocorasick.rs:aho_corasick::ahocorasick::AhoCorasickBuilder::build (9x) [./target/valgrind/s4]
   705,930 ( 0.20%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build [./target/valgrind/s4]
 1,870,849 ( 0.54%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle (48x) [./target/valgrind/s4]
 1,354,850 ( 0.39%)   1,230 ( 0.15%)   1 ( 0.31%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::init_unanchored_start_state (48x) [./target/valgrind/s4]
   921,773 ( 0.27%)     796 ( 0.10%)   6 ( 1.85%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::densify (48x) [./target/valgrind/s4]
   652,804 ( 0.19%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::add_transition (2,432x) [./target/valgrind/s4]
   564,716 ( 0.16%)     384 ( 0.05%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions (48x) [./target/valgrind/s4]
   457,056 ( 0.13%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::add_dead_state_loop (48x) [./target/valgrind/s4]
   385,728 ( 0.11%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state (48x) [./target/valgrind/s4]
   298,368 ( 0.09%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/prefilter.rs:aho_corasick::util::prefilter::Builder::build (48x) [./target/valgrind/s4]
   238,270 ( 0.07%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::byte_classes (48x) [./target/valgrind/s4]
   214,784 ( 0.06%)     609 ( 0.08%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (2,624x) [./target/valgrind/s4]
   168,663 ( 0.05%)     305 ( 0.04%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::add_match (1,394x) [./target/valgrind/s4]
   158,544 ( 0.05%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::add_unanchored_start_state_loop (48x) [./target/valgrind/s4]
   125,120 ( 0.04%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::set_range (3,680x) [./target/valgrind/s4]
    68,181 ( 0.02%)     602 ( 0.07%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::shrink_to_fit (240x) [./target/valgrind/s4]
    33,120 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::iter_trans (3,680x) [./target/valgrind/s4]
    32,264 ( 0.01%)      94 ( 0.01%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::new (48x) [./target/valgrind/s4]
    11,136 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (144x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    11,040 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::State::is_match (3,680x) [./target/valgrind/s4]
     9,501 ( 0.00%)      94 ( 0.01%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<aho_corasick::util::prefilter::Builder> (48x) [./target/valgrind/s4]
       816 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::close_start_state_loop_for_leftmost (48x) [./target/valgrind/s4]

   700,386 ( 0.20%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/alphabet.rs:regex_automata::hybrid::dfa::Lazy::init_cache

   694,344 ( 0.20%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_syntax::ast::visitor::visit

164,120,136 (47.23%) 350,504 (43.26%) 126 (38.89%)  1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/regex.rs:regex_automata::meta::regex::Builder::build (81x) [./target/valgrind/s4]
   690,131 ( 0.20%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/strategy.rs:regex_automata::meta::strategy::new [./target/valgrind/s4]
31,332,161 ( 9.02%)  58,077 ( 7.17%)  21 ( 6.48%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::extract (13x) [./target/valgrind/s4]
11,570,144 ( 3.33%)  38,013 ( 4.69%)   1 ( 0.31%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> (175x) [./target/valgrind/s4]
 7,615,076 ( 2.19%)  16,850 ( 2.08%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/prefilter/mod.rs:regex_automata::util::prefilter::prefixes (16x) [./target/valgrind/s4]
 2,513,072 ( 0.72%)   2,502 ( 0.31%)   2 ( 0.62%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::OnePass::new (81x) [./target/valgrind/s4]
 2,469,073 ( 0.71%)   5,221 ( 0.64%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/prefilter/mod.rs:regex_automata::util::prefilter::suffixes (13x) [./target/valgrind/s4]
 1,177,206 ( 0.34%)     606 ( 0.07%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::new (81x) [./target/valgrind/s4]
   231,560 ( 0.07%)   1,123 ( 0.14%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (13x) [./target/valgrind/s4]
    87,088 ( 0.03%)      39 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::new (13x) [./target/valgrind/s4]
    48,088 ( 0.01%)     111 ( 0.01%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::BoundedBacktracker::new (81x) [./target/valgrind/s4]
    47,734 ( 0.01%)     111 ( 0.01%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::PikeVM::new (81x) [./target/valgrind/s4]
     4,225 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::new (13x) [./target/valgrind/s4]
     2,626 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (26x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
       458 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/literal.rs:regex_automata::meta::literal::alternation_literals (16x) [./target/valgrind/s4]
       351 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::configure (13x) [./target/valgrind/s4]

 1,236,667 ( 0.36%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build (175x) [./target/valgrind/s4]
   672,734 ( 0.19%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::remap [./target/valgrind/s4]

   671,943 ( 0.19%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/range.rs:alloc::vec::Vec<T,A>::extend_with

   659,961 ( 0.19%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   637,468 ( 0.18%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

   622,983 ( 0.18%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_automata::nfa::thompson::builder::Builder::build

   621,488 ( 0.18%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::into_parts
 1,048,761 ( 0.30%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (38,843x) [./target/valgrind/s4]
   971,075 ( 0.28%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (38,843x) [./target/valgrind/s4]

   606,645 ( 0.17%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::add
 3,379,462 ( 0.97%)   5,098 ( 0.63%)  25 ( 7.72%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (1,376x) [./target/valgrind/s4]

   597,028 ( 0.17%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::PreferenceTrie::insert
 1,546,713 ( 0.45%)   5,033 ( 0.62%)   6 ( 1.85%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (2,014x) [./target/valgrind/s4]

22,955,858 ( 6.61%) 101,427 (12.52%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast> (774x) [./target/valgrind/s4]
   584,191 ( 0.17%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop [./target/valgrind/s4]
16,767,779 ( 4.83%)  99,842 (12.32%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (71,256x) [./target/valgrind/s4]

   545,024 ( 0.16%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::dfa::Builder::finish_build_one_start

   523,590 ( 0.15%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments
    82,590 ( 0.02%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   520,854 ( 0.15%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   513,492 ( 0.15%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/convert/num.rs:aho_corasick::dfa::Builder::finish_build_one_start

   510,608 ( 0.15%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   493,605 ( 0.14%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

   491,126 ( 0.14%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/traits.rs:regex_syntax::ast::parse::ParserI<P>::char

   490,624 ( 0.14%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::char

   490,624 ( 0.14%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_syntax::ast::parse::ParserI<P>::char

   490,624 ( 0.14%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_syntax::ast::parse::ParserI<P>::char

   869,544 ( 0.25%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (16,096x)
   839,724 ( 0.24%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::literal (15,406x) [./target/valgrind/s4]
    98,933 ( 0.03%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::literal (1,912x) [./target/valgrind/s4]
    63,976 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class (1,454x) [./target/valgrind/s4]
       785 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/os_str.rs:std::sys::unix::os_str::Slice::to_str (12x)
       384 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:std::sys::unix::os_str::Buf::into_string (5x)
       173 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/chrono-0.4.40/src/offset/local/tz_info/parser.rs:chrono::offset::local::tz_info::rule::RuleDay::parse (4x)
       110 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/chrono-0.4.40/src/offset/local/tz_info/parser.rs:chrono::offset::local::tz_info::parser::parse (1x) [./target/valgrind/s4]
        88 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (2x) [./target/valgrind/s4]
        74 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/chrono-0.4.40/src/offset/local/tz_info/parser.rs:chrono::offset::local::tz_info::parser::Cursor::read_int (2x) [./target/valgrind/s4]
        74 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/clap_lex-0.4.1/src/ext.rs:clap_lex::ParsedArg::to_short (2x)
        44 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/chrono-0.4.40/src/offset/local/tz_info/parser.rs:chrono::offset::local::tz_info::rule::parse_hhmmss (1x)
   488,558 ( 0.14%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/converts.rs:core::str::converts::from_utf8 [./target/valgrind/s4]

31,793,163 ( 9.15%) 144,990 (17.90%)  81 (25.00%)  .           < ???:__rust_realloc (60,797x) [./target/valgrind/s4]
   486,376 ( 0.14%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/alloc.rs:__rdl_realloc [./target/valgrind/s4]

   738,576 ( 0.21%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::init_cache (22,413x) [./target/valgrind/s4]
     7,194 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (218x) [./target/valgrind/s4]
   475,251 ( 0.14%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::set_transition [./target/valgrind/s4]

   472,696 ( 0.14%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap

 8,066,965 ( 2.32%)  29,389 ( 3.63%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (20,550x) [./target/valgrind/s4]
 4,715,984 ( 1.36%)     956 ( 0.12%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (18,288x) [./target/valgrind/s4]
     1,220 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation'2 (5x) [./target/valgrind/s4]
   466,116 ( 0.13%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::into_parts [./target/valgrind/s4]

   463,662 ( 0.13%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::Extractor::union
   536,073 ( 0.15%)   1,085 ( 0.13%)   1 ( 0.31%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_extend.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend (2,443x) [./target/valgrind/s4]

   456,868 ( 0.13%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/primitives.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   454,682 ( 0.13%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Builder::build
    19,516 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:<aho_corasick::util::primitives::SmallIndex as core::convert::TryFrom<usize>>::try_from (2,788x) [./target/valgrind/s4]

   434,923 ( 0.13%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/alloc/layout.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push

 9,354,277 ( 2.69%)   1,198 ( 0.15%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (2,753x) [./target/valgrind/s4]
   434,027 ( 0.12%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class [./target/valgrind/s4]
 2,682,187 ( 0.77%)     330 ( 0.04%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (2,824x) [./target/valgrind/s4]
 2,185,246 ( 0.63%)       2 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x) [./target/valgrind/s4]
 1,393,222 ( 0.40%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range (3,549x) [./target/valgrind/s4]
   943,165 ( 0.27%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::maybe_parse_ascii_class (841x) [./target/valgrind/s4]
   267,648 ( 0.08%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (12,720x) [./target/valgrind/s4]
   189,060 ( 0.05%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (6,302x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   179,406 ( 0.05%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (9,967x) [./target/valgrind/s4]

   427,273 ( 0.12%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::into_parts
 4,961,892 ( 1.43%)  29,815 ( 3.68%)   .           .           >   ???:__rust_alloc (38,843x) [./target/valgrind/s4]
 3,860,291 ( 1.11%)     530 ( 0.07%)   .           .           >   ???:__rust_dealloc (38,843x) [./target/valgrind/s4]

   427,273 ( 0.12%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::hir::Hir::into_parts

   422,207 ( 0.12%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

   420,357 ( 0.12%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_automata::nfa::thompson::builder::Builder::patch

   418,916 ( 0.12%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ops/range.rs:aho_corasick::dfa::Builder::finish_build_one_start

   418,550 ( 0.12%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

   411,659 ( 0.12%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments
 5,503,764 ( 1.58%)  28,829 ( 3.56%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (18,495x) [./target/valgrind/s4]

   406,972 ( 0.12%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:aho_corasick::dfa::Builder::finish_build_one_start

   652,804 ( 0.19%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (2,432x) [./target/valgrind/s4]
   406,806 ( 0.12%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::add_transition [./target/valgrind/s4]

71,042,846 (20.45%) 394,157 (48.65%)  75 (23.15%)  1 ( 0.07%)  < ???:__rust_alloc (402,527x) [./target/valgrind/s4]
   402,769 ( 0.12%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/alloc.rs:__rdl_alloc [./target/valgrind/s4]

29,777,298 ( 8.57%) 154,446 (19.06%)  21 ( 6.48%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::finish_grow (156,689x) [./target/valgrind/s4]
11,363,631 ( 3.27%)  82,035 (10.13%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (52,360x)
 4,961,892 ( 1.43%)  29,815 ( 3.68%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::into_parts (38,843x)
 3,265,871 ( 0.94%)  22,947 ( 2.83%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::Concat::into_ast (15,786x)
 2,863,294 ( 0.82%)  20,368 ( 2.51%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::builder::Builder::build (12,204x)
 2,331,834 ( 0.67%)  16,855 ( 2.08%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::concat (17,551x)
 2,086,458 ( 0.60%)  10,021 ( 1.24%)   2 ( 0.62%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (19,936x)
 2,014,352 ( 0.58%)     262 ( 0.03%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend (81x)
 1,495,927 ( 0.43%)   9,946 ( 1.23%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::cross (7,320x)
 1,131,444 ( 0.33%)   7,733 ( 0.95%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::raw_vec::RawVec<T,A>::allocate_in (5,396x)
   876,350 ( 0.25%)     606 ( 0.07%)  40 (12.35%)  1 ( 0.07%)  < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::map::Utf8BoundedMap::clear (67x)
   866,077 ( 0.25%)     950 ( 0.12%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::meta::strategy::new (81x)
   842,354 ( 0.24%)     977 ( 0.12%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::translate::TranslatorI::push_char (16,096x)
   786,925 ( 0.23%)      12 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::literal (15,406x)
   654,680 ( 0.19%)   4,402 ( 0.54%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::class (2,728x)
   538,489 ( 0.15%)   2,938 ( 0.36%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::extract'2 (5,194x)
   507,110 ( 0.15%)   3,638 ( 0.45%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::literal (1,912x)
   489,848 ( 0.14%)   3,706 ( 0.46%)   1 ( 0.31%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::repetition (2,034x)
   368,952 ( 0.11%)   2,751 ( 0.34%)   1 ( 0.31%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::meta::reverse_inner::flatten'2 (2,166x)
   364,723 ( 0.10%)   2,940 ( 0.36%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<alloc::vec::Vec<T,A> as core::clone::Clone>::clone (1,657x)
   336,217 ( 0.10%)   1,237 ( 0.15%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition (3,426x)
   296,065 ( 0.09%)   2,226 ( 0.27%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::packed::pattern::Patterns::add (1,394x)
   284,222 ( 0.08%)   2,012 ( 0.25%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::class (1,454x)
   185,577 ( 0.05%)     142 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (81x)
   182,445 ( 0.05%)   1,014 ( 0.13%)   6 ( 1.85%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::alternation (1,157x)
   166,679 ( 0.05%)     192 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::meta::reverse_inner::flatten (118x)
   166,055 ( 0.05%)   1,132 ( 0.14%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::capture (693x)
   147,703 ( 0.04%)   1,018 ( 0.13%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::util::captures::GroupInfo::new (761x)
   140,278 ( 0.04%)     306 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<T as alloc::vec::spec_from_elem::SpecFromElem>::from_elem (153x)
   139,740 ( 0.04%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop (2,740x)
   139,107 ( 0.04%)       2 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (2,722x) [./target/valgrind/s4]
   138,954 ( 0.04%)     863 ( 0.11%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (773x)
   113,571 ( 0.03%)   1,066 ( 0.13%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::meta::regex::Builder::build (405x)
   111,674 ( 0.03%)     824 ( 0.10%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (586x)
   110,919 ( 0.03%)     314 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (1,386x)
   109,939 ( 0.03%)     420 ( 0.05%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::utf8::Utf8Sequences::new (1,386x)
    92,468 ( 0.03%)     613 ( 0.08%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::Alternation::into_ast (512x)
    91,133 ( 0.03%)     435 ( 0.05%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter (913x)
    75,053 ( 0.02%)     133 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<alloc::string::String as core::clone::Clone>::clone (1,188x)
    71,061 ( 0.02%)     319 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (693x)
    67,227 ( 0.02%)     374 ( 0.05%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::map::Utf8SuffixMap::clear (68x)
    52,455 ( 0.02%)     100 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex::builders::Builder::build_one_bytes (80x)
    45,786 ( 0.01%)     188 ( 0.02%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (495x) [./target/valgrind/s4]
    44,165 ( 0.01%)     177 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::meta::regex::RegexInfo::new (162x)
    41,613 ( 0.01%)       6 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::meta::regex::Regex::create_captures (86x)
    40,023 ( 0.01%)     104 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (512x)
    39,632 ( 0.01%)      34 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::Ast::empty (693x)
    37,752 ( 0.01%)     160 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash (347x)
    37,418 ( 0.01%)      77 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (586x)
    33,077 ( 0.01%)      24 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (595x)
    29,269 ( 0.01%)     262 ( 0.03%)   4 ( 1.23%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (114x)
    26,765 ( 0.01%)     158 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (174x)
    19,104 ( 0.01%)     142 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::util::captures::GroupInfoInner::add_first_group (81x)
    18,490 ( 0.01%)      82 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::Ast::repetition (172x)
    17,737 ( 0.01%)     128 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::union (81x)
    16,707 ( 0.00%)      92 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Repetition::with (149x)
    16,278 ( 0.00%)       6 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_automata::meta::strategy::Core as regex_automata::meta::strategy::Strategy>::create_cache (42x)
    15,430 ( 0.00%)      52 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (172x)
    15,399 ( 0.00%)      52 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (208x)
    14,892 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::util::determinize::state::State::dead (292x)
    12,312 ( 0.00%)      50 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::FatAVX2<3_usize>::new_unchecked (42x)
    11,911 ( 0.00%)      30 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::util::prefilter::Prefilter::from_choice (50x)
     8,925 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x)
     8,292 ( 0.00%)      56 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::Edge>::insert_recursing (72x)
     7,901 ( 0.00%)      31 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<1_usize>::new_unchecked (36x)
     6,622 ( 0.00%)      12 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::packed::api::Builder::build (96x)
     6,269 ( 0.00%)      26 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert (73x)
     5,172 ( 0.00%)      14 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::slice::sort::merge_sort (76x)
     5,170 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Compiler::c (110x)
     4,744 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::data::line::Line::get_boxptrs (84x)
     3,951 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:std::sys::unix::os_str::Slice::to_owned (22x)
     3,895 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (71x)
     2,925 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<P as clap_builder::builder::value_parser::AnyValueParser>::parse_ref (15x)
     2,879 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::extract (51x)
     2,749 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<clap_builder::builder::styled_str::StyledStr as core::convert::From<&str>>::from (20x)
     2,682 ( 0.00%)      11 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<3_usize>::new_unchecked (15x)
     2,448 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle (48x)
     2,448 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::util::remapper::Remapper::remap (48x)
     2,372 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::builder::arg::Arg::_build (12x)
     2,091 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x)
     1,553 ( 0.00%)      14 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:hashbrown::raw::RawTable<T,A>::fallible_with_capacity (13x)
     1,480 ( 0.00%)      10 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::linereader::LineReader::insert_line (5x)
     1,467 ( 0.00%)       4 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::push_group (20x)
     1,441 ( 0.00%)       8 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:lru::LruCache<K,V,S>::put (15x)
     1,320 ( 0.00%)      12 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:lru::LruCache<K,V>::new (6x)
     1,292 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:std::env::args_os (7x)
       946 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (6x)
       756 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::parser::parser::Parser::add_defaults (12x)
       744 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4::processing_loop (2x)
       699 ( 0.00%)       6 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:hashbrown::raw::RawTableInner::fallible_with_capacity (4x)
       663 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::meta::reverse_inner::extract (13x)
       660 ( 0.00%)       6 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::linereader::LineReader::find_line_in_block (3x)
       642 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<T,I>>::from_iter (3x)
       613 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ops::function::FnOnce::call_once (3x)
       585 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::parser::parser::Parser::start_custom_arg (3x)
       583 ( 0.00%)       3 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<4_usize>::new_unchecked (3x)
       561 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_automata::meta::strategy::ReverseInner as regex_automata::meta::strategy::Strategy>::create_cache (11x)
       482 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::insert_sysline (4x)
       459 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::ahocorasick::AhoCorasickBuilder::build (9x)
       440 ( 0.00%)       4 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::linereader::LineReader::new (2x)
       392 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:chrono::offset::local::tz_info::parser::parse (2x)
       384 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<F as clap_builder::builder::value_parser::TypedValueParser>::parse_ref (2x)
       379 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<alloc::boxed::Box<[I]> as core::iter::traits::collect::FromIterator<I>>::from_iter (1x)
       363 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:std::sys::unix::thread::Thread::new (2x)
       354 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:std::sys_common::once::futex::Once::call (2x)
       297 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:std::thread::Thread::new (3x)
       285 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::look (2x)
       276 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::blockreader::BlockReader::read_block_File (2x)
       260 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<P as clap_builder::builder::value_parser::AnyValueParser>::possible_values (2x)
       255 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:crossbeam_channel::select::Select::new (5x)
       255 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::unicode::perl_digit (5x)
       222 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::new (1x)
       218 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:crossbeam_channel::context::Context::new (1x)
       213 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::printer::printers::PrinterLogMessage::new (1x)
       205 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<clap_lex::RawArgs as core::convert::From<I>>::from (1x)
       204 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:std::thread::Builder::spawn_unchecked (4x)
       203 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::get_matches_from (1x)
       197 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:std::fs::read::inner (1x)
       189 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<&str as alloc::ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl (1x)
       141 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::unroll_arg_requires (3x)
       102 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::alternation'2 (2x)
       102 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::_build_self (2x)
       102 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4::main (2x)
       102 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::linereader::LineReader::find_line (2x)
       102 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4::process_dt_exit (2x)
       102 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::fmt::format::format_inner (2x)
        94 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::find_sysline_in_block_year (2x)
        94 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::find_sysline_year (2x)
        51 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:std::sys::unix::os::getenv::{{closure}} (1x)
        51 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::filepreprocessor::process_path (1x)
        51 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::helpers::basename (1x)
        51 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::dfa::remapper::Remapper::new (1x)
        51 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex::builders::Builder::build_one_string (1x)
        51 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::required_graph (1x)
        51 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:std::sys::unix::fs::canonicalize (1x)
        51 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::dfa::remapper::Remapper::remap (1x)
        47 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::interval::IntervalSet<I>::new (1x)
        47 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::filepreprocessor::pathbuf_to_filetype_impl (1x)
        47 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:ctrlc::init_and_set_handler (1x)
   402,527 ( 0.12%)       .            .           .           *  ???:__rust_alloc [./target/valgrind/s4]
71,042,846 (20.45%) 394,157 (48.65%)  75 (23.15%)  1 ( 0.07%)  >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/alloc.rs:__rdl_alloc (402,527x) [./target/valgrind/s4]

   398,025 ( 0.11%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

   393,439 ( 0.11%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle

   389,543 ( 0.11%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_syntax::hir::Hir::alternation

48,295,583 (13.90%) 261,138 (32.23%)   1 ( 0.31%)  .           < ???:__rust_dealloc (386,109x) [./target/valgrind/s4]
   386,109 ( 0.11%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/alloc.rs:__rdl_dealloc [./target/valgrind/s4]
47,909,474 (13.79%) 261,138 (32.23%)   1 ( 0.31%)  .           >   ./malloc/./malloc/malloc.c:free (386,109x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

11,896,747 ( 3.42%)  94,299 (11.64%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (90,718x) [./target/valgrind/s4]
 6,075,124 ( 1.75%)   2,148 ( 0.27%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::concat (60,755x)
 5,784,507 ( 1.66%)  40,268 ( 4.97%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (45,047x)
 4,418,157 ( 1.27%)  33,379 ( 4.12%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (34,540x)
 4,296,335 ( 1.24%)  27,229 ( 3.36%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (27,622x)
 3,860,291 ( 1.11%)     530 ( 0.07%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::into_parts (38,843x)
 3,838,353 ( 1.10%)  28,817 ( 3.56%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (30,129x) [./target/valgrind/s4]
 1,946,447 ( 0.56%)   2,960 ( 0.37%)   1 ( 0.31%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> (2,155x)
 1,085,839 ( 0.31%)     292 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile (10,884x)
   934,804 ( 0.27%)   7,516 ( 0.93%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::PreferenceTrie::minimize (7,022x)
   694,295 ( 0.20%)   3,372 ( 0.42%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::cross (5,904x)
   335,353 ( 0.10%)   2,601 ( 0.32%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (2,598x)
   333,296 ( 0.10%)   2,543 ( 0.31%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::vec::Vec<T,A>::retain_mut (2,598x)
   227,553 ( 0.07%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,299x)
   213,250 ( 0.06%)     397 ( 0.05%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::extract'2 (2,035x)
   192,908 ( 0.06%)   1,513 ( 0.19%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::util::prefilter::teddy::Teddy::new (1,490x)
   173,625 ( 0.05%)     991 ( 0.12%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::sync::Arc<T,A>::drop_slow (1,456x)
   163,318 ( 0.05%)   1,107 ( 0.14%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::meta::reverse_inner::prefilter (1,317x)
   151,936 ( 0.04%)   1,005 ( 0.12%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::meta::regex::Builder::build (1,231x)
   144,470 ( 0.04%)      19 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::class (1,454x)
   120,858 ( 0.03%)     938 ( 0.12%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<aho_corasick::dfa::DFA> (909x)
    96,261 ( 0.03%)     729 ( 0.09%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_automata::util::prefilter::teddy::Teddy> (745x)
    94,550 ( 0.03%)      68 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::extract (935x)
    92,659 ( 0.03%)      36 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (947x)
    92,015 ( 0.03%)      44 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::Concat::into_ast (917x)
    88,847 ( 0.03%)     888 ( 0.11%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (595x)
    86,957 ( 0.03%)     982 ( 0.12%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (596x)
    85,144 ( 0.02%)      51 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (846x) [./target/valgrind/s4]
    84,761 ( 0.02%)     669 ( 0.08%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::alternation (657x)
    80,787 ( 0.02%)     281 ( 0.03%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (735x)
    79,745 ( 0.02%)     107 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast> (774x) [./target/valgrind/s4]
    76,541 ( 0.02%)     582 ( 0.07%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (565x)
    75,177 ( 0.02%)     574 ( 0.07%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (586x)
    74,721 ( 0.02%)     552 ( 0.07%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::sync::Arc<T,A>::drop_slow'2 (555x)
    74,512 ( 0.02%)     724 ( 0.09%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::builder::Builder::build (525x)
    70,326 ( 0.02%)      63 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x)
    65,176 ( 0.02%)     349 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (525x)
    64,170 ( 0.02%)     427 ( 0.05%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<alloc::collections::btree::map::BTreeMap<K,V,A> as core::ops::drop::Drop>::drop (519x)
    41,211 ( 0.01%)     298 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::visitor::visit (324x)
    35,776 ( 0.01%)     359 ( 0.04%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<aho_corasick::nfa::noncontiguous::NFA> (240x)
    32,551 ( 0.01%)     246 ( 0.03%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::union (254x)
    28,860 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::util::determinize::state::State::dead (292x)
    24,830 ( 0.01%)      89 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (224x)
    20,965 ( 0.01%)      96 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (177x)
    19,817 ( 0.01%)     134 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex::regex::bytes::Regex::new (160x)
    16,923 ( 0.00%)      85 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::meta::strategy::new (143x)
    15,738 ( 0.00%)     122 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<aho_corasick::packed::teddy::generic::Teddy<16_usize>> (122x)
    14,851 ( 0.00%)       4 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash (149x)
    14,229 ( 0.00%)      91 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::packed::api::Builder::build (108x)
    13,515 ( 0.00%)     158 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop (81x)
    11,183 ( 0.00%)       1 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (113x) [./target/valgrind/s4]
     9,594 ( 0.00%)      12 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::parse_datetime_in_line_cached (94x)
     9,488 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::util::remapper::Remapper::remap (96x)
     9,377 ( 0.00%)      19 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<core::option::Option<regex::regex::string::Regex>> (10x)
     8,068 ( 0.00%)       8 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::data::datetime::bytes_to_regex_to_datetime (79x)
     7,917 ( 0.00%)      94 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<aho_corasick::util::prefilter::Builder> (48x)
     7,812 ( 0.00%)      12 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::slice::sort::merge_sort (76x)
     7,615 ( 0.00%)      78 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions (48x)
     6,499 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::parser::matches::matched_arg::MatchedArg::into_vals_flatten (59x)
     4,424 ( 0.00%)      46 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::collections::btree::node::BalancingContext<K,V>::merge_tracking_child_edge (24x)
     4,417 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::parser::matches::arg_matches::ArgMatches::try_remove_one (37x)
     3,564 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Seq::optimize_by_preference (36x)
     2,885 ( 0.00%)      25 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_automata::hybrid::dfa::Cache> (21x)
     2,837 ( 0.00%)       6 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (27x)
     2,635 ( 0.00%)      12 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<lru::LruCache<K,V,S> as core::ops::drop::Drop>::drop (23x)
     2,360 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<1_usize>::new_unchecked (24x)
     2,302 ( 0.00%)      24 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::util::prefilter::prefixes (15x)
     2,079 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::FatAVX2<3_usize>::new_unchecked (21x)
     1,903 ( 0.00%)       7 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<hashbrown::raw::RawTable<T,A> as core::ops::drop::Drop>::drop (18x)
     1,863 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<clap_builder::builder::styled_str::StyledStr as core::convert::From<&str>>::from (20x)
     1,660 ( 0.00%)      12 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::meta::reverse_inner::extract (13x)
     1,365 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::parser::parser::Parser::push_arg_values (15x)
     1,279 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::into_kind (13x)
     1,269 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::util::prefilter::suffixes (12x)
     1,242 ( 0.00%)      10 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<aho_corasick::packed::teddy::generic::Teddy<8_usize>> (10x)
     1,199 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Seq::cross_preamble (13x)
     1,100 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<clap_builder::builder::command::Command> (10x)
     1,085 ( 0.00%)       3 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4::processing_loop (11x)
       990 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<3_usize>::new_unchecked (10x)
       829 ( 0.00%)       8 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<s4lib::readers::syslogprocessor::SyslogProcessor> (6x)
       812 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::alternation'2 (8x)
       714 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4::main (7x)
       672 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::parser::matches::any_value::AnyValue::downcast_into (6x)
       637 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::get_matches_from (7x)
       549 ( 0.00%)       2 ( 0.00%)   .           .           < src/data/datetime.rs:s4lib::data::datetime::bytes_to_regex_to_datetime (5x) [./target/valgrind/s4]
       546 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::unroll_arg_requires (6x)
       441 ( 0.00%)       6 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<&T,I>>::spec_extend (3x)
       435 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::_build_self (4x)
       399 ( 0.00%)       4 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::collections::btree::remove::<impl alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::KV>>::remove_leaf_kv (2x)
       364 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind>'2 (4x) [./target/valgrind/s4]
       364 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4::process_dt_exit (4x)
       351 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<alloc::boxed::Box<crossbeam_channel::counter::Counter<crossbeam_channel::flavors::array::Channel<s4::ChanDatum>>>> (3x)
       351 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<s4lib::readers::blockreader::BlockReader> (3x)
       306 ( 0.00%)       4 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::collections::btree::node::BalancingContext<K,V>::do_merge (2x)
       273 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<T,I>>::from_iter (3x)
       263 ( 0.00%)       3 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:std::sys::common::thread_local::fast_local::destroy_value (2x)
       250 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex::regex::string::Regex::new (2x)
       231 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop (2x)
       225 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<clap_builder::parser::matches::arg_matches::ArgMatches> (2x)
       198 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::collections::btree::map::IntoIter<K,V,A>::dying_next (2x)
       198 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::dfa::remapper::Remapper::remap (2x)
       198 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::summary (2x)
       198 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<4_usize>::new_unchecked (2x)
       182 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:std::sys::unix::thread::Thread::new::thread_start (2x)
       182 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4::cli_process_blocksz (2x)
       182 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::filepreprocessor::process_path (2x)
       182 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::parser::validator::Validator::validate (2x)
       182 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4::string_wdhms_to_duration (2x)
       182 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ops::function::FnOnce::call_once (2x)
       182 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<F as clap_builder::builder::value_parser::TypedValueParser>::parse_ref (2x)
       139 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<core::option::Option<s4lib::printer::printers::PrinterLogMessage>> (1x)
       134 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:chrono::offset::local::tz_info::timezone::TimeZone::from_posix_tz (1x)
       112 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir>'2 (1x) [./target/valgrind/s4]
       112 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir>'2 (1x)
        99 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::dt_patterns_analysis (1x)
        99 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::blockreader::BlockReader::new (1x)
        99 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<s4lib::readers::summary::Summary> (1x)
        91 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<std::io::buffered::linewriter::LineWriter<std::io::stdio::StdoutRaw>> (1x)
        91 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<clap_lex::RawArgs as core::convert::From<I>>::from (1x)
        91 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4::exec_fileprocessor_thread (1x)
        91 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:s4lib::readers::filepreprocessor::pathbuf_to_filetype_impl (1x)
        91 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<clap_builder::parser::matches::arg_matches::Values<T> as core::iter::traits::iterator::Iterator>::next (1x)
        91 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:clap_builder::parser::parser::Parser::get_matches_with (1x)
        91 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (1x)
        91 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:termcolor::ColorChoice::should_attempt_color (1x)
   386,109 ( 0.11%)       .            .           .           *  ???:__rust_dealloc [./target/valgrind/s4]
48,295,583 (13.90%) 261,138 (32.23%)   1 ( 0.31%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/alloc.rs:__rdl_dealloc (386,109x) [./target/valgrind/s4]

   385,388 ( 0.11%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

   383,680 ( 0.11%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::dfa::Builder::finish_build_one_start

   374,085 ( 0.11%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

   371,635 ( 0.11%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_syntax::hir::literal::Extractor::union
 1,135,082 ( 0.33%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (51,690x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 2,381,543 ( 0.69%)      12 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (15,406x) [./target/valgrind/s4]
   369,744 ( 0.11%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::literal [./target/valgrind/s4]
   839,724 ( 0.24%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/converts.rs:core::str::converts::from_utf8 (15,406x) [./target/valgrind/s4]

   359,228 ( 0.10%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap

   357,028 ( 0.10%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::builder::Builder::add

   352,454 ( 0.10%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::Builder::build

   349,352 ( 0.10%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::concat
 6,075,124 ( 1.75%)   2,148 ( 0.27%)   .           .           >   ???:__rust_dealloc (60,755x) [./target/valgrind/s4]
 2,331,834 ( 0.67%)  16,855 ( 2.08%)   .           .           >   ???:__rust_alloc (17,551x) [./target/valgrind/s4]

   347,692 ( 0.10%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop
 5,028,015 ( 1.45%)  29,391 ( 3.63%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (27,518x) [./target/valgrind/s4]
   719,567 ( 0.21%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop'2 (27,518x) [./target/valgrind/s4]

   344,086 ( 0.10%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_syntax::ast::visitor::visit

   339,029 ( 0.10%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   335,268 ( 0.10%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:alloc::vec::Vec<T,A>::extend_with

   333,360 ( 0.10%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

   324,591 ( 0.09%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2
 1,274,375 ( 0.37%)   7,729 ( 0.95%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::allocate_in (5,376x) [./target/valgrind/s4]

   317,853 ( 0.09%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (35,317x) [./target/valgrind/s4]
   317,853 ( 0.09%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> [./target/valgrind/s4]

   311,522 ( 0.09%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

   311,407 ( 0.09%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments
11,363,631 ( 3.27%)  82,035 (10.13%)   .           .           >   ???:__rust_alloc (52,360x) [./target/valgrind/s4]

   305,906 ( 0.09%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::literal::Extractor::union

   302,964 ( 0.09%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   298,718 ( 0.09%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push

 1,353,314 ( 0.39%)   1,230 ( 0.15%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::init_unanchored_start_state (96x) [./target/valgrind/s4]
   456,288 ( 0.13%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::add_dead_state_loop (48x) [./target/valgrind/s4]
   297,792 ( 0.09%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state [./target/valgrind/s4]

   293,139 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/traits/iterator.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

   290,416 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

   287,926 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

   287,300 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::translate::TranslatorI::push_char
 3,634,164 ( 1.05%)  30,798 ( 3.80%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle (15,399x) [./target/valgrind/s4]

 2,150,787 ( 0.62%)   1,397 ( 0.17%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::meta::wrappers::Hybrid::create_cache (106x)
   137,571 ( 0.04%)     139 ( 0.02%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::meta::wrappers::ReverseHybrid::create_cache (11x)
   285,518 ( 0.08%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::init_cache [./target/valgrind/s4]
   738,576 ( 0.21%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::set_transition (22,413x) [./target/valgrind/s4]
    41,862 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/state.rs:regex_automata::util::determinize::state::State::dead (117x) [./target/valgrind/s4]

   285,127 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap

   283,244 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_syntax::hir::Hir::concat

   282,462 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::concat
 2,400,726 ( 0.69%)   3,724 ( 0.46%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (16,418x) [./target/valgrind/s4]

   277,269 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::bump

   277,269 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::bump

   277,269 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/mod.rs:regex_syntax::ast::parse::ParserI<P>::bump

   273,261 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::translate::TranslatorI::push_char
   568,395 ( 0.16%)   1,812 ( 0.22%)   3 ( 0.93%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (221x) [./target/valgrind/s4]

   271,864 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::map::Utf8SuffixMap::clear

 1,488,569 ( 0.43%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::remap (48x) [./target/valgrind/s4]
   270,270 ( 0.08%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap [./target/valgrind/s4]

 7,008,374 ( 2.02%)   1,076 ( 0.13%)   4 ( 1.23%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:regex_automata::util::prefilter::teddy::Teddy::new (39x)
 1,981,771 ( 0.57%)   1,790 ( 0.22%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/ahocorasick.rs:aho_corasick::ahocorasick::AhoCorasickBuilder::build (9x) [./target/valgrind/s4]
   267,654 ( 0.08%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::build_from_noncontiguous [./target/valgrind/s4]
 6,452,372 ( 1.86%)     908 ( 0.11%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::finish_build_one_start (39x) [./target/valgrind/s4]
   311,549 ( 0.09%)   1,640 ( 0.20%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::DFA::set_matches (882x) [./target/valgrind/s4]
   177,084 ( 0.05%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::finish_build_both_starts::{{closure}} (6,273x) [./target/valgrind/s4]
     3,696 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   264,055 ( 0.08%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/primitives.rs:regex_automata::nfa::thompson::builder::Builder::build

   261,481 ( 0.08%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::nfa::Inner::add
 1,264,275 ( 0.36%)   4,023 ( 0.50%)   8 ( 2.47%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (1,275x) [./target/valgrind/s4]

   257,656 ( 0.07%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::nfa::Inner::add

 1,618,106 ( 0.47%)   1,570 ( 0.19%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (4,916x) [./target/valgrind/s4]
   253,542 ( 0.07%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post [./target/valgrind/s4]
    85,144 ( 0.02%)      51 ( 0.01%)   .           .           >   ???:__rust_dealloc (846x) [./target/valgrind/s4]
    10,600 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::TranslatorI::hir_perl_unicode_class (5x) [./target/valgrind/s4]

   252,274 ( 0.07%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

   250,159 ( 0.07%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/primitives.rs:regex_automata::nfa::thompson::nfa::Inner::remap

   249,384 ( 0.07%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::dfa::Builder::finish_build_one_start

   249,045 ( 0.07%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2
 3,470,874 ( 1.00%)   2,720 ( 0.34%)   4 ( 1.23%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (41,209x) [./target/valgrind/s4]

   246,647 ( 0.07%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::concat
     1,836 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (68x) [./target/valgrind/s4]
     1,700 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (68x) [./target/valgrind/s4]

   241,800 ( 0.07%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/char/methods.rs:regex_syntax::hir::translate::TranslatorI::push_char

   362,834 ( 0.10%)     336 ( 0.04%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (4,385x)
    46,801 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre (2,753x)
    38,420 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple (1,120x)
    28,356 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::union (903x) [./target/valgrind/s4]
    22,046 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::Hir::alternation (1,159x)
    19,169 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::new (1,126x) [./target/valgrind/s4]
     6,035 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::unicode::perl_digit (5x)
     2,530 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::Hir::dot (110x)
     1,207 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre (71x)
       723 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::Hir::alternation'2 (1x)
   240,838 ( 0.07%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize [./target/valgrind/s4]

   841,889 ( 0.24%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (2,824x) [./target/valgrind/s4]
   237,245 ( 0.07%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open [./target/valgrind/s4]
   251,442 ( 0.07%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (2,826x) [./target/valgrind/s4]
   237,222 ( 0.07%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (11,298x) [./target/valgrind/s4]
    50,868 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (2,826x) [./target/valgrind/s4]

 3,736,537 ( 1.08%)  22,017 ( 2.72%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (15,929x) [./target/valgrind/s4]
   159,454 ( 0.05%)     842 ( 0.10%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x) [./target/valgrind/s4]
    22,461 ( 0.01%)     132 ( 0.02%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group_end (81x) [./target/valgrind/s4]
   233,842 ( 0.07%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast [./target/valgrind/s4]

   229,410 ( 0.07%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_syntax::hir::literal::Extractor::union

   227,950 ( 0.07%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add
 5,750,455 ( 1.65%)  30,845 ( 3.81%)   2 ( 0.62%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle (19,750x) [./target/valgrind/s4]

   223,488 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state
   438,434 ( 0.13%)   1,230 ( 0.15%)   1 ( 0.31%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (384x) [./target/valgrind/s4]

   221,616 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

   203,008 ( 0.06%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/hash/sip.rs:core::hash::BuildHasher::hash_one (4,055x)
    57,495 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/hash/mod.rs:core::hash::BuildHasher::hash_one (1,637x) [./target/valgrind/s4]
   221,590 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/hash/sip.rs:<core::hash::sip::Hasher<S> as core::hash::Hasher>::write [./target/valgrind/s4]

   221,095 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::raw_vec::finish_grow
28,977,302 ( 8.34%) 111,656 (13.78%)  81 (25.00%)  .           >   ???:__rust_realloc (44,219x) [./target/valgrind/s4]

   214,947 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

   214,010 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   213,601 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:regex_syntax::ast::visitor::visit

   210,024 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

   238,270 ( 0.07%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
   209,616 ( 0.06%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::byte_classes [./target/valgrind/s4]
     1,440 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 1,394,311 ( 0.40%)   2,942 ( 0.36%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSet> (5,577x) [./target/valgrind/s4]
   203,416 ( 0.06%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop [./target/valgrind/s4]
    82,740 ( 0.02%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,758x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   402,767 ( 0.12%)     251 ( 0.03%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (3,756x) [./target/valgrind/s4]
   202,000 ( 0.06%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next [./target/valgrind/s4]

   200,996 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::Hir::concat

   198,711 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

 1,393,222 ( 0.40%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (3,549x) [./target/valgrind/s4]
   195,210 ( 0.06%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range [./target/valgrind/s4]
 1,012,864 ( 0.29%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item (3,549x) [./target/valgrind/s4]
    75,129 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (3,549x) [./target/valgrind/s4]
    63,882 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (3,549x) [./target/valgrind/s4]

   195,165 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

   195,068 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::NFA::add_transition

 2,682,187 ( 0.77%)     330 ( 0.04%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (2,824x) [./target/valgrind/s4]
   194,937 ( 0.06%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open [./target/valgrind/s4]
   841,889 ( 0.24%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open (2,824x) [./target/valgrind/s4]
   169,440 ( 0.05%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (5,648x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    59,268 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,824x) [./target/valgrind/s4]

   193,440 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs:regex_syntax::hir::translate::TranslatorI::push_char

   193,296 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::translate::TranslatorI::push_char

   193,170 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

   192,237 ( 0.06%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2
   554,049 ( 0.16%)     314 ( 0.04%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (5,376x) [./target/valgrind/s4]

   190,186 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

   189,432 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::ast::Concat::into_ast

   921,773 ( 0.27%)     796 ( 0.10%)   6 ( 1.85%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
   187,250 ( 0.05%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::densify [./target/valgrind/s4]

   185,086 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/char/methods.rs:regex_syntax::ast::parse::ParserI<P>::bump

   184,927 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_syntax::ast::parse::ParserI<P>::bump

   184,846 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_syntax::ast::parse::ParserI<P>::bump

   184,765 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_syntax::ast::parse::ParserI<P>::bump

   183,373 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::ast::visitor::visit

 2,185,246 ( 0.63%)       2 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (2,824x) [./target/valgrind/s4]
   181,517 ( 0.05%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class [./target/valgrind/s4]
   530,912 ( 0.15%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op (2,824x) [./target/valgrind/s4]
   254,160 ( 0.07%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (8,472x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   251,336 ( 0.07%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (2,824x) [./target/valgrind/s4]
   183,560 ( 0.05%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSet> (2,824x) [./target/valgrind/s4]
    59,304 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,824x) [./target/valgrind/s4]

   180,153 ( 0.05%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/primitives.rs:regex_automata::nfa::thompson::builder::Builder::patch

   178,514 ( 0.05%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/primitives.rs:regex_automata::nfa::thompson::builder::Builder::add

   177,680 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push

   177,267 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate

   176,130 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post
 2,565,036 ( 0.74%)  29,826 ( 3.68%)   .           .           >   ???:__rust_realloc (14,913x) [./target/valgrind/s4]
 2,086,458 ( 0.60%)  10,021 ( 1.24%)   2 ( 0.62%)  .           >   ???:__rust_alloc (19,936x) [./target/valgrind/s4]

 5,183,047 ( 1.49%)   9,591 ( 1.18%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract (975x) [./target/valgrind/s4]
 2,302,205 ( 0.66%)   7,432 ( 0.92%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (1,944x) [./target/valgrind/s4]
   175,932 ( 0.05%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 [./target/valgrind/s4]
 2,466,334 ( 0.71%)   1,074 ( 0.13%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::union (1,583x) [./target/valgrind/s4]
 2,302,205 ( 0.66%)   7,432 ( 0.92%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (1,944x) [./target/valgrind/s4]
 1,432,633 ( 0.41%)   4,675 ( 0.58%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (371x) [./target/valgrind/s4]

   169,250 ( 0.05%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (84,625x) [./target/valgrind/s4]
     4,518 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (2,259x) [./target/valgrind/s4]
       574 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (287x) [./target/valgrind/s4]
       568 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten (284x) [./target/valgrind/s4]
        26 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::extract (13x) [./target/valgrind/s4]
   174,936 ( 0.05%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::kind [./target/valgrind/s4]

   174,924 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::nfa::Inner::remap

   174,060 ( 0.05%)       .            .           .           *  ./elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object
   112,671 ( 0.03%)       .            .           .           >   ./elf/./elf/dl-lookup.c:_dl_lookup_symbol_x (179x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
        66 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove.c:memmove (3x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        66 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memcmp.c:bcmp (3x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        48 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memset.c:memset (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        46 ( 0.00%)       .            .           .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wmemchr.c:wmemchr (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        46 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memchr.c:memchr (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        44 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memcpy.c:memcpy@@GLIBC_2.14 (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        42 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strlen.c:strlen (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        42 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strnlen.c:strnlen (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        42 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memrchr.c:memrchr (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        42 ( 0.00%)       .            .           .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcschr.c:wcschr (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        38 ( 0.00%)       .            .           .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wmemset.c:wmemset (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        28 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86/cacheinfo.c:__x86_cacheinfo (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        23 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/rawmemchr.c:rawmemchr (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        22 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/mempcpy.c:mempcpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        22 ( 0.00%)       .            .           .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wmemcmp.c:wmemcmp (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        21 ( 0.00%)       .            .           .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcscmp.c:wcscmp (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        21 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strrchr.c:rindex (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        21 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strchrnul.c:strchrnul (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        19 ( 0.00%)       .            .           .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcslen.c:wcslen (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        19 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strchr.c:index (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        19 ( 0.00%)       .            .           .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcsnlen.c:wcsnlen (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        17 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strncpy.c:strncpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        17 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/stpncpy.c:stpncpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        17 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strcat.c:strcat (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        17 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strncmp.c:strncmp (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        17 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strcpy.c:strcpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        17 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/stpcpy.c:stpcpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        17 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strcmp.c:strcmp (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         7 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strcspn.c:strcspn (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         7 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strcasecmp.c:strcasecmp (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         7 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strncase_l.c:strncasecmp_l (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         7 ( 0.00%)       .            .           .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcscpy.c:wcscpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         7 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strspn.c:strspn (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         7 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strncase.c:strncasecmp (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         7 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strcasecmp_l.c:strcasecmp_l (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         7 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/strpbrk.c:strpbrk (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         6 ( 0.00%)       .            .           .           >   ./elf/../sysdeps/x86/dl-get-cpu-features.c:__x86_cpu_features (1x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

   172,982 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop

   169,466 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::hir::Hir::literal

   169,139 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/into_iter.rs:regex_syntax::hir::Hir::concat

   167,611 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_syntax::hir::literal::Extractor::union

   167,521 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   166,355 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

   162,683 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

   161,392 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

   385,728 ( 0.11%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
   161,088 ( 0.05%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state [./target/valgrind/s4]
     2,304 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::copy_matches (48x) [./target/valgrind/s4]

   160,083 ( 0.05%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::build
   543,588 ( 0.16%)   2,134 ( 0.26%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (1,033x) [./target/valgrind/s4]

   159,744 ( 0.05%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::prefilter::Builder::build

   155,917 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_syntax::hir::Hir::concat

 2,109,901 ( 0.61%)   9,536 ( 1.18%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (3,873x) [./target/valgrind/s4]
     1,937 ( 0.00%)      10 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (5x)
       151 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation'2 (1x) [./target/valgrind/s4]
   155,642 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class [./target/valgrind/s4]
   707,635 ( 0.20%)   4,020 ( 0.50%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::class (2,425x) [./target/valgrind/s4]
   447,821 ( 0.13%)     589 ( 0.07%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::literal (3,879x) [./target/valgrind/s4]
    63,976 ( 0.02%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/converts.rs:core::str::converts::from_utf8 (1,454x) [./target/valgrind/s4]

   153,962 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

   151,482 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   149,064 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

   148,684 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

   147,984 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state

   564,716 ( 0.16%)     384 ( 0.05%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
   146,696 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions [./target/valgrind/s4]
    32,304 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::copy_matches (673x) [./target/valgrind/s4]

   145,435 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

   145,080 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::hir::translate::TranslatorI::push_char

   144,833 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

   142,311 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   141,043 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::builder::Builder::build

22,587,538 ( 6.50%)  16,536 ( 2.04%)  26 ( 8.02%)  1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (538x) [./target/valgrind/s4]
    44,110 ( 0.01%)      38 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (1x) [./target/valgrind/s4]
   140,904 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter [./target/valgrind/s4]
21,098,019 ( 6.07%)  14,557 ( 1.80%)  26 ( 8.02%)  1 ( 0.07%)  >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (6,614x) [./target/valgrind/s4]
 1,178,064 ( 0.34%)   1,829 ( 0.23%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (13,228x) [./target/valgrind/s4]

   140,349 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop
 3,930,752 ( 1.13%)   1,427 ( 0.18%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle (270x) [./target/valgrind/s4]

   139,298 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop

   138,500 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::nfa::Inner::remap

 5,542,985 ( 1.60%)  33,310 ( 4.11%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> (674x) [./target/valgrind/s4]
    90,936 ( 0.03%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (5,052x)
    50,832 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSet> (2,824x) [./target/valgrind/s4]
    18,260 ( 0.01%)      69 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:alloc::sync::Arc<T,A>::drop_slow'2 (3x)
    14,097 ( 0.00%)      96 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::meta::strategy::new (12x)
     7,723 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<clap_builder::builder::command::Command> (2x) [./target/valgrind/s4]
     4,050 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::meta::regex::Builder::build (243x)
     3,220 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::literal::Extractor::extract'2 (322x)
     2,195 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::alternation (5x)
     1,993 ( 0.00%)       6 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<clap_builder::parser::matches::arg_matches::ArgMatches> (1x) [./target/valgrind/s4]
       560 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::literal::Extractor::extract (56x)
       168 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<core::option::Option<regex::regex::string::Regex>> (1x) [./target/valgrind/s4]
        19 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:clap_builder::builder::command::Command::_do_parse (1x)
        19 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:clap_builder::builder::command::Command::_build_self (1x)
        18 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:s4::processing_loop (1x)
   138,493 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop [./target/valgrind/s4]

   137,072 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

   133,076 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

 2,466,334 ( 0.71%)   1,074 ( 0.13%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (1,583x) [./target/valgrind/s4]
 1,051,775 ( 0.30%)     257 ( 0.03%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract (864x) [./target/valgrind/s4]
   132,949 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::union [./target/valgrind/s4]

   530,912 ( 0.15%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x) [./target/valgrind/s4]
   132,728 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op [./target/valgrind/s4]
   169,440 ( 0.05%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (5,648x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   132,227 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/alloc/layout.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle

 8,949,928 ( 2.58%)  20,198 ( 2.49%)   8 ( 2.47%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::PreferenceTrie::minimize (177x) [./target/valgrind/s4]
   132,204 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::retain_mut [./target/valgrind/s4]

   131,304 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post
   869,544 ( 0.25%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/converts.rs:core::str::converts::from_utf8 (16,096x) [./target/valgrind/s4]
   590,898 ( 0.17%)   3,432 ( 0.42%)   1 ( 0.31%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::repetition (1,885x) [./target/valgrind/s4]
   209,714 ( 0.06%)   1,132 ( 0.14%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::capture (693x) [./target/valgrind/s4]
    41,130 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::new (1,125x) [./target/valgrind/s4]
     3,211 ( 0.00%)      10 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::negate (6x) [./target/valgrind/s4]
     1,937 ( 0.00%)      10 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class (5x) [./target/valgrind/s4]

   130,806 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile
 1,319,234 ( 0.38%)     576 ( 0.07%)   9 ( 2.78%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (16,950x) [./target/valgrind/s4]

   130,061 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

   130,648 ( 0.04%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (4,916x) [./target/valgrind/s4]
   129,456 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:<regex_syntax::ast::parse::NestLimiter<P> as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre [./target/valgrind/s4]

   128,997 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/convert/num.rs:regex_automata::nfa::thompson::nfa::Inner::add

   128,828 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/primitives.rs:regex_automata::nfa::thompson::nfa::Inner::add

   177,084 ( 0.05%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (6,273x) [./target/valgrind/s4]
   126,576 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::finish_build_both_starts::{{closure}} [./target/valgrind/s4]

   125,238 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::Extractor::cross

   124,200 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

   374,378 ( 0.11%)   2,885 ( 0.36%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/alloc.rs:__rdl_alloc_zeroed (1,316x)
     2,106 ( 0.00%)      10 ( 0.00%)   .           .           < ???:0x0000000004898400 (9x) [???]
       659 ( 0.00%)       2 ( 0.00%)   .           .           < ./elf/../include/rtld-malloc.h:_dl_allocate_tls (2x)
   123,975 ( 0.04%)   2,620 ( 0.32%)   .           .           *  ./malloc/./malloc/malloc.c:calloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
   213,961 ( 0.06%)     277 ( 0.03%)   .           .           >   ./malloc/./malloc/malloc.c:_int_malloc (1,327x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    14,298 ( 0.00%)       .            .           .           >   ???:0x0000000004898670 (224x) [???]

   122,545 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions

 1,012,864 ( 0.29%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range (3,549x) [./target/valgrind/s4]
   122,304 ( 0.04%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item [./target/valgrind/s4]
   484,598 ( 0.14%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape (1,612x) [./target/valgrind/s4]
   198,960 ( 0.06%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (9,360x) [./target/valgrind/s4]
   173,833 ( 0.05%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,937x) [./target/valgrind/s4]

   121,666 ( 0.04%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::nfa::Inner::add

   158,544 ( 0.05%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
   121,392 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::add_unanchored_start_state_loop [./target/valgrind/s4]

   120,212 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::visitor::visit

 1,738,425 ( 0.50%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle (48x) [./target/valgrind/s4]
   120,108 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::remap [./target/valgrind/s4]
 1,488,569 ( 0.43%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap (48x) [./target/valgrind/s4]

 1,895,581 ( 0.55%)   8,643 ( 1.07%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract (111x) [./target/valgrind/s4]
 1,432,633 ( 0.41%)   4,675 ( 0.58%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (371x) [./target/valgrind/s4]
   119,278 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross [./target/valgrind/s4]
    45,742 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Seq::cross_preamble (482x) [./target/valgrind/s4]

 1,178,064 ( 0.34%)   1,829 ( 0.23%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter (13,228x) [./target/valgrind/s4]
   119,052 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch [./target/valgrind/s4]
   966,416 ( 0.28%)   1,829 ( 0.23%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (13,228x) [./target/valgrind/s4]

   118,430 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_syntax::ast::visitor::visit

   117,786 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2
 5,784,507 ( 1.66%)  40,268 ( 4.97%)   .           .           >   ???:__rust_dealloc (45,047x) [./target/valgrind/s4]

   117,717 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:core::hash::BuildHasher::hash_one

   117,414 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ops/range.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

   117,144 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/convert/num.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

 1,386,817 ( 0.40%)   2,942 ( 0.36%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (2,753x) [./target/valgrind/s4]
   183,560 ( 0.05%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x) [./target/valgrind/s4]
   116,762 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSet> [./target/valgrind/s4]
 1,394,311 ( 0.40%)   2,942 ( 0.36%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (5,577x) [./target/valgrind/s4]
    50,832 ( 0.01%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (2,824x) [./target/valgrind/s4]

   116,178 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

   116,004 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

   115,525 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::literal::Extractor::cross

   822,584 ( 0.24%)   1,237 ( 0.15%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (1,713x) [./target/valgrind/s4]
   115,293 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition [./target/valgrind/s4]
   152,457 ( 0.04%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,713x) [./target/valgrind/s4]
    74,718 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (3,558x) [./target/valgrind/s4]

   114,975 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::builder::Builder::build

   114,654 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   114,491 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class
   191,190 ( 0.06%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (6,373x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   922,317 ( 0.27%)   2,302 ( 0.28%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (693x) [./target/valgrind/s4]
   114,185 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group [./target/valgrind/s4]
   159,454 ( 0.05%)     842 ( 0.10%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (693x) [./target/valgrind/s4]
   109,876 ( 0.03%)     613 ( 0.08%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Alternation::into_ast (512x) [./target/valgrind/s4]
    61,677 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (693x) [./target/valgrind/s4]
    14,553 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (693x) [./target/valgrind/s4]

   113,385 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::alternation
     2,195 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (5x) [./target/valgrind/s4]
       163 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/into_iter.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop (1x) [./target/valgrind/s4]
       135 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (5x) [./target/valgrind/s4]
       125 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (5x) [./target/valgrind/s4]

   112,816 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::translate::TranslatorI::push_char
   773,760 ( 0.22%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48,360x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   112,453 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/alphabet.rs:regex_automata::hybrid::dfa::Lazy::set_transition

   112,435 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   111,875 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::patch
 1,651,291 ( 0.48%)   8,696 ( 1.07%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (5,355x) [./target/valgrind/s4]

   111,333 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_automata::hybrid::dfa::Lazy::init_cache

   125,120 ( 0.04%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (3,680x) [./target/valgrind/s4]
   110,400 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::set_range [./target/valgrind/s4]

   105,575 ( 0.03%)       .            .           .           *  ./elf/./elf/do-rel.h:_dl_relocate_object

   105,066 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_syntax::hir::Hir::concat

   104,600 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs:regex_syntax::unicode::SimpleCaseFolder::overlaps

   104,424 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::literal::Extractor::union

   103,094 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle

 1,274,375 ( 0.37%)   7,729 ( 0.95%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (5,376x)
     2,241 ( 0.00%)       4 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::meta::reverse_inner::extract (13x)
       400 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::Hir::alternation (5x)
       156 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::compiler::Compiler::c (2x)
   102,578 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::allocate_in [./target/valgrind/s4]

   101,836 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre

   100,819 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class

   100,220 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::literal::PreferenceTrie::insert
 2,821,056 ( 0.81%)  12,622 ( 1.56%)   2 ( 0.62%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle (8,722x) [./target/valgrind/s4]

    99,397 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate
   839,962 ( 0.24%)   4,453 ( 0.55%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (1,445x) [./target/valgrind/s4]

    99,224 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

    99,214 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/char/methods.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

 2,040,964 ( 0.59%)     264 ( 0.03%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex::regex::bytes::Regex::new (80x)
 1,530,852 ( 0.44%)   2,000 ( 0.25%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (2,604x) [./target/valgrind/s4]
   536,073 ( 0.15%)   1,085 ( 0.13%)   1 ( 0.31%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::Extractor::union (2,443x)
   113,059 ( 0.03%)     144 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::util::prefilter::prefixes (15x)
     7,525 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::hybrid::dfa::Builder::new (175x)
     6,966 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::meta::strategy::new (162x)
     5,524 ( 0.00%)      12 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::util::prefilter::suffixes (12x)
     3,483 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::meta::wrappers::PikeVM::new (81x)
     3,483 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::hybrid::dfa::DFA::builder (81x)
     3,483 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::meta::wrappers::BoundedBacktracker::new (81x)
     3,483 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::dfa::onepass::Builder::new (81x)
       559 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::new (13x)
       269 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex::regex::string::Regex::new (1x)
    99,093 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_extend.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend [./target/valgrind/s4]

    98,514 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre
   322,591 ( 0.09%)   1,297 ( 0.16%)   4 ( 1.23%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (297x) [./target/valgrind/s4]
    79,837 ( 0.02%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_from_iter.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,alloc::vec::into_iter::IntoIter<T>>>::from_iter (2,753x) [./target/valgrind/s4]

    98,349 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/hash/sip.rs:core::hash::BuildHasher::hash_one
   203,008 ( 0.06%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/hash/sip.rs:<core::hash::sip::Hasher<S> as core::hash::Hasher>::write (4,055x) [./target/valgrind/s4]

    97,888 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

    96,720 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_syntax::hir::translate::TranslatorI::push_char

    94,270 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple

    93,439 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

    93,107 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/map.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    92,423 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_syntax::ast::parse::ParserI<P>::bump

    92,423 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_syntax::ast::parse::ParserI<P>::bump

    92,423 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/traits.rs:regex_syntax::ast::parse::ParserI<P>::bump

   484,598 ( 0.14%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item (1,612x) [./target/valgrind/s4]
    92,302 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape [./target/valgrind/s4]
   286,491 ( 0.08%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (3,219x) [./target/valgrind/s4]
    67,704 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (3,224x) [./target/valgrind/s4]
    16,069 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/lib.rs:regex_syntax::is_meta_character (1,607x) [./target/valgrind/s4]
     1,105 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_perl_class (5x) [./target/valgrind/s4]

    79,837 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre (2,753x)
    33,582 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::alternation (1,158x)
     2,059 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre (71x)
       145 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::unicode::perl_digit (5x)
    91,701 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_from_iter.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,alloc::vec::into_iter::IntoIter<T>>>::from_iter [./target/valgrind/s4]

    90,366 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop

    89,713 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::builder::Builder::build
   367,133 ( 0.11%)   1,002 ( 0.12%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle (175x) [./target/valgrind/s4]

    89,367 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::bump_space

    89,257 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::builder::Builder::add

    89,257 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_automata::nfa::thompson::builder::Builder::add

    89,257 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_automata::nfa::thompson::builder::Builder::add

    88,901 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop
   167,610 ( 0.05%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (5,587x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    86,957 ( 0.03%)     982 ( 0.12%)   .           .           >   ???:__rust_dealloc (596x) [./target/valgrind/s4]
    70,880 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop'2 (2,758x) [./target/valgrind/s4]
    14,175 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/drain.rs:<alloc::vec::drain::Drain<T,A> as core::ops::drop::Drop>::drop (525x) [./target/valgrind/s4]
     3,621 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSet>'2 (71x) [./target/valgrind/s4]

    85,074 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (2,578x) [./target/valgrind/s4]
     2,673 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::finish (81x) [./target/valgrind/s4]
    87,747 ( 0.03%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::HirFrame::unwrap_expr [./target/valgrind/s4]

    87,422 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::nfa::Inner::add

    87,003 ( 0.03%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::builder::Builder::build
 2,863,294 ( 0.82%)  20,368 ( 2.51%)   .           .           >   ???:__rust_alloc (12,204x) [./target/valgrind/s4]
    77,814 ( 0.02%)     356 ( 0.04%)   .           .           >   ???:__rust_alloc_zeroed (175x) [./target/valgrind/s4]
    74,512 ( 0.02%)     724 ( 0.09%)   .           .           >   ???:__rust_dealloc (525x) [./target/valgrind/s4]

    86,823 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::builder::Builder::build
   284,952 ( 0.08%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (175x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    86,681 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::alternation
    33,582 ( 0.01%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_from_iter.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,alloc::vec::into_iter::IntoIter<T>>>::from_iter (1,158x) [./target/valgrind/s4]
     9,335 ( 0.00%)      30 ( 0.00%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (24x) [./target/valgrind/s4]

    86,282 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::dfa::Builder::finish_build_one_start

    85,480 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap

    85,075 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post

    83,802 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop
 4,296,335 ( 1.24%)  27,229 ( 3.36%)   .           .           >   ???:__rust_dealloc (27,622x) [./target/valgrind/s4]
    15,399 ( 0.00%)      52 ( 0.01%)   .           .           >   ???:__rust_alloc (208x) [./target/valgrind/s4]

    82,100 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/unicode.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple

   943,165 ( 0.27%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (841x) [./target/valgrind/s4]
    82,078 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::maybe_parse_ascii_class [./target/valgrind/s4]
   627,895 ( 0.18%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (7,055x) [./target/valgrind/s4]
   148,491 ( 0.04%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (7,071x) [./target/valgrind/s4]
    31,216 ( 0.01%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_syntax::ast::ClassAsciiKind::from_name (770x) [./target/valgrind/s4]

    81,681 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::Concat::into_ast
 3,265,871 ( 0.94%)  22,947 ( 2.83%)   .           .           >   ???:__rust_alloc (15,786x) [./target/valgrind/s4]
    92,015 ( 0.03%)      44 ( 0.01%)   .           .           >   ???:__rust_dealloc (917x) [./target/valgrind/s4]

    81,164 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::literal::Extractor::cross
   223,949 ( 0.06%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (13,790x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    79,340 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

    79,175 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::hir::Hir::concat

    79,072 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op
    84,720 ( 0.02%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    78,752 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   839,875 ( 0.24%)     314 ( 0.04%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (586x) [./target/valgrind/s4]
    77,353 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name [./target/valgrind/s4]
   304,647 ( 0.09%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (3,423x) [./target/valgrind/s4]
   143,766 ( 0.04%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (6,846x) [./target/valgrind/s4]

    77,184 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    77,030 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::literal
   786,925 ( 0.23%)      12 ( 0.00%)   .           .           >   ???:__rust_alloc (15,406x) [./target/valgrind/s4]

    76,646 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/into_iter.rs:regex_syntax::hir::Hir::alternation

    75,345 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:alloc::vec::Vec<T,A>::retain_mut
 8,379,527 ( 2.41%)  17,655 ( 2.18%)   8 ( 2.47%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::PreferenceTrie::insert (16,878x) [./target/valgrind/s4]

   298,368 ( 0.09%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
    74,688 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/prefilter.rs:aho_corasick::util::prefilter::Builder::build [./target/valgrind/s4]
     1,152 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/api.rs:aho_corasick::packed::api::Builder::build (48x) [./target/valgrind/s4]

 1,664,363 ( 0.48%)   7,274 ( 0.90%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten (1,589x) [./target/valgrind/s4]
   444,692 ( 0.13%)   2,174 ( 0.27%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (653x) [./target/valgrind/s4]
    74,368 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 [./target/valgrind/s4]
   444,692 ( 0.13%)   2,174 ( 0.27%)   1 ( 0.31%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (653x) [./target/valgrind/s4]
   179,874 ( 0.05%)      66 ( 0.01%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (12x) [./target/valgrind/s4]
   168,287 ( 0.05%)     325 ( 0.04%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (83x) [./target/valgrind/s4]
    11,532 ( 0.00%)      58 ( 0.01%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Repetition::with (74x) [./target/valgrind/s4]
     4,518 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::kind (2,259x) [./target/valgrind/s4]

    73,872 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ops/range.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

    73,728 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

    74,002 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (2,726x) [./target/valgrind/s4]
    73,610 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind>'2 [./target/valgrind/s4]
       364 ( 0.00%)       .            .           .           >   ???:__rust_dealloc (4x) [./target/valgrind/s4]

    73,440 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

    70,880 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (2,758x)
     1,775 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSet>'2 (71x) [./target/valgrind/s4]
    72,655 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop'2 [./target/valgrind/s4]

    71,760 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

    71,256 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

    70,940 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs:regex_syntax::unicode::SimpleCaseFolder::mapping

 1,030,449 ( 0.30%)     755 ( 0.09%)   2 ( 0.62%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (1,451x) [./target/valgrind/s4]
    69,833 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::compile_transition [./target/valgrind/s4]
   916,619 ( 0.26%)     755 ( 0.09%)   2 ( 0.62%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (1,451x) [./target/valgrind/s4]

    69,814 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:core::str::converts::from_utf8

   808,237 ( 0.23%)   1,420 ( 0.18%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::add (1,179x) [./target/valgrind/s4]
   147,182 ( 0.04%)     290 ( 0.04%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::finish (126x) [./target/valgrind/s4]
    69,581 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from [./target/valgrind/s4]
   451,230 ( 0.13%)     829 ( 0.10%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (1,588x) [./target/valgrind/s4]

    69,137 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/set_len_on_drop.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

    68,997 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop

    68,836 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate

    68,835 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter

   590,898 ( 0.17%)   3,432 ( 0.42%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (1,885x)
    24,579 ( 0.01%)     138 ( 0.02%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::meta::reverse_inner::flatten (75x)
    23,672 ( 0.01%)     136 ( 0.02%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::meta::reverse_inner::flatten'2 (74x)
    68,636 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::repetition [./target/valgrind/s4]

    67,893 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/id.rs:regex_automata::hybrid::dfa::Lazy::set_transition

 1,445,243 ( 0.42%)     667 ( 0.08%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_group (713x) [./target/valgrind/s4]
    67,544 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group [./target/valgrind/s4]
   839,875 ( 0.24%)     314 ( 0.04%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (586x) [./target/valgrind/s4]
   223,455 ( 0.06%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (2,511x) [./target/valgrind/s4]
    52,799 ( 0.02%)      34 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Ast::empty (693x) [./target/valgrind/s4]
    45,303 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,159x) [./target/valgrind/s4]
    14,280 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_flags (20x) [./target/valgrind/s4]
    12,834 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (713x) [./target/valgrind/s4]

   183,220 ( 0.05%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (1,120x) [./target/valgrind/s4]
    67,010 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::SimpleCaseFolder::overlaps [./target/valgrind/s4]

   447,821 ( 0.13%)     589 ( 0.07%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class (3,879x) [./target/valgrind/s4]
     3,307 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Class::literal (193x) [./target/valgrind/s4]
    66,562 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::literal [./target/valgrind/s4]

    66,496 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/char/methods.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next

    66,473 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::literal::PreferenceTrie::minimize

    66,305 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::literal::Extractor::cross

    66,140 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_automata::nfa::thompson::compiler::Compiler::patch

    65,913 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post
   254,712 ( 0.07%)     279 ( 0.03%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (1,978x) [./target/valgrind/s4]
   122,114 ( 0.04%)     423 ( 0.05%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_from_iter.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter (770x) [./target/valgrind/s4]

 2,458,192 ( 0.71%)   2,421 ( 0.30%)   2 ( 0.62%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::OnePass::new (81x) [./target/valgrind/s4]
    65,912 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::Builder::build_from_nfa [./target/valgrind/s4]
 1,030,449 ( 0.30%)     755 ( 0.09%)   2 ( 0.62%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::compile_transition (1,451x) [./target/valgrind/s4]
   274,669 ( 0.08%)     250 ( 0.03%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (162x) [./target/valgrind/s4]
   237,539 ( 0.07%)     260 ( 0.03%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push (2,672x) [./target/valgrind/s4]
   103,856 ( 0.03%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/remapper.rs:regex_automata::dfa::remapper::Remapper::remap (1x) [./target/valgrind/s4]
     1,956 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/remapper.rs:regex_automata::dfa::remapper::Remapper::swap (1x) [./target/valgrind/s4]
       486 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::nfa::NFA::patterns (81x) [./target/valgrind/s4]
       176 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/remapper.rs:regex_automata::dfa::remapper::Remapper::new (1x) [./target/valgrind/s4]
        65 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    65,881 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    65,764 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate

   916,619 ( 0.26%)     755 ( 0.09%)   2 ( 0.62%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::compile_transition (1,451x) [./target/valgrind/s4]
   274,669 ( 0.08%)     250 ( 0.03%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (162x) [./target/valgrind/s4]
    65,582 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state [./target/valgrind/s4]

    64,414 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::nfa::Inner::add

    64,414 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_automata::nfa::thompson::nfa::Inner::add

    63,772 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/mem/manually_drop.rs:regex_syntax::hir::Hir::concat

    63,642 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_syntax::hir::literal::PreferenceTrie::insert

    63,096 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:regex_syntax::hir::Hir::concat

    61,632 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::Hir::concat
   264,180 ( 0.08%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (15,408x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    61,624 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::literal

28,977,302 ( 8.34%) 111,656 (13.78%)  81 (25.00%)  .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::raw_vec::finish_grow (44,219x)
 2,565,036 ( 0.74%)  29,826 ( 3.68%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (14,913x)
   250,063 ( 0.07%)   2,906 ( 0.36%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::class (1,454x)
    61,559 ( 0.02%)     602 ( 0.07%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::vec::Vec<T,A>::shrink_to_fit (211x)
    60,797 ( 0.02%)       .            .           .           *  ???:__rust_realloc [./target/valgrind/s4]
31,793,163 ( 9.15%) 144,990 (17.90%)  81 (25.00%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/alloc.rs:__rdl_realloc (60,797x) [./target/valgrind/s4]

    60,308 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle

    65,027 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (4,916x) [./target/valgrind/s4]
    59,134 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre [./target/valgrind/s4]

    58,035 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_automata::hybrid::dfa::Builder::build_from_nfa

    57,858 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::literal::PreferenceTrie::minimize

    57,781 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa

    57,744 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

    56,861 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_automata::nfa::thompson::compiler::Compiler::c

    56,132 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::util::remapper::Remapper::remap

    80,466 ( 0.02%)       .            .           .           < ./elf/./elf/dl-lookup.c:_dl_lookup_symbol_x (190x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    55,360 ( 0.02%)       .            .           .           *  ./elf/./elf/dl-lookup.c:do_lookup_x [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    22,516 ( 0.01%)       .            .           .           >   ./elf/./elf/dl-lookup.c:check_match (192x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

    55,328 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

86,151,395 (24.79%) 201,207 (24.83%)  88 (27.16%)  1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (1,386x) [./target/valgrind/s4]
    54,747 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 [./target/valgrind/s4]
85,436,813 (24.59%) 199,882 (24.67%)  87 (26.85%)  1 ( 0.07%)  >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (1,386x) [./target/valgrind/s4]
   186,208 ( 0.05%)     407 ( 0.05%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add_capture_start (693x) [./target/valgrind/s4]
    49,896 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (1,386x) [./target/valgrind/s4]

   707,635 ( 0.20%)   4,020 ( 0.50%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class (2,425x) [./target/valgrind/s4]
    51,275 ( 0.01%)     298 ( 0.04%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::meta::reverse_inner::flatten'2 (159x)
    16,100 ( 0.00%)      40 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::dot (110x) [./target/valgrind/s4]
     8,350 ( 0.00%)      44 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::meta::reverse_inner::flatten (34x)
    54,670 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::class [./target/valgrind/s4]

    54,346 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_syntax::hir::Hir::alternation

    53,656 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open
    84,720 ( 0.02%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    83,493 ( 0.02%)       .            .           .           < ./stdio-common/./stdio-common/isoc99_sscanf.c:__isoc99_sscanf (49x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    52,758 ( 0.02%)       .            .           .           *  ./stdio-common/./stdio-common/vfscanf-internal.c:__vfscanf_internal [/usr/lib/x86_64-linux-gnu/libc.so.6]
    25,100 ( 0.01%)       .            .           .           >   ./stdlib/../stdlib/strtol.c:__strtoul_internal (98x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     3,724 ( 0.00%)       .            .           .           >   ./libio/./libio/genops.c:_IO_sputbackc (196x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
       490 ( 0.00%)       .            .           .           >   ./nptl/./nptl/libc-cleanup.c:__libc_cleanup_push_defer (49x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
       392 ( 0.00%)       .            .           .           >   ./nptl/./nptl/libc-cleanup.c:__libc_cleanup_pop_restore (49x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    52,603 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

    52,360 ( 0.02%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

83,174,154 (23.94%) 191,168 (23.60%)  90 (27.78%)  1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap (175x) [./target/valgrind/s4]
    32,450 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (110x) [./target/valgrind/s4]
    52,273 ( 0.02%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c [./target/valgrind/s4]
82,889,700 (23.86%) 191,126 (23.59%)  90 (27.78%)  1 ( 0.07%)  >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (2,840x) [./target/valgrind/s4]
    98,360 ( 0.03%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (2,671x) [./target/valgrind/s4]
    44,110 ( 0.01%)      38 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter (1x) [./target/valgrind/s4]
     1,210 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassBytesIter as core::iter::traits::iterator::Iterator>::next (220x) [./target/valgrind/s4]
       574 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::kind (287x) [./target/valgrind/s4]
       440 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::ClassBytes::iter (110x) [./target/valgrind/s4]
       336 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::ClassBytes::ranges (112x) [./target/valgrind/s4]
       220 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassBytesRange::end (110x) [./target/valgrind/s4]
       220 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassBytesRange::start (110x) [./target/valgrind/s4]
        58 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next (10x) [./target/valgrind/s4]
        46 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (1x) [./target/valgrind/s4]
        16 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicodeRange::start (8x) [./target/valgrind/s4]
        16 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicodeRange::end (8x) [./target/valgrind/s4]
        14 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::ClassUnicode::is_ascii (2x) [./target/valgrind/s4]
         8 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::ClassUnicode::iter (2x) [./target/valgrind/s4]

    51,343 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre

    67,360 ( 0.02%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/slice.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,318x)
    22,823 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/slice.rs:aho_corasick::packed::api::Builder::build (48x)
    12,990 ( 0.00%)      12 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/slice.rs:itertools::Itertools::sorted_by (3x)
    11,036 ( 0.00%)      14 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/slice.rs:s4lib::readers::syslinereader::SyslineReader::parse_datetime_in_line_cached (5x)
        42 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/slice.rs:s4lib::readers::syslinereader::SyslineReader::summary (2x)
        21 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/slice.rs:s4lib::readers::syslinereader::SyslineReader::dt_patterns_analysis (1x)
    50,891 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/sort.rs:core::slice::sort::merge_sort [./target/valgrind/s4]
    36,488 ( 0.01%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/sort.rs:core::slice::sort::insertion_sort_shift_left (1,334x) [./target/valgrind/s4]

    50,778 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions

   422,588 ( 0.12%)     825 ( 0.10%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/fmt/mod.rs:<str as core::fmt::Display>::fmt (1,863x) [./target/valgrind/s4]
    50,301 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/fmt/mod.rs:core::fmt::Formatter::pad [./target/valgrind/s4]
   370,424 ( 0.11%)     825 ( 0.10%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:<alloc::string::String as core::fmt::Write>::write_str (1,863x) [./target/valgrind/s4]

 5,393,530 ( 1.55%)       .            .           .           < ./malloc/./malloc/malloc.c:_int_realloc (25,082x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     1,126 ( 0.00%)       .            .           .           < ./libio/./libio/iogetdelim.c:getdelim (53x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        42 ( 0.00%)       .            .           .           < ./nptl/./nptl/pthread_attr_setaffinity.c:pthread_attr_setaffinity_np@@GLIBC_2.32 (3x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        24 ( 0.00%)       .            .           .           < ./malloc/./malloc/scratch_buffer_dupfree.c:__libc_scratch_buffer_dupfree (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    50,278 ( 0.01%)       .            .           .           *  ???:0x0000000004898620 [???]
 5,344,444 ( 1.54%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (25,139x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    50,169 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::cross
 1,495,927 ( 0.43%)   9,946 ( 1.23%)   .           .           >   ???:__rust_alloc (7,320x) [./target/valgrind/s4]
   694,295 ( 0.20%)   3,372 ( 0.42%)   .           .           >   ???:__rust_dealloc (5,904x) [./target/valgrind/s4]

   214,784 ( 0.06%)     609 ( 0.08%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (2,624x) [./target/valgrind/s4]
    49,856 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state [./target/valgrind/s4]

    49,564 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::util::remapper::Remapper::remap

    49,392 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state

    49,308 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/vec_deque/mod.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions
    76,878 ( 0.02%)     306 ( 0.04%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/vec_deque/mod.rs:alloc::collections::vec_deque::VecDeque<T,A>::grow (180x) [./target/valgrind/s4]

    48,866 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class
   441,813 ( 0.13%)     866 ( 0.11%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (2,914x) [./target/valgrind/s4]

    48,851 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/traits/iterator.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    48,288 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::translate::TranslatorI::push_char
   842,354 ( 0.24%)     977 ( 0.12%)   .           .           >   ???:__rust_alloc (16,096x) [./target/valgrind/s4]

    47,787 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate

    47,141 ( 0.01%)       .            .           .           *  /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/raw/mod.rs:hashbrown::map::HashMap<K,V,S,A>::insert
   267,880 ( 0.08%)     164 ( 0.02%)   .           .           >   /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/raw/mod.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash (347x) [./target/valgrind/s4]

   920,256 ( 0.26%)   1,420 ( 0.18%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (1,179x) [./target/valgrind/s4]
    47,075 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::add [./target/valgrind/s4]
   808,237 ( 0.23%)   1,420 ( 0.18%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from (1,179x) [./target/valgrind/s4]

    46,913 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions

    46,333 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    46,137 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range

    45,262 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_automata::hybrid::dfa::Lazy::set_transition

    45,046 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:aho_corasick::nfa::noncontiguous::Builder::build

    44,900 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:aho_corasick::nfa::noncontiguous::Builder::build
     9,120 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (96x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    44,800 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/convert/num.rs:regex_automata::hybrid::dfa::Builder::build_from_nfa

    44,625 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/convert/num.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa

    44,282 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre

   168,663 ( 0.05%)     305 ( 0.04%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (1,394x) [./target/valgrind/s4]
    43,214 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::add_match [./target/valgrind/s4]

    42,600 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:regex_syntax::unicode::SimpleCaseFolder::mapping

    42,263 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::remapper::onepass::<impl regex_automata::dfa::remapper::Remappable for regex_automata::dfa::onepass::DFA>::remap

    42,091 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize

   165,920 ( 0.05%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple (1,120x) [./target/valgrind/s4]
    41,730 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::SimpleCaseFolder::mapping [./target/valgrind/s4]

    41,258 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

 5,259,272 ( 1.51%)  17,698 ( 2.18%)   8 ( 2.47%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_automata::meta::reverse_inner::prefilter (44x)
 4,918,785 ( 1.42%)  10,016 ( 1.24%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_automata::util::prefilter::prefixes (16x)
     3,916 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_automata::util::prefilter::suffixes (13x)
    41,174 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Seq::optimize_by_preference [./target/valgrind/s4]
10,042,992 ( 2.89%)  27,714 ( 3.42%)   8 ( 2.47%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::PreferenceTrie::minimize (177x) [./target/valgrind/s4]

    41,036 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/set_len_on_drop.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

   237,539 ( 0.07%)     260 ( 0.03%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (2,672x) [./target/valgrind/s4]
    40,291 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push [./target/valgrind/s4]

    40,094 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind>

    39,646 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/map.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile

    39,543 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open

    39,372 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_syntax::hir::literal::Extractor::cross

   112,671 ( 0.03%)       .            .           .           < ./elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object (179x)
     4,019 ( 0.00%)       .            .           .           < ./elf/./elf/dl-runtime.c:_dl_fixup (6x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
     2,280 ( 0.00%)       .            .           .           < ./elf/./elf/dl-minimal.c:lookup_malloc_symbol (4x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
       707 ( 0.00%)       .            .           .           < ./elf/./elf/dl-sym.c:_dl_sym (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    39,211 ( 0.01%)       .            .           .           *  ./elf/./elf/dl-lookup.c:_dl_lookup_symbol_x [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    80,466 ( 0.02%)       .            .           .           >   ./elf/./elf/dl-lookup.c:do_lookup_x (190x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

   267,880 ( 0.08%)     164 ( 0.02%)   .           .           < /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/raw/mod.rs:hashbrown::map::HashMap<K,V,S,A>::insert (347x)
    39,203 ( 0.01%)       .            .           .           *  /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/raw/mod.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash [./target/valgrind/s4]

    39,129 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post

    38,979 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

    38,649 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_syntax::hir::Hir::alternation

    38,317 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_syntax::hir::literal::Extractor::cross

    37,686 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition

    36,864 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

    36,864 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

    36,780 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_syntax::ast::visitor::visit

   311,549 ( 0.09%)   1,640 ( 0.20%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (882x) [./target/valgrind/s4]
   251,252 ( 0.07%)     908 ( 0.11%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::finish_build_one_start (953x) [./target/valgrind/s4]
    36,700 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::DFA::set_matches [./target/valgrind/s4]

    36,589 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_syntax::hir::Hir::alternation

    36,262 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::nfa::thompson::builder::Builder::build
   155,904 ( 0.04%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (12,029x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    36,155 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

    35,336 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_syntax::hir::literal::Extractor::cross
   115,108 ( 0.03%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (5,251x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    35,292 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/range.rs:regex_automata::nfa::thompson::map::Utf8SuffixMap::clear

    35,117 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::Hir::alternation
       400 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::allocate_in (5x) [./target/valgrind/s4]
       108 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle (1x) [./target/valgrind/s4]

    34,797 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_syntax::hir::literal::Extractor::cross

   245,756 ( 0.07%)       .            .           .           < /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/map.rs:hashbrown::map::HashMap<K,V,S,A>::insert (1,269x) [./target/valgrind/s4]
   137,878 ( 0.04%)       .            .           .           < /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/map.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash (748x)
    80,442 ( 0.02%)       .            .           .           < /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/map.rs:regex_automata::util::captures::GroupInfo::new (505x)
    47,138 ( 0.01%)       .            .           .           < /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/map.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (218x)
    10,185 ( 0.00%)       .            .           .           < /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/map.rs:regex_automata::util::captures::Captures::get_group_by_name (65x)
    10,134 ( 0.00%)       .            .           .           < /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/map.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x)
       440 ( 0.00%)       .            .           .           < /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/map.rs:s4::processing_loop (5x)
    34,674 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/hash/mod.rs:core::hash::BuildHasher::hash_one [./target/valgrind/s4]
    57,495 ( 0.02%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/hash/sip.rs:<core::hash::sip::Hasher<S> as core::hash::Hasher>::write (1,637x) [./target/valgrind/s4]

    34,452 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/alloc/layout.rs:regex_automata::nfa::thompson::builder::Builder::build

    34,320 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/sparse_set.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push

    34,285 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

    34,122 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_syntax::hir::literal::Extractor::union

   941,175 ( 0.27%)   2,240 ( 0.28%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple (1,120x)
    13,930 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (70x)
    33,830 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple [./target/valgrind/s4]
   165,920 ( 0.05%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::SimpleCaseFolder::mapping (1,120x) [./target/valgrind/s4]

    33,406 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::Concat::into_ast

    33,323 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/traits/accum.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    33,260 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop

    32,994 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next
    47,671 ( 0.01%)     251 ( 0.03%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (123x) [./target/valgrind/s4]

    32,993 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/adapters/map.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    32,920 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::NFA::add_transition

    32,793 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    32,544 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::hir::Properties::repetition

    32,544 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/search.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new

    91,463 ( 0.03%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (16,182x) [./target/valgrind/s4]
        58 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (10x) [./target/valgrind/s4]
    32,384 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next [./target/valgrind/s4]

    32,264 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_syntax::hir::translate::TranslatorI::push_char

    32,192 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/slice.rs:regex_syntax::hir::translate::TranslatorI::push_char

    32,157 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile
 1,085,839 ( 0.31%)     292 ( 0.04%)   .           .           >   ???:__rust_dealloc (10,884x) [./target/valgrind/s4]

    31,876 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::extract'2
   538,489 ( 0.15%)   2,938 ( 0.36%)   .           .           >   ???:__rust_alloc (5,194x) [./target/valgrind/s4]
   213,250 ( 0.06%)     397 ( 0.05%)   .           .           >   ???:__rust_dealloc (2,035x) [./target/valgrind/s4]

    31,858 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate

    31,858 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::visitor::visit

 1,560,256 ( 0.45%)     673 ( 0.08%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (713x) [./target/valgrind/s4]
    31,636 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_group [./target/valgrind/s4]
 1,445,243 ( 0.42%)     667 ( 0.08%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (713x) [./target/valgrind/s4]
    14,961 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (713x) [./target/valgrind/s4]

    31,335 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    30,812 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::literal

    30,812 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_syntax::hir::Hir::literal

    30,782 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/alphabet.rs:regex_automata::dfa::onepass::InternalBuilder::compile_transition

    30,736 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_syntax::hir::Hir::alternation

   315,613 ( 0.09%)     126 ( 0.02%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/collections/hash/map.rs:regex_automata::util::captures::GroupInfo::new (586x)
   170,393 ( 0.05%)     377 ( 0.05%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/collections/hash/map.rs:regex_automata::hybrid::dfa::Lazy::init_cache (468x)
   135,892 ( 0.04%)      12 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/collections/hash/map.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (174x)
    14,070 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/collections/hash/map.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x)
     2,469 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/collections/hash/map.rs:s4::processing_loop (15x)
       608 ( 0.00%)       .            .           .           < /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/set.rs:s4::processing_loop (4x)
    30,482 ( 0.01%)       .            .           .           *  /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/map.rs:hashbrown::map::HashMap<K,V,S,A>::insert [./target/valgrind/s4]
   245,756 ( 0.07%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/hash/mod.rs:core::hash::BuildHasher::hash_one (1,269x) [./target/valgrind/s4]

    30,408 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next

    30,030 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_syntax::hir::literal::Seq::optimize_by_preference

    30,008 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::hir::Properties::class

    29,566 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize

    29,272 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new
    78,870 ( 0.02%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (3,659x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   451,230 ( 0.13%)     829 ( 0.10%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from (1,588x) [./target/valgrind/s4]
    64,820 ( 0.02%)     116 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::finish (126x) [./target/valgrind/s4]
    29,240 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile [./target/valgrind/s4]

    28,921 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

   247,118 ( 0.07%)     618 ( 0.08%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (210x) [./target/valgrind/s4]
   113,563 ( 0.03%)     260 ( 0.03%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (134x) [./target/valgrind/s4]
    28,826 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_concat [./target/valgrind/s4]
   317,829 ( 0.09%)     878 ( 0.11%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (580x) [./target/valgrind/s4]
     8,496 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (236x) [./target/valgrind/s4]

    28,821 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

    28,560 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push

   370,424 ( 0.11%)     825 ( 0.10%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/fmt/mod.rs:core::fmt::Formatter::pad (1,863x) [./target/valgrind/s4]
       782 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/fmt/mod.rs:core::fmt::Formatter::pad_integral (6x) [./target/valgrind/s4]
        86 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/fmt/mod.rs:core::fmt::write (2x) [./target/valgrind/s4]
    28,065 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:<alloc::string::String as core::fmt::Write>::write_str [./target/valgrind/s4]

   642,264 ( 0.18%)   3,137 ( 0.39%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/api.rs:aho_corasick::packed::api::Builder::extend (1,394x) [./target/valgrind/s4]
    28,060 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/pattern.rs:aho_corasick::packed::pattern::Patterns::add [./target/valgrind/s4]

    27,821 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_syntax::hir::literal::Seq::optimize_by_preference

   686,726 ( 0.20%)   3,137 ( 0.39%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/prefilter/teddy.rs:regex_automata::util::prefilter::teddy::Teddy::new (48x) [./target/valgrind/s4]
    27,686 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/api.rs:aho_corasick::packed::api::Builder::extend [./target/valgrind/s4]
   642,264 ( 0.18%)   3,137 ( 0.39%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/pattern.rs:aho_corasick::packed::pattern::Patterns::add (1,394x) [./target/valgrind/s4]
     5,576 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::packed::pattern::Patterns::len (2,788x) [./target/valgrind/s4]

    27,530 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre
    46,801 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (2,753x) [./target/valgrind/s4]

 1,870,849 ( 0.54%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
    27,434 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle [./target/valgrind/s4]
 1,738,425 ( 0.50%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::remap (48x) [./target/valgrind/s4]
    60,952 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::swap (1,490x) [./target/valgrind/s4]

    27,415 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition

    27,235 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:<core::hash::sip::Hasher<S> as core::hash::Hasher>::write

    27,078 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

    26,753 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next

    26,694 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2
   335,353 ( 0.10%)   2,601 ( 0.32%)   .           .           >   ???:__rust_dealloc (2,598x) [./target/valgrind/s4]

    26,570 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::meta::reverse_inner::flatten'2
   667,227 ( 0.19%)   3,638 ( 0.45%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::literal (1,912x) [./target/valgrind/s4]
    51,275 ( 0.01%)     298 ( 0.04%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::class (159x) [./target/valgrind/s4]
    23,672 ( 0.01%)     136 ( 0.02%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::repetition (74x) [./target/valgrind/s4]
     5,023 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Class::literal (159x) [./target/valgrind/s4]
       477 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Class::is_empty (159x) [./target/valgrind/s4]
       333 ( 0.00%)       2 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::look (2x) [./target/valgrind/s4]
       148 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::properties (74x) [./target/valgrind/s4]

   186,208 ( 0.05%)     407 ( 0.05%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (693x) [./target/valgrind/s4]
    39,746 ( 0.01%)      82 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap (81x) [./target/valgrind/s4]
    26,478 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add_capture_start [./target/valgrind/s4]
    54,218 ( 0.02%)      52 ( 0.01%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (774x) [./target/valgrind/s4]

    26,456 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::patch

    26,267 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:<regex_syntax::ast::parse::NestLimiter<P> as regex_syntax::ast::visitor::Visitor>::visit_pre

    26,102 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/search.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert

    25,611 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

    25,441 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_syntax::hir::Hir::concat

    25,426 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open

    25,416 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op

    25,416 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open
   149,644 ( 0.04%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    25,388 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class
   182,954 ( 0.05%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     8,165 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (71x) [./target/valgrind/s4]

    25,048 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_group

    25,014 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/drain.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

    25,006 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa

    24,909 ( 0.01%)       .            .           .           *  ./malloc/./malloc/arena.c:calloc

   858,248 ( 0.25%)   2,525 ( 0.31%)   2 ( 0.62%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::builder::Builder::build (175x)
    24,871 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/captures.rs:regex_automata::util::captures::GroupInfo::new [./target/valgrind/s4]
    66,383 ( 0.02%)     250 ( 0.03%)   2 ( 0.62%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/captures.rs:regex_automata::util::captures::GroupInfoInner::add_first_group (81x) [./target/valgrind/s4]
     4,232 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/captures.rs:regex_automata::util::captures::GroupInfoInner::fixup_slot_ranges (175x) [./target/valgrind/s4]

    24,816 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state

    24,720 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::Compiler::add_unanchored_start_state_loop

    24,708 ( 0.01%)       .            .           .           < ./stdlib/../stdlib/strtol.c:__strtoul_internal (98x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    24,708 ( 0.01%)       .            .           .           *  ./stdlib/../stdlib/strtol_l.c:____strtoul_l_internal [/usr/lib/x86_64-linux-gnu/libc.so.6]

    24,674 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop

   946,041 ( 0.27%)     339 ( 0.04%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::new (162x) [./target/valgrind/s4]
    74,447 ( 0.02%)      26 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::new (13x) [./target/valgrind/s4]
    24,649 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Builder::build_from_nfa [./target/valgrind/s4]
    62,626 ( 0.02%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/state.rs:regex_automata::util::determinize::state::State::dead (175x) [./target/valgrind/s4]
     5,250 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    24,621 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

    24,576 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::util::prefilter::Builder::build

    24,529 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::hir::literal::Extractor::extract'2
     3,220 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (322x) [./target/valgrind/s4]

    32,304 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions (673x) [./target/valgrind/s4]
     2,304 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state (48x) [./target/valgrind/s4]
    24,514 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::copy_matches [./target/valgrind/s4]

    24,145 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from
   360,701 ( 0.10%)     881 ( 0.11%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (1,901x) [./target/valgrind/s4]

    23,980 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_automata::dfa::remapper::onepass::<impl regex_automata::dfa::remapper::Remappable for regex_automata::dfa::onepass::DFA>::remap

 3,352,826 ( 0.96%)   6,688 ( 0.83%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::prefilter (44x) [./target/valgrind/s4]
 2,486,247 ( 0.72%)   6,666 ( 0.82%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/prefilter/mod.rs:regex_automata::util::prefilter::prefixes (16x) [./target/valgrind/s4]
 2,453,236 ( 0.71%)   5,207 ( 0.64%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/prefilter/mod.rs:regex_automata::util::prefilter::suffixes (13x) [./target/valgrind/s4]
    23,974 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract [./target/valgrind/s4]
 5,183,047 ( 1.49%)   9,591 ( 1.18%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (975x) [./target/valgrind/s4]
 1,895,581 ( 0.55%)   8,643 ( 1.07%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (111x) [./target/valgrind/s4]
 1,051,775 ( 0.30%)     257 ( 0.03%)   1 ( 0.31%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::union (864x) [./target/valgrind/s4]

   506,084 ( 0.15%)     482 ( 0.06%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::search::find_fwd (218x)
    23,834 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state [./target/valgrind/s4]
   154,889 ( 0.04%)       2 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::next (218x) [./target/valgrind/s4]
     7,194 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::set_transition (218x) [./target/valgrind/s4]
     1,914 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::next_state_id (174x) [./target/valgrind/s4]

    23,755 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/sparse_set.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa

   248,159 ( 0.07%)     134 ( 0.02%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (172x) [./target/valgrind/s4]
    23,548 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition [./target/valgrind/s4]
   107,731 ( 0.03%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (239x) [./target/valgrind/s4]
    23,478 ( 0.01%)      82 ( 0.01%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Ast::repetition (172x) [./target/valgrind/s4]
    21,271 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (239x) [./target/valgrind/s4]
    20,640 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_and_bump_space (172x) [./target/valgrind/s4]
    15,855 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (755x) [./target/valgrind/s4]
     4,302 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (239x) [./target/valgrind/s4]
     3,096 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::push (172x) [./target/valgrind/s4]
     1,943 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::specialize_err (67x) [./target/valgrind/s4]
     1,204 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Ast::span (172x) [./target/valgrind/s4]

   208,081 ( 0.06%)     314 ( 0.04%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (846x)
    15,320 ( 0.00%)      28 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (57x) [./target/valgrind/s4]
    23,478 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::union [./target/valgrind/s4]
    28,356 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (903x) [./target/valgrind/s4]

    23,161 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::literal::Extractor::extract'2

    23,136 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:aho_corasick::util::remapper::Remapper::swap

   667,227 ( 0.19%)   3,638 ( 0.45%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::meta::reverse_inner::flatten'2 (1,912x)
    22,944 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::literal [./target/valgrind/s4]
    98,933 ( 0.03%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/converts.rs:core::str::converts::from_utf8 (1,912x) [./target/valgrind/s4]

    22,631 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::hybrid::dfa::Lazy::set_transition

    22,467 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::hybrid::dfa::Lazy::init_cache

    31,216 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::maybe_parse_ascii_class (770x) [./target/valgrind/s4]
    22,348 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_syntax::ast::ClassAsciiKind::from_name [./target/valgrind/s4]

    22,280 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/convert/num.rs:regex_automata::hybrid::dfa::Lazy::set_transition

    22,269 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition

    22,141 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre

    22,097 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post

    22,004 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:<T as alloc::vec::spec_from_elem::SpecFromElem>::from_elem
    69,914 ( 0.02%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (5,378x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    21,823 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next

    21,794 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class

    21,629 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:<regex_syntax::ast::parse::NestLimiter<P> as regex_syntax::ast::visitor::Visitor>::visit_pre

    21,584 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:alloc::raw_vec::RawVec<T,A>::allocate_in
 1,131,444 ( 0.33%)   7,733 ( 0.95%)   .           .           >   ???:__rust_alloc (5,396x) [./target/valgrind/s4]

    21,547 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new

    66,501 ( 0.02%)      73 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (586x)
    65,950 ( 0.02%)      52 ( 0.01%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (586x) [./target/valgrind/s4]
       552 ( 0.00%)       4 ( 0.00%)   .           .           < src/readers/syslogprocessor.rs:s4lib::readers::syslogprocessor::SyslogProcessor::summary_complete (2x) [./target/valgrind/s4]
       547 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/borrow.rs:core::ops::function::FnOnce::call_once (3x)
       534 ( 0.00%)       4 ( 0.00%)   .           .           < src/readers/blockreader.rs:s4lib::readers::blockreader::BlockReader::new (2x) [./target/valgrind/s4]
       293 ( 0.00%)       .            .           .           < src/bin/s4.rs:s4::processing_loop (3x) [./target/valgrind/s4]
       198 ( 0.00%)       .            .           .           < src/bin/s4.rs:s4::process_dt_exit (2x) [./target/valgrind/s4]
        98 ( 0.00%)       .            .           .           < src/readers/syslogprocessor.rs:s4lib::readers::syslogprocessor::SyslogProcessor::new (1x) [./target/valgrind/s4]
        98 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/borrow.rs:s4::processing_loop (1x)
        98 ( 0.00%)       .            .           .           < src/readers/filepreprocessor.rs:s4lib::readers::filepreprocessor::process_path (1x) [./target/valgrind/s4]
        98 ( 0.00%)       .            .           .           < src/bin/s4.rs:s4::exec_fileprocessor_thread (1x) [./target/valgrind/s4]
        98 ( 0.00%)       .            .           .           < src/bin/s4.rs:s4::main (1x) [./target/valgrind/s4]
    21,402 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:<alloc::string::String as core::clone::Clone>::clone [./target/valgrind/s4]

    49,410 ( 0.01%)      56 ( 0.01%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/map/entry.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert (540x)
    21,374 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/node.rs:alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::Edge>::insert_recursing [./target/valgrind/s4]
       565 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/node.rs:alloc::collections::btree::node::splitpoint (49x) [./target/valgrind/s4]

    21,193 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend
 1,248,056 ( 0.36%)   3,243 ( 0.40%)   1 ( 0.31%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle (833x) [./target/valgrind/s4]

    21,106 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (10,553x) [./target/valgrind/s4]
        16 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (8x) [./target/valgrind/s4]
    21,122 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicodeRange::end [./target/valgrind/s4]

    21,106 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (10,553x) [./target/valgrind/s4]
        16 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (8x) [./target/valgrind/s4]
    21,122 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicodeRange::start [./target/valgrind/s4]

    21,086 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::builder::x86_64::FatAVX2<3_usize>::new_unchecked
   709,589 ( 0.20%)   2,441 ( 0.30%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (21x) [./target/valgrind/s4]
     1,365 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (21x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    21,032 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::hir::Properties::literal

    20,864 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind>

    20,745 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_automata::hybrid::dfa::Builder::build_from_nfa

    20,712 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::literal::PreferenceTrie::minimize
   934,804 ( 0.27%)   7,516 ( 0.93%)   .           .           >   ???:__rust_dealloc (7,022x) [./target/valgrind/s4]

    20,610 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add
    56,690 ( 0.02%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (4,122x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    20,606 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa
    61,742 ( 0.02%)     332 ( 0.04%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (175x) [./target/valgrind/s4]

    20,482 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter

    20,354 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_syntax::hir::literal::Extractor::cross

    21,330 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (2,370x) [./target/valgrind/s4]
    20,198 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs:regex_syntax::utf8::Utf8Sequence::as_slice [./target/valgrind/s4]

    20,185 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::dfa::DFA::set_matches

    20,180 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class
    90,936 ( 0.03%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (5,052x) [./target/valgrind/s4]

    19,988 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/navigate.rs:<alloc::collections::btree::map::Iter<K,V> as core::iter::traits::iterator::Iterator>::next

    19,886 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:aho_corasick::packed::api::Builder::build

    21,497 ( 0.01%)       .            .           .           < ./elf/../elf/dl-sysdep.c:_dl_sysdep_start (1x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    19,879 ( 0.01%)       .            .           .           *  ./elf/./elf/dl-tunables.c:__GI___tunables_init [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

    19,825 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::ast::parse::ParserI<P>::pop_class

    19,516 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Builder::build (2,788x)
    19,516 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:<aho_corasick::util::primitives::SmallIndex as core::convert::TryFrom<usize>>::try_from [./target/valgrind/s4]

    19,472 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_syntax::ast::visitor::visit

    19,393 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/alloc/layout.rs:alloc::sync::arcinner_layout_for_value_layout

    19,341 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::dfa::Builder::finish_build_both_starts::{{closure}}

    19,040 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple
   941,175 ( 0.27%)   2,240 ( 0.28%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple (1,120x) [./target/valgrind/s4]
    38,420 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,120x) [./target/valgrind/s4]

    18,903 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/look.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    18,902 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:regex_syntax::hir::ClassUnicode::literal
    11,632 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/fmt/mod.rs:core::fmt::Formatter::new (1,454x) [./target/valgrind/s4]

   722,748 ( 0.21%)   2,041 ( 0.25%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (134x) [./target/valgrind/s4]
    18,882 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded [./target/valgrind/s4]
   292,111 ( 0.08%)     917 ( 0.11%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (526x) [./target/valgrind/s4]
   223,553 ( 0.06%)     810 ( 0.10%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (1,712x) [./target/valgrind/s4]
   113,563 ( 0.03%)     260 ( 0.03%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_concat (134x) [./target/valgrind/s4]
    35,605 ( 0.01%)      52 ( 0.01%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (526x) [./target/valgrind/s4]

    18,764 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter

    18,573 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::dfa::onepass::Builder::build_from_nfa
     9,153 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (81x) [./target/valgrind/s4]

    18,334 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/convert/num.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    41,130 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (1,125x)
       156 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (1x) [./target/valgrind/s4]
    18,029 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::new [./target/valgrind/s4]
    19,169 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,126x) [./target/valgrind/s4]

    18,022 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name

   141,817 ( 0.04%)     420 ( 0.05%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (1,386x) [./target/valgrind/s4]
    18,018 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs:regex_syntax::utf8::Utf8Sequences::new [./target/valgrind/s4]

    17,980 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name
    66,501 ( 0.02%)      73 ( 0.01%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:<alloc::string::String as core::clone::Clone>::clone (586x) [./target/valgrind/s4]

    17,872 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/primitives.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push

   709,589 ( 0.20%)   2,441 ( 0.30%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::builder::x86_64::FatAVX2<3_usize>::new_unchecked (21x)
   125,295 ( 0.04%)     490 ( 0.06%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<3_usize>::new_unchecked (10x)
    83,945 ( 0.02%)     303 ( 0.04%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<1_usize>::new_unchecked (24x)
     9,052 ( 0.00%)      35 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<4_usize>::new_unchecked (2x)
    17,832 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new [./target/valgrind/s4]
   122,023 ( 0.04%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/map.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert (406x) [./target/valgrind/s4]
     2,445 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (57x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    17,781 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class

    17,672 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from

    17,649 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_syntax::hir::Hir::concat

    17,646 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/collections/hash/map.rs:core::hash::BuildHasher::hash_one

    17,620 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::Concat::into_ast

    60,952 ( 0.02%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle (1,490x) [./target/valgrind/s4]
    17,528 ( 0.01%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::swap [./target/valgrind/s4]

    17,398 ( 0.01%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert

    17,205 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<T as alloc::vec::spec_from_elem::SpecFromElem>::from_elem

    17,185 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from

    17,136 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_automata::nfa::thompson::map::Utf8SuffixMap::clear

    17,130 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition
   336,217 ( 0.10%)   1,237 ( 0.15%)   .           .           >   ???:__rust_alloc (3,426x) [./target/valgrind/s4]

    17,130 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition

    16,944 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::pop_class

    16,944 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op

    49,748 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/state.rs:regex_automata::util::determinize::next (218x)
    16,940 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/state.rs:regex_automata::util::determinize::state::Repr::iter_nfa_state_ids [./target/valgrind/s4]

    16,893 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::is_ascii

    16,781 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::packed::api::Builder::build
   199,321 ( 0.06%)     274 ( 0.03%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_from_elem.rs:<T as alloc::vec::spec_from_elem::SpecFromElem>::from_elem (48x) [./target/valgrind/s4]
   184,327 ( 0.05%)     752 ( 0.09%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (733x) [./target/valgrind/s4]

    16,728 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::NFA::add_match

    16,632 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::ast::parse::ParserI<P>::pop_group

    16,612 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/char/methods.rs:regex_syntax::hir::Properties::class

    11,524 ( 0.00%)       .            .           .           < ./elf/./elf/dl-lookup.c:check_match (299x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
     3,516 ( 0.00%)       .            .           .           < ./elf/./elf/dl-misc.c:_dl_name_match_p (86x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
       857 ( 0.00%)       .            .           .           < ./elf/./elf/dl-version.c:_dl_check_map_versions (23x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
       282 ( 0.00%)       .            .           .           < ./elf/./elf/dl-lookup-direct.c:_dl_lookup_direct (6x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
       242 ( 0.00%)       .            .           .           < ./elf/./elf/dl-load.c:_dl_map_object (6x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
        50 ( 0.00%)       .            .           .           < ./elf/../sysdeps/x86/dl-procinfo.h:_dl_load_cache_lookup (2x)
        50 ( 0.00%)       .            .           .           < ./elf/./elf/dl-load.c:_dl_map_object_from_fd (2x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
        43 ( 0.00%)       .            .           .           < ./elf/./elf/rtld.c:dl_main (1x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    16,564 ( 0.00%)       .            .           .           *  ./string/../sysdeps/x86_64/strcmp.S:strcmp [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

    16,518 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/traits/collect.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre

    16,515 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::dfa::DFA::set_matches
   461,876 ( 0.13%)   2,548 ( 0.31%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (1,835x) [./target/valgrind/s4]

    16,506 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class

   154,889 ( 0.04%)       2 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (218x) [./target/valgrind/s4]
    16,491 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::next [./target/valgrind/s4]
    30,902 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::epsilon_closure (194x) [./target/valgrind/s4]
    24,097 ( 0.01%)       2 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::add_nfa_states (218x) [./target/valgrind/s4]
        60 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/state.rs:regex_automata::util::determinize::state::StateBuilderMatches::add_match_pattern_id (3x) [./target/valgrind/s4]

    16,379 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

    16,368 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::class
   654,680 ( 0.19%)   4,402 ( 0.54%)   .           .           >   ???:__rust_alloc (2,728x) [./target/valgrind/s4]

    16,298 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2

    16,296 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop
   461,208 ( 0.13%)   1,048 ( 0.13%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle (525x) [./target/valgrind/s4]

   122,023 ( 0.04%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (406x) [./target/valgrind/s4]
    53,406 ( 0.02%)      58 ( 0.01%)   .           .           < src/readers/syslinereader.rs:s4lib::readers::syslinereader::SyslineReader::new (173x) [./target/valgrind/s4]
     1,928 ( 0.00%)      12 ( 0.00%)   .           .           < src/bin/s4.rs:s4::processing_loop (5x) [./target/valgrind/s4]
     1,364 ( 0.00%)       4 ( 0.00%)   .           .           < src/readers/linereader.rs:s4lib::readers::linereader::LineReader::insert_line (10x) [./target/valgrind/s4]
     1,278 ( 0.00%)       4 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rangemap-1.5.1/src/map.rs:rangemap::map::RangeMap<K,V>::insert (9x) [./target/valgrind/s4]
       393 ( 0.00%)       .            .           .           < src/readers/syslinereader.rs:s4lib::readers::syslinereader::SyslineReader::insert_sysline (4x) [./target/valgrind/s4]
       324 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/map.rs:s4lib::readers::syslinereader::SyslineReader::summary (4x)
       246 ( 0.00%)       2 ( 0.00%)   .           .           < src/readers/blockreader.rs:s4lib::readers::blockreader::BlockReader::read_block_File (1x) [./target/valgrind/s4]
       246 ( 0.00%)       2 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/set.rs:s4lib::readers::blockreader::BlockReader::read_block_File (1x)
    16,260 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/map.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert [./target/valgrind/s4]

   107,731 ( 0.03%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (239x) [./target/valgrind/s4]
    16,243 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal [./target/valgrind/s4]
    33,789 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (1,609x) [./target/valgrind/s4]
    21,360 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (240x) [./target/valgrind/s4]
    10,525 ( 0.00%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/uint_macros.rs:core::num::<impl u32>::from_str_radix (239x) [./target/valgrind/s4]
     4,320 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (240x) [./target/valgrind/s4]

    30,450 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::hybrid::dfa::Builder::new (350x)
    28,373 ( 0.01%)       2 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::meta::strategy::new (324x)
    14,094 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::dfa::onepass::Builder::new (162x)
    14,094 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::PikeVM::new (162x)
    14,094 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::BoundedBacktracker::new (162x)
    14,094 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::hybrid::dfa::DFA::builder (162x)
     2,262 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::nfa::thompson::compiler::Compiler::new (26x)
    16,176 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::nfa::thompson::range_trie::RangeTrie::add_empty [./target/valgrind/s4]

    16,137 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile

    16,093 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_syntax::ast::parse::ParserI<P>::pop_class
    68,970 ( 0.02%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,299x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    16,069 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape (1,607x) [./target/valgrind/s4]
    16,069 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/lib.rs:regex_syntax::is_meta_character [./target/valgrind/s4]

    16,050 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post
   362,834 ( 0.10%)     336 ( 0.04%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (4,385x) [./target/valgrind/s4]
    13,930 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple (70x) [./target/valgrind/s4]

    15,994 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::hir::Hir::class

    15,960 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

    15,949 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::builder::Builder::patch

    15,949 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::builder::Builder::patch

    15,929 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::ast::visitor::visit

    15,929 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate

    15,782 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post

    15,744 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state

    15,686 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::push_group

    15,666 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:regex_syntax::hir::literal::PreferenceTrie::insert
    38,848 ( 0.01%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,611x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    45,742 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (482x) [./target/valgrind/s4]
    15,626 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Seq::cross_preamble [./target/valgrind/s4]

    15,496 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item

    15,406 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::Hir::literal

   209,714 ( 0.06%)   1,132 ( 0.14%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (693x)
    15,246 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::capture [./target/valgrind/s4]

 1,610,640 ( 0.46%)   1,255 ( 0.15%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build (175x) [./target/valgrind/s4]
    15,067 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa [./target/valgrind/s4]

    36,488 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/sort.rs:core::slice::sort::merge_sort (1,334x) [./target/valgrind/s4]
    14,985 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/sort.rs:core::slice::sort::insertion_sort_shift_left [./target/valgrind/s4]

    14,944 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<alloc::string::String as core::fmt::Write>::write_str
   279,647 ( 0.08%)     825 ( 0.10%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle (1,865x) [./target/valgrind/s4]

    11,632 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:regex_syntax::hir::ClassUnicode::literal (1,454x)
     3,256 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:regex_syntax::hir::literal::Extractor::extract'2 (407x)
        16 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:core::ops::function::FnOnce::call_once (2x)
        16 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:regex_syntax::hir::literal::Extractor::extract (2x)
         8 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:<F as clap_builder::builder::value_parser::TypedValueParser>::parse_ref (1x)
         8 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:s4lib::readers::syslinereader::SyslineReader::new (1x)
    14,936 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/fmt/mod.rs:core::fmt::Formatter::new [./target/valgrind/s4]

    14,918 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    14,892 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:core::str::count::char_count_general_case

    14,789 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/sparse_set.rs:regex_automata::util::determinize::epsilon_closure

    14,720 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/convert/num.rs:aho_corasick::util::alphabet::ByteClassSet::set_range

    14,718 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize
    83,655 ( 0.02%)     336 ( 0.04%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (167x) [./target/valgrind/s4]

    14,660 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple
   521,235 ( 0.15%)   2,240 ( 0.28%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (1,120x) [./target/valgrind/s4]

 1,025,515 ( 0.30%)   2,240 ( 0.28%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (1,120x) [./target/valgrind/s4]
    14,560 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple [./target/valgrind/s4]

    14,540 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::class
   284,222 ( 0.08%)   2,012 ( 0.25%)   .           .           >   ???:__rust_alloc (1,454x) [./target/valgrind/s4]
   250,063 ( 0.07%)   2,906 ( 0.36%)   .           .           >   ???:__rust_realloc (1,454x) [./target/valgrind/s4]

    14,497 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class
   129,570 ( 0.04%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (4,319x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    14,488 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape

    14,460 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs:aho_corasick::util::remapper::Remapper::swap

    14,411 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle

    14,378 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:aho_corasick::nfa::noncontiguous::Builder::build

    14,339 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2

    14,175 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/char/methods.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name

    14,004 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state
   119,436 ( 0.03%)     609 ( 0.08%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (221x) [./target/valgrind/s4]

    14,000 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_automata::hybrid::dfa::Builder::configure

    13,978 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_syntax::hir::Properties::repetition

    13,943 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop
   139,740 ( 0.04%)       .            .           .           >   ???:__rust_alloc (2,740x) [./target/valgrind/s4]
    13,515 ( 0.00%)     158 ( 0.02%)   .           .           >   ???:__rust_dealloc (81x) [./target/valgrind/s4]

    13,941 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_automata::nfa::thompson::compiler::Compiler::c

    13,941 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_syntax::hir::literal::Extractor::extract

    13,940 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::packed::api::Builder::build

    13,932 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/captures.rs:regex_automata::nfa::thompson::builder::Builder::build

22,955,355 ( 6.61%) 101,507 (12.53%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::meta::regex::Builder::build (81x)
    94,954 ( 0.03%)      27 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x)
    13,932 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast> [./target/valgrind/s4]
22,955,858 ( 6.61%) 101,427 (12.52%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop (774x) [./target/valgrind/s4]
    79,745 ( 0.02%)     107 ( 0.01%)   .           .           >   ???:__rust_dealloc (774x) [./target/valgrind/s4]

    13,928 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_syntax::ast::parse::ParserI<P>::parse_group

    13,704 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition

    13,583 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:aho_corasick::util::alphabet::ByteClassSet::byte_classes

    13,582 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded

    13,527 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_group

    13,446 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::packed::pattern::Patterns::add
   246,714 ( 0.07%)     911 ( 0.11%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (360x) [./target/valgrind/s4]

    19,446 ( 0.01%)       4 ( 0.00%) 158 (48.77%)  1 ( 0.07%)  < ./malloc/./malloc/malloc.c:_int_malloc (157x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    13,401 ( 0.00%)       .            .           .           *  ./malloc/./malloc/malloc.c:sysmalloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
       128 ( 0.00%)       0            3 ( 0.93%)  .           >   ./malloc/./malloc/morecore.c:__glibc_morecore (3x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        63 ( 0.00%)       4 ( 0.00%)   1 ( 0.31%)  .           >   ./malloc/./malloc/malloc.c:sysmalloc_mmap.constprop.0 (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   122,114 ( 0.04%)     423 ( 0.05%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (770x)
    27,089 ( 0.01%)       6 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:s4lib::readers::syslinereader::SyslineReader::parse_datetime_in_line_cached (5x)
    26,617 ( 0.01%)       6 ( 0.00%)   .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:itertools::Itertools::sorted_by (3x)
    11,880 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::dot (110x)
     4,746 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (17x)
       718 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:s4lib::readers::syslinereader::SyslineReader::summary (2x)
       600 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::interval::IntervalSet<I>::new (5x)
       169 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:s4lib::readers::syslinereader::SyslineReader::dt_patterns_analysis (1x)
    13,356 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_from_iter.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter [./target/valgrind/s4]

    13,329 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter

    13,287 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile
   138,954 ( 0.04%)     863 ( 0.11%)   .           .           >   ???:__rust_alloc (773x) [./target/valgrind/s4]
    92,659 ( 0.03%)      36 ( 0.00%)   .           .           >   ???:__rust_dealloc (947x) [./target/valgrind/s4]

    13,160 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/alloc.rs:__rdl_alloc_zeroed
   374,378 ( 0.11%)   2,885 ( 0.36%)   .           .           >   ./malloc/./malloc/malloc.c:calloc (1,316x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    13,143 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:regex_syntax::hir::literal::Seq::optimize_by_preference

    12,988 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_syntax::hir::literal::Extractor::extract'2

    12,978 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::dfa::Builder::finish_build_both_starts::{{closure}}

    12,932 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::add

    12,931 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:core::slice::sort::insertion_sort_shift_left

    12,857 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_syntax::hir::literal::Extractor::cross

    12,812 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::util::prefilter::prefixes
   113,059 ( 0.03%)     144 ( 0.02%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_extend.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend (15x) [./target/valgrind/s4]

    12,739 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/primitives.rs:regex_automata::util::captures::GroupInfo::new

    12,676 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/range.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    12,608 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_automata::meta::reverse_inner::flatten'2

    12,552 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop

    12,546 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::NFA::add_match

    12,450 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple

    12,418 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_automata::util::captures::GroupInfo::new

    12,384 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Compiler::add_unanchored_start_state_loop

    12,360 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa

    12,288 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/convert/num.rs:aho_corasick::util::prefilter::Builder::build

    12,288 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ops/range.rs:aho_corasick::util::prefilter::Builder::build

    24,786 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::new (162x) [./target/valgrind/s4]
     1,989 ( 0.00%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::new (13x) [./target/valgrind/s4]
    12,250 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Builder::configure [./target/valgrind/s4]

    12,240 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/convert/num.rs:aho_corasick::util::alphabet::ByteClassSet::byte_classes

    39,809 ( 0.01%)     134 ( 0.02%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x) [./target/valgrind/s4]
    24,097 ( 0.01%)       2 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::next (218x) [./target/valgrind/s4]
    12,202 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::add_nfa_states [./target/valgrind/s4]

    12,168 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:aho_corasick::nfa::noncontiguous::Compiler::densify
   314,783 ( 0.09%)     796 ( 0.10%)   6 ( 1.85%)  .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve::do_reserve_and_handle (314x) [./target/valgrind/s4]

    12,132 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::range_trie::RangeTrie::add_empty
    77,021 ( 0.02%)       2 ( 0.00%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (674x) [./target/valgrind/s4]

    12,103 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_automata::util::prefilter::prefixes
    43,283 ( 0.01%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (1,941x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    12,066 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs:regex_automata::dfa::remapper::onepass::<impl regex_automata::dfa::remapper::Remappable for regex_automata::dfa::onepass::DFA>::remap

    12,051 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/traits/iterator.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop

   102,562 ( 0.03%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/remapper.rs:regex_automata::dfa::remapper::Remapper::remap (1x) [./target/valgrind/s4]
    12,009 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/remapper.rs:regex_automata::dfa::remapper::onepass::<impl regex_automata::dfa::remapper::Remappable for regex_automata::dfa::onepass::DFA>::remap [./target/valgrind/s4]

    11,961 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,alloc::vec::into_iter::IntoIter<T>>>::from_iter

    11,961 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,alloc::vec::into_iter::IntoIter<T>>>::from_iter

    11,942 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state

    11,898 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::dfa::Builder::finish_build_both_starts::{{closure}}

    11,890 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_automata::util::determinize::state::Repr::iter_nfa_state_ids

    11,853 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_syntax::hir::literal::Seq::cross_preamble

 1,356,033 ( 0.39%)     758 ( 0.09%)   2 ( 0.62%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (142x) [./target/valgrind/s4]
    83,548 ( 0.02%)       2 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::compile (110x) [./target/valgrind/s4]
    11,844 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least [./target/valgrind/s4]
 1,286,072 ( 0.37%)     544 ( 0.07%)   2 ( 0.62%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (142x) [./target/valgrind/s4]
    74,025 ( 0.02%)     216 ( 0.03%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (504x) [./target/valgrind/s4]
    32,450 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (110x) [./target/valgrind/s4]
       288 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::properties (144x) [./target/valgrind/s4]

    11,842 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize

    11,794 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter
    36,843 ( 0.01%)       .            .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/map.rs:<alloc::collections::btree::map::Iter<K,V> as core::iter::traits::iterator::Iterator>::next (1,041x) [./target/valgrind/s4]

    11,781 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2

    11,745 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::meta::wrappers::Hybrid::new

    11,713 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_group
   114,509 ( 0.03%)     443 ( 0.05%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (243x) [./target/valgrind/s4]
    15,360 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (512x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    37,318 ( 0.01%)      14 ( 0.00%)   .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x) [./target/valgrind/s4]
    30,902 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::next (194x) [./target/valgrind/s4]
    11,638 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::epsilon_closure [./target/valgrind/s4]

    11,610 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:regex_syntax::unicode::SimpleCaseFolder::overlaps

    11,604 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind>
    75,177 ( 0.02%)     574 ( 0.07%)   .           .           >   ???:__rust_dealloc (586x) [./target/valgrind/s4]

    11,589 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::Hir::alternation
    22,046 ( 0.01%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,159x) [./target/valgrind/s4]

    11,458 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open
 1,063,519 ( 0.31%)     330 ( 0.04%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (81x) [./target/valgrind/s4]

    11,457 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_group

    11,420 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/pattern.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new

    11,337 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile

    11,331 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs:alloc::vec::Vec<T,A>::retain_mut

 2,540,387 ( 0.73%)   8,008 ( 0.99%)   1 ( 0.31%)  .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::extract (193x) [./target/valgrind/s4]
    11,325 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten [./target/valgrind/s4]
 1,664,363 ( 0.48%)   7,274 ( 0.90%)   1 ( 0.31%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (1,589x) [./target/valgrind/s4]
   582,137 ( 0.17%)     250 ( 0.03%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (55x) [./target/valgrind/s4]
    47,535 ( 0.01%)      76 ( 0.01%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (29x) [./target/valgrind/s4]
    10,539 ( 0.00%)      34 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Repetition::with (75x) [./target/valgrind/s4]
       568 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::kind (284x) [./target/valgrind/s4]

    36,843 ( 0.01%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter (1,041x)
     6,243 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/traits/iterator.rs:s4lib::readers::syslinereader::SyslineReader::dt_patterns_counts_in_use (176x)
     6,195 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/traits/iterator.rs:s4lib::readers::syslinereader::SyslineReader::dt_patterns_analysis (174x)
       471 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_from_iter_nested.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter (9x)
       351 ( 0.00%)       .            .           .           < src/bin/s4.rs:s4::processing_loop (15x) [./target/valgrind/s4]
        96 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/traits/iterator.rs:s4lib::readers::syslinereader::SyslineReader::summary (4x)
        49 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/map.rs:s4::processing_loop (2x)
    11,322 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/map.rs:<alloc::collections::btree::map::Iter<K,V> as core::iter::traits::iterator::Iterator>::next [./target/valgrind/s4]

    11,296 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:regex_syntax::ast::parse::ParserI<P>::pop_class

    11,296 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op

    11,296 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open

    11,262 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs:regex_syntax::hir::ClassUnicode::is_ascii

    11,235 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state

102,524,736 (29.51%) 224,173 (27.67%) 102 (31.48%)  1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::meta::strategy::new (175x)
    11,198 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::compile [./target/valgrind/s4]
83,307,290 (23.98%) 191,348 (23.62%)  91 (28.09%)  1 ( 0.07%)  >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/adapters/map.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (350x) [./target/valgrind/s4]
19,010,900 ( 5.47%)  32,738 ( 4.04%)  11 ( 3.40%)  .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build (175x) [./target/valgrind/s4]
    83,548 ( 0.02%)       2 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (110x) [./target/valgrind/s4]
    39,420 ( 0.01%)      40 ( 0.00%)   .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::dot (110x) [./target/valgrind/s4]
    28,140 ( 0.01%)       1 ( 0.00%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (110x) [./target/valgrind/s4]
     7,950 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (175x) [./target/valgrind/s4]
     5,425 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::clear (175x) [./target/valgrind/s4]
       350 ( 0.00%)       .            .           .           >   /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::properties (175x) [./target/valgrind/s4]

    11,152 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert
    30,525 ( 0.01%)       .            .           .           >   ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (1,394x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    11,110 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push
    94,698 ( 0.03%)     260 ( 0.03%)   .           .           >   /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::reserve_for_push (211x) [./target/valgrind/s4]

    11,052 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/sparse_set.rs:regex_automata::util::determinize::state::Repr::iter_nfa_state_ids

    14,175 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (525x)
        31 ( 0.00%)       .            .           .           < /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:s4::processing_loop (1x)
    11,048 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/drain.rs:<alloc::vec::drain::Drain<T,A> as core::ops::drop::Drop>::drop [./target/valgrind/s4]

    33,120 ( 0.01%)       .            .           .           < /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (3,680x) [./target/valgrind/s4]
    11,040 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::iter_trans [./target/valgrind/s4]

    11,040 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::NFA::iter_trans

    11,040 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::NFA::iter_trans

    11,010 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::dfa::DFA::set_matches

    22,516 ( 0.01%)       .            .           .           < ./elf/./elf/dl-lookup.c:do_lookup_x (192x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    10,992 ( 0.00%)       .            .           .           *  ./elf/./elf/dl-lookup.c:check_match [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    11,524 ( 0.00%)       .            .           .           >   ./string/../sysdeps/x86_64/strcmp.S:strcmp (299x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

    10,884 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

    10,824 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next

    10,810 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::add_transition

    10,792 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:alloc::raw_vec::RawVec<T,A>::allocate_in

    10,774 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/alloc/layout.rs:alloc::raw_vec::RawVec<T,A>::allocate_in

    10,716 ( 0.00%)       .            .           .           *  /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/primitives.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state

    10,701 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::add

    10,650 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:regex_syntax::unicode::SimpleCaseFolder::mapping

    10,636 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

    10,578 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:alloc::sync::arcinner_layout_for_value_layout

    10,561 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next

    10,496 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state

    10,464 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post

    10,434 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/range.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle

    10,431 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:alloc::vec::Vec<T,A>::retain_mut

    10,395 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::hir::Properties::capture

    55,628 ( 0.02%)      91 ( 0.01%)   .           .           < ./malloc/./malloc/malloc.c:posix_memalign (121x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    10,391 ( 0.00%)       .            .           .           *  ./malloc/./malloc/malloc.c:_int_memalign [/usr/lib/x86_64-linux-gnu/libc.so.6]
    31,691 ( 0.01%)       .            .           .           >   ./malloc/./malloc/malloc.c:_int_malloc (121x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    13,546 ( 0.00%)      91 ( 0.01%)   .           .           >   ./malloc/./malloc/malloc.c:_int_free (170x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    10,311 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    10,170 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::repetition
   489,848 ( 0.14%)   3,706 ( 0.46%)   1 ( 0.31%)  .           >   ???:__rust_alloc (2,034x) [./target/valgrind/s4]

    10,170 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/uint_macros.rs:regex_syntax::hir::Properties::repetition

    10,100 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions

    10,096 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/adapters/take.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new

     9,997 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter

     9,982 ( 0.00%)       .            .           .           *  ./malloc/./malloc/malloc.c:__malloc_arena_thread_freeres
    41,422 ( 0.01%)     721 ( 0.09%)   .           .           >   ./malloc/./malloc/malloc.c:_int_free (381x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
       142 ( 0.00%)       2 ( 0.00%)   .           .           >   ./malloc/./malloc/malloc.c:free (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

     9,962 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name

     9,954 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/validations.rs:core::str::count::char_count_general_case

     9,849 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop

     9,826 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs:regex_syntax::hir::Hir::alternation

     9,735 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs:regex_syntax::hir::Properties::repetition

     9,702 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::pop_group
   110,919 ( 0.03%)     314 ( 0.04%)   .           .           >   ???:__rust_alloc (1,386x) [./target/valgrind/s4]
    70,326 ( 0.02%)      63 ( 0.01%)   .           .           >   ???:__rust_dealloc (693x) [./target/valgrind/s4]

     9,700 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T,A> as core::clone::Clone>::clone

     9,665 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/node.rs:<alloc::collections::btree::map::Iter<K,V> as core::iter::traits::iterator::Iterator>::next

     9,656 ( 0.00%)       .            .           .           *  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/alphabet.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 96 ----------------------------------------
        .          .          .          .               /// All possible byte values are legal. However, when creating a haystack
        .          .          .          .               /// unit for a specific DFA, one should be careful to only construct units
        .          .          .          .               /// that are in that DFA's alphabet. Namely, one way to compact a DFA's
        .          .          .          .               /// in-memory representation is to collapse its transitions to a set of
        .          .          .          .               /// equivalence classes into a set of all possible byte values. If a DFA
        .          .          .          .               /// uses equivalence classes instead of byte values, then the byte given
        .          .          .          .               /// here should be the equivalence class.
        .          .          .          .               pub fn u8(byte: u8) -> Unit {
  113,179 ( 0.03%) .          .          .                   Unit(UnitKind::U8(byte))
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Create a new "end of input" haystack unit.
        .          .          .          .               ///
        .          .          .          .               /// The value given is the sentinel value used by this unit to represent
        .          .          .          .               /// the "end of input." The value should be the total number of equivalence
        .          .          .          .               /// classes in the corresponding alphabet. Its maximum value is `256`,
        .          .          .          .               /// which occurs when every byte is its own equivalence class.
-- line 112 ----------------------------------------
-- line 115 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// This panics when `num_byte_equiv_classes` is greater than `256`.
        .          .          .          .               pub fn eoi(num_byte_equiv_classes: usize) -> Unit {
        .          .          .          .                   assert!(
        .          .          .          .                       num_byte_equiv_classes <= 256,
        .          .          .          .                       "max number of byte-based equivalent classes is 256, but got {}",
        .          .          .          .                       num_byte_equiv_classes,
        .          .          .          .                   );
      702 ( 0.00%) .          .          .                   Unit(UnitKind::EOI(u16::try_from(num_byte_equiv_classes).unwrap()))
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// If this unit is not an "end of input" sentinel, then returns its
        .          .          .          .               /// underlying byte value. Otherwise return `None`.
        .          .          .          .               pub fn as_u8(self) -> Option<u8> {
      120 ( 0.00%) .          .          .                   match self.0 {
        .          .          .          .                       UnitKind::U8(b) => Some(b),
        .          .          .          .                       UnitKind::EOI(_) => None,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// If this unit is an "end of input" sentinel, then return the underlying
        .          .          .          .               /// sentinel value that was given to [`Unit::eoi`]. Otherwise return
        .          .          .          .               /// `None`.
-- line 137 ----------------------------------------
-- line 206 ----------------------------------------
        .          .          .          .           /// let classes = nfa.byte_classes();
        .          .          .          .           /// // 'a' and 'z' are in the same class for this regex.
        .          .          .          .           /// assert_eq!(classes.get(b'a'), classes.get(b'z'));
        .          .          .          .           /// // But 'a' and 'A' are not.
        .          .          .          .           /// assert_ne!(classes.get(b'a'), classes.get(b'A'));
        .          .          .          .           ///
        .          .          .          .           /// # Ok::<(), Box<dyn std::error::Error>>(())
        .          .          .          .           /// ```
    2,673 ( 0.00%) .          .          .           #[derive(Clone, Copy)]
        .          .          .          .           pub struct ByteClasses([u8; 256]);
        .          .          .          .           
        .          .          .          .           impl ByteClasses {
        .          .          .          .               /// Creates a new set of equivalence classes where all bytes are mapped to
        .          .          .          .               /// the same class.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn empty() -> ByteClasses {
        .          .          .          .                   ByteClasses([0; 256])
-- line 222 ----------------------------------------
-- line 225 ----------------------------------------
        .          .          .          .               /// Creates a new set of equivalence classes where each byte belongs to
        .          .          .          .               /// its own equivalence class.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn singletons() -> ByteClasses {
        .          .          .          .                   let mut classes = ByteClasses::empty();
        .          .          .          .                   for b in 0..=255 {
        .          .          .          .                       classes.set(b, b);
        .          .          .          .                   }
    5,600 ( 0.00%) .          .          .                   classes
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Deserializes a byte class map from the given slice. If the slice is of
        .          .          .          .               /// insufficient length or otherwise contains an impossible mapping, then
        .          .          .          .               /// an error is returned. Upon success, the number of bytes read along with
        .          .          .          .               /// the map are returned. The number of bytes read is always a multiple of
        .          .          .          .               /// 8.
        .          .          .          .               pub(crate) fn from_bytes(
-- line 241 ----------------------------------------
-- line 281 ----------------------------------------
        .          .          .          .               /// Returns the total number of bytes written by `write_to`.
        .          .          .          .               pub(crate) fn write_to_len(&self) -> usize {
        .          .          .          .                   256
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Set the equivalence class for the given byte.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn set(&mut self, byte: u8, class: u8) {
   96,950 ( 0.03%) .          .          .                   self.0[usize::from(byte)] = class;
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Get the equivalence class for the given byte.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn get(&self, byte: u8) -> u8 {
  116,748 ( 0.03%) .          .          .                   self.0[usize::from(byte)]
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Get the equivalence class for the given haystack unit and return the
        .          .          .          .               /// class as a `usize`.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn get_by_unit(&self, unit: Unit) -> usize {
   45,262 ( 0.01%) .          .          .                   match unit.0 {
        .          .          .          .                       UnitKind::U8(b) => usize::from(self.get(b)),
        .          .          .          .                       UnitKind::EOI(b) => usize::from(b),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Create a unit that represents the "end of input" sentinel based on the
        .          .          .          .               /// number of equivalence classes.
        .          .          .          .               #[inline]
-- line 310 ----------------------------------------
-- line 317 ----------------------------------------
        .          .          .          .               /// Return the total number of elements in the alphabet represented by
        .          .          .          .               /// these equivalence classes. Equivalently, this returns the total number
        .          .          .          .               /// of equivalence classes.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn alphabet_len(&self) -> usize {
        .          .          .          .                   // Add one since the number of equivalence classes is one bigger than
        .          .          .          .                   // the last one. But add another to account for the final EOI class
        .          .          .          .                   // that isn't explicitly represented.
      256 ( 0.00%) .          .          .                   usize::from(self.0[255]) + 1 + 1
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the stride, as a base-2 exponent, required for these
        .          .          .          .               /// equivalence classes.
        .          .          .          .               ///
        .          .          .          .               /// The stride is always the smallest power of 2 that is greater than or
        .          .          .          .               /// equal to the alphabet length, and the `stride2` returned here is the
        .          .          .          .               /// exponent applied to `2` to get the smallest power. This is done so that
-- line 333 ----------------------------------------
-- line 415 ----------------------------------------
        .          .          .          .               ) -> ByteClassRepresentatives<'_> {
        .          .          .          .                   use core::ops::Bound;
        .          .          .          .           
        .          .          .          .                   let cur_byte = match range.start_bound() {
        .          .          .          .                       Bound::Included(&i) => usize::from(i),
        .          .          .          .                       Bound::Excluded(&i) => usize::from(i).checked_add(1).unwrap(),
        .          .          .          .                       Bound::Unbounded => 0,
        .          .          .          .                   };
    1,451 ( 0.00%) .          .          .                   let end_byte = match range.end_bound() {
        .          .          .          .                       Bound::Included(&i) => {
        .          .          .          .                           Some(usize::from(i).checked_add(1).unwrap())
        .          .          .          .                       }
        .          .          .          .                       Bound::Excluded(&i) => Some(usize::from(i)),
        .          .          .          .                       Bound::Unbounded => None,
        .          .          .          .                   };
        .          .          .          .                   assert_ne!(
        .          .          .          .                       cur_byte,
-- line 431 ----------------------------------------
-- line 557 ----------------------------------------
        .          .          .          .               end_byte: Option<usize>,
        .          .          .          .               last_class: Option<u8>,
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'a> Iterator for ByteClassRepresentatives<'a> {
        .          .          .          .               type Item = Unit;
        .          .          .          .           
        .          .          .          .               fn next(&mut self) -> Option<Unit> {
  300,439 ( 0.09%) .          .          .                   while self.cur_byte < self.end_byte.unwrap_or(256) {
        .          .          .          .                       let byte = u8::try_from(self.cur_byte).unwrap();
        .          .          .          .                       let class = self.classes.get(byte);
   92,114 ( 0.03%) .          .          .                       self.cur_byte += 1;
        .          .          .          .           
        .          .          .          .                       if self.last_class != Some(class) {
        .          .          .          .                           self.last_class = Some(class);
        .          .          .          .                           return Some(Unit::u8(byte));
        .          .          .          .                       }
        .          .          .          .                   }
    1,404 ( 0.00%) .          .          .                   if self.cur_byte != usize::MAX && self.end_byte.is_none() {
        .          .          .          .                       // Using usize::MAX as a sentinel is OK because we ban usize::MAX
        .          .          .          .                       // from appearing as a start bound in iterator construction. But
        .          .          .          .                       // why do it this way? Well, we want to return the EOI class
        .          .          .          .                       // whenever the end of the given range is unbounded because EOI
        .          .          .          .                       // isn't really a "byte" per se, so the only way it should be
        .          .          .          .                       // excluded is if there is a bounded end to the range. Therefore,
        .          .          .          .                       // when the end is unbounded, we just need to know whether we've
        .          .          .          .                       // reported EOI or not. When we do, we set cur_byte to a value it
        .          .          .          .                       // can never otherwise be.
        .          .          .          .                       self.cur_byte = usize::MAX;
      351 ( 0.00%) .          .          .                       return Some(self.classes.eoi());
        .          .          .          .                   }
        .          .          .          .                   None
   23,817 ( 0.01%) .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// An iterator over all elements in an equivalence class.
        .          .          .          .           ///
        .          .          .          .           /// This is created by the [`ByteClasses::elements`] method.
        .          .          .          .           ///
        .          .          .          .           /// The lifetime `'a` refers to the lifetime of the byte classes that this
        .          .          .          .           /// iterator was created from.
-- line 597 ----------------------------------------
-- line 691 ----------------------------------------
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[cfg(feature = "alloc")]
        .          .          .          .           impl ByteClassSet {
        .          .          .          .               /// Create a new set of byte classes where all bytes are part of the same
        .          .          .          .               /// equivalence class.
        .          .          .          .               pub(crate) fn empty() -> Self {
      350 ( 0.00%) .          .          .                   ByteClassSet(ByteSet::empty())
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Indicate the range of byte given (inclusive) can discriminate a
        .          .          .          .               /// match between it and all other bytes outside of the range.
        .          .          .          .               pub(crate) fn set_range(&mut self, start: u8, end: u8) {
        .          .          .          .                   debug_assert!(start <= end);
  167,916 ( 0.05%) .          .          .                   if start > 0 {
   83,725 ( 0.02%) .          .          .                       self.0.add(start - 1);
        .          .          .          .                   }
        .          .          .          .                   self.0.add(end);
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Add the contiguous ranges in the set given to this byte class set.
        .          .          .          .               pub(crate) fn add_set(&mut self, set: &ByteSet) {
        .          .          .          .                   for (start, end) in set.iter_ranges() {
        .          .          .          .                       self.set_range(start, end);
-- line 715 ----------------------------------------
-- line 720 ----------------------------------------
        .          .          .          .               /// corresponding equivalence class. The last mapping indicates the largest
        .          .          .          .               /// equivalence class identifier (which is never bigger than 255).
        .          .          .          .               pub(crate) fn byte_classes(&self) -> ByteClasses {
        .          .          .          .                   let mut classes = ByteClasses::empty();
        .          .          .          .                   let mut class = 0u8;
        .          .          .          .                   let mut b = 0u8;
        .          .          .          .                   loop {
        .          .          .          .                       classes.set(b, class);
  178,500 ( 0.05%) .          .          .                       if b == 255 {
        .          .          .          .                           break;
        .          .          .          .                       }
   89,250 ( 0.03%) .          .          .                       if self.0.contains(b) {
        .          .          .          .                           class = class.checked_add(1).unwrap();
        .          .          .          .                       }
        .          .          .          .                       b = b.checked_add(1).unwrap();
        .          .          .          .                   }
    6,650 ( 0.00%) .          .          .                   classes
    5,250 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// A simple set of bytes that is reasonably cheap to copy and allocation free.
      700 ( 0.00%) .          .          .           #[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
        .          .          .          .           pub(crate) struct ByteSet {
        .          .          .          .               bits: BitSet,
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// The representation of a byte set. Split out so that we can define a
        .          .          .          .           /// convenient Debug impl for it while keeping "ByteSet" in the output.
        .          .          .          .           #[derive(Clone, Copy, Default, Eq, PartialEq)]
        .          .          .          .           struct BitSet([u128; 2]);
        .          .          .          .           
        .          .          .          .           impl ByteSet {
        .          .          .          .               /// Create an empty set of bytes.
        .          .          .          .               pub(crate) fn empty() -> ByteSet {
      700 ( 0.00%) .          .          .                   ByteSet { bits: BitSet([0; 2]) }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Add a byte to this set.
        .          .          .          .               ///
        .          .          .          .               /// If the given byte already belongs to this set, then this is a no-op.
        .          .          .          .               pub(crate) fn add(&mut self, byte: u8) {
  380,810 ( 0.11%) .          .          .                   let bucket = byte / 128;
        .          .          .          .                   let bit = byte % 128;
1,708,525 ( 0.49%) .          .          .                   self.bits.0[usize::from(bucket)] |= 1 << bit;
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Remove a byte from this set.
        .          .          .          .               ///
        .          .          .          .               /// If the given byte is not in this set, then this is a no-op.
        .          .          .          .               pub(crate) fn remove(&mut self, byte: u8) {
        .          .          .          .                   let bucket = byte / 128;
        .          .          .          .                   let bit = byte % 128;
        .          .          .          .                   self.bits.0[usize::from(bucket)] &= !(1 << bit);
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return true if and only if the given byte is in this set.
        .          .          .          .               pub(crate) fn contains(&self, byte: u8) -> bool {
  178,500 ( 0.05%) .          .          .                   let bucket = byte / 128;
        .          .          .          .                   let bit = byte % 128;
  981,750 ( 0.28%) .          .          .                   self.bits.0[usize::from(bucket)] & (1 << bit) > 0
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return true if and only if the given inclusive range of bytes is in
        .          .          .          .               /// this set.
        .          .          .          .               pub(crate) fn contains_range(&self, start: u8, end: u8) -> bool {
        .          .          .          .                   (start..=end).all(|b| self.contains(b))
        .          .          .          .               }
        .          .          .          .           
-- line 787 ----------------------------------------
-- line 793 ----------------------------------------
        .          .          .          .               /// Returns an iterator over all contiguous ranges of bytes in this set.
        .          .          .          .               pub(crate) fn iter_ranges(&self) -> ByteSetRangeIter {
        .          .          .          .                   ByteSetRangeIter { set: self, b: 0 }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return true if and only if this set is empty.
        .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
        .          .          .          .               pub(crate) fn is_empty(&self) -> bool {
      234 ( 0.00%) .          .          .                   self.bits.0 == [0, 0]
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Deserializes a byte set from the given slice. If the slice is of
        .          .          .          .               /// incorrect length or is otherwise malformed, then an error is returned.
        .          .          .          .               /// Upon success, the number of bytes read along with the set are returned.
        .          .          .          .               /// The number of bytes read is always a multiple of 8.
        .          .          .          .               pub(crate) fn from_bytes(
        .          .          .          .                   slice: &[u8],
-- line 809 ----------------------------------------

  285,527 ( 0.08%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/alphabet.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/lib.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 252 ----------------------------------------
    .          .          .          .           /// assert!(is_meta_character('#'));
    .          .          .          .           ///
    .          .          .          .           /// assert!(!is_meta_character('%'));
    .          .          .          .           /// assert!(!is_meta_character('/'));
    .          .          .          .           /// assert!(!is_meta_character('!'));
    .          .          .          .           /// assert!(!is_meta_character('"'));
    .          .          .          .           /// assert!(!is_meta_character('e'));
    .          .          .          .           /// ```
1,607 ( 0.00%) .          .          .           pub fn is_meta_character(c: char) -> bool {
4,821 ( 0.00%) .          .          .               match c {
    .          .          .          .                   '\\' | '.' | '+' | '*' | '?' | '(' | ')' | '|' | '[' | ']' | '{'
    .          .          .          .                   | '}' | '^' | '$' | '#' | '&' | '-' | '~' => true,
    .          .          .          .                   _ => false,
    .          .          .          .               }
1,607 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Returns true if the given character can be escaped in a regex.
    .          .          .          .           ///
    .          .          .          .           /// This returns true in all cases that `is_meta_character` returns true, but
    .          .          .          .           /// also returns true in some cases where `is_meta_character` returns false.
    .          .          .          .           /// For example, `%` is not a meta character, but it is escapeable. That is,
    .          .          .          .           /// `%` and `\%` both match a literal `%` in all contexts.
    .          .          .          .           ///
-- line 274 ----------------------------------------
-- line 302 ----------------------------------------
    .          .          .          .           /// ```
    .          .          .          .           pub fn is_escapeable_character(c: char) -> bool {
    .          .          .          .               // Certainly escapeable if it's a meta character.
    .          .          .          .               if is_meta_character(c) {
    .          .          .          .                   return true;
    .          .          .          .               }
    .          .          .          .               // Any character that isn't ASCII is definitely not escapeable. There's
    .          .          .          .               // no real need to allow things like \☃ right?
    1 ( 0.00%) .          .          .               if !c.is_ascii() {
    .          .          .          .                   return false;
    .          .          .          .               }
    .          .          .          .               // Otherwise, we basically say that everything is escapeable unless it's a
    .          .          .          .               // letter or digit. Things like \3 are either octal (when enabled) or an
    .          .          .          .               // error, and we should keep it that way. Otherwise, letters are reserved
    .          .          .          .               // for adding new syntax in a backwards compatible way.
    .          .          .          .               match c {
    9 ( 0.00%) .          .          .                   '0'..='9' | 'A'..='Z' | 'a'..='z' => false,
    .          .          .          .                   // While not currently supported, we keep these as not escapeable to
    .          .          .          .                   // give us some flexibility with respect to supporting the \< and
    .          .          .          .                   // \> word boundary assertions in the future. By rejecting them as
    .          .          .          .                   // escapeable, \< and \> will result in a parse error. Thus, we can
    .          .          .          .                   // turn them into something else in the future without it being a
    .          .          .          .                   // backwards incompatible change.
    .          .          .          .                   //
    .          .          .          .                   // OK, now we support \< and \>, and we need to retain them as *not*
-- line 326 ----------------------------------------

8,034 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/lib.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/captures.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 209 ----------------------------------------
    .          .          .          .               /// assert_eq!(None, caps.get_group_by_name("lower"));
    .          .          .          .               /// assert_eq!(Some(Span::from(0..3)), caps.get_group_by_name("upper"));
    .          .          .          .               /// assert_eq!(Some(Span::from(3..6)), caps.get_group_by_name("digits"));
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               pub fn all(group_info: GroupInfo) -> Captures {
    .          .          .          .                   let slots = group_info.slot_len();
  278 ( 0.00%) .          .          .                   Captures { group_info, pid: None, slots: vec![None; slots] }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Create new storage for only the full match spans of a pattern. This
    .          .          .          .               /// does not include any capturing group offsets.
    .          .          .          .               ///
    .          .          .          .               /// It is unspecified behavior to use the returned `Captures` value in a
    .          .          .          .               /// search with a `GroupInfo` other than the one that is provided to this
    .          .          .          .               /// constructor.
-- line 225 ----------------------------------------
-- line 362 ----------------------------------------
    .          .          .          .               /// // Recall that offsets are only available when using a non-empty
    .          .          .          .               /// // Captures value. So even though a match occurred, this returns None!
    .          .          .          .               /// assert_eq!(None, caps.get_match());
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn pattern(&self) -> Option<PatternID> {
   65 ( 0.00%) .          .          .                   self.pid
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the pattern ID and the span of the match, if one occurred.
    .          .          .          .               ///
    .          .          .          .               /// This always returns `None` when `Captures` was created with
    .          .          .          .               /// [`Captures::empty`], even if a match was found.
    .          .          .          .               ///
    .          .          .          .               /// If this routine returns a non-`None` value, then `is_match` is
-- line 378 ----------------------------------------
-- line 451 ----------------------------------------
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn get_group(&self, index: usize) -> Option<Span> {
    .          .          .          .                   let pid = self.pattern()?;
    .          .          .          .                   // There's a little bit of work needed to map captures to slots in the
    .          .          .          .                   // fully general case. But in the overwhelming common case of a single
    .          .          .          .                   // pattern, we can just do some simple arithmetic.
  195 ( 0.00%) .          .          .                   let (slot_start, slot_end) = if self.group_info().pattern_len() == 1 {
    .          .          .          .                       (index.checked_mul(2)?, index.checked_mul(2)?.checked_add(1)?)
    .          .          .          .                   } else {
    .          .          .          .                       self.group_info().slots(pid, index)?
    .          .          .          .                   };
  260 ( 0.00%) .          .          .                   let start = self.slots.get(slot_start).copied()??;
   65 ( 0.00%) .          .          .                   let end = self.slots.get(slot_end).copied()??;
  260 ( 0.00%) .          .          .                   Some(Span { start: start.get(), end: end.get() })
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the span of a capturing group match corresponding to the group
    .          .          .          .               /// name given, only if both the overall pattern matched and the capturing
    .          .          .          .               /// group participated in that match.
    .          .          .          .               ///
    .          .          .          .               /// This returns `None` if `name` does not correspond to a valid capturing
    .          .          .          .               /// group for the pattern that matched.
-- line 474 ----------------------------------------
-- line 499 ----------------------------------------
    .          .          .          .               /// assert_eq!(Some(Match::must(0, 0..17)), caps.get_match());
    .          .          .          .               /// assert_eq!(Some(Span::from(0..5)), caps.get_group_by_name("first"));
    .          .          .          .               /// assert_eq!(Some(Span::from(6..17)), caps.get_group_by_name("last"));
    .          .          .          .               /// // Looking for a non-existent capturing group will return None:
    .          .          .          .               /// assert_eq!(None, caps.get_group_by_name("middle"));
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
  520 ( 0.00%) .          .          .               pub fn get_group_by_name(&self, name: &str) -> Option<Span> {
  130 ( 0.00%) .          .          .                   let index = self.group_info().to_index(self.pattern()?, name)?;
    .          .          .          .                   self.get_group(index)
  585 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns an iterator of possible spans for every capturing group in the
    .          .          .          .               /// matching pattern.
    .          .          .          .               ///
    .          .          .          .               /// If this `Captures` value does not correspond to a match, then the
    .          .          .          .               /// iterator returned yields no elements.
    .          .          .          .               ///
    .          .          .          .               /// Note that the iterator returned yields elements of type `Option<Span>`.
-- line 518 ----------------------------------------
-- line 1127 ----------------------------------------
    .          .          .          .               ///     Some(6),
    .          .          .          .               ///     Some(17),
    .          .          .          .               /// ]);
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn set_pattern(&mut self, pid: Option<PatternID>) {
  258 ( 0.00%) .          .          .                   self.pid = pid;
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the underlying slots, where each slot stores a single offset.
    .          .          .          .               ///
    .          .          .          .               /// Every matching capturing group generally corresponds to two slots: one
    .          .          .          .               /// slot for the starting position and another for the ending position.
    .          .          .          .               /// Typically, either both are present or neither are. (The weasel word
    .          .          .          .               /// "typically" is used here because it really depends on the regex engine
-- line 1143 ----------------------------------------
-- line 1442 ----------------------------------------
    .          .          .          .           /// // group index for a specific pattern will return None. So for example,
    .          .          .          .           /// // you're guaranteed to not get the slots for a different pattern than the
    .          .          .          .           /// // one requested.
    .          .          .          .           /// assert_eq!(None, info.slots(PatternID::must(5), 0));
    .          .          .          .           /// assert_eq!(None, info.slots(PatternID::must(1), 1));
    .          .          .          .           ///
    .          .          .          .           /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .           /// ```
  139 ( 0.00%) .          .          .           #[derive(Clone, Debug, Default)]
    .          .          .          .           pub struct GroupInfo(Arc<GroupInfoInner>);
    .          .          .          .           
    .          .          .          .           impl GroupInfo {
    .          .          .          .               /// Creates a new group info from a sequence of patterns, where each
    .          .          .          .               /// sequence of patterns yields a sequence of possible group names. The
    .          .          .          .               /// index of each pattern in the sequence corresponds to its `PatternID`,
    .          .          .          .               /// and the index of each group in each pattern's sequence corresponds to
    .          .          .          .               /// its corresponding group index.
-- line 1458 ----------------------------------------
-- line 1561 ----------------------------------------
    .          .          .          .               /// ]).is_ok());
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               ///
    .          .          .          .               /// There are other ways for building a `GroupInfo` to fail but are
    .          .          .          .               /// difficult to show. For example, if the number of patterns given would
    .          .          .          .               /// overflow `PatternID`.
1,400 ( 0.00%) .          .          .               pub fn new<P, G, N>(pattern_groups: P) -> Result<GroupInfo, GroupInfoError>
    .          .          .          .               where
    .          .          .          .                   P: IntoIterator<Item = G>,
    .          .          .          .                   G: IntoIterator<Item = Option<N>>,
    .          .          .          .                   N: AsRef<str>,
    .          .          .          .               {
1,400 ( 0.00%) .          .          .                   let mut group_info = GroupInfoInner {
    .          .          .          .                       slot_ranges: vec![],
    .          .          .          .                       name_to_index: vec![],
    .          .          .          .                       index_to_name: vec![],
    .          .          .          .                       memory_extra: 0,
    .          .          .          .                   };
    .          .          .          .                   for (pattern_index, groups) in pattern_groups.into_iter().enumerate() {
    .          .          .          .                       // If we can't convert the pattern index to an ID, then the caller
    .          .          .          .                       // tried to build capture info for too many patterns.
    .          .          .          .                       let pid = PatternID::new(pattern_index)
    .          .          .          .                           .map_err(GroupInfoError::too_many_patterns)?;
    .          .          .          .           
    .          .          .          .                       let mut groups_iter = groups.into_iter().enumerate();
   81 ( 0.00%) .          .          .                       match groups_iter.next() {
    .          .          .          .                           None => return Err(GroupInfoError::missing_groups(pid)),
    .          .          .          .                           Some((_, Some(_))) => {
    .          .          .          .                               return Err(GroupInfoError::first_must_be_unnamed(pid))
    .          .          .          .                           }
    .          .          .          .                           Some((_, None)) => {}
    .          .          .          .                       }
  162 ( 0.00%) .          .          .                       group_info.add_first_group(pid);
66,383 ( 0.02%) 250 ( 0.03%) 2 ( 0.62%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/captures.rs:regex_automata::util::captures::GroupInfoInner::add_first_group (81x)
    .          .          .          .                       // Now iterate over the rest, which correspond to all of the
    .          .          .          .                       // (conventionally) explicit capture groups in a regex pattern.
    .          .          .          .                       for (group_index, maybe_name) in groups_iter {
    .          .          .          .                           // Just like for patterns, if the group index can't be
    .          .          .          .                           // converted to a "small" index, then the caller has given too
    .          .          .          .                           // many groups for a particular pattern.
    .          .          .          .                           let group = SmallIndex::new(group_index).map_err(|_| {
    .          .          .          .                               GroupInfoError::too_many_groups(pid, group_index)
    .          .          .          .                           })?;
    .          .          .          .                           group_info.add_explicit_group(pid, group, maybe_name)?;
    .          .          .          .                       }
    .          .          .          .                   }
  175 ( 0.00%) .          .          .                   group_info.fixup_slot_ranges()?;
4,232 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/captures.rs:regex_automata::util::captures::GroupInfoInner::fixup_slot_ranges (175x)
2,275 ( 0.00%) .          .          .                   Ok(GroupInfo(Arc::new(group_info)))
1,400 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// This creates an empty `GroupInfo`.
    .          .          .          .               ///
    .          .          .          .               /// This is a convenience routine for calling `GroupInfo::new` with an
    .          .          .          .               /// iterator that yields no elements.
    .          .          .          .               ///
    .          .          .          .               /// # Example
    .          .          .          .               ///
-- line 1618 ----------------------------------------
-- line 1897 ----------------------------------------
    .          .          .          .               ///     nfa.group_info().slot(PatternID::must(0), 0),
    .          .          .          .               ///     nfa.group_info().slot(PatternID::must(1), 0),
    .          .          .          .               /// );
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn slot(&self, pid: PatternID, group_index: usize) -> Option<usize> {
3,096 ( 0.00%) .          .          .                   if group_index >= self.group_len(pid) {
    .          .          .          .                       return None;
    .          .          .          .                   }
    .          .          .          .                   // At this point, we know that 'pid' refers to a real pattern and that
    .          .          .          .                   // 'group_index' refers to a real group. We therefore also know that
    .          .          .          .                   // the pattern and group can be combined to return a correct slot.
    .          .          .          .                   // That's why we don't need to use checked arithmetic below.
6,192 ( 0.00%) .          .          .                   if group_index == 0 {
    .          .          .          .                       Some(pid.as_usize() * 2)
    .          .          .          .                   } else {
    .          .          .          .                       // As above, we don't need to check that our slot is less than the
    .          .          .          .                       // end of our range since we already know the group index is a
    .          .          .          .                       // valid index for the given pattern.
    .          .          .          .                       let (start, _) = self.0.slot_ranges[pid];
    .          .          .          .                       Some(start.as_usize() + ((group_index - 1) * 2))
    .          .          .          .                   }
-- line 1920 ----------------------------------------
-- line 2092 ----------------------------------------
    .          .          .          .               /// assert_eq!(2, info.implicit_slot_len());
    .          .          .          .               /// // 2 explicit capturing groups gives us 2*2=4 explicit slots.
    .          .          .          .               /// assert_eq!(4, info.explicit_slot_len());
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn implicit_slot_len(&self) -> usize {
  152 ( 0.00%) .          .          .                   self.pattern_len() * 2
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the total number of slots for explicit capturing groups.
    .          .          .          .               ///
    .          .          .          .               /// This is like [`GroupInfo::slot_len`], except it doesn't include the
    .          .          .          .               /// implicit slots for each pattern. (There are always 2 implicit slots for
    .          .          .          .               /// each pattern.)
    .          .          .          .               ///
-- line 2108 ----------------------------------------
-- line 2184 ----------------------------------------
    .          .          .          .               /// This adds the first unnamed group for the given pattern ID. The given
    .          .          .          .               /// pattern ID must be zero if this is the first time this method is
    .          .          .          .               /// called, or must be exactly one more than the pattern ID supplied to the
    .          .          .          .               /// previous call to this method. (This method panics if this rule is
    .          .          .          .               /// violated.)
    .          .          .          .               ///
    .          .          .          .               /// This can be thought of as initializing the GroupInfo state for the
    .          .          .          .               /// given pattern and closing off the state for any previous pattern.
  405 ( 0.00%) .          .          .               fn add_first_group(&mut self, pid: PatternID) {
  162 ( 0.00%) .          .          .                   assert_eq!(pid.as_usize(), self.slot_ranges.len());
  162 ( 0.00%) .          .          .                   assert_eq!(pid.as_usize(), self.name_to_index.len());
  162 ( 0.00%) .          .          .                   assert_eq!(pid.as_usize(), self.index_to_name.len());
    .          .          .          .                   // This is the start of our slots for the explicit capturing groups.
    .          .          .          .                   // Note that since the slots for the 0th group for every pattern appear
    .          .          .          .                   // before any slots for the nth group (where n > 0) in any pattern, we
    .          .          .          .                   // will have to fix up the slot ranges once we know how many patterns
    .          .          .          .                   // we've added capture groups for.
    .          .          .          .                   let slot_start = self.small_slot_len();
    .          .          .          .                   self.slot_ranges.push((slot_start, slot_start));
    .          .          .          .                   self.name_to_index.push(CaptureNameMap::new());
  162 ( 0.00%) .          .          .                   self.index_to_name.push(vec![None]);
    .          .          .          .                   self.memory_extra += core::mem::size_of::<Option<Arc<str>>>();
  405 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Add an explicit capturing group for the given pattern with the given
    .          .          .          .               /// index. If the group has a name, then that must be given as well.
    .          .          .          .               ///
    .          .          .          .               /// Note that every capturing group except for the first or zeroth group is
    .          .          .          .               /// explicit.
    .          .          .          .               ///
    .          .          .          .               /// This returns an error if adding this group would result in overflowing
-- line 2214 ----------------------------------------
-- line 2222 ----------------------------------------
    .          .          .          .               ) -> Result<(), GroupInfoError> {
    .          .          .          .                   // We also need to check that the slot index generated for
    .          .          .          .                   // this group is also valid. Although, this is a little weird
    .          .          .          .                   // because we offset these indices below, at which point, we'll
    .          .          .          .                   // have to recheck them. Gosh this is annoying. Note that
    .          .          .          .                   // the '+2' below is OK because 'end' is guaranteed to be less
    .          .          .          .                   // than isize::MAX.
    .          .          .          .                   let end = &mut self.slot_ranges[pid].1;
2,079 ( 0.00%) .          .          .                   *end = SmallIndex::new(end.as_usize() + 2).map_err(|_| {
    .          .          .          .                       GroupInfoError::too_many_groups(pid, group.as_usize())
    .          .          .          .                   })?;
  693 ( 0.00%) .          .          .                   if let Some(name) = maybe_name {
2,344 ( 0.00%) .          .          .                       let name = Arc::<str>::from(name.as_ref());
    .          .          .          .                       if self.name_to_index[pid].contains_key(&*name) {
    .          .          .          .                           return Err(GroupInfoError::duplicate(pid, &name));
    .          .          .          .                       }
    .          .          .          .                       let len = name.len();
    .          .          .          .                       self.name_to_index[pid].insert(Arc::clone(&name), group);
1,172 ( 0.00%) .          .          .                       self.index_to_name[pid].push(Some(name));
    .          .          .          .                       // Adds the memory used by the Arc<str> in both maps.
  586 ( 0.00%) .          .          .                       self.memory_extra +=
    .          .          .          .                           2 * (len + core::mem::size_of::<Option<Arc<str>>>());
    .          .          .          .                       // And also the value entry for the 'name_to_index' map.
    .          .          .          .                       // This is probably an underestimate for 'name_to_index' since
    .          .          .          .                       // hashmaps/btrees likely have some non-zero overhead, but we
    .          .          .          .                       // assume here that they have zero overhead.
2,344 ( 0.00%) .          .          .                       self.memory_extra += core::mem::size_of::<SmallIndex>();
    .          .          .          .                   } else {
    .          .          .          .                       self.index_to_name[pid].push(None);
  214 ( 0.00%) .          .          .                       self.memory_extra += core::mem::size_of::<Option<Arc<str>>>();
    .          .          .          .                   }
    .          .          .          .                   // This is a sanity assert that checks that our group index
    .          .          .          .                   // is in line with the number of groups added so far for this
    .          .          .          .                   // pattern.
2,079 ( 0.00%) .          .          .                   assert_eq!(group.one_more(), self.group_len(pid));
    .          .          .          .                   // And is also in line with the 'index_to_name' map.
1,386 ( 0.00%) .          .          .                   assert_eq!(group.one_more(), self.index_to_name[pid].len());
    .          .          .          .                   Ok(())
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// This corrects the slot ranges to account for the slots corresponding
    .          .          .          .               /// to the zeroth group of each pattern. That is, every slot range is
    .          .          .          .               /// offset by 'pattern_len() * 2', since each pattern uses two slots to
    .          .          .          .               /// represent the zeroth group.
  350 ( 0.00%) .          .          .               fn fixup_slot_ranges(&mut self) -> Result<(), GroupInfoError> {
    .          .          .          .                   use crate::util::primitives::IteratorIndexExt;
    .          .          .          .                   // Since we know number of patterns fits in PatternID and
    .          .          .          .                   // PatternID::MAX < isize::MAX, it follows that multiplying by 2 will
    .          .          .          .                   // never overflow usize.
    .          .          .          .                   let offset = self.pattern_len().checked_mul(2).unwrap();
    .          .          .          .                   for (pid, &mut (ref mut start, ref mut end)) in
    .          .          .          .                       self.slot_ranges.iter_mut().with_pattern_ids()
    .          .          .          .                   {
    .          .          .          .                       let group_len = 1 + ((end.as_usize() - start.as_usize()) / 2);
   81 ( 0.00%) .          .          .                       let new_end = match end.as_usize().checked_add(offset) {
    .          .          .          .                           Some(new_end) => new_end,
    .          .          .          .                           None => {
    .          .          .          .                               return Err(GroupInfoError::too_many_groups(
    .          .          .          .                                   pid, group_len,
    .          .          .          .                               ))
    .          .          .          .                           }
    .          .          .          .                       };
   81 ( 0.00%) .          .          .                       *end = SmallIndex::new(new_end).map_err(|_| {
    .          .          .          .                           GroupInfoError::too_many_groups(pid, group_len)
    .          .          .          .                       })?;
    .          .          .          .                       // Since start <= end, if end is valid then start must be too.
  162 ( 0.00%) .          .          .                       *start = SmallIndex::new(start.as_usize() + offset).unwrap();
    .          .          .          .                   }
  175 ( 0.00%) .          .          .                   Ok(())
  700 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Return the total number of patterns represented by this capture slot
    .          .          .          .               /// info.
    .          .          .          .               fn pattern_len(&self) -> usize {
    .          .          .          .                   self.slot_ranges.len()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Return the total number of capturing groups for the given pattern. If
    .          .          .          .               /// the given pattern isn't valid for this capture slot info, then 0 is
    .          .          .          .               /// returned.
    .          .          .          .               fn group_len(&self, pid: PatternID) -> usize {
2,241 ( 0.00%) .          .          .                   let (start, end) = match self.slot_ranges.get(pid.as_usize()) {
    .          .          .          .                       None => return 0,
    .          .          .          .                       Some(range) => range,
    .          .          .          .                   };
    .          .          .          .                   // The difference between any two SmallIndex values always fits in a
    .          .          .          .                   // usize since we know that SmallIndex::MAX <= isize::MAX-1. We also
    .          .          .          .                   // know that start<=end by construction and that the number of groups
    .          .          .          .                   // never exceeds SmallIndex and thus never overflows usize.
5,175 ( 0.00%) .          .          .                   1 + ((end.as_usize() - start.as_usize()) / 2)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Return the total number of slots in this capture slot info as a
    .          .          .          .               /// "small index."
    .          .          .          .               fn small_slot_len(&self) -> SmallIndex {
    .          .          .          .                   // Since slots are allocated in order of pattern (starting at 0) and
    .          .          .          .                   // then in order of capture group, it follows that the number of slots
    .          .          .          .                   // is the end of the range of slots for the last pattern. This is
-- line 2319 ----------------------------------------

3,065 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/captures.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 45 ----------------------------------------
     .          .          .          .           /// The idea here is that the prefilter returned can be used to find candidate
     .          .          .          .           /// matches. And then the HIR returned can be used to build a reverse regex
     .          .          .          .           /// matcher, which will find the start of the candidate match. Finally, the
     .          .          .          .           /// match still has to be confirmed with a normal anchored forward scan to find
     .          .          .          .           /// the end position of the match.
     .          .          .          .           ///
     .          .          .          .           /// Note that this assumes leftmost-first match semantics, so callers must
     .          .          .          .           /// not call this otherwise.
   104 ( 0.00%) .          .          .           pub(crate) fn extract(hirs: &[&Hir]) -> Option<(Hir, Prefilter)> {
    26 ( 0.00%) .          .          .               if hirs.len() != 1 {
     .          .          .          .                   debug!(
     .          .          .          .                       "skipping reverse inner optimization since it only \
     .          .          .          .           		 	 supports 1 pattern, {} were given",
     .          .          .          .                       hirs.len(),
     .          .          .          .                   );
     .          .          .          .                   return None;
     .          .          .          .               }
    26 ( 0.00%) .          .          .               let mut concat = match top_concat(hirs[0]) {
     .          .          .          .                   Some(concat) => concat,
     .          .          .          .                   None => {
     .          .          .          .                       debug!(
     .          .          .          .                           "skipping reverse inner optimization because a top-level \
     .          .          .          .           		 	     concatenation could not found",
     .          .          .          .                       );
     .          .          .          .                       return None;
     .          .          .          .                   }
     .          .          .          .               };
     .          .          .          .               // We skip the first HIR because if it did have a prefix prefilter in it,
     .          .          .          .               // we probably wouldn't be here looking for an inner prefilter.
     .          .          .          .               for i in 1..concat.len() {
     .          .          .          .                   let hir = &concat[i];
   186 ( 0.00%) .          .          .                   let pre = match prefilter(hir) {
15,622,303 ( 4.50%) 21,839 ( 2.70%) 12 ( 3.70%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::prefilter (31x)
     .          .          .          .                       None => continue,
    88 ( 0.00%) .          .          .                       Some(pre) => pre,
     .          .          .          .                   };
     .          .          .          .                   // Even if we got a prefilter, if it isn't consider "fast," then we
     .          .          .          .                   // probably don't want to bother with it. Namely, since the reverse
     .          .          .          .                   // inner optimization requires some overhead, it likely only makes
     .          .          .          .                   // sense if the prefilter scan itself is (believed) to be much faster
     .          .          .          .                   // than the regex engine.
    22 ( 0.00%) .          .          .                   if !pre.is_fast() {
     .          .          .          .                       debug!(
     .          .          .          .                           "skipping extracted inner prefilter because \
     .          .          .          .           				 it probably isn't fast"
     .          .          .          .                       );
     .          .          .          .                       continue;
     .          .          .          .                   }
    52 ( 0.00%) .          .          .                   let concat_suffix = Hir::concat(concat.split_off(i));
110,290 ( 0.03%) 101 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (13x)
   104 ( 0.00%) .          .          .                   let concat_prefix = Hir::concat(concat);
17,682 ( 0.01%) 26 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (13x)
     .          .          .          .                   // Look for a prefilter again. Why? Because above we only looked for
     .          .          .          .                   // a prefilter on the individual 'hir', but we might be able to find
     .          .          .          .                   // something better and more discriminatory by looking at the entire
     .          .          .          .                   // suffix. We don't do this above to avoid making this loop worst case
     .          .          .          .                   // quadratic in the length of 'concat'.
    52 ( 0.00%) .          .          .                   let pre2 = match prefilter(&concat_suffix) {
11,705,462 ( 3.37%) 21,454 ( 2.65%) 8 ( 2.47%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::prefilter (13x)
     .          .          .          .                       None => pre,
    52 ( 0.00%) .          .          .                       Some(pre2) => {
    13 ( 0.00%) .          .          .                           if pre2.is_fast() {
    65 ( 0.00%) .          .          .                               pre2
     .          .          .          .                           } else {
     .          .          .          .                               pre
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   };
   195 ( 0.00%) .          .          .                   return Some((concat_prefix, pre2));
    26 ( 0.00%) .          .          .               }
     .          .          .          .               debug!(
     .          .          .          .                   "skipping reverse inner optimization because a top-level \
     .          .          .          .           	     sub-expression with a fast prefilter could not be found"
     .          .          .          .               );
     .          .          .          .               None
   117 ( 0.00%) .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Attempt to extract a prefilter from an HIR expression.
     .          .          .          .           ///
     .          .          .          .           /// We do a little massaging here to do our best that the prefilter we get out
     .          .          .          .           /// of this is *probably* fast. Basically, the false positive rate has a much
     .          .          .          .           /// higher impact for things like the reverse inner optimization because more
     .          .          .          .           /// work needs to potentially be done for each candidate match.
     .          .          .          .           ///
     .          .          .          .           /// Note that this assumes leftmost-first match semantics, so callers must
     .          .          .          .           /// not call this otherwise.
   528 ( 0.00%) .          .          .           fn prefilter(hir: &Hir) -> Option<Prefilter> {
    88 ( 0.00%) .          .          .               let mut extractor = literal::Extractor::new();
   308 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::new (44x)
   176 ( 0.00%) .          .          .               extractor.kind(literal::ExtractKind::Prefix);
   132 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::kind (44x)
   132 ( 0.00%) .          .          .               let mut prefixes = extractor.extract(hir);
3,352,826 ( 0.96%) 6,688 ( 0.83%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract (44x)
     .          .          .          .               debug!(
     .          .          .          .                   "inner prefixes (len={:?}) extracted before optimization: {:?}",
     .          .          .          .                   prefixes.len(),
     .          .          .          .                   prefixes
     .          .          .          .               );
     .          .          .          .               // Since these are inner literals, we know they cannot be exact. But the
     .          .          .          .               // extractor doesn't know this. We mark them as inexact because this might
     .          .          .          .               // impact literal optimization. Namely, optimization weights "all literals
     .          .          .          .               // are exact" as very high, because it presumes that any match results in
     .          .          .          .               // an overall match. But of course, that is not the case here.
     .          .          .          .               //
     .          .          .          .               // In practice, this avoids plucking out a ASCII-only \s as an alternation
     .          .          .          .               // of single-byte whitespace characters.
    88 ( 0.00%) .          .          .               prefixes.make_inexact();
     .          .          .          .               prefixes.optimize_for_prefix_by_preference();
     .          .          .          .               debug!(
     .          .          .          .                   "inner prefixes (len={:?}) extracted after optimization: {:?}",
     .          .          .          .                   prefixes.len(),
     .          .          .          .                   prefixes
     .          .          .          .               );
     .          .          .          .               prefixes
     .          .          .          .                   .literals()
     .          .          .          .                   .and_then(|lits| Prefilter::new(MatchKind::LeftmostFirst, lits))
   352 ( 0.00%) .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Looks for a "top level" HirKind::Concat item in the given HIR. This will
     .          .          .          .           /// try to return one even if it's embedded in a capturing group, but is
     .          .          .          .           /// otherwise pretty conservative in what is returned.
     .          .          .          .           ///
     .          .          .          .           /// The HIR returned is a complete copy of the concat with all capturing
     .          .          .          .           /// groups removed. In effect, the concat returned is "flattened" with respect
     .          .          .          .           /// to capturing groups. This makes the detection logic above for prefixes
     .          .          .          .           /// a bit simpler, and it works because 1) capturing groups never influence
     .          .          .          .           /// whether a match occurs or not and 2) capturing groups are not used when
     .          .          .          .           /// doing the reverse inner search to find the start of the match.
     .          .          .          .           fn top_concat(mut hir: &Hir) -> Option<Vec<Hir>> {
     .          .          .          .               loop {
   130 ( 0.00%) .          .          .                   hir = match hir.kind() {
    26 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::kind (13x)
     .          .          .          .                       HirKind::Empty
     .          .          .          .                       | HirKind::Literal(_)
     .          .          .          .                       | HirKind::Class(_)
     .          .          .          .                       | HirKind::Look(_)
     .          .          .          .                       | HirKind::Repetition(_)
     .          .          .          .                       | HirKind::Alternation(_) => return None,
     .          .          .          .                       HirKind::Capture(hir::Capture { ref sub, .. }) => sub,
     .          .          .          .                       HirKind::Concat(ref subs) => {
     .          .          .          .                           // We are careful to only do the flattening/copy when we know
     .          .          .          .                           // we have a "top level" concat we can inspect. This avoids
     .          .          .          .                           // doing extra work in cases where we definitely won't use it.
     .          .          .          .                           // (This might still be wasted work if we can't go on to find
     .          .          .          .                           // some literals to extract.)
     .          .          .          .                           let concat =
   438 ( 0.00%) .          .          .                               Hir::concat(subs.iter().map(|h| flatten(h)).collect());
2,540,387 ( 0.73%) 8,008 ( 0.99%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten (193x)
127,542 ( 0.04%) 112 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (13x)
    52 ( 0.00%) .          .          .                           return match concat.into_kind() {
 2,280 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::into_kind (13x)
    26 ( 0.00%) .          .          .                               HirKind::Concat(xs) => Some(xs),
     .          .          .          .                               // It is actually possible for this case to occur, because
     .          .          .          .                               // 'Hir::concat' might simplify the expression to the point
     .          .          .          .                               // that concatenations are actually removed. One wonders
     .          .          .          .                               // whether this leads to other cases where we should be
     .          .          .          .                               // extracting literals, but in theory, I believe if we do
     .          .          .          .                               // get here, then it means that a "real" prefilter failed
     .          .          .          .                               // to be extracted and we should probably leave well enough
     .          .          .          .                               // alone. (A "real" prefilter is unbothered by "top-level
-- line 193 ----------------------------------------
-- line 195 ----------------------------------------
     .          .          .          .                               _ => return None,
     .          .          .          .                           };
     .          .          .          .                       }
     .          .          .          .                   };
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Returns a copy of the given HIR but with all capturing groups removed.
24,350 ( 0.01%) .          .          .           fn flatten(hir: &Hir) -> Hir {
22,887 ( 0.01%) .          .          .               match hir.kind() {
   568 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::kind (284x)
     .          .          .          .                   HirKind::Empty => Hir::empty(),
     .          .          .          .                   HirKind::Literal(hir::Literal(ref x)) => Hir::literal(x.clone()),
     .          .          .          .                   HirKind::Class(ref x) => Hir::class(x.clone()),
     .          .          .          .                   HirKind::Look(ref x) => Hir::look(x.clone()),
 1,490 ( 0.00%) .          .          .                   HirKind::Repetition(ref x) => Hir::repetition(x.with(flatten(&x.sub))),
91,613 ( 0.03%) 246 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (75x)
10,539 ( 0.00%) 34 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Repetition::with (75x)
     .          .          .          .                   // This is the interesting case. We just drop the group information
     .          .          .          .                   // entirely and use the child HIR itself.
   216 ( 0.00%) .          .          .                   HirKind::Capture(hir::Capture { ref sub, .. }) => flatten(sub),
     .          .          .          .                   HirKind::Alternation(ref xs) => {
 3,962 ( 0.00%) .          .          .                       Hir::alternation(xs.iter().map(|x| flatten(x)).collect())
1,110,787 ( 0.32%) 5,362 ( 0.66%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (1,446x)
582,137 ( 0.17%) 250 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (55x)
     .          .          .          .                   }
     .          .          .          .                   HirKind::Concat(ref xs) => {
   940 ( 0.00%) .          .          .                       Hir::concat(xs.iter().map(|x| flatten(x)).collect())
461,963 ( 0.13%) 1,666 ( 0.21%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (68x)
47,535 ( 0.01%) 76 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (29x)
     .          .          .          .                   }
     .          .          .          .               }
21,915 ( 0.01%) .          .          .           }

10,133 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

      .          .          .          .           use crate::util::int::Usize;
      .          .          .          .           
      .          .          .          .           /// A representation of byte oriented equivalence classes.
      .          .          .          .           ///
      .          .          .          .           /// This is used in finite state machines to reduce the size of the transition
      .          .          .          .           /// table. This can have a particularly large impact not only on the total size
      .          .          .          .           /// of an FSM, but also on FSM build times because it reduces the number of
      .          .          .          .           /// transitions that need to be visited/set.
  1,632 ( 0.00%) .          .          .           #[derive(Clone, Copy)]
      .          .          .          .           pub(crate) struct ByteClasses([u8; 256]);
      .          .          .          .           
      .          .          .          .           impl ByteClasses {
      .          .          .          .               /// Creates a new set of equivalence classes where all bytes are mapped to
      .          .          .          .               /// the same class.
      .          .          .          .               pub(crate) fn empty() -> ByteClasses {
      .          .          .          .                   ByteClasses([0; 256])
      .          .          .          .               }
-- line 17 ----------------------------------------
-- line 18 ----------------------------------------
      .          .          .          .           
      .          .          .          .               /// Creates a new set of equivalence classes where each byte belongs to
      .          .          .          .               /// its own equivalence class.
      .          .          .          .               pub(crate) fn singletons() -> ByteClasses {
      .          .          .          .                   let mut classes = ByteClasses::empty();
      .          .          .          .                   for b in 0..=255 {
      .          .          .          .                       classes.set(b, b);
      .          .          .          .                   }
  1,536 ( 0.00%) .          .          .                   classes
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the equivalence class for the given byte.
      .          .          .          .               #[inline]
      .          .          .          .               pub(crate) fn set(&mut self, byte: u8, class: u8) {
 13,296 ( 0.00%) .          .          .                   self.0[usize::from(byte)] = class;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Get the equivalence class for the given byte.
      .          .          .          .               #[inline]
      .          .          .          .               pub(crate) fn get(&self, byte: u8) -> u8 {
694,406 ( 0.20%) .          .          .                   self.0[usize::from(byte)]
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the total number of elements in the alphabet represented by
      .          .          .          .               /// these equivalence classes. Equivalently, this returns the total number
      .          .          .          .               /// of equivalence classes.
      .          .          .          .               #[inline]
      .          .          .          .               pub(crate) fn alphabet_len(&self) -> usize {
      .          .          .          .                   // Add one since the number of equivalence classes is one bigger than
      .          .          .          .                   // the last one.
  4,876 ( 0.00%) .          .          .                   usize::from(self.0[255]) + 1
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the stride, as a base-2 exponent, required for these
      .          .          .          .               /// equivalence classes.
      .          .          .          .               ///
      .          .          .          .               /// The stride is always the smallest power of 2 that is greater than or
      .          .          .          .               /// equal to the alphabet length. This is done so that converting between
      .          .          .          .               /// state IDs and indices can be done with shifts alone, which is much
-- line 56 ----------------------------------------
-- line 60 ----------------------------------------
      .          .          .          .                   let zeros = self.alphabet_len().next_power_of_two().trailing_zeros();
      .          .          .          .                   usize::try_from(zeros).unwrap()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the stride for these equivalence classes, which corresponds
      .          .          .          .               /// to the smallest power of 2 greater than or equal to the number of
      .          .          .          .               /// equivalence classes.
      .          .          .          .               pub(crate) fn stride(&self) -> usize {
    192 ( 0.00%) .          .          .                   1 << self.stride2()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if every byte in this class maps to its own
      .          .          .          .               /// equivalence class. Equivalently, there are 257 equivalence classes
      .          .          .          .               /// and each class contains exactly one byte (plus the special EOI class).
      .          .          .          .               #[inline]
      .          .          .          .               pub(crate) fn is_singleton(&self) -> bool {
      .          .          .          .                   self.alphabet_len() == 256
-- line 76 ----------------------------------------
-- line 211 ----------------------------------------
      .          .          .          .                   ByteClassSet::empty()
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ByteClassSet {
      .          .          .          .               /// Create a new set of byte classes where all bytes are part of the same
      .          .          .          .               /// equivalence class.
      .          .          .          .               pub(crate) fn empty() -> Self {
     96 ( 0.00%) .          .          .                   ByteClassSet(ByteSet::empty())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Indicate the the range of byte given (inclusive) can discriminate a
      .          .          .          .               /// match between it and all other bytes outside of the range.
  3,680 ( 0.00%) .          .          .               pub(crate) fn set_range(&mut self, start: u8, end: u8) {
      .          .          .          .                   debug_assert!(start <= end);
  7,360 ( 0.00%) .          .          .                   if start > 0 {
  3,680 ( 0.00%) .          .          .                       self.0.add(start - 1);
      .          .          .          .                   }
      .          .          .          .                   self.0.add(end);
  3,680 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Convert this boolean set to a map that maps all byte values to their
      .          .          .          .               /// corresponding equivalence class. The last mapping indicates the largest
      .          .          .          .               /// equivalence class identifier (which is never bigger than 255).
    144 ( 0.00%) .          .          .               pub(crate) fn byte_classes(&self) -> ByteClasses {
      .          .          .          .                   let mut classes = ByteClasses::empty();
      .          .          .          .                   let mut class = 0u8;
      .          .          .          .                   let mut b = 0u8;
      .          .          .          .                   loop {
      .          .          .          .                       classes.set(b, class);
 24,480 ( 0.01%) .          .          .                       if b == 255 {
      .          .          .          .                           break;
      .          .          .          .                       }
 12,240 ( 0.00%) .          .          .                       if self.0.contains(b) {
      .          .          .          .                           class = class.checked_add(1).unwrap();
      .          .          .          .                       }
      .          .          .          .                       b = b.checked_add(1).unwrap();
      .          .          .          .                   }
    144 ( 0.00%) .          .          .                   classes
  1,440 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x)
    192 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A simple set of bytes that is reasonably cheap to copy and allocation free.
      .          .          .          .           #[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
      .          .          .          .           pub(crate) struct ByteSet {
      .          .          .          .               bits: BitSet,
      .          .          .          .           }
      .          .          .          .           
-- line 258 ----------------------------------------
-- line 266 ----------------------------------------
      .          .          .          .               pub(crate) fn empty() -> ByteSet {
      .          .          .          .                   ByteSet { bits: BitSet([0; 2]) }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add a byte to this set.
      .          .          .          .               ///
      .          .          .          .               /// If the given byte already belongs to this set, then this is a no-op.
      .          .          .          .               pub(crate) fn add(&mut self, byte: u8) {
 11,040 ( 0.00%) .          .          .                   let bucket = byte / 128;
      .          .          .          .                   let bit = byte % 128;
 73,600 ( 0.02%) .          .          .                   self.bits.0[usize::from(bucket)] |= 1 << bit;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return true if and only if the given byte is in this set.
      .          .          .          .               pub(crate) fn contains(&self, byte: u8) -> bool {
 49,056 ( 0.01%) .          .          .                   let bucket = byte / 128;
      .          .          .          .                   let bit = byte % 128;
269,808 ( 0.08%) .          .          .                   self.bits.0[usize::from(bucket)] & (1 << bit) > 0
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl core::fmt::Debug for BitSet {
      .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      .          .          .          .                   let mut fmtd = f.debug_set();
      .          .          .          .                   for b in 0u8..=255 {
      .          .          .          .                       if (ByteSet { bits: *self }).contains(b) {
-- line 291 ----------------------------------------

  7,504 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 309 ----------------------------------------
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Span represents the position information of a single AST item.
      .          .          .          .           ///
      .          .          .          .           /// All span positions are absolute byte offsets that can be used on the
      .          .          .          .           /// original regular expression that was parsed.
  4,688 ( 0.00%) .          .          .           #[derive(Clone, Copy, Eq, PartialEq)]
      .          .          .          .           #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
      .          .          .          .           pub struct Span {
      .          .          .          .               /// The start byte offset.
      .          .          .          .               pub start: Position,
      .          .          .          .               /// The end byte offset.
      .          .          .          .               pub end: Position,
      .          .          .          .           }
      .          .          .          .           
-- line 325 ----------------------------------------
-- line 340 ----------------------------------------
      .          .          .          .                   Some(self.cmp(other))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A single position in a regular expression.
      .          .          .          .           ///
      .          .          .          .           /// A position encodes one half of a span, and include the byte offset, line
      .          .          .          .           /// number and column number.
  6,260 ( 0.00%) .          .          .           #[derive(Clone, Copy, Eq, PartialEq)]
      .          .          .          .           #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
      .          .          .          .           pub struct Position {
      .          .          .          .               /// The absolute offset of this position, starting at `0` from the
      .          .          .          .               /// beginning of the regular expression pattern string.
      .          .          .          .               pub offset: usize,
      .          .          .          .               /// The line number, starting at `1`.
      .          .          .          .               pub line: usize,
      .          .          .          .               /// The approximate column number, starting at `1`.
-- line 356 ----------------------------------------
-- line 377 ----------------------------------------
      .          .          .          .               fn partial_cmp(&self, other: &Position) -> Option<Ordering> {
      .          .          .          .                   Some(self.cmp(other))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Span {
      .          .          .          .               /// Create a new span with the given positions.
      .          .          .          .               pub fn new(start: Position, end: Position) -> Span {
195,205 ( 0.06%) .          .          .                   Span { start, end }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new span using the given position as the start and end.
      .          .          .          .               pub fn splat(pos: Position) -> Span {
 92,683 ( 0.03%) .          .          .                   Span::new(pos, pos)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new span by replacing the starting the position with the one
      .          .          .          .               /// given.
      .          .          .          .               pub fn with_start(self, pos: Position) -> Span {
      .          .          .          .                   Span { start: pos, ..self }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new span by replacing the ending the position with the one
      .          .          .          .               /// given.
      .          .          .          .               pub fn with_end(self, pos: Position) -> Span {
  7,540 ( 0.00%) .          .          .                   Span { end: pos, ..self }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this span occurs on a single line.
      .          .          .          .               pub fn is_one_line(&self) -> bool {
      .          .          .          .                   self.start.line == self.end.line
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this span is empty. That is, it points to
-- line 410 ----------------------------------------
-- line 492 ----------------------------------------
      .          .          .          .               /// An alternation of regular expressions.
      .          .          .          .               Alternation(Box<Alternation>),
      .          .          .          .               /// A concatenation of regular expressions.
      .          .          .          .               Concat(Box<Concat>),
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Ast {
      .          .          .          .               /// Create an "empty" AST item.
  1,386 ( 0.00%) .          .          .               pub fn empty(span: Span) -> Ast {
      .          .          .          .                   Ast::Empty(Box::new(span))
  2,079 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a "flags" AST item.
      .          .          .          .               pub fn flags(e: SetFlags) -> Ast {
      .          .          .          .                   Ast::Flags(Box::new(e))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a "literal" AST item.
      .          .          .          .               pub fn literal(e: Literal) -> Ast {
-- line 510 ----------------------------------------
-- line 532 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a "bracketed class" AST item.
      .          .          .          .               pub fn class_bracketed(e: ClassBracketed) -> Ast {
      .          .          .          .                   Ast::ClassBracketed(Box::new(e))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a "repetition" AST item.
    344 ( 0.00%) .          .          .               pub fn repetition(e: Repetition) -> Ast {
      .          .          .          .                   Ast::Repetition(Box::new(e))
    516 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a "group" AST item.
      .          .          .          .               pub fn group(e: Group) -> Ast {
      .          .          .          .                   Ast::Group(Box::new(e))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a "alternation" AST item.
      .          .          .          .               pub fn alternation(e: Alternation) -> Ast {
-- line 550 ----------------------------------------
-- line 553 ----------------------------------------
      .          .          .          .           
      .          .          .          .               /// Create a "concat" AST item.
      .          .          .          .               pub fn concat(e: Concat) -> Ast {
      .          .          .          .                   Ast::Concat(Box::new(e))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the span of this abstract syntax tree.
      .          .          .          .               pub fn span(&self) -> &Span {
 12,851 ( 0.00%) .          .          .                   match *self {
      .          .          .          .                       Ast::Empty(ref span) => span,
      .          .          .          .                       Ast::Flags(ref x) => &x.span,
      .          .          .          .                       Ast::Literal(ref x) => &x.span,
      .          .          .          .                       Ast::Dot(ref span) => span,
      .          .          .          .                       Ast::Assertion(ref x) => &x.span,
      .          .          .          .                       Ast::ClassUnicode(ref x) => &x.span,
      .          .          .          .                       Ast::ClassPerl(ref x) => &x.span,
      .          .          .          .                       Ast::ClassBracketed(ref x) => &x.span,
      .          .          .          .                       Ast::Repetition(ref x) => &x.span,
      1 ( 0.00%) .          .          .                       Ast::Group(ref x) => &x.span,
      .          .          .          .                       Ast::Alternation(ref x) => &x.span,
      .          .          .          .                       Ast::Concat(ref x) => &x.span,
      .          .          .          .                   }
    172 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return true if and only if this Ast is empty.
      .          .          .          .               pub fn is_empty(&self) -> bool {
      .          .          .          .                   match *self {
      .          .          .          .                       Ast::Empty(_) => true,
      .          .          .          .                       _ => false,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this AST has any (including possibly empty)
      .          .          .          .               /// subexpressions.
      .          .          .          .               fn has_subexprs(&self) -> bool {
  2,578 ( 0.00%) .          .          .                   match *self {
      .          .          .          .                       Ast::Empty(_)
      .          .          .          .                       | Ast::Flags(_)
      .          .          .          .                       | Ast::Literal(_)
      .          .          .          .                       | Ast::Dot(_)
      .          .          .          .                       | Ast::Assertion(_)
      .          .          .          .                       | Ast::ClassUnicode(_)
      .          .          .          .                       | Ast::ClassPerl(_) => false,
      .          .          .          .                       Ast::ClassBracketed(_)
-- line 596 ----------------------------------------
-- line 628 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Alternation {
      .          .          .          .               /// Return this alternation as an AST.
      .          .          .          .               ///
      .          .          .          .               /// If this alternation contains zero ASTs, then `Ast::empty` is returned.
      .          .          .          .               /// If this alternation contains exactly 1 AST, then the corresponding AST
      .          .          .          .               /// is returned. Otherwise, `Ast::alternation` is returned.
  2,048 ( 0.00%) .          .          .               pub fn into_ast(mut self) -> Ast {
  2,048 ( 0.00%) .          .          .                   match self.asts.len() {
      .          .          .          .                       0 => Ast::empty(self.span),
      .          .          .          .                       1 => self.asts.pop().unwrap(),
      .          .          .          .                       _ => Ast::alternation(self),
      .          .          .          .                   }
  3,072 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A concatenation of regular expressions.
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
      .          .          .          .           pub struct Concat {
      .          .          .          .               /// The span of this concatenation.
      .          .          .          .               pub span: Span,
-- line 650 ----------------------------------------
-- line 653 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Concat {
      .          .          .          .               /// Return this concatenation as an AST.
      .          .          .          .               ///
      .          .          .          .               /// If this alternation contains zero ASTs, then `Ast::empty` is returned.
      .          .          .          .               /// If this alternation contains exactly 1 AST, then the corresponding AST
      .          .          .          .               /// is returned. Otherwise, `Ast::concat` is returned.
 66,812 ( 0.02%) .          .          .               pub fn into_ast(mut self) -> Ast {
 66,812 ( 0.02%) .          .          .                   match self.asts.len() {
      .          .          .          .                       0 => Ast::empty(self.span),
      .          .          .          .                       1 => self.asts.pop().unwrap(),
      .          .          .          .                       _ => Ast::concat(self),
      .          .          .          .                   }
100,218 ( 0.03%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A single literal expression.
      .          .          .          .           ///
      .          .          .          .           /// A literal corresponds to a single Unicode scalar value. Literals may be
      .          .          .          .           /// represented in their literal form, e.g., `a` or in their escaped form,
      .          .          .          .           /// e.g., `\x61`.
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
-- line 675 ----------------------------------------
-- line 857 ----------------------------------------
      .          .          .          .               /// The name given should correspond to the lowercase version of the
      .          .          .          .               /// variant name. e.g., `cntrl` is the name for `ClassAsciiKind::Cntrl`.
      .          .          .          .               ///
      .          .          .          .               /// If no variant with the corresponding name exists, then `None` is
      .          .          .          .               /// returned.
      .          .          .          .               pub fn from_name(name: &str) -> Option<ClassAsciiKind> {
      .          .          .          .                   use self::ClassAsciiKind::*;
      .          .          .          .                   match name {
    769 ( 0.00%) .          .          .                       "alnum" => Some(Alnum),
    759 ( 0.00%) .          .          .                       "alpha" => Some(Alpha),
    747 ( 0.00%) .          .          .                       "ascii" => Some(Ascii),
    747 ( 0.00%) .          .          .                       "blank" => Some(Blank),
    513 ( 0.00%) .          .          .                       "cntrl" => Some(Cntrl),
    513 ( 0.00%) .          .          .                       "digit" => Some(Digit),
      .          .          .          .                       "graph" => Some(Graph),
      .          .          .          .                       "lower" => Some(Lower),
      .          .          .          .                       "print" => Some(Print),
      .          .          .          .                       "punct" => Some(Punct),
      .          .          .          .                       "space" => Some(Space),
      .          .          .          .                       "upper" => Some(Upper),
      2 ( 0.00%) .          .          .                       "word" => Some(Word),
      .          .          .          .                       "xdigit" => Some(Xdigit),
      .          .          .          .                       _ => None,
      .          .          .          .                   }
    770 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A Unicode character class.
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
      .          .          .          .           pub struct ClassUnicode {
      .          .          .          .               /// The span of this class.
      .          .          .          .               pub span: Span,
-- line 889 ----------------------------------------
-- line 1147 ----------------------------------------
      .          .          .          .                   match *self {
      .          .          .          .                       ClassSet::Item(ref x) => x.span(),
      .          .          .          .                       ClassSet::BinaryOp(ref x) => &x.span,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return true if and only if this class set is empty.
      .          .          .          .               fn is_empty(&self) -> bool {
    141 ( 0.00%) .          .          .                   match *self {
      .          .          .          .                       ClassSet::Item(ClassSetItem::Empty(_)) => true,
      .          .          .          .                       _ => false,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A single component of a character class set.
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
-- line 1163 ----------------------------------------
-- line 1185 ----------------------------------------
      .          .          .          .               Bracketed(Box<ClassBracketed>),
      .          .          .          .               /// A union of items.
      .          .          .          .               Union(ClassSetUnion),
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ClassSetItem {
      .          .          .          .               /// Return the span of this character class set item.
      .          .          .          .               pub fn span(&self) -> &Span {
 47,797 ( 0.01%) .          .          .                   match *self {
      .          .          .          .                       ClassSetItem::Empty(ref span) => span,
      .          .          .          .                       ClassSetItem::Literal(ref x) => &x.span,
      .          .          .          .                       ClassSetItem::Range(ref x) => &x.span,
      .          .          .          .                       ClassSetItem::Ascii(ref x) => &x.span,
      .          .          .          .                       ClassSetItem::Perl(ref x) => &x.span,
      .          .          .          .                       ClassSetItem::Unicode(ref x) => &x.span,
      .          .          .          .                       ClassSetItem::Bracketed(ref x) => &x.span,
      .          .          .          .                       ClassSetItem::Union(ref x) => &x.span,
-- line 1201 ----------------------------------------
-- line 1243 ----------------------------------------
      .          .          .          .               /// position of the span of the item given. If the union is empty, then
      .          .          .          .               /// the starting position of this union is set to the starting position
      .          .          .          .               /// of this item.
      .          .          .          .               ///
      .          .          .          .               /// In other words, if you only use this method to add items to a union
      .          .          .          .               /// and you set the spans on each item correctly, then you should never
      .          .          .          .               /// need to adjust the span of the union directly.
      .          .          .          .               pub fn push(&mut self, item: ClassSetItem) {
  8,782 ( 0.00%) .          .          .                   if self.items.is_empty() {
 14,049 ( 0.00%) .          .          .                       self.span.start = item.span().start;
      .          .          .          .                   }
 21,882 ( 0.01%) .          .          .                   self.span.end = item.span().end;
      .          .          .          .                   self.items.push(item);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return this union as a character class set item.
      .          .          .          .               ///
      .          .          .          .               /// If this union contains zero items, then an empty union is
      .          .          .          .               /// returned. If this concatenation contains exactly 1 item, then the
      .          .          .          .               /// corresponding item is returned. Otherwise, ClassSetItem::Union is
      .          .          .          .               /// returned.
      .          .          .          .               pub fn into_item(mut self) -> ClassSetItem {
 11,296 ( 0.00%) .          .          .                   match self.items.len() {
      .          .          .          .                       0 => ClassSetItem::Empty(self.span),
      .          .          .          .                       1 => self.items.pop().unwrap(),
  5,775 ( 0.00%) .          .          .                       _ => ClassSetItem::Union(self),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A Unicode character class set operation.
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
      .          .          .          .           pub struct ClassSetBinaryOp {
-- line 1276 ----------------------------------------
-- line 1394 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl RepetitionRange {
      .          .          .          .               /// Returns true if and only if this repetition range is valid.
      .          .          .          .               ///
      .          .          .          .               /// The only case where a repetition range is invalid is if it is bounded
      .          .          .          .               /// and its start is greater than its end.
      .          .          .          .               pub fn is_valid(&self) -> bool {
    516 ( 0.00%) .          .          .                   match *self {
      .          .          .          .                       RepetitionRange::Bounded(s, e) if s > e => false,
      .          .          .          .                       _ => true,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A grouped regular expression.
      .          .          .          .           ///
-- line 1410 ----------------------------------------
-- line 1422 ----------------------------------------
      .          .          .          .               /// The regular expression in this group.
      .          .          .          .               pub ast: Box<Ast>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Group {
      .          .          .          .               /// If this group is non-capturing, then this returns the (possibly empty)
      .          .          .          .               /// set of flags. Otherwise, `None` is returned.
      .          .          .          .               pub fn flags(&self) -> Option<&Flags> {
  1,386 ( 0.00%) .          .          .                   match self.kind {
      .          .          .          .                       GroupKind::NonCapturing(ref flags) => Some(flags),
      .          .          .          .                       _ => None,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this group is capturing.
      .          .          .          .               pub fn is_capturing(&self) -> bool {
      .          .          .          .                   match self.kind {
-- line 1438 ----------------------------------------
-- line 1469 ----------------------------------------
      .          .          .          .               /// `(?:a)` and `(?i:a)`
      .          .          .          .               NonCapturing(Flags),
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A capture name.
      .          .          .          .           ///
      .          .          .          .           /// This corresponds to the name itself between the angle brackets in, e.g.,
      .          .          .          .           /// `(?P<foo>expr)`.
  1,172 ( 0.00%) .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
 66,501 ( 0.02%) 73 ( 0.01%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:<alloc::string::String as core::clone::Clone>::clone (586x)
      .          .          .          .           pub struct CaptureName {
      .          .          .          .               /// The span of this capture name.
      .          .          .          .               pub span: Span,
      .          .          .          .               /// The capture name.
      .          .          .          .               pub name: String,
      .          .          .          .               /// The capture index.
      .          .          .          .               pub index: u32,
      .          .          .          .           }
-- line 1485 ----------------------------------------
-- line 1559 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// If the given flag is in the set and is not negated, then `Some(true)`
      .          .          .          .               /// is returned.
      .          .          .          .               ///
      .          .          .          .               /// Otherwise, `None` is returned.
      .          .          .          .               pub fn flag_state(&self, flag: Flag) -> Option<bool> {
      .          .          .          .                   let mut negated = false;
      .          .          .          .                   for x in &self.items {
    240 ( 0.00%) .          .          .                       match x.kind {
      .          .          .          .                           FlagsItemKind::Negation => {
      .          .          .          .                               negated = true;
      .          .          .          .                           }
      .          .          .          .                           FlagsItemKind::Flag(ref xflag) if xflag == &flag => {
      .          .          .          .                               return Some(!negated);
      .          .          .          .                           }
      .          .          .          .                           _ => {}
      .          .          .          .                       }
-- line 1575 ----------------------------------------
-- line 1584 ----------------------------------------
      .          .          .          .           pub struct FlagsItem {
      .          .          .          .               /// The span of this item.
      .          .          .          .               pub span: Span,
      .          .          .          .               /// The kind of this item.
      .          .          .          .               pub kind: FlagsItemKind,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// The kind of an item in a group of flags.
     60 ( 0.00%) .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
      .          .          .          .           pub enum FlagsItemKind {
      .          .          .          .               /// A negation operator applied to all subsequent flags in the enclosing
      .          .          .          .               /// group.
      .          .          .          .               Negation,
      .          .          .          .               /// A single flag in a group.
      .          .          .          .               Flag(Flag),
      .          .          .          .           }
-- line 1600 ----------------------------------------
-- line 1627 ----------------------------------------
      .          .          .          .               CRLF,
      .          .          .          .               /// `x`
      .          .          .          .               IgnoreWhitespace,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A custom `Drop` impl is used for `Ast` such that it uses constant stack
      .          .          .          .           /// space but heap space proportional to the depth of the `Ast`.
      .          .          .          .           impl Drop for Ast {
522,256 ( 0.15%) .          .          .               fn drop(&mut self) {
      .          .          .          .                   use core::mem;
      .          .          .          .           
223,824 ( 0.06%) .          .          .                   match *self {
      .          .          .          .                       Ast::Empty(_)
      .          .          .          .                       | Ast::Flags(_)
      .          .          .          .                       | Ast::Literal(_)
      .          .          .          .                       | Ast::Dot(_)
      .          .          .          .                       | Ast::Assertion(_)
      .          .          .          .                       | Ast::ClassUnicode(_)
      .          .          .          .                       | Ast::ClassPerl(_)
      .          .          .          .                       // Bracketed classes are recursive, they get their own Drop impl.
      .          .          .          .                       | Ast::ClassBracketed(_) => return,
  3,770 ( 0.00%) .          .          .                       Ast::Repetition(ref x) if !x.ast.has_subexprs() => return,
  1,386 ( 0.00%) .          .          .                       Ast::Group(ref x) if !x.ast.has_subexprs() => return,
      .          .          .          .                       Ast::Alternation(ref x) if x.asts.is_empty() => return,
      .          .          .          .                       Ast::Concat(ref x) if x.asts.is_empty() => return,
      .          .          .          .                       _ => {}
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   let empty_span = || Span::splat(Position::new(0, 0, 0));
      .          .          .          .                   let empty_ast = || Ast::empty(empty_span());
    243 ( 0.00%) .          .          .                   let mut stack = vec![mem::replace(self, empty_ast())];
142,512 ( 0.04%) .          .          .                   while let Some(mut ast) = stack.pop() {
142,512 ( 0.04%) .          .          .                       match ast {
      .          .          .          .                           Ast::Empty(_)
      .          .          .          .                           | Ast::Flags(_)
      .          .          .          .                           | Ast::Literal(_)
      .          .          .          .                           | Ast::Dot(_)
      .          .          .          .                           | Ast::Assertion(_)
      .          .          .          .                           | Ast::ClassUnicode(_)
      .          .          .          .                           | Ast::ClassPerl(_)
      .          .          .          .                           // Bracketed classes are recursive, so they get their own Drop
      .          .          .          .                           // impl.
      .          .          .          .                           | Ast::ClassBracketed(_) => {}
      .          .          .          .                           Ast::Repetition(ref mut x) => {
  1,885 ( 0.00%) .          .          .                               stack.push(mem::replace(&mut x.ast, empty_ast()));
      .          .          .          .                           }
      .          .          .          .                           Ast::Group(ref mut x) => {
    693 ( 0.00%) .          .          .                               stack.push(mem::replace(&mut x.ast, empty_ast()));
      .          .          .          .                           }
      .          .          .          .                           Ast::Alternation(ref mut x) => {
  1,024 ( 0.00%) .          .          .                               stack.extend(x.asts.drain(..));
      .          .          .          .                           }
      .          .          .          .                           Ast::Concat(ref mut x) => {
 31,572 ( 0.01%) .          .          .                               stack.extend(x.asts.drain(..));
      .          .          .          .                           }
      .          .          .          .                       }
142,512 ( 0.04%) .          .          .                   }
16,767,779 ( 4.83%) 99,842 (12.32%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (71,256x)
596,864 ( 0.17%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A custom `Drop` impl is used for `ClassSet` such that it uses constant
      .          .          .          .           /// stack space but heap space proportional to the depth of the `ClassSet`.
      .          .          .          .           impl Drop for ClassSet {
 67,248 ( 0.02%) .          .          .               fn drop(&mut self) {
      .          .          .          .                   use core::mem;
      .          .          .          .           
 25,218 ( 0.01%) .          .          .                   match *self {
 54,451 ( 0.02%) .          .          .                       ClassSet::Item(ref item) => match *item {
      .          .          .          .                           ClassSetItem::Empty(_)
      .          .          .          .                           | ClassSetItem::Literal(_)
      .          .          .          .                           | ClassSetItem::Range(_)
      .          .          .          .                           | ClassSetItem::Ascii(_)
      .          .          .          .                           | ClassSetItem::Unicode(_)
      .          .          .          .                           | ClassSetItem::Perl(_) => return,
      .          .          .          .                           ClassSetItem::Bracketed(ref x) => {
    353 ( 0.00%) .          .          .                               if x.kind.is_empty() {
      .          .          .          .                                   return;
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                           ClassSetItem::Union(ref x) => {
  7,748 ( 0.00%) .          .          .                               if x.items.is_empty() {
      .          .          .          .                                   return;
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                       },
      .          .          .          .                       ClassSet::BinaryOp(ref op) => {
      .          .          .          .                           if op.lhs.is_empty() && op.rhs.is_empty() {
      .          .          .          .                               return;
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   let empty_span = || Span::splat(Position::new(0, 0, 0));
      .          .          .          .                   let empty_set = || ClassSet::Item(ClassSetItem::Empty(empty_span()));
    595 ( 0.00%) .          .          .                   let mut stack = vec![mem::replace(self, empty_set())];
 24,822 ( 0.01%) .          .          .                   while let Some(mut set) = stack.pop() {
 82,740 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,758x)
  5,516 ( 0.00%) .          .          .                       match set {
 22,660 ( 0.01%) .          .          .                           ClassSet::Item(ref mut item) => match *item {
      .          .          .          .                               ClassSetItem::Empty(_)
      .          .          .          .                               | ClassSetItem::Literal(_)
      .          .          .          .                               | ClassSetItem::Range(_)
      .          .          .          .                               | ClassSetItem::Ascii(_)
      .          .          .          .                               | ClassSetItem::Unicode(_)
      .          .          .          .                               | ClassSetItem::Perl(_) => {}
      .          .          .          .                               ClassSetItem::Bracketed(ref mut x) => {
     71 ( 0.00%) .          .          .                                   stack.push(mem::replace(&mut x.kind, empty_set()));
      .          .          .          .                               }
      .          .          .          .                               ClassSetItem::Union(ref mut x) => {
      .          .          .          .                                   stack.extend(x.items.drain(..).map(ClassSet::Item));
      .          .          .          .                               }
      .          .          .          .                           },
      .          .          .          .                           ClassSet::BinaryOp(ref mut op) => {
      .          .          .          .                               stack.push(mem::replace(&mut op.lhs, empty_set()));
      .          .          .          .                               stack.push(mem::replace(&mut op.rhs, empty_set()));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
 67,248 ( 0.02%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[cfg(test)]
      .          .          .          .           mod tests {
      .          .          .          .               use super::*;
      .          .          .          .           
      .          .          .          .               // We use a thread with an explicit stack size to test that our destructor
      .          .          .          .               // for Ast can handle arbitrarily sized expressions in constant stack
-- line 1752 ----------------------------------------

295,415 ( 0.09%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 255 ----------------------------------------
     .          .          .          .                   self.byte_classes.unwrap_or(true)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the DFA size limit of this configuration if one was set.
     .          .          .          .               /// The size limit is total number of bytes on the heap that a DFA is
     .          .          .          .               /// permitted to use. If the DFA exceeds this limit during construction,
     .          .          .          .               /// then construction is stopped and an error is returned.
     .          .          .          .               pub fn get_size_limit(&self) -> Option<usize> {
 1,147 ( 0.00%) .          .          .                   self.size_limit.unwrap_or(None)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Overwrite the default configuration such that the options in `o` are
     .          .          .          .               /// always used. If an option in `o` is not set, then the corresponding
     .          .          .          .               /// option in `self` is used. If it's not set in `self` either, then it
     .          .          .          .               /// remains not set.
     .          .          .          .               pub(crate) fn overwrite(&self, o: Config) -> Config {
     .          .          .          .                   Config {
-- line 271 ----------------------------------------
-- line 335 ----------------------------------------
     .          .          .          .           pub struct Builder {
     .          .          .          .               config: Config,
     .          .          .          .               #[cfg(feature = "syntax")]
     .          .          .          .               thompson: thompson::Compiler,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl Builder {
     .          .          .          .               /// Create a new one-pass DFA builder with the default configuration.
   405 ( 0.00%) .          .          .               pub fn new() -> Builder {
   243 ( 0.00%) .          .          .                   Builder {
     .          .          .          .                       config: Config::default(),
     .          .          .          .                       #[cfg(feature = "syntax")]
     .          .          .          .                       thompson: thompson::Compiler::new(),
     .          .          .          .                   }
   486 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Build a one-pass DFA from the given pattern.
     .          .          .          .               ///
     .          .          .          .               /// If there was a problem parsing or compiling the pattern, then an error
     .          .          .          .               /// is returned.
     .          .          .          .               #[cfg(feature = "syntax")]
     .          .          .          .               pub fn build(&self, pattern: &str) -> Result<DFA, BuildError> {
     .          .          .          .                   self.build_many(&[pattern])
-- line 357 ----------------------------------------
-- line 387 ----------------------------------------
     .          .          .          .               ///     .build(r"[a-z0-9]+")?;
     .          .          .          .               /// let re = DFA::builder().build_from_nfa(nfa)?;
     .          .          .          .               /// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());
     .          .          .          .               /// re.captures(&mut cache, "foo123bar", &mut caps);
     .          .          .          .               /// assert_eq!(Some(Match::must(0, 0..9)), caps.get_match());
     .          .          .          .               ///
     .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
     .          .          .          .               /// ```
   729 ( 0.00%) .          .          .               pub fn build_from_nfa(&self, nfa: NFA) -> Result<DFA, BuildError> {
     .          .          .          .                   // Why take ownership if we're just going to pass a reference to the
     .          .          .          .                   // NFA to our internal builder? Well, the first thing to note is that
     .          .          .          .                   // an NFA uses reference counting internally, so either choice is going
     .          .          .          .                   // to be cheap. So there isn't much cost either way.
     .          .          .          .                   //
     .          .          .          .                   // The real reason is that a one-pass DFA, semantically, shares
     .          .          .          .                   // ownership of an NFA. This is unlike other DFAs that don't share
     .          .          .          .                   // ownership of an NFA at all, primarily because they want to be
-- line 403 ----------------------------------------
-- line 405 ----------------------------------------
     .          .          .          .                   //
     .          .          .          .                   // But then why pass a '&nfa' below if we want to share ownership?
     .          .          .          .                   // Well, it turns out that using a '&NFA' in our internal builder
     .          .          .          .                   // separates its lifetime from the DFA we're building, and this turns
     .          .          .          .                   // out to make code a bit more composable. e.g., We can iterate over
     .          .          .          .                   // things inside the NFA while borrowing the builder as mutable because
     .          .          .          .                   // we know the NFA cannot be mutated. So TL;DR --- this weirdness is
     .          .          .          .                   // "because borrow checker."
   324 ( 0.00%) .          .          .                   InternalBuilder::new(self.config.clone(), &nfa).build()
   729 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Apply the given one-pass DFA configuration options to this builder.
     .          .          .          .               pub fn configure(&mut self, config: Config) -> &mut Builder {
   405 ( 0.00%) .          .          .                   self.config = self.config.overwrite(config);
     .          .          .          .                   self
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set the syntax configuration for this builder using
     .          .          .          .               /// [`syntax::Config`](crate::util::syntax::Config).
     .          .          .          .               ///
     .          .          .          .               /// This permits setting things like case insensitivity, Unicode and multi
     .          .          .          .               /// line mode.
-- line 426 ----------------------------------------
-- line 517 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// This is duplicated in dfa.classes.
     .          .          .          .               classes: ByteClasses,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<'a> InternalBuilder<'a> {
     .          .          .          .               /// Create a new builder with an initial empty DFA.
     .          .          .          .               fn new(config: Config, nfa: &'a NFA) -> InternalBuilder<'a> {
    81 ( 0.00%) .          .          .                   let classes = if !config.get_byte_classes() {
     .          .          .          .                       // A one-pass DFA will always use the equivalence class map, but
     .          .          .          .                       // enabling this option is useful for debugging. Namely, this will
     .          .          .          .                       // cause all transitions to be defined over their actual bytes
     .          .          .          .                       // instead of an opaque equivalence class identifier. The former is
     .          .          .          .                       // much easier to grok as a human.
     .          .          .          .                       ByteClasses::singletons()
     .          .          .          .                   } else {
     .          .          .          .                       nfa.byte_classes().clone()
-- line 533 ----------------------------------------
-- line 555 ----------------------------------------
     .          .          .          .                       min_match_id: StateID::MAX,
     .          .          .          .                       classes: classes.clone(),
     .          .          .          .                       alphabet_len,
     .          .          .          .                       stride2,
     .          .          .          .                       pateps_offset: alphabet_len,
     .          .          .          .                       // OK because PatternID::MAX*2 is guaranteed not to overflow.
     .          .          .          .                       explicit_slot_start: nfa.pattern_len().checked_mul(2).unwrap(),
     .          .          .          .                   };
 4,860 ( 0.00%) .          .          .                   InternalBuilder {
     .          .          .          .                       dfa,
     .          .          .          .                       uncompiled_nfa_ids: vec![],
     .          .          .          .                       nfa_to_dfa_id: vec![DEAD; nfa.states().len()],
     .          .          .          .                       stack: vec![],
     .          .          .          .                       seen: SparseSet::new(nfa.states().len()),
     .          .          .          .                       matched: false,
     .          .          .          .                       config,
     .          .          .          .                       nfa,
 3,240 ( 0.00%) .          .          .                       classes,
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Build the DFA from the NFA given to this builder. If the NFA is not
     .          .          .          .               /// one-pass, then return an error. An error may also be returned if a
     .          .          .          .               /// particular limit is exceeded. (Some limits, like the total heap memory
     .          .          .          .               /// used, are configurable. Others, like the total patterns or slots, are
     .          .          .          .               /// hard-coded based on representational limitations.)
-- line 580 ----------------------------------------
-- line 581 ----------------------------------------
     .          .          .          .               fn build(mut self) -> Result<DFA, BuildError> {
     .          .          .          .                   self.nfa.look_set_any().available().map_err(BuildError::word)?;
     .          .          .          .                   for look in self.nfa.look_set_any().iter() {
     .          .          .          .                       // This is a future incompatibility check where if we add any
     .          .          .          .                       // more look-around assertions, then the one-pass DFA either
     .          .          .          .                       // needs to reject them (what we do here) or it needs to have its
     .          .          .          .                       // Transition representation modified to be capable of storing the
     .          .          .          .                       // new assertions.
   244 ( 0.00%) .          .          .                       if look.as_repr() > Look::WordUnicodeNegate.as_repr() {
     .          .          .          .                           return Err(BuildError::unsupported_look(look));
     .          .          .          .                       }
     .          .          .          .                   }
   162 ( 0.00%) .          .          .                   if self.nfa.pattern_len().as_u64() > PatternEpsilons::PATTERN_ID_LIMIT
     .          .          .          .                   {
     .          .          .          .                       return Err(BuildError::too_many_patterns(
     .          .          .          .                           PatternEpsilons::PATTERN_ID_LIMIT,
     .          .          .          .                       ));
     .          .          .          .                   }
   243 ( 0.00%) .          .          .                   if self.nfa.group_info().explicit_slot_len() > Slots::LIMIT {
     .          .          .          .                       return Err(BuildError::not_one_pass(
     .          .          .          .                           "too many explicit capturing groups (max is 16)",
     .          .          .          .                       ));
     .          .          .          .                   }
     .          .          .          .                   assert_eq!(DEAD, self.add_empty_state()?);
     .          .          .          .           
     .          .          .          .                   // This is where the explicit slots start. We care about this because
     .          .          .          .                   // we only need to track explicit slots. The implicit slots---two for
     .          .          .          .                   // each pattern---are tracked as part of the search routine itself.
     .          .          .          .                   let explicit_slot_start = self.nfa.pattern_len() * 2;
    81 ( 0.00%) .          .          .                   self.add_start_state(None, self.nfa.start_anchored())?;
    81 ( 0.00%) .          .          .                   if self.config.get_starts_for_each_pattern() {
   405 ( 0.00%) .          .          .                       for pid in self.nfa.patterns() {
   486 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::nfa::NFA::patterns (81x)
     .          .          .          .                           self.add_start_state(
     .          .          .          .                               Some(pid),
   162 ( 0.00%) .          .          .                               self.nfa.start_pattern(pid).unwrap(),
     .          .          .          .                           )?;
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   // NOTE: One wonders what the effects of treating 'uncompiled_nfa_ids'
     .          .          .          .                   // as a stack are. It is really an unordered *set* of NFA state IDs.
     .          .          .          .                   // If it, for example, in practice led to discovering whether a regex
     .          .          .          .                   // was or wasn't one-pass later than if we processed NFA state IDs in
     .          .          .          .                   // ascending order, then that would make this routine more costly in
     .          .          .          .                   // the somewhat common case of a regex that isn't one-pass.
     .          .          .          .                   while let Some(nfa_id) = self.uncompiled_nfa_ids.pop() {
   392 ( 0.00%) .          .          .                       let dfa_id = self.nfa_to_dfa_id[nfa_id];
     .          .          .          .                       // Once we see a match, we keep going, but don't add any new
     .          .          .          .                       // transitions. Normally we'd just stop, but we have to keep
     .          .          .          .                       // going in order to verify that our regex is actually one-pass.
   392 ( 0.00%) .          .          .                       self.matched = false;
     .          .          .          .                       // The NFA states we've already explored for this DFA state.
     .          .          .          .                       self.seen.clear();
     .          .          .          .                       // The NFA states to explore via epsilon transitions. If we ever
     .          .          .          .                       // try to push an NFA state that we've already seen, then the NFA
     .          .          .          .                       // is not one-pass because it implies there are multiple epsilon
     .          .          .          .                       // transition paths that lead to the same NFA state. In other
     .          .          .          .                       // words, there is ambiguity.
 1,176 ( 0.00%) .          .          .                       self.stack_push(nfa_id, Epsilons::empty())?;
     .          .          .          .                       while let Some((id, epsilons)) = self.stack.pop() {
 5,995 ( 0.00%) .          .          .                           match *self.nfa.state(id) {
     .          .          .          .                               thompson::State::ByteRange { ref trans } => {
 2,340 ( 0.00%) .          .          .                                   self.compile_transition(dfa_id, trans, epsilons)?;
269,779 ( 0.08%) 237 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::compile_transition (390x)
     .          .          .          .                               }
     .          .          .          .                               thompson::State::Sparse(ref sparse) => {
   416 ( 0.00%) .          .          .                                   for trans in sparse.transitions.iter() {
 7,427 ( 0.00%) .          .          .                                       self.compile_transition(dfa_id, trans, epsilons)?;
760,670 ( 0.22%) 518 ( 0.06%) 2 ( 0.62%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::compile_transition (1,061x)
     .          .          .          .                                   }
     .          .          .          .                               }
     .          .          .          .                               thompson::State::Dense(ref dense) => {
     .          .          .          .                                   for trans in dense.iter() {
     .          .          .          .                                       self.compile_transition(dfa_id, &trans, epsilons)?;
     .          .          .          .                                   }
     .          .          .          .                               }
    66 ( 0.00%) .          .          .                               thompson::State::Look { look, next } => {
     .          .          .          .                                   let looks = epsilons.looks().insert(look);
   198 ( 0.00%) .          .          .                                   self.stack_push(next, epsilons.set_looks(looks))?;
     .          .          .          .                               }
     .          .          .          .                               thompson::State::Union { ref alternates } => {
 1,720 ( 0.00%) .          .          .                                   for &sid in alternates.iter().rev() {
 4,932 ( 0.00%) .          .          .                                       self.stack_push(sid, epsilons)?;
168,365 ( 0.05%) 258 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push (1,644x)
     .          .          .          .                                   }
     .          .          .          .                               }
   224 ( 0.00%) .          .          .                               thompson::State::BinaryUnion { alt1, alt2 } => {
   560 ( 0.00%) .          .          .                                   self.stack_push(alt2, epsilons)?;
 6,023 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push (112x)
   560 ( 0.00%) .          .          .                                   self.stack_push(alt1, epsilons)?;
     .          .          .          .                               }
   346 ( 0.00%) .          .          .                               thompson::State::Capture { next, slot, .. } => {
     .          .          .          .                                   let slot = slot.as_usize();
   692 ( 0.00%) .          .          .                                   let epsilons = if slot < explicit_slot_start {
     .          .          .          .                                       // If this is an implicit slot, we don't care
     .          .          .          .                                       // about it, since we handle implicit slots in
     .          .          .          .                                       // the search routine. We can get away with that
     .          .          .          .                                       // because there are 2 implicit slots for every
     .          .          .          .                                       // pattern.
     .          .          .          .                                       epsilons
     .          .          .          .                                   } else {
     .          .          .          .                                       // Offset our explicit slots so that they start
-- line 677 ----------------------------------------
-- line 679 ----------------------------------------
     .          .          .          .                                       let offset = slot - explicit_slot_start;
     .          .          .          .                                       epsilons.set_slots(epsilons.slots().insert(offset))
     .          .          .          .                                   };
     .          .          .          .                                   self.stack_push(next, epsilons)?;
     .          .          .          .                               }
     .          .          .          .                               thompson::State::Fail => {
     .          .          .          .                                   continue;
     .          .          .          .                               }
     1 ( 0.00%) .          .          .                               thompson::State::Match { pattern_id } => {
     .          .          .          .                                   // If we found two different paths to a match state
     .          .          .          .                                   // for the same DFA state, then we have ambiguity.
     .          .          .          .                                   // Thus, it's not one-pass.
     2 ( 0.00%) .          .          .                                   if self.matched {
     .          .          .          .                                       return Err(BuildError::not_one_pass(
     .          .          .          .                                           "multiple epsilon transitions to match state",
     .          .          .          .                                       ));
     .          .          .          .                                   }
     1 ( 0.00%) .          .          .                                   self.matched = true;
     .          .          .          .                                   // Shove the matching pattern ID and the 'epsilons'
     .          .          .          .                                   // into the current DFA state's pattern epsilons. The
     .          .          .          .                                   // 'epsilons' includes the slots we need to capture
     .          .          .          .                                   // before reporting the match and also the conditional
     .          .          .          .                                   // epsilon transitions we need to check before we can
     .          .          .          .                                   // report a match.
     .          .          .          .                                   self.dfa.set_pattern_epsilons(
     .          .          .          .                                       dfa_id,
-- line 704 ----------------------------------------
-- line 717 ----------------------------------------
     .          .          .          .                                   // continue on. When we go to compile a new DFA state,
     .          .          .          .                                   // we just skip that part. But otherwise check that the
     .          .          .          .                                   // one-pass property is upheld.
     .          .          .          .                               }
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   self.shuffle_states();
     4 ( 0.00%) .          .          .                   Ok(self.dfa)
    65 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Shuffle all match states to the end of the transition table and set
     .          .          .          .               /// 'min_match_id' to the ID of the first such match state.
     .          .          .          .               ///
     .          .          .          .               /// The point of this is to make it extremely cheap to determine whether
     .          .          .          .               /// a state is a match state or not. We need to check on this on every
     .          .          .          .               /// transition during a search, so it being cheap is important. This
     .          .          .          .               /// permits us to check it by simply comparing two state identifiers, as
     .          .          .          .               /// opposed to looking for the pattern ID in the state's `PatternEpsilons`.
     .          .          .          .               /// (Which requires a memory load and some light arithmetic.)
     .          .          .          .               fn shuffle_states(&mut self) {
     1 ( 0.00%) .          .          .                   let mut remapper = Remapper::new(&self.dfa);
   176 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/remapper.rs:regex_automata::dfa::remapper::Remapper::new (1x)
     2 ( 0.00%) .          .          .                   let mut next_dest = self.dfa.last_state_id();
     .          .          .          .                   for i in (0..self.dfa.state_len()).rev() {
     .          .          .          .                       let id = StateID::must(i);
     .          .          .          .                       let is_match =
     .          .          .          .                           self.dfa.pattern_epsilons(id).pattern_id().is_some();
     .          .          .          .                       if !is_match {
     .          .          .          .                           continue;
     .          .          .          .                       }
     6 ( 0.00%) .          .          .                       remapper.swap(&mut self.dfa, next_dest, id);
 1,956 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/remapper.rs:regex_automata::dfa::remapper::Remapper::swap (1x)
     1 ( 0.00%) .          .          .                       self.dfa.min_match_id = next_dest;
     .          .          .          .                       next_dest = self.dfa.prev_state_id(next_dest).expect(
     .          .          .          .                           "match states should be a proper subset of all states",
     .          .          .          .                       );
     .          .          .          .                   }
     8 ( 0.00%) .          .          .                   remapper.remap(&mut self.dfa);
103,856 ( 0.03%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/remapper.rs:regex_automata::dfa::remapper::Remapper::remap (1x)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Compile the given NFA transition into the DFA state given.
     .          .          .          .               ///
     .          .          .          .               /// 'Epsilons' corresponds to any conditional epsilon transitions that need
     .          .          .          .               /// to be satisfied to follow this transition, and any slots that need to
     .          .          .          .               /// be saved if the transition is followed.
     .          .          .          .               ///
     .          .          .          .               /// If this transition indicates that the NFA is not one-pass, then
     .          .          .          .               /// this returns an error. (This occurs, for example, if the DFA state
     .          .          .          .               /// already has a transition defined for the same input symbols as the
     .          .          .          .               /// given transition, *and* the result of the old and new transitions is
     .          .          .          .               /// different.)
17,412 ( 0.01%) .          .          .               fn compile_transition(
     .          .          .          .                   &mut self,
     .          .          .          .                   dfa_id: StateID,
     .          .          .          .                   trans: &thompson::Transition,
     .          .          .          .                   epsilons: Epsilons,
     .          .          .          .               ) -> Result<(), BuildError> {
 2,902 ( 0.00%) .          .          .                   let next_dfa_id = self.add_dfa_state_for_nfa_state(trans.next)?;
916,619 ( 0.26%) 755 ( 0.09%) 2 ( 0.62%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (1,451x)
     .          .          .          .                   for byte in self
     .          .          .          .                       .classes
 1,451 ( 0.00%) .          .          .                       .representatives(trans.start..=trans.end)
     .          .          .          .                       .filter_map(|r| r.as_u8())
     .          .          .          .                   {
     .          .          .          .                       let oldtrans = self.dfa.transition(dfa_id, byte);
     .          .          .          .                       let newtrans =
 1,851 ( 0.00%) .          .          .                           Transition::new(self.matched, next_dfa_id, epsilons);
     .          .          .          .                       // If the old transition points to the DEAD state, then we know
     .          .          .          .                       // 'byte' has not been mapped to any transition for this DFA state
     .          .          .          .                       // yet. So set it unconditionally. Otherwise, we require that the
     .          .          .          .                       // old and new transitions are equivalent. Otherwise, there is
     .          .          .          .                       // ambiguity and thus the regex is not one-pass.
 5,553 ( 0.00%) .          .          .                       if oldtrans.state_id() == DEAD {
     .          .          .          .                           self.dfa.set_transition(dfa_id, byte, newtrans);
    80 ( 0.00%) .          .          .                       } else if oldtrans != newtrans {
   400 ( 0.00%) .          .          .                           return Err(BuildError::not_one_pass(
     .          .          .          .                               "conflicting transition",
     .          .          .          .                           ));
     .          .          .          .                       }
     .          .          .          .                   }
 1,371 ( 0.00%) .          .          .                   Ok(())
10,157 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add a start state to the DFA corresponding to the given NFA starting
     .          .          .          .               /// state ID.
     .          .          .          .               ///
     .          .          .          .               /// If adding a state would blow any limits (configured or hard-coded),
     .          .          .          .               /// then an error is returned.
     .          .          .          .               ///
     .          .          .          .               /// If the starting state is an anchored state for a particular pattern,
-- line 804 ----------------------------------------
-- line 809 ----------------------------------------
     .          .          .          .               fn add_start_state(
     .          .          .          .                   &mut self,
     .          .          .          .                   pid: Option<PatternID>,
     .          .          .          .                   nfa_id: StateID,
     .          .          .          .               ) -> Result<StateID, BuildError> {
     .          .          .          .                   match pid {
     .          .          .          .                       // With no pid, this should be the start state for all patterns
     .          .          .          .                       // and thus be the first one.
    81 ( 0.00%) .          .          .                       None => assert!(self.dfa.starts.is_empty()),
     .          .          .          .                       // With a pid, we want it to be at self.dfa.starts[pid+1].
   162 ( 0.00%) .          .          .                       Some(pid) => assert!(self.dfa.starts.len() == pid.one_more()),
     .          .          .          .                   }
   324 ( 0.00%) .          .          .                   let dfa_id = self.add_dfa_state_for_nfa_state(nfa_id)?;
274,669 ( 0.08%) 250 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (162x)
     .          .          .          .                   self.dfa.starts.push(dfa_id);
     .          .          .          .                   Ok(dfa_id)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add a new DFA state corresponding to the given NFA state. If adding a
     .          .          .          .               /// state would blow any limits (configured or hard-coded), then an error
     .          .          .          .               /// is returned. If a DFA state already exists for the given NFA state,
     .          .          .          .               /// then that DFA state's ID is returned and no new states are added.
     .          .          .          .               ///
     .          .          .          .               /// It is not expected that this routine is called for every NFA state.
     .          .          .          .               /// Instead, an NFA state ID will usually correspond to the "start" state
     .          .          .          .               /// for a sub-graph of the NFA, where all states in the sub-graph are
     .          .          .          .               /// reachable via epsilon transitions (conditional or unconditional). That
     .          .          .          .               /// sub-graph of NFA states is ultimately what produces a single DFA state.
12,904 ( 0.00%) .          .          .               fn add_dfa_state_for_nfa_state(
     .          .          .          .                   &mut self,
     .          .          .          .                   nfa_id: StateID,
     .          .          .          .               ) -> Result<StateID, BuildError> {
     .          .          .          .                   // If we've already built a DFA state for the given NFA state, then
     .          .          .          .                   // just return that. We definitely do not want to have more than one
     .          .          .          .                   // DFA state in existence for the same NFA state, since all but one of
     .          .          .          .                   // them will likely become unreachable. And at least some of them are
     .          .          .          .                   // likely to wind up being incomplete.
 1,613 ( 0.00%) .          .          .                   let existing_dfa_id = self.nfa_to_dfa_id[nfa_id];
 1,613 ( 0.00%) .          .          .                   if existing_dfa_id != DEAD {
 1,094 ( 0.00%) .          .          .                       return Ok(existing_dfa_id);
     .          .          .          .                   }
     .          .          .          .                   // If we don't have any DFA state yet, add it and then add the given
     .          .          .          .                   // NFA state to the list of states to explore.
     .          .          .          .                   let dfa_id = self.add_empty_state()?;
 1,066 ( 0.00%) .          .          .                   self.nfa_to_dfa_id[nfa_id] = dfa_id;
   154 ( 0.00%) .          .          .                   self.uncompiled_nfa_ids.push(nfa_id);
 3,198 ( 0.00%) .          .          .                   Ok(dfa_id)
12,904 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Unconditionally add a new empty DFA state. If adding it would exceed
     .          .          .          .               /// any limits (configured or hard-coded), then an error is returned. The
     .          .          .          .               /// ID of the new state is returned on success.
     .          .          .          .               ///
     .          .          .          .               /// The added state is *not* a match state.
     .          .          .          .               fn add_empty_state(&mut self) -> Result<StateID, BuildError> {
     .          .          .          .                   let state_limit = Transition::STATE_ID_LIMIT;
-- line 863 ----------------------------------------
-- line 864 ----------------------------------------
     .          .          .          .                   // Note that unlike dense and lazy DFAs, we specifically do NOT
     .          .          .          .                   // premultiply our state IDs here. The reason is that we want to pack
     .          .          .          .                   // our state IDs into 64-bit transitions with other info, so the fewer
     .          .          .          .                   // the bits we use for state IDs the better. If we premultiply, then
     .          .          .          .                   // our state ID space shrinks. We justify this by the assumption that
     .          .          .          .                   // a one-pass DFA is just already doing a fair bit more work than a
     .          .          .          .                   // normal DFA anyway, so an extra multiplication to compute a state
     .          .          .          .                   // transition doesn't seem like a huge deal.
 4,264 ( 0.00%) .          .          .                   let next_id = self.dfa.table.len() >> self.dfa.stride2();
     .          .          .          .                   let id = StateID::new(next_id)
     .          .          .          .                       .map_err(|_| BuildError::too_many_states(state_limit))?;
 2,132 ( 0.00%) .          .          .                   if id.as_u64() > Transition::STATE_ID_LIMIT {
     .          .          .          .                       return Err(BuildError::too_many_states(state_limit));
     .          .          .          .                   }
     .          .          .          .                   self.dfa
     .          .          .          .                       .table
     .          .          .          .                       .extend(core::iter::repeat(Transition(0)).take(self.dfa.stride()));
     .          .          .          .                   // The default empty value for 'PatternEpsilons' is sadly not all
     .          .          .          .                   // zeroes. Instead, a special sentinel is used to indicate that there
     .          .          .          .                   // is no pattern. So we need to explicitly set the pattern epsilons to
     .          .          .          .                   // the correct "empty" PatternEpsilons.
     .          .          .          .                   self.dfa.set_pattern_epsilons(id, PatternEpsilons::empty());
 2,375 ( 0.00%) .          .          .                   if let Some(size_limit) = self.config.get_size_limit() {
 2,294 ( 0.00%) .          .          .                       if self.dfa.memory_usage() > size_limit {
     .          .          .          .                           return Err(BuildError::exceeded_size_limit(size_limit));
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   Ok(id)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Push the given NFA state ID and its corresponding epsilons (slots and
     .          .          .          .               /// conditional epsilon transitions) on to a stack for use in a depth first
     .          .          .          .               /// traversal of a sub-graph of the NFA.
     .          .          .          .               ///
     .          .          .          .               /// If the given NFA state ID has already been pushed on to the stack, then
     .          .          .          .               /// it indicates the regex is not one-pass and this correspondingly returns
     .          .          .          .               /// an error.
21,376 ( 0.01%) .          .          .               fn stack_push(
     .          .          .          .                   &mut self,
     .          .          .          .                   nfa_id: StateID,
     .          .          .          .                   epsilons: Epsilons,
     .          .          .          .               ) -> Result<(), BuildError> {
     .          .          .          .                   // If we already have seen a match and we are compiling a leftmost
     .          .          .          .                   // first DFA, then we shouldn't add any more states to look at. This is
     .          .          .          .                   // effectively how preference order and non-greediness is implemented.
     .          .          .          .                   // if !self.config.get_match_kind().continue_past_first_match()
-- line 909 ----------------------------------------
-- line 911 ----------------------------------------
     .          .          .          .                   // {
     .          .          .          .                   // return Ok(());
     .          .          .          .                   // }
     .          .          .          .                   if !self.seen.insert(nfa_id) {
     .          .          .          .                       return Err(BuildError::not_one_pass(
     .          .          .          .                           "multiple epsilon transitions to same state",
     .          .          .          .                       ));
     .          .          .          .                   }
   211 ( 0.00%) .          .          .                   self.stack.push((nfa_id, epsilons));
 2,672 ( 0.00%) .          .          .                   Ok(())
16,032 ( 0.00%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A one-pass DFA for executing a subset of anchored regex searches while
     .          .          .          .           /// resolving capturing groups.
     .          .          .          .           ///
     .          .          .          .           /// A one-pass DFA can be built from an NFA that is one-pass. An NFA is
     .          .          .          .           /// one-pass when there is never any ambiguity about how to continue a search.
     .          .          .          .           /// For example, `a*a` is not one-pass becuase during a search, it's not
-- line 929 ----------------------------------------
-- line 1438 ----------------------------------------
     .          .          .          .           
     .          .          .          .               /// Returns the total number of states in this one-pass DFA.
     .          .          .          .               ///
     .          .          .          .               /// Note that unlike dense or sparse DFAs, a one-pass DFA does not expose
     .          .          .          .               /// a low level DFA API. Therefore, this routine has little use other than
     .          .          .          .               /// being informational.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn state_len(&self) -> usize {
     6 ( 0.00%) .          .          .                   self.table.len() >> self.stride2()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the total number of elements in the alphabet for this DFA.
     .          .          .          .               ///
     .          .          .          .               /// That is, this returns the total number of transitions that each
     .          .          .          .               /// state in this DFA must have. The maximum alphabet size is 256, which
     .          .          .          .               /// corresponds to each possible byte value.
     .          .          .          .               ///
-- line 1454 ----------------------------------------
-- line 1499 ----------------------------------------
     .          .          .          .               /// than `8`. (Do note that a maximal stride is incredibly rare, as it
     .          .          .          .               /// would imply that there is almost no redundant in the regex pattern.)
     .          .          .          .               ///
     .          .          .          .               /// Note that unlike dense or sparse DFAs, a one-pass DFA does not expose
     .          .          .          .               /// a low level DFA API. Therefore, this routine has little use other than
     .          .          .          .               /// being informational.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn stride2(&self) -> usize {
 3,213 ( 0.00%) .          .          .                   self.stride2
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the total stride for every state in this DFA. This corresponds
     .          .          .          .               /// to the total number of transitions used by each state in this DFA's
     .          .          .          .               /// transition table.
     .          .          .          .               ///
     .          .          .          .               /// Please see [`DFA::stride2`] for more information. In particular, this
     .          .          .          .               /// returns the stride as the number of transitions, where as `stride2`
     .          .          .          .               /// returns it as the exponent of a power of 2.
     .          .          .          .               ///
     .          .          .          .               /// Note that unlike dense or sparse DFAs, a one-pass DFA does not expose
     .          .          .          .               /// a low level DFA API. Therefore, this routine has little use other than
     .          .          .          .               /// being informational.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn stride(&self) -> usize {
 2,213 ( 0.00%) .          .          .                   1 << self.stride2()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the memory usage, in bytes, of this DFA.
     .          .          .          .               ///
     .          .          .          .               /// The memory usage is computed based on the number of bytes used to
     .          .          .          .               /// represent this DFA.
     .          .          .          .               ///
     .          .          .          .               /// This does **not** include the stack size used up by this DFA. To
     .          .          .          .               /// compute that, use `std::mem::size_of::<onepass::DFA>()`.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn memory_usage(&self) -> usize {
     .          .          .          .                   use core::mem::size_of;
     .          .          .          .           
 3,360 ( 0.00%) .          .          .                   self.table.len() * size_of::<Transition>()
     .          .          .          .                       + self.starts.len() * size_of::<StateID>()
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl DFA {
     .          .          .          .               /// Executes an anchored leftmost forward search, and returns true if and
     .          .          .          .               /// only if this one-pass DFA matches the given haystack.
     .          .          .          .               ///
-- line 1545 ----------------------------------------
-- line 1969 ----------------------------------------
     .          .          .          .               /// ```
     .          .          .          .               #[inline]
     .          .          .          .               pub fn try_search_slots(
     .          .          .          .                   &self,
     .          .          .          .                   cache: &mut Cache,
     .          .          .          .                   input: &Input<'_>,
     .          .          .          .                   slots: &mut [Option<NonMaxUsize>],
     .          .          .          .               ) -> Result<Option<PatternID>, MatchError> {
     1 ( 0.00%) .          .          .                   let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
     .          .          .          .                   if !utf8empty {
     .          .          .          .                       return self.try_search_slots_imp(cache, input, slots);
     .          .          .          .                   }
     .          .          .          .                   // See PikeVM::try_search_slots for why we do this.
     .          .          .          .                   let min = self.get_nfa().group_info().implicit_slot_len();
     .          .          .          .                   if slots.len() >= min {
     .          .          .          .                       return self.try_search_slots_imp(cache, input, slots);
     .          .          .          .                   }
-- line 1985 ----------------------------------------
-- line 1995 ----------------------------------------
     .          .          .          .                   let got = self.try_search_slots_imp(cache, input, &mut enough)?;
     .          .          .          .                   // This is OK because we know `enough_slots` is strictly bigger than
     .          .          .          .                   // `slots`, otherwise this special case isn't reached.
     .          .          .          .                   slots.copy_from_slice(&enough[..slots.len()]);
     .          .          .          .                   Ok(got)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline(never)]
     8 ( 0.00%) .          .          .               fn try_search_slots_imp(
     .          .          .          .                   &self,
     .          .          .          .                   cache: &mut Cache,
     .          .          .          .                   input: &Input<'_>,
     .          .          .          .                   slots: &mut [Option<NonMaxUsize>],
     .          .          .          .               ) -> Result<Option<PatternID>, MatchError> {
     1 ( 0.00%) .          .          .                   let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
     1 ( 0.00%) .          .          .                   match self.search_imp(cache, input, slots)? {
     .          .          .          .                       None => return Ok(None),
     .          .          .          .                       Some(pid) if !utf8empty => return Ok(Some(pid)),
     .          .          .          .                       Some(pid) => {
     .          .          .          .                           // These slot indices are always correct because we know our
     .          .          .          .                           // 'pid' is valid and thus we know that the slot indices for it
     .          .          .          .                           // are valid.
     .          .          .          .                           let slot_start = pid.as_usize().wrapping_mul(2);
     .          .          .          .                           let slot_end = slot_start.wrapping_add(1);
-- line 2018 ----------------------------------------
-- line 2028 ----------------------------------------
     .          .          .          .                           // searches, we don't try to skip ahead to find the next match.
     .          .          .          .                           // We can just quit with nothing.
     .          .          .          .                           if start == end && !input.is_char_boundary(start) {
     .          .          .          .                               return Ok(None);
     .          .          .          .                           }
     .          .          .          .                           Ok(Some(pid))
     .          .          .          .                       }
     .          .          .          .                   }
     9 ( 0.00%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl DFA {
     .          .          .          .               fn search_imp(
     .          .          .          .                   &self,
     .          .          .          .                   cache: &mut Cache,
     .          .          .          .                   input: &Input<'_>,
     .          .          .          .                   slots: &mut [Option<NonMaxUsize>],
-- line 2044 ----------------------------------------
-- line 2075 ----------------------------------------
     .          .          .          .                   // case, maybe an extra function call is OK, but even then, it might be
     .          .          .          .                   // too much of a latency hit. Another idea is to just try and figure
     .          .          .          .                   // out how to reduce the code size of 'find_match'. RE2 has a trick
     .          .          .          .                   // here where the match handling isn't done if we know the next byte of
     .          .          .          .                   // input yields a match too. Maybe we adopt that?
     .          .          .          .                   //
     .          .          .          .                   // This just might be a tricky DFA to optimize.
     .          .          .          .           
     1 ( 0.00%) .          .          .                   if input.is_done() {
     .          .          .          .                       return Ok(None);
     .          .          .          .                   }
     .          .          .          .                   // We unfortunately have a bit of book-keeping to do to set things
     .          .          .          .                   // up. We do have to setup our cache and clear all of our slots. In
     .          .          .          .                   // particular, clearing the slots is necessary for the case where we
     .          .          .          .                   // report a match, but one of the capturing groups didn't participate
     .          .          .          .                   // in the match but had a span set from a previous search. That would
     .          .          .          .                   // be bad. In theory, we could avoid all this slot clearing if we knew
     .          .          .          .                   // that every slot was always activated for every match. Then we would
     .          .          .          .                   // know they would always be overwritten when a match is found.
     .          .          .          .                   let explicit_slots_len = core::cmp::min(
     .          .          .          .                       Slots::LIMIT,
     1 ( 0.00%) .          .          .                       slots.len().saturating_sub(self.explicit_slot_start),
     .          .          .          .                   );
     .          .          .          .                   cache.setup_search(explicit_slots_len);
     .          .          .          .                   for slot in cache.explicit_slots() {
     5 ( 0.00%) .          .          .                       *slot = None;
    19 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
     .          .          .          .                   }
     .          .          .          .                   for slot in slots.iter_mut() {
     5 ( 0.00%) .          .          .                       *slot = None;
    19 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
     .          .          .          .                   }
     .          .          .          .                   // We set the starting slots for every pattern up front. This does
     .          .          .          .                   // increase our latency somewhat, but it avoids having to do it every
     .          .          .          .                   // time we see a match state (which could be many times in a single
     .          .          .          .                   // search if the match state consumes input).
     2 ( 0.00%) .          .          .                   for pid in self.nfa.patterns() {
     4 ( 0.00%) .          .          .                       let i = pid.as_usize() * 2;
     2 ( 0.00%) .          .          .                       if i >= slots.len() {
     .          .          .          .                           break;
     .          .          .          .                       }
     1 ( 0.00%) .          .          .                       slots[i] = NonMaxUsize::new(input.start());
     .          .          .          .                   }
     .          .          .          .                   let mut pid = None;
     1 ( 0.00%) .          .          .                   let mut next_sid = match input.get_anchored() {
     .          .          .          .                       Anchored::Yes => self.start(),
     .          .          .          .                       Anchored::Pattern(pid) => self.start_pattern(pid)?,
     .          .          .          .                       Anchored::No => {
     .          .          .          .                           // If the regex is itself always anchored, then we're fine,
     .          .          .          .                           // even if the search is configured to be unanchored.
     1 ( 0.00%) .          .          .                           if !self.nfa.is_always_start_anchored() {
     .          .          .          .                               return Err(MatchError::unsupported_anchored(
     .          .          .          .                                   Anchored::No,
     .          .          .          .                               ));
     .          .          .          .                           }
     .          .          .          .                           self.start()
     .          .          .          .                       }
     .          .          .          .                   };
     .          .          .          .                   let leftmost_first =
     .          .          .          .                       matches!(self.config.get_match_kind(), MatchKind::LeftmostFirst);
     .          .          .          .                   for at in input.start()..input.end() {
     .          .          .          .                       let sid = next_sid;
    12 ( 0.00%) .          .          .                       let trans = self.transition(sid, input.haystack()[at]);
     .          .          .          .                       next_sid = trans.state_id();
     .          .          .          .                       let epsilons = trans.epsilons();
     .          .          .          .                       if sid >= self.min_match_id {
     .          .          .          .                           if self.find_match(cache, input, at, sid, slots, &mut pid) {
     .          .          .          .                               if input.get_earliest()
     .          .          .          .                                   || (leftmost_first && trans.match_wins())
     .          .          .          .                               {
     .          .          .          .                                   return Ok(pid);
     .          .          .          .                               }
     .          .          .          .                           }
     .          .          .          .                       }
     4 ( 0.00%) .          .          .                       if sid == DEAD
     1 ( 0.00%) .          .          .                           || (!epsilons.looks().is_empty()
     .          .          .          .                               && !self.nfa.look_matcher().matches_set_inline(
     .          .          .          .                                   epsilons.looks(),
     .          .          .          .                                   input.haystack(),
     .          .          .          .                                   at,
     .          .          .          .                               ))
     .          .          .          .                       {
     .          .          .          .                           return Ok(pid);
     .          .          .          .                       }
-- line 2156 ----------------------------------------
-- line 2250 ----------------------------------------
     .          .          .          .                   Ok(self.starts.get(pid.one_more()).copied().unwrap_or(DEAD))
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the transition from the given state ID and byte of input. The
     .          .          .          .               /// transition includes the next state ID, the slots that should be saved
     .          .          .          .               /// and any conditional epsilon transitions that must be satisfied in order
     .          .          .          .               /// to take this transition.
     .          .          .          .               fn transition(&self, sid: StateID, byte: u8) -> Transition {
 3,704 ( 0.00%) .          .          .                   let offset = sid.as_usize() << self.stride2();
     .          .          .          .                   let class = self.classes.get(byte).as_usize();
 7,408 ( 0.00%) .          .          .                   self.table[offset + class]
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set the transition from the given state ID and byte of input to the
     .          .          .          .               /// transition given.
     .          .          .          .               fn set_transition(&mut self, sid: StateID, byte: u8, to: Transition) {
     .          .          .          .                   let offset = sid.as_usize() << self.stride2();
     .          .          .          .                   let class = self.classes.get(byte).as_usize();
 3,542 ( 0.00%) .          .          .                   self.table[offset + class] = to;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return an iterator of "sparse" transitions for the given state ID.
     .          .          .          .               /// "sparse" in this context means that consecutive transitions that are
     .          .          .          .               /// equivalent are returned as one group, and transitions to the DEAD state
     .          .          .          .               /// are ignored.
     .          .          .          .               ///
     .          .          .          .               /// This winds up being useful for debug printing, since it's much terser
-- line 2276 ----------------------------------------
-- line 2286 ----------------------------------------
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return the pattern epsilons for the given state ID.
     .          .          .          .               ///
     .          .          .          .               /// If the given state ID does not correspond to a match state ID, then the
     .          .          .          .               /// pattern epsilons returned is empty.
     .          .          .          .               fn pattern_epsilons(&self, sid: StateID) -> PatternEpsilons {
    74 ( 0.00%) .          .          .                   let offset = sid.as_usize() << self.stride2();
    74 ( 0.00%) .          .          .                   PatternEpsilons(self.table[offset + self.pateps_offset].0)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set the pattern epsilons for the given state ID.
     .          .          .          .               fn set_pattern_epsilons(&mut self, sid: StateID, pateps: PatternEpsilons) {
 4,069 ( 0.00%) .          .          .                   let offset = sid.as_usize() << self.stride2();
 2,380 ( 0.00%) .          .          .                   self.table[offset + self.pateps_offset] = Transition(pateps.0);
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the state ID prior to the one given. This returns None if the
     .          .          .          .               /// given ID is the first DFA state.
     .          .          .          .               fn prev_state_id(&self, id: StateID) -> Option<StateID> {
     1 ( 0.00%) .          .          .                   if id == DEAD {
     .          .          .          .                       None
     .          .          .          .                   } else {
     .          .          .          .                       // CORRECTNESS: Since 'id' is not the first state, subtracting 1
     .          .          .          .                       // is always valid.
     .          .          .          .                       Some(StateID::new_unchecked(id.as_usize().checked_sub(1).unwrap()))
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
-- line 2315 ----------------------------------------
-- line 2317 ----------------------------------------
     .          .          .          .               /// "last" in this context means the last state to appear in memory, i.e.,
     .          .          .          .               /// the one with the greatest ID.
     .          .          .          .               fn last_state_id(&self) -> StateID {
     .          .          .          .                   // CORRECTNESS: A DFA table is always non-empty since it always at
     .          .          .          .                   // least contains a DEAD state. Since every state has the same stride,
     .          .          .          .                   // we can just compute what the "next" state ID would have been and
     .          .          .          .                   // then subtract 1 from it.
     .          .          .          .                   StateID::new_unchecked(
     1 ( 0.00%) .          .          .                       (self.table.len() >> self.stride2()).checked_sub(1).unwrap(),
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Move the transitions from 'id1' to 'id2' and vice versa.
     .          .          .          .               ///
     .          .          .          .               /// WARNING: This does not update the rest of the transition table to have
     .          .          .          .               /// transitions to 'id1' changed to 'id2' and vice versa. This merely moves
     .          .          .          .               /// the states in memory.
     .          .          .          .               pub(super) fn swap_states(&mut self, id1: StateID, id2: StateID) {
     3 ( 0.00%) .          .          .                   let o1 = id1.as_usize() << self.stride2();
     3 ( 0.00%) .          .          .                   let o2 = id2.as_usize() << self.stride2();
     .          .          .          .                   for b in 0..self.stride() {
     .          .          .          .                       self.table.swap(o1 + b, o2 + b);
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Map all state IDs in this DFA (transition table + start states)
     .          .          .          .               /// according to the closure given.
     .          .          .          .               pub(super) fn remap(&mut self, map: impl Fn(StateID) -> StateID) {
     .          .          .          .                   for i in 0..self.state_len() {
   148 ( 0.00%) .          .          .                       let offset = i << self.stride2();
     .          .          .          .                       for b in 0..self.alphabet_len() {
     .          .          .          .                           let next = self.table[offset + b].state_id();
     .          .          .          .                           self.table[offset + b].set_state_id(map(next));
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   for i in 0..self.starts.len() {
     4 ( 0.00%) .          .          .                       self.starts[i] = map(self.starts[i]);
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl core::fmt::Debug for DFA {
     .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
     .          .          .          .                   fn debug_state_transitions(
     .          .          .          .                       f: &mut core::fmt::Formatter,
-- line 2361 ----------------------------------------
-- line 2506 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// A potentially more convenient routine to create a cache is
     .          .          .          .               /// [`DFA::create_cache`], as it does not require also importing the
     .          .          .          .               /// `Cache` type.
     .          .          .          .               ///
     .          .          .          .               /// If you want to reuse the returned `Cache` with some other one-pass DFA,
     .          .          .          .               /// then you must call [`Cache::reset`] with the desired one-pass DFA.
     .          .          .          .               pub fn new(re: &DFA) -> Cache {
     5 ( 0.00%) .          .          .                   let mut cache = Cache { explicit_slots: vec![], explicit_slot_len: 0 };
     .          .          .          .                   cache.reset(re);
     6 ( 0.00%) .          .          .                   cache
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Reset this cache such that it can be used for searching with a
     .          .          .          .               /// different [`onepass::DFA`](DFA).
     .          .          .          .               ///
     .          .          .          .               /// A cache reset permits reusing memory already allocated in this cache
     .          .          .          .               /// with a different one-pass DFA.
     .          .          .          .               ///
-- line 2524 ----------------------------------------
-- line 2552 ----------------------------------------
     .          .          .          .               /// assert_eq!(
     .          .          .          .               ///     Some(Match::must(0, 0..3)),
     .          .          .          .               ///     { re2.captures(&mut cache, "☃", &mut caps2); caps2.get_match() },
     .          .          .          .               /// );
     .          .          .          .               ///
     .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
     .          .          .          .               /// ```
     .          .          .          .               pub fn reset(&mut self, re: &DFA) {
     1 ( 0.00%) .          .          .                   let explicit_slot_len = re.get_nfa().group_info().explicit_slot_len();
     .          .          .          .                   self.explicit_slots.resize(explicit_slot_len, None);
     1 ( 0.00%) .          .          .                   self.explicit_slot_len = explicit_slot_len;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the heap memory usage, in bytes, of this cache.
     .          .          .          .               ///
     .          .          .          .               /// This does **not** include the stack size used up by this cache. To
     .          .          .          .               /// compute that, use `std::mem::size_of::<Cache>()`.
     .          .          .          .               pub fn memory_usage(&self) -> usize {
     .          .          .          .                   self.explicit_slots.len() * core::mem::size_of::<Option<NonMaxUsize>>()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               fn explicit_slots(&mut self) -> &mut [Option<NonMaxUsize>] {
     2 ( 0.00%) .          .          .                   &mut self.explicit_slots[..self.explicit_slot_len]
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               fn setup_search(&mut self, explicit_slot_len: usize) {
     1 ( 0.00%) .          .          .                   self.explicit_slot_len = explicit_slot_len;
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Represents a single transition in a one-pass DFA.
     .          .          .          .           ///
     .          .          .          .           /// The high 21 bits corresponds to the state ID. The bit following corresponds
     .          .          .          .           /// to the special "match wins" flag. The remaining low 42 bits corresponds to
     .          .          .          .           /// the transition epsilons, which contains the slots that should be saved when
     .          .          .          .           /// this transition is followed and the conditional epsilon transitions that
     .          .          .          .           /// must be satisfied in order to follow this transition.
    80 ( 0.00%) .          .          .           #[derive(Clone, Copy, Eq, PartialEq)]
     .          .          .          .           struct Transition(u64);
     .          .          .          .           
     .          .          .          .           impl Transition {
     .          .          .          .               const STATE_ID_BITS: u64 = 21;
     .          .          .          .               const STATE_ID_SHIFT: u64 = 64 - Transition::STATE_ID_BITS;
     .          .          .          .               const STATE_ID_LIMIT: u64 = 1 << Transition::STATE_ID_BITS;
     .          .          .          .               const MATCH_WINS_SHIFT: u64 = 64 - (Transition::STATE_ID_BITS + 1);
     .          .          .          .               const INFO_MASK: u64 = 0x000003FF_FFFFFFFF;
     .          .          .          .           
     .          .          .          .               /// Return a new transition to the given state ID with the given epsilons.
     .          .          .          .               fn new(match_wins: bool, sid: StateID, epsilons: Epsilons) -> Transition {
     .          .          .          .                   let match_wins =
 1,851 ( 0.00%) .          .          .                       if match_wins { 1 << Transition::MATCH_WINS_SHIFT } else { 0 };
 5,994 ( 0.00%) .          .          .                   let sid = sid.as_u64() << Transition::STATE_ID_SHIFT;
13,839 ( 0.00%) .          .          .                   Transition(sid | match_wins | epsilons.0)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this transition points to the DEAD state.
     .          .          .          .               fn is_dead(self) -> bool {
     .          .          .          .                   self.state_id() == DEAD
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return whether this transition has a "match wins" property.
-- line 2612 ----------------------------------------
-- line 2623 ----------------------------------------
     .          .          .          .           
     .          .          .          .               /// Return the "next" state ID that this transition points to.
     .          .          .          .               fn state_id(&self) -> StateID {
     .          .          .          .                   // OK because a Transition has a valid StateID in its upper bits by
     .          .          .          .                   // construction. The cast to usize is also correct, even on 16-bit
     .          .          .          .                   // targets because, again, we know the upper bits is a valid StateID,
     .          .          .          .                   // which can never overflow usize on any supported target.
     .          .          .          .                   StateID::new_unchecked(
17,982 ( 0.01%) .          .          .                       (self.0 >> Transition::STATE_ID_SHIFT).as_usize(),
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set the "next" state ID in this transition.
     .          .          .          .               fn set_state_id(&mut self, sid: StateID) {
 5,994 ( 0.00%) .          .          .                   *self = Transition::new(self.match_wins(), sid, self.epsilons());
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return the epsilons embedded in this transition.
     .          .          .          .               fn epsilons(&self) -> Epsilons {
     .          .          .          .                   Epsilons(self.0 & Transition::INFO_MASK)
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
-- line 2645 ----------------------------------------
-- line 2699 ----------------------------------------
     .          .          .          .               /// no pattern ID and an empty epsilons.
     .          .          .          .               fn is_empty(self) -> bool {
     .          .          .          .                   self.pattern_id().is_none() && self.epsilons().is_empty()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return the pattern ID in this pattern epsilons if one exists.
     .          .          .          .               fn pattern_id(self) -> Option<PatternID> {
     .          .          .          .                   let pid = self.0 >> PatternEpsilons::PATTERN_ID_SHIFT;
   148 ( 0.00%) .          .          .                   if pid == PatternEpsilons::PATTERN_ID_LIMIT {
     .          .          .          .                       None
     .          .          .          .                   } else {
     .          .          .          .                       Some(PatternID::new_unchecked(pid.as_usize()))
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the pattern ID without checking whether it's valid. If this is
     .          .          .          .               /// called and there is no pattern ID in this `PatternEpsilons`, then this
-- line 2715 ----------------------------------------
-- line 2722 ----------------------------------------
     .          .          .          .                   let pid = self.0 >> PatternEpsilons::PATTERN_ID_SHIFT;
     .          .          .          .                   PatternID::new_unchecked(pid.as_usize())
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return a new pattern epsilons with the given pattern ID, but the same
     .          .          .          .               /// epsilons.
     .          .          .          .               fn set_pattern_id(self, pid: PatternID) -> PatternEpsilons {
     .          .          .          .                   PatternEpsilons(
     1 ( 0.00%) .          .          .                       (pid.as_u64() << PatternEpsilons::PATTERN_ID_SHIFT)
     .          .          .          .                           | (self.0 & PatternEpsilons::EPSILONS_MASK),
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return the epsilons part of this pattern epsilons.
     .          .          .          .               fn epsilons(self) -> Epsilons {
     .          .          .          .                   Epsilons(self.0 & PatternEpsilons::EPSILONS_MASK)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return a new pattern epsilons with the given epsilons, but the same
     .          .          .          .               /// pattern ID.
     .          .          .          .               fn set_epsilons(self, epsilons: Epsilons) -> PatternEpsilons {
     .          .          .          .                   PatternEpsilons(
     1 ( 0.00%) .          .          .                       (self.0 & PatternEpsilons::PATTERN_ID_MASK)
     3 ( 0.00%) .          .          .                           | (u64::from(epsilons.0) & PatternEpsilons::EPSILONS_MASK),
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl core::fmt::Debug for PatternEpsilons {
     .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
     .          .          .          .                   if self.is_empty() {
     .          .          .          .                       return write!(f, "N/A");
-- line 2753 ----------------------------------------
-- line 2797 ----------------------------------------
     .          .          .          .           
     .          .          .          .               /// Returns true if this epsilons contains no slots and no assertions.
     .          .          .          .               fn is_empty(self) -> bool {
     .          .          .          .                   self.0 == 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the slot epsilon transitions.
     .          .          .          .               fn slots(self) -> Slots {
   530 ( 0.00%) .          .          .                   Slots((self.0 >> Epsilons::SLOT_SHIFT).low_u32())
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set the slot epsilon transitions.
     .          .          .          .               fn set_slots(self, slots: Slots) -> Epsilons {
     .          .          .          .                   Epsilons(
   528 ( 0.00%) .          .          .                       (u64::from(slots.0) << Epsilons::SLOT_SHIFT)
   264 ( 0.00%) .          .          .                           | (self.0 & Epsilons::LOOK_MASK),
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return the set of look-around assertions in these epsilon transitions.
     .          .          .          .               fn looks(self) -> LookSet {
     .          .          .          .                   LookSet { bits: (self.0 & Epsilons::LOOK_MASK).low_u32() }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set the look-around assertions on these epsilon transitions.
     .          .          .          .               fn set_looks(self, look_set: LookSet) -> Epsilons {
     .          .          .          .                   Epsilons(
   198 ( 0.00%) .          .          .                       (self.0 & Epsilons::SLOT_MASK)
    66 ( 0.00%) .          .          .                           | (u64::from(look_set.bits) & Epsilons::LOOK_MASK),
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl core::fmt::Debug for Epsilons {
     .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
     .          .          .          .                   let mut wrote = false;
     .          .          .          .                   if !self.slots().is_empty() {
-- line 2833 ----------------------------------------
-- line 2884 ----------------------------------------
     .          .          .          .           struct Slots(u32);
     .          .          .          .           
     .          .          .          .           impl Slots {
     .          .          .          .               const LIMIT: usize = 32;
     .          .          .          .           
     .          .          .          .               /// Insert the slot at the given bit index.
     .          .          .          .               fn insert(self, slot: usize) -> Slots {
     .          .          .          .                   debug_assert!(slot < Slots::LIMIT);
   264 ( 0.00%) .          .          .                   Slots(self.0 | (1 << slot.as_u32()))
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Remove the slot at the given bit index.
     .          .          .          .               fn remove(self, slot: usize) -> Slots {
     .          .          .          .                   debug_assert!(slot < Slots::LIMIT);
     .          .          .          .                   Slots(self.0 & !(1 << slot.as_u32()))
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set contains no slots.
     .          .          .          .               fn is_empty(self) -> bool {
     1 ( 0.00%) .          .          .                   self.0 == 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns an iterator over all of the set bits in this set.
     .          .          .          .               fn iter(self) -> SlotsIter {
     .          .          .          .                   SlotsIter { slots: self }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// For the position `at` in the current haystack, copy it to
-- line 2911 ----------------------------------------
-- line 2917 ----------------------------------------
     .          .          .          .               /// The slice *must* correspond only to the explicit slots and the first
     .          .          .          .               /// element of the slice must always correspond to the first explicit slot
     .          .          .          .               /// in the corresponding NFA.
     .          .          .          .               fn apply(
     .          .          .          .                   self,
     .          .          .          .                   at: usize,
     .          .          .          .                   caller_explicit_slots: &mut [Option<NonMaxUsize>],
     .          .          .          .               ) {
     1 ( 0.00%) .          .          .                   if self.is_empty() {
     .          .          .          .                       return;
     .          .          .          .                   }
     .          .          .          .                   let at = NonMaxUsize::new(at);
     .          .          .          .                   for slot in self.iter() {
     .          .          .          .                       if slot >= caller_explicit_slots.len() {
     .          .          .          .                           break;
     .          .          .          .                       }
     .          .          .          .                       caller_explicit_slots[slot] = at;
-- line 2933 ----------------------------------------

38,380 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/onepass.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/visitor.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 110 ----------------------------------------
        .          .          .          .           /// analysis over an `Ast` without using a stack size proportional to the depth
        .          .          .          .           /// of the `Ast`. Namely, this method will instead use constant stack size, but
        .          .          .          .           /// will use heap space proportional to the size of the `Ast`. This may be
        .          .          .          .           /// desirable in cases where the size of `Ast` is proportional to end user
        .          .          .          .           /// input.
        .          .          .          .           ///
        .          .          .          .           /// If the visitor returns an error at any point, then visiting is stopped and
        .          .          .          .           /// the error is returned.
    1,539 ( 0.00%) .          .          .           pub fn visit<V: Visitor>(ast: &Ast, visitor: V) -> Result<V::Output, V::Err> {
        .          .          .          .               HeapVisitor::new().visit(ast, visitor)
    1,458 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           /// HeapVisitor visits every item in an `Ast` recursively using constant stack
        .          .          .          .           /// size and a heap size proportional to the size of the `Ast`.
        .          .          .          .           struct HeapVisitor<'a> {
        .          .          .          .               /// A stack of `Ast` nodes. This is roughly analogous to the call stack
        .          .          .          .               /// used in a typical recursive visitor.
        .          .          .          .               stack: Vec<(&'a Ast, Frame<'a>)>,
        .          .          .          .               /// Similar to the `Ast` stack above, but is used only for character
-- line 128 ----------------------------------------
-- line 194 ----------------------------------------
        .          .          .          .           /// syntax, which is not possible.)
        .          .          .          .           enum ClassInduct<'a> {
        .          .          .          .               Item(&'a ast::ClassSetItem),
        .          .          .          .               BinaryOp(&'a ast::ClassSetBinaryOp),
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'a> HeapVisitor<'a> {
        .          .          .          .               fn new() -> HeapVisitor<'a> {
      729 ( 0.00%) .          .          .                   HeapVisitor { stack: vec![], stack_class: vec![] }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn visit<V: Visitor>(
        .          .          .          .                   &mut self,
        .          .          .          .                   mut ast: &'a Ast,
        .          .          .          .                   mut visitor: V,
        .          .          .          .               ) -> Result<V::Output, V::Err> {
        .          .          .          .                   self.stack.clear();
        .          .          .          .                   self.stack_class.clear();
        .          .          .          .           
        .          .          .          .                   visitor.start();
        .          .          .          .                   loop {
  427,455 ( 0.12%) .          .          .                       visitor.visit_pre(ast)?;
2,518,325 ( 0.72%) 1,297 ( 0.16%) 4 ( 1.23%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre (71,256x)
1,969,692 ( 0.57%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:<regex_syntax::ast::parse::NestLimiter<P> as regex_syntax::ast::visitor::Visitor>::visit_pre (71,256x)
  142,512 ( 0.04%) .          .          .                       if let Some(x) = self.induct(ast, &mut visitor)? {
        .          .          .          .                           let child = x.child();
        .          .          .          .                           self.stack.push((ast, x));
        .          .          .          .                           ast = child;
        .          .          .          .                           continue;
        .          .          .          .                       }
        .          .          .          .                       // No induction means we have a base case, so we can post visit
        .          .          .          .                       // it now.
  209,520 ( 0.06%) .          .          .                       visitor.visit_post(ast)?;
        .          .          .          .           
        .          .          .          .                       // At this point, we now try to pop our call stack until it is
        .          .          .          .                       // either empty or we hit another inductive case.
        .          .          .          .                       loop {
  546,600 ( 0.16%) .          .          .                           let (post_ast, frame) = match self.stack.pop() {
      648 ( 0.00%) .          .          .                               None => return visitor.finish(),
    6,237 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::finish (81x)
        .          .          .          .                               Some((post_ast, frame)) => (post_ast, frame),
        .          .          .          .                           };
        .          .          .          .                           // If this is a concat/alternate, then we might have additional
        .          .          .          .                           // inductive steps to process.
        .          .          .          .                           if let Some(x) = self.pop(frame) {
        .          .          .          .                               match x {
        .          .          .          .                                   Frame::Alternation { .. } => {
        .          .          .          .                                       visitor.visit_alternation_in()?;
-- line 238 ----------------------------------------
-- line 243 ----------------------------------------
        .          .          .          .                                   _ => {}
        .          .          .          .                               }
        .          .          .          .                               ast = x.child();
        .          .          .          .                               self.stack.push((post_ast, x));
        .          .          .          .                               break;
        .          .          .          .                           }
        .          .          .          .                           // Otherwise, we've finished visiting all the child nodes for
        .          .          .          .                           // this AST, so we can post visit it now.
   56,628 ( 0.02%) .          .          .                           visitor.visit_post(post_ast)?;
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Build a stack frame for the given AST if one is needed (which occurs if
        .          .          .          .               /// and only if there are child nodes in the AST). Otherwise, return None.
        .          .          .          .               ///
        .          .          .          .               /// If this visits a class, then the underlying visitor implementation may
        .          .          .          .               /// return an error which will be passed on here.
        .          .          .          .               fn induct<V: Visitor>(
        .          .          .          .                   &mut self,
        .          .          .          .                   ast: &'a Ast,
        .          .          .          .                   visitor: &mut V,
        .          .          .          .               ) -> Result<Option<Frame<'a>>, V::Err> {
  427,536 ( 0.12%) .          .          .                   Ok(match *ast {
        .          .          .          .                       Ast::ClassBracketed(ref x) => {
        .          .          .          .                           self.visit_class(x, visitor)?;
        .          .          .          .                           None
        .          .          .          .                       }
        .          .          .          .                       Ast::Repetition(ref x) => Some(Frame::Repetition(x)),
        .          .          .          .                       Ast::Group(ref x) => Some(Frame::Group(x)),
   63,144 ( 0.02%) .          .          .                       Ast::Concat(ref x) if x.asts.is_empty() => None,
        .          .          .          .                       Ast::Concat(ref x) => {
   31,572 ( 0.01%) .          .          .                           Some(Frame::Concat { head: &x.asts[0], tail: &x.asts[1..] })
        .          .          .          .                       }
    2,048 ( 0.00%) .          .          .                       Ast::Alternation(ref x) if x.asts.is_empty() => None,
        .          .          .          .                       Ast::Alternation(ref x) => Some(Frame::Alternation {
    1,024 ( 0.00%) .          .          .                           head: &x.asts[0],
        .          .          .          .                           tail: &x.asts[1..],
        .          .          .          .                       }),
        .          .          .          .                       _ => None,
        .          .          .          .                   })
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Pops the given frame. If the frame has an additional inductive step,
        .          .          .          .               /// then return it, otherwise return `None`.
        .          .          .          .               fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {
  353,297 ( 0.10%) .          .          .                   match induct {
        .          .          .          .                       Frame::Repetition(_) => None,
        .          .          .          .                       Frame::Group(_) => None,
        .          .          .          .                       Frame::Concat { tail, .. } => {
  140,682 ( 0.04%) .          .          .                           if tail.is_empty() {
        .          .          .          .                               None
        .          .          .          .                           } else {
        .          .          .          .                               Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })
        .          .          .          .                           }
        .          .          .          .                       }
        .          .          .          .                       Frame::Alternation { tail, .. } => {
   32,882 ( 0.01%) .          .          .                           if tail.is_empty() {
        .          .          .          .                               None
        .          .          .          .                           } else {
        .          .          .          .                               Some(Frame::Alternation {
        .          .          .          .                                   head: &tail[0],
        .          .          .          .                                   tail: &tail[1..],
        .          .          .          .                               })
        .          .          .          .                           }
        .          .          .          .                       }
-- line 308 ----------------------------------------
-- line 323 ----------------------------------------
        .          .          .          .                           ast = child;
        .          .          .          .                           continue;
        .          .          .          .                       }
        .          .          .          .                       self.visit_class_post(&ast, visitor)?;
        .          .          .          .           
        .          .          .          .                       // At this point, we now try to pop our call stack until it is
        .          .          .          .                       // either empty or we hit another inductive case.
        .          .          .          .                       loop {
   21,624 ( 0.01%) .          .          .                           let (post_ast, frame) = match self.stack_class.pop() {
        .          .          .          .                               None => return Ok(()),
        .          .          .          .                               Some((post_ast, frame)) => (post_ast, frame),
        .          .          .          .                           };
        .          .          .          .                           // If this is a union or a binary op, then we might have
        .          .          .          .                           // additional inductive steps to process.
        .          .          .          .                           if let Some(x) = self.pop_class(frame) {
        .          .          .          .                               if let ClassFrame::BinaryRHS { ref op, .. } = x {
        .          .          .          .                                   visitor.visit_class_set_binary_op_in(op)?;
-- line 339 ----------------------------------------
-- line 350 ----------------------------------------
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Call the appropriate `Visitor` methods given an inductive step.
        .          .          .          .               fn visit_class_pre<V: Visitor>(
        .          .          .          .                   &self,
        .          .          .          .                   ast: &ClassInduct<'a>,
        .          .          .          .                   visitor: &mut V,
        .          .          .          .               ) -> Result<(), V::Err> {
   22,417 ( 0.01%) .          .          .                   match *ast {
        .          .          .          .                       ClassInduct::Item(item) => {
   19,664 ( 0.01%) .          .          .                           visitor.visit_class_set_item_pre(item)?;
  130,648 ( 0.04%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:<regex_syntax::ast::parse::NestLimiter<P> as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre (4,916x)
   65,027 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre (4,916x)
        .          .          .          .                       }
        .          .          .          .                       ClassInduct::BinaryOp(op) => {
   19,664 ( 0.01%) .          .          .                           visitor.visit_class_set_binary_op_pre(op)?;
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   Ok(())
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Call the appropriate `Visitor` methods given an inductive step.
        .          .          .          .               fn visit_class_post<V: Visitor>(
        .          .          .          .                   &self,
        .          .          .          .                   ast: &ClassInduct<'a>,
        .          .          .          .                   visitor: &mut V,
        .          .          .          .               ) -> Result<(), V::Err> {
    2,384 ( 0.00%) .          .          .                   match *ast {
        .          .          .          .                       ClassInduct::Item(item) => {
   17,876 ( 0.01%) .          .          .                           visitor.visit_class_set_item_post(item)?;
1,618,106 ( 0.47%) 1,570 ( 0.19%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (4,916x)
        .          .          .          .                       }
        .          .          .          .                       ClassInduct::BinaryOp(op) => {
    1,788 ( 0.00%) .          .          .                           visitor.visit_class_set_binary_op_post(op)?;
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   Ok(())
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Build a stack frame for the given class node if one is needed (which
        .          .          .          .               /// occurs if and only if there are child nodes). Otherwise, return None.
        .          .          .          .               fn induct_class(&self, ast: &ClassInduct<'a>) -> Option<ClassFrame<'a>> {
   86,388 ( 0.02%) .          .          .                   match *ast {
        .          .          .          .                       ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) => {
      568 ( 0.00%) .          .          .                           match x.kind {
        .          .          .          .                               ast::ClassSet::Item(ref item) => {
        .          .          .          .                                   Some(ClassFrame::Union { head: item, tail: &[] })
        .          .          .          .                               }
        .          .          .          .                               ast::ClassSet::BinaryOp(ref op) => {
        .          .          .          .                                   Some(ClassFrame::Binary { op })
        .          .          .          .                               }
        .          .          .          .                           }
        .          .          .          .                       }
        .          .          .          .                       ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) => {
    2,100 ( 0.00%) .          .          .                           if x.items.is_empty() {
        .          .          .          .                               None
        .          .          .          .                           } else {
        .          .          .          .                               Some(ClassFrame::Union {
    1,050 ( 0.00%) .          .          .                                   head: &x.items[0],
        .          .          .          .                                   tail: &x.items[1..],
        .          .          .          .                               })
        .          .          .          .                           }
        .          .          .          .                       }
        .          .          .          .                       ClassInduct::BinaryOp(op) => {
        .          .          .          .                           Some(ClassFrame::BinaryLHS { op, lhs: &op.lhs, rhs: &op.rhs })
        .          .          .          .                       }
        .          .          .          .                       _ => None,
-- line 413 ----------------------------------------
-- line 414 ----------------------------------------
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Pops the given frame. If the frame has an additional inductive step,
        .          .          .          .               /// then return it, otherwise return `None`.
        .          .          .          .               fn pop_class(&self, induct: ClassFrame<'a>) -> Option<ClassFrame<'a>> {
        .          .          .          .                   match induct {
        .          .          .          .                       ClassFrame::Union { tail, .. } => {
    8,652 ( 0.00%) .          .          .                           if tail.is_empty() {
        .          .          .          .                               None
        .          .          .          .                           } else {
        .          .          .          .                               Some(ClassFrame::Union {
        .          .          .          .                                   head: &tail[0],
        .          .          .          .                                   tail: &tail[1..],
        .          .          .          .                               })
        .          .          .          .                           }
        .          .          .          .                       }
-- line 430 ----------------------------------------
-- line 437 ----------------------------------------
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'a> Frame<'a> {
        .          .          .          .               /// Perform the next inductive step on this frame and return the next
        .          .          .          .               /// child AST node to visit.
        .          .          .          .               fn child(&self) -> &'a Ast {
        .          .          .          .                   match *self {
    7,540 ( 0.00%) .          .          .                       Frame::Repetition(rep) => &rep.ast,
    2,772 ( 0.00%) .          .          .                       Frame::Group(group) => &group.ast,
        .          .          .          .                       Frame::Concat { head, .. } => head,
        .          .          .          .                       Frame::Alternation { head, .. } => head,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'a> ClassFrame<'a> {
        .          .          .          .               /// Perform the next inductive step on this frame and return the next
-- line 454 ----------------------------------------
-- line 464 ----------------------------------------
        .          .          .          .                           ClassInduct::from_set(rhs)
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'a> ClassInduct<'a> {
        .          .          .          .               fn from_bracketed(ast: &'a ast::ClassBracketed) -> ClassInduct<'a> {
    5,506 ( 0.00%) .          .          .                   ClassInduct::from_set(&ast.kind)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn from_set(ast: &'a ast::ClassSet) -> ClassInduct<'a> {
   11,012 ( 0.00%) .          .          .                   match *ast {
        .          .          .          .                       ast::ClassSet::Item(ref item) => ClassInduct::Item(item),
        .          .          .          .                       ast::ClassSet::BinaryOp(ref op) => ClassInduct::BinaryOp(op),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'a> core::fmt::Debug for ClassFrame<'a> {
        .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-- line 484 ----------------------------------------

1,232,449 ( 0.35%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/visitor.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/state.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 100 ----------------------------------------
    .          .          .          .           /// A DFA state that, at its core, is represented by an ordered set of NFA
    .          .          .          .           /// states.
    .          .          .          .           ///
    .          .          .          .           /// This type is intended to be used only in NFA-to-DFA conversion via powerset
    .          .          .          .           /// construction.
    .          .          .          .           ///
    .          .          .          .           /// It may be cheaply cloned and accessed safely from multiple threads
    .          .          .          .           /// simultaneously.
  566 ( 0.00%) .          .          .           #[derive(Clone, Eq, Hash, PartialEq, PartialOrd, Ord)]
    .          .          .          .           pub(crate) struct State(Arc<[u8]>);
    .          .          .          .           
    .          .          .          .           /// This Borrow impl permits us to lookup any state in a map by its byte
    .          .          .          .           /// representation. This is particularly convenient when one has a StateBuilder
    .          .          .          .           /// and we want to see if a correspondingly equivalent state already exists. If
    .          .          .          .           /// one does exist, then we can reuse the allocation required by StateBuilder
    .          .          .          .           /// without having to convert it into a State first.
    .          .          .          .           impl core::borrow::Borrow<[u8]> for State {
    .          .          .          .               fn borrow(&self) -> &[u8] {
   51 ( 0.00%) .          .          .                   &*self.0
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl core::fmt::Debug for State {
    .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    .          .          .          .                   f.debug_tuple("State").field(&self.repr()).finish()
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// For docs on these routines, see the internal Repr and ReprVec types below.
    .          .          .          .           impl State {
2,044 ( 0.00%) .          .          .               pub(crate) fn dead() -> State {
    .          .          .          .                   StateBuilderEmpty::new().into_matches().into_nfa().to_state()
2,920 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn is_match(&self) -> bool {
    .          .          .          .                   self.repr().is_match()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn is_from_word(&self) -> bool {
    .          .          .          .                   self.repr().is_from_word()
    .          .          .          .               }
-- line 140 ----------------------------------------
-- line 164 ----------------------------------------
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               #[cfg(all(test, not(miri)))]
    .          .          .          .               pub(crate) fn iter_match_pattern_ids<F: FnMut(PatternID)>(&self, f: F) {
    .          .          .          .                   self.repr().iter_match_pattern_ids(f)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn iter_nfa_state_ids<F: FnMut(StateID)>(&self, f: F) {
1,090 ( 0.00%) .          .          .                   self.repr().iter_nfa_state_ids(f)
49,748 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/state.rs:regex_automata::util::determinize::state::Repr::iter_nfa_state_ids (218x)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn memory_usage(&self) -> usize {
    .          .          .          .                   self.0.len()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               fn repr(&self) -> Repr<'_> {
  218 ( 0.00%) .          .          .                   Repr(&*self.0)
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// A state builder that represents an empty state.
    .          .          .          .           ///
    .          .          .          .           /// This is a useful "initial condition" for state construction. It has no
    .          .          .          .           /// NFA state IDs, no assertions set and no pattern IDs. No allocations are
    .          .          .          .           /// made when new() is called. Its main use is for being converted into a
    .          .          .          .           /// builder that can capture assertions and pattern IDs.
    .          .          .          .           #[derive(Clone, Debug)]
    .          .          .          .           pub(crate) struct StateBuilderEmpty(Vec<u8>);
    .          .          .          .           
    .          .          .          .           /// For docs on these routines, see the internal Repr and ReprVec types below.
    .          .          .          .           impl StateBuilderEmpty {
    .          .          .          .               pub(crate) fn new() -> StateBuilderEmpty {
1,227 ( 0.00%) .          .          .                   StateBuilderEmpty(alloc::vec![])
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn into_matches(mut self) -> StateBuilderMatches {
    .          .          .          .                   self.0.extend_from_slice(&[0, 0, 0, 0, 0, 0, 0, 0, 0]);
1,069 ( 0.00%) .          .          .                   StateBuilderMatches(self.0)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               fn clear(&mut self) {
    .          .          .          .                   self.0.clear();
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn capacity(&self) -> usize {
    .          .          .          .                   self.0.capacity()
-- line 209 ----------------------------------------
-- line 222 ----------------------------------------
    .          .          .          .                   f.debug_tuple("StateBuilderMatches").field(&self.repr()).finish()
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// For docs on these routines, see the internal Repr and ReprVec types below.
    .          .          .          .           impl StateBuilderMatches {
    .          .          .          .               pub(crate) fn into_nfa(mut self) -> StateBuilderNFA {
    .          .          .          .                   self.repr_vec().close_match_pattern_ids();
1,295 ( 0.00%) .          .          .                   StateBuilderNFA { repr: self.0, prev_nfa_state_id: StateID::ZERO }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn set_is_from_word(&mut self) {
    .          .          .          .                   self.repr_vec().set_is_from_word()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn set_is_half_crlf(&mut self) {
    .          .          .          .                   self.repr_vec().set_is_half_crlf()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn look_have(&self) -> LookSet {
  470 ( 0.00%) .          .          .                   LookSet::read_repr(&self.0[1..])
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn set_look_have(
    .          .          .          .                   &mut self,
    .          .          .          .                   set: impl FnMut(LookSet) -> LookSet,
    .          .          .          .               ) {
    .          .          .          .                   self.repr_vec().set_look_have(set)
    .          .          .          .               }
    .          .          .          .           
    9 ( 0.00%) .          .          .               pub(crate) fn add_match_pattern_id(&mut self, pid: PatternID) {
    .          .          .          .                   self.repr_vec().add_match_pattern_id(pid)
   12 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               fn repr(&self) -> Repr<'_> {
    .          .          .          .                   Repr(&self.0)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               fn repr_vec(&mut self) -> ReprVec<'_> {
    .          .          .          .                   ReprVec(&mut self.0)
    .          .          .          .               }
-- line 262 ----------------------------------------
-- line 290 ----------------------------------------
    .          .          .          .           
    .          .          .          .               pub(crate) fn clear(self) -> StateBuilderEmpty {
    .          .          .          .                   let mut builder = StateBuilderEmpty(self.repr);
    .          .          .          .                   builder.clear();
    .          .          .          .                   builder
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn look_need(&self) -> LookSet {
  518 ( 0.00%) .          .          .                   self.repr().look_need()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn set_look_have(
    .          .          .          .                   &mut self,
    .          .          .          .                   set: impl FnMut(LookSet) -> LookSet,
    .          .          .          .               ) {
    .          .          .          .                   self.repr_vec().set_look_have(set)
    .          .          .          .               }
-- line 306 ----------------------------------------
-- line 389 ----------------------------------------
    .          .          .          .               /// Returns true if and only if this is a match state.
    .          .          .          .               ///
    .          .          .          .               /// If callers have added pattern IDs to this state, then callers MUST set
    .          .          .          .               /// this state as a match state explicitly. However, as a special case,
    .          .          .          .               /// states that are marked as match states but with no pattern IDs, then
    .          .          .          .               /// the state is treated as if it had a single pattern ID equivalent to
    .          .          .          .               /// PatternID::ZERO.
    .          .          .          .               fn is_match(&self) -> bool {
  879 ( 0.00%) .          .          .                   self.0[0] & (1 << 0) > 0
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns true if and only if this state has had at least one pattern
    .          .          .          .               /// ID added to it.
    .          .          .          .               ///
    .          .          .          .               /// This is an internal-only flag that permits the representation to save
    .          .          .          .               /// space in the common case of an NFA with one pattern in it. In that
    .          .          .          .               /// case, a match state can only ever have exactly one pattern ID:
    .          .          .          .               /// PatternID::ZERO. So there's no need to represent it.
    .          .          .          .               fn has_pattern_ids(&self) -> bool {
3,047 ( 0.00%) .          .          .                   self.0[0] & (1 << 1) > 0
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns true if and only if this state is marked as having been created
    .          .          .          .               /// from a transition over a word byte. This is useful for checking whether
    .          .          .          .               /// a word boundary assertion is true or not, which requires look-behind
    .          .          .          .               /// (whether the current state came from a word byte or not) and look-ahead
    .          .          .          .               /// (whether the transition byte is a word byte or not).
    .          .          .          .               ///
-- line 416 ----------------------------------------
-- line 423 ----------------------------------------
    .          .          .          .                   self.0[0] & (1 << 2) > 0
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns true if and only if this state is marked as being inside of a
    .          .          .          .               /// CRLF terminator. In the forward direction, this means the state was
    .          .          .          .               /// created after seeing a `\r`. In the reverse direction, this means the
    .          .          .          .               /// state was created after seeing a `\n`.
    .          .          .          .               fn is_half_crlf(&self) -> bool {
   80 ( 0.00%) .          .          .                   self.0[0] & (1 << 3) > 0
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// The set of look-behind assertions that were true in the transition that
    .          .          .          .               /// created this state.
    .          .          .          .               ///
    .          .          .          .               /// Generally, this should be empty if 'look_need' is empty, since there is
    .          .          .          .               /// no reason to track which look-behind assertions are true if the state
    .          .          .          .               /// has no conditional epsilon transitions.
-- line 439 ----------------------------------------
-- line 515 ----------------------------------------
    .          .          .          .                       // This is OK since we only ever serialize valid PatternIDs to
    .          .          .          .                       // states. And since pattern IDs can never exceed a usize, the
    .          .          .          .                       // unwrap is OK.
    .          .          .          .                       f(PatternID::new_unchecked(usize::try_from(pid).unwrap()));
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Calls the given function on every NFA state ID in this state.
1,526 ( 0.00%) .          .          .               fn iter_nfa_state_ids<F: FnMut(StateID)>(&self, mut f: F) {
  436 ( 0.00%) .          .          .                   let mut sids = &self.0[self.pattern_offset_end()..];
    .          .          .          .                   let mut prev = 0i32;
1,206 ( 0.00%) .          .          .                   while !sids.is_empty() {
    .          .          .          .                       let (delta, nr) = read_vari32(sids);
    .          .          .          .                       sids = &sids[nr..];
  988 ( 0.00%) .          .          .                       let sid = prev + delta;
    .          .          .          .                       prev = sid;
    .          .          .          .                       // This is OK since we only ever serialize valid StateIDs to
    .          .          .          .                       // states. And since state IDs can never exceed an isize, they must
    .          .          .          .                       // always be able to fit into a usize, and thus cast is OK.
    .          .          .          .                       f(StateID::new_unchecked(sid.as_usize()))
    .          .          .          .                   }
1,744 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the offset into this state's representation where the pattern
    .          .          .          .               /// IDs end and the NFA state IDs begin.
    .          .          .          .               fn pattern_offset_end(&self) -> usize {
    .          .          .          .                   let encoded = self.encoded_pattern_len();
    .          .          .          .                   if encoded == 0 {
    .          .          .          .                       return 9;
    .          .          .          .                   }
-- line 544 ----------------------------------------
-- line 548 ----------------------------------------
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the total number of *encoded* pattern IDs in this state.
    .          .          .          .               ///
    .          .          .          .               /// This may return 0 even when this is a match state, since the pattern
    .          .          .          .               /// ID `PatternID::ZERO` is not encoded when it's the only pattern ID in
    .          .          .          .               /// the match state (the overwhelming common case).
    .          .          .          .               fn encoded_pattern_len(&self) -> usize {
  218 ( 0.00%) .          .          .                   if !self.has_pattern_ids() {
    .          .          .          .                       return 0;
    .          .          .          .                   }
    .          .          .          .                   // This unwrap is OK since the total number of patterns is always
    .          .          .          .                   // guaranteed to fit into a usize.
    .          .          .          .                   usize::try_from(wire::read_u32(&self.0[9..13])).unwrap()
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
-- line 564 ----------------------------------------
-- line 588 ----------------------------------------
    .          .          .          .           struct ReprVec<'a>(&'a mut Vec<u8>);
    .          .          .          .           
    .          .          .          .           impl<'a> ReprVec<'a> {
    .          .          .          .               /// Set this state as a match state.
    .          .          .          .               ///
    .          .          .          .               /// This should not be exposed explicitly outside of this module. It is
    .          .          .          .               /// set automatically when a pattern ID is added.
    .          .          .          .               fn set_is_match(&mut self) {
    6 ( 0.00%) .          .          .                   self.0[0] |= 1 << 0;
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Set that this state has pattern IDs explicitly written to it.
    .          .          .          .               ///
    .          .          .          .               /// This should not be exposed explicitly outside of this module. This is
    .          .          .          .               /// used internally as a space saving optimization. Namely, if the state
    .          .          .          .               /// is a match state but does not have any pattern IDs written to it,
    .          .          .          .               /// then it is automatically inferred to have a pattern ID of ZERO.
-- line 604 ----------------------------------------
-- line 621 ----------------------------------------
    .          .          .          .               /// In the reverse direction, this should be set when a `\n` has been seen.
    .          .          .          .               fn set_is_half_crlf(&mut self) {
    .          .          .          .                   self.0[0] |= 1 << 3;
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// The set of look-behind assertions that were true in the transition that
    .          .          .          .               /// created this state.
    .          .          .          .               fn look_have(&self) -> LookSet {
   40 ( 0.00%) .          .          .                   self.repr().look_have()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// The set of look-around (both behind and ahead) assertions that appear
    .          .          .          .               /// at least once in this state's set of NFA states.
    .          .          .          .               fn look_need(&self) -> LookSet {
    .          .          .          .                   self.repr().look_need()
    .          .          .          .               }
    .          .          .          .           
-- line 637 ----------------------------------------
-- line 660 ----------------------------------------
    .          .          .          .                   // not write either the pattern ID or the number of patterns encoded.
    .          .          .          .                   // Instead, all we do is set the 'is_match' bit on this state. Overall,
    .          .          .          .                   // this saves 8 bytes per match state for the overwhelming majority of
    .          .          .          .                   // match states.
    .          .          .          .                   //
    .          .          .          .                   // In order to know whether pattern IDs need to be explicitly read or
    .          .          .          .                   // not, we use another internal-only bit, 'has_pattern_ids', to
    .          .          .          .                   // indicate whether they have been explicitly written or not.
    6 ( 0.00%) .          .          .                   if !self.repr().has_pattern_ids() {
    6 ( 0.00%) .          .          .                       if pid == PatternID::ZERO {
    .          .          .          .                           self.set_is_match();
    .          .          .          .                           return;
    .          .          .          .                       }
    .          .          .          .                       // Make room for 'close_match_pattern_ids' to write the total
    .          .          .          .                       // number of pattern IDs written.
    .          .          .          .                       self.0.extend(core::iter::repeat(0).take(PatternID::SIZE));
    .          .          .          .                       self.set_has_pattern_ids();
    .          .          .          .                       // If this was already a match state, then the only way that's
-- line 677 ----------------------------------------
-- line 695 ----------------------------------------
    .          .          .          .               /// Once this is called, callers must not call it or 'add_match_pattern_id'
    .          .          .          .               /// again.
    .          .          .          .               ///
    .          .          .          .               /// This should not be exposed explicitly outside of this module. It
    .          .          .          .               /// should be called only when converting a StateBuilderMatches into a
    .          .          .          .               /// StateBuilderNFA.
    .          .          .          .               fn close_match_pattern_ids(&mut self) {
    .          .          .          .                   // If we never wrote any pattern IDs, then there's nothing to do here.
  551 ( 0.00%) .          .          .                   if !self.repr().has_pattern_ids() {
    .          .          .          .                       return;
    .          .          .          .                   }
    .          .          .          .                   let patsize = PatternID::SIZE;
    .          .          .          .                   let pattern_bytes = self.0.len() - 13;
    .          .          .          .                   // Every pattern ID uses 4 bytes, so number of bytes should be
    .          .          .          .                   // divisible by 4.
    .          .          .          .                   assert_eq!(pattern_bytes % patsize, 0);
    .          .          .          .                   // This unwrap is OK since we are guaranteed that the maximum number
-- line 711 ----------------------------------------
-- line 713 ----------------------------------------
    .          .          .          .                   let count32 = u32::try_from(pattern_bytes / patsize).unwrap();
    .          .          .          .                   wire::NE::write_u32(count32, &mut self.0[9..13]);
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Add an NFA state ID to this state. The order in which NFA states are
    .          .          .          .               /// added matters. It is the caller's responsibility to ensure that
    .          .          .          .               /// duplicate NFA state IDs are not added.
    .          .          .          .               fn add_nfa_state_id(&mut self, prev: &mut StateID, sid: StateID) {
1,994 ( 0.00%) .          .          .                   let delta = sid.as_i32() - prev.as_i32();
    .          .          .          .                   write_vari32(self.0, delta);
  997 ( 0.00%) .          .          .                   *prev = sid;
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Return a read-only view of this state's representation.
    .          .          .          .               fn repr(&self) -> Repr<'_> {
    .          .          .          .                   Repr(self.0.as_slice())
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Write a signed 32-bit integer using zig-zag encoding.
    .          .          .          .           ///
    .          .          .          .           /// https://developers.google.com/protocol-buffers/docs/encoding#varints
    .          .          .          .           fn write_vari32(data: &mut Vec<u8>, n: i32) {
  997 ( 0.00%) .          .          .               let mut un = n.to_bits() << 1;
1,994 ( 0.00%) .          .          .               if n < 0 {
    .          .          .          .                   un = !un;
    .          .          .          .               }
    .          .          .          .               write_varu32(data, un)
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Read a signed 32-bit integer using zig-zag encoding. Also, return the
    .          .          .          .           /// number of bytes read.
    .          .          .          .           ///
    .          .          .          .           /// https://developers.google.com/protocol-buffers/docs/encoding#varints
    .          .          .          .           fn read_vari32(data: &[u8]) -> (i32, usize) {
    .          .          .          .               let (un, i) = read_varu32(data);
    .          .          .          .               let mut n = i32::from_bits(un >> 1);
2,964 ( 0.00%) .          .          .               if un & 1 != 0 {
    .          .          .          .                   n = !n;
    .          .          .          .               }
    .          .          .          .               (n, i)
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Write an unsigned 32-bit integer as a varint. In essence, `n` is written
    .          .          .          .           /// as a sequence of bytes where all bytes except for the last one have the
    .          .          .          .           /// most significant bit set. The least significant 7 bits correspond to the
    .          .          .          .           /// actual bits of `n`. So in the worst case, a varint uses 5 bytes, but in
    .          .          .          .           /// very common cases, it uses fewer than 4.
    .          .          .          .           ///
    .          .          .          .           /// https://developers.google.com/protocol-buffers/docs/encoding#varints
    .          .          .          .           fn write_varu32(data: &mut Vec<u8>, mut n: u32) {
2,968 ( 0.00%) .          .          .               while n >= 0b1000_0000 {
   18 ( 0.00%) .          .          .                   data.push(n.low_u8() | 0b1000_0000);
   18 ( 0.00%) .          .          .                   n >>= 7;
    .          .          .          .               }
    .          .          .          .               data.push(n.low_u8());
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Read an unsigned 32-bit varint. Also, return the number of bytes read.
    .          .          .          .           ///
    .          .          .          .           /// https://developers.google.com/protocol-buffers/docs/encoding#varints
    .          .          .          .           fn read_varu32(data: &[u8]) -> (u32, usize) {
    .          .          .          .               // N.B. We can assume correctness here since we know that all varuints are
    .          .          .          .               // written with write_varu32. Hence, the 'as' uses and unchecked arithmetic
    .          .          .          .               // is all okay.
    .          .          .          .               let mut n: u32 = 0;
    .          .          .          .               let mut shift: u32 = 0;
  998 ( 0.00%) .          .          .               for (i, &b) in data.iter().enumerate() {
1,996 ( 0.00%) .          .          .                   if b < 0b1000_0000 {
  988 ( 0.00%) .          .          .                       return (n | (u32::from(b) << shift), i + 1);
    .          .          .          .                   }
   30 ( 0.00%) .          .          .                   n |= (u32::from(b) & 0b0111_1111) << shift;
   10 ( 0.00%) .          .          .                   shift += 7;
    .          .          .          .               }
    .          .          .          .               (0, 0)
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Push a native-endian encoded `n` on to `dst`.
    .          .          .          .           fn write_u32(dst: &mut Vec<u8>, n: u32) {
    .          .          .          .               use crate::util::wire::NE;
    .          .          .          .           
-- line 793 ----------------------------------------

3,816 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/state.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 448 ----------------------------------------
      .          .          .          .               ///     None,
      .          .          .          .               ///     re.find(&mut cache, b"\nabc\n"),
      .          .          .          .               /// );
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn look_matcher(mut self, m: LookMatcher) -> Config {
      .          .          .          .                   self.look_matcher = Some(m);
    104 ( 0.00%) .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Whether to compile an unanchored prefix into this NFA.
      .          .          .          .               ///
      .          .          .          .               /// This is enabled by default. It is made available for tests only to make
      .          .          .          .               /// it easier to unit test the output of the compiler.
      .          .          .          .               #[cfg(test)]
      .          .          .          .               fn unanchored_prefix(mut self, yes: bool) -> Config {
-- line 464 ----------------------------------------
-- line 468 ----------------------------------------
      .          .          .          .           
      .          .          .          .               /// Returns whether this configuration has enabled UTF-8 mode.
      .          .          .          .               pub fn get_utf8(&self) -> bool {
      .          .          .          .                   self.utf8.unwrap_or(true)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns whether this configuration has enabled reverse NFA compilation.
      .          .          .          .               pub fn get_reverse(&self) -> bool {
    175 ( 0.00%) .          .          .                   self.reverse.unwrap_or(false)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the configured NFA size limit, if it exists, in the number of
      .          .          .          .               /// bytes of heap used.
      .          .          .          .               pub fn get_nfa_size_limit(&self) -> Option<usize> {
    350 ( 0.00%) .          .          .                   self.nfa_size_limit.unwrap_or(None)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return whether NFA shrinking is enabled.
      .          .          .          .               pub fn get_shrink(&self) -> bool {
      .          .          .          .                   self.shrink.unwrap_or(false)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return whether NFA compilation is configured to produce capture states.
-- line 490 ----------------------------------------
-- line 519 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Overwrite the default configuration such that the options in `o` are
      .          .          .          .               /// always used. If an option in `o` is not set, then the corresponding
      .          .          .          .               /// option in `self` is used. If it's not set in `self` either, then it
      .          .          .          .               /// remains not set.
      .          .          .          .               pub(crate) fn overwrite(&self, o: Config) -> Config {
      .          .          .          .                   Config {
     13 ( 0.00%) .          .          .                       utf8: o.utf8.or(self.utf8),
      .          .          .          .                       reverse: o.reverse.or(self.reverse),
     13 ( 0.00%) .          .          .                       nfa_size_limit: o.nfa_size_limit.or(self.nfa_size_limit),
      .          .          .          .                       shrink: o.shrink.or(self.shrink),
      .          .          .          .                       which_captures: o.which_captures.or(self.which_captures),
     13 ( 0.00%) .          .          .                       look_matcher: o.look_matcher.or_else(|| self.look_matcher.clone()),
      .          .          .          .                       #[cfg(test)]
      .          .          .          .                       unanchored_prefix: o.unanchored_prefix.or(self.unanchored_prefix),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A configuration indicating which kinds of
      .          .          .          .           /// [`State::Capture`](crate::nfa::thompson::State::Capture) states to include.
-- line 540 ----------------------------------------
-- line 571 ----------------------------------------
      .          .          .          .                   WhichCaptures::All
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl WhichCaptures {
      .          .          .          .               /// Returns true if this configuration indicates that no capture states
      .          .          .          .               /// should be produced in an NFA.
      .          .          .          .               pub fn is_none(&self) -> bool {
     94 ( 0.00%) .          .          .                   matches!(*self, WhichCaptures::None)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if this configuration indicates that some capture states
      .          .          .          .               /// should be added to an NFA. Note that this might only include capture
      .          .          .          .               /// states for implicit capture groups.
      .          .          .          .               pub fn is_any(&self) -> bool {
      .          .          .          .                   !self.is_none()
      .          .          .          .               }
-- line 587 ----------------------------------------
-- line 710 ----------------------------------------
      .          .          .          .               trie_state: RefCell<RangeTrie>,
      .          .          .          .               /// State used for caching common suffixes when compiling reverse UTF-8
      .          .          .          .               /// automata (for Unicode character classes).
      .          .          .          .               utf8_suffix: RefCell<Utf8SuffixMap>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Compiler {
      .          .          .          .               /// Create a new NFA builder with its default configuration.
     65 ( 0.00%) .          .          .               pub fn new() -> Compiler {
  5,580 ( 0.00%) .          .          .                   Compiler {
    674 ( 0.00%) .          .          .                       parser: ParserBuilder::new(),
    405 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/parser.rs:regex_syntax::parser::ParserBuilder::new (81x)
      .          .          .          .                       config: Config::default(),
      .          .          .          .                       builder: RefCell::new(Builder::new()),
      .          .          .          .                       utf8_state: RefCell::new(Utf8State::new()),
      .          .          .          .                       trie_state: RefCell::new(RangeTrie::new()),
      .          .          .          .                       utf8_suffix: RefCell::new(Utf8SuffixMap::new(1000)),
      .          .          .          .                   }
     78 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given regular expression pattern into an NFA.
      .          .          .          .               ///
      .          .          .          .               /// If there was a problem parsing the regex, then that error is returned.
      .          .          .          .               ///
      .          .          .          .               /// Otherwise, if there was a problem building the NFA, then an error is
      .          .          .          .               /// returned. The only error that can occur is if the compiled regex would
      .          .          .          .               /// exceed the size limits configured on this builder, or if any part of
-- line 735 ----------------------------------------
-- line 829 ----------------------------------------
      .          .          .          .               /// let mut caps = re.create_captures();
      .          .          .          .               /// let expected = Some(Match::must(0, 3..4));
      .          .          .          .               /// re.captures(&mut cache, "!@#A#@!", &mut caps);
      .          .          .          .               /// assert_eq!(expected, caps.get_match());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn build_from_hir(&self, expr: &Hir) -> Result<NFA, BuildError> {
     13 ( 0.00%) .          .          .                   self.build_many_from_hir(&[expr])
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given high level intermediate representations of regular
      .          .          .          .               /// expressions into a single NFA.
      .          .          .          .               ///
      .          .          .          .               /// When matches are returned, the pattern ID corresponds to the index of
      .          .          .          .               /// the pattern in the slice given.
      .          .          .          .               ///
-- line 845 ----------------------------------------
-- line 873 ----------------------------------------
      .          .          .          .               /// assert_eq!(expected, caps.get_match());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn build_many_from_hir<H: Borrow<Hir>>(
      .          .          .          .                   &self,
      .          .          .          .                   exprs: &[H],
      .          .          .          .               ) -> Result<NFA, BuildError> {
    444 ( 0.00%) .          .          .                   self.compile(exprs)
102,524,736 (29.51%) 224,173 (27.67%) 102 (31.48%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::compile (175x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Apply the given NFA configuration options to this builder.
      .          .          .          .               ///
      .          .          .          .               /// # Example
      .          .          .          .               ///
      .          .          .          .               /// ```
      .          .          .          .               /// use regex_automata::nfa::thompson::NFA;
      .          .          .          .               ///
      .          .          .          .               /// let config = NFA::config().nfa_size_limit(Some(1_000));
      .          .          .          .               /// let nfa = NFA::compiler().configure(config).build(r"(?-u)\w")?;
      .          .          .          .               /// assert_eq!(nfa.pattern_len(), 1);
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
     13 ( 0.00%) .          .          .               pub fn configure(&mut self, config: Config) -> &mut Compiler {
  1,523 ( 0.00%) .          .          .                   self.config = self.config.overwrite(config);
      .          .          .          .                   self
     13 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the syntax configuration for this builder using
      .          .          .          .               /// [`syntax::Config`](crate::util::syntax::Config).
      .          .          .          .               ///
      .          .          .          .               /// This permits setting things like case insensitivity, Unicode and multi
      .          .          .          .               /// line mode.
      .          .          .          .               ///
      .          .          .          .               /// This syntax configuration only applies when an NFA is built directly
-- line 908 ----------------------------------------
-- line 931 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Compiler {
      .          .          .          .               /// Compile the sequence of HIR expressions given. Pattern IDs are
      .          .          .          .               /// allocated starting from 0, in correspondence with the slice given.
      .          .          .          .               ///
      .          .          .          .               /// It is legal to provide an empty slice. In that case, the NFA returned
      .          .          .          .               /// has no patterns and will never match anything.
  1,575 ( 0.00%) .          .          .               fn compile<H: Borrow<Hir>>(&self, exprs: &[H]) -> Result<NFA, BuildError> {
    350 ( 0.00%) .          .          .                   if exprs.len() > PatternID::LIMIT {
      .          .          .          .                       return Err(BuildError::too_many_patterns(exprs.len()));
      .          .          .          .                   }
    269 ( 0.00%) .          .          .                   if self.config.get_reverse()
      .          .          .          .                       && self.config.get_which_captures().is_any()
      .          .          .          .                   {
      .          .          .          .                       return Err(BuildError::unsupported_captures());
      .          .          .          .                   }
      .          .          .          .           
    350 ( 0.00%) .          .          .                   self.builder.borrow_mut().clear();
  5,425 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::clear (175x)
      .          .          .          .                   self.builder.borrow_mut().set_utf8(self.config.get_utf8());
      .          .          .          .                   self.builder.borrow_mut().set_reverse(self.config.get_reverse());
      .          .          .          .                   self.builder
      .          .          .          .                       .borrow_mut()
      .          .          .          .                       .set_look_matcher(self.config.get_look_matcher());
      .          .          .          .                   self.builder
      .          .          .          .                       .borrow_mut()
      .          .          .          .                       .set_size_limit(self.config.get_nfa_size_limit())?;
      .          .          .          .           
      .          .          .          .                   // We always add an unanchored prefix unless we were specifically told
      .          .          .          .                   // not to (for tests only), or if we know that the regex is anchored
      .          .          .          .                   // for all matches. When an unanchored prefix is not added, then the
      .          .          .          .                   // NFA's anchored and unanchored start states are equivalent.
      .          .          .          .                   let all_anchored = exprs.iter().all(|e| {
    175 ( 0.00%) .          .          .                       let props = e.borrow().properties();
    350 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::properties (175x)
    350 ( 0.00%) .          .          .                       if self.config.get_reverse() {
      .          .          .          .                           props.look_set_suffix().contains(hir::Look::End)
      .          .          .          .                       } else {
      .          .          .          .                           props.look_set_prefix().contains(hir::Look::Start)
      .          .          .          .                       }
      .          .          .          .                   });
      .          .          .          .                   let anchored = !self.config.get_unanchored_prefix() || all_anchored;
      .          .          .          .                   let unanchored_prefix = if anchored {
      .          .          .          .                       self.c_empty()?
      .          .          .          .                   } else {
    880 ( 0.00%) .          .          .                       self.c_at_least(&Hir::dot(hir::Dot::AnyByte), false, 0)?
 83,548 ( 0.02%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (110x)
 39,420 ( 0.01%) 40 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::dot (110x)
    330 ( 0.00%) .          .          .                   };
 28,140 ( 0.01%) 1 ( 0.00%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (110x)
      .          .          .          .           
      .          .          .          .                   let compiled = self.c_alt_iter(exprs.iter().map(|e| {
      .          .          .          .                       let _ = self.start_pattern()?;
    700 ( 0.00%) .          .          .                       let one = self.c_cap(0, None, e.borrow())?;
83,239,373 (23.96%) 191,262 (23.61%) 90 (27.78%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap (175x)
      .          .          .          .                       let match_state_id = self.add_match()?;
      .          .          .          .                       self.patch(one.end, match_state_id)?;
      .          .          .          .                       let _ = self.finish_pattern(one.start)?;
      .          .          .          .                       Ok(ThompsonRef { start: one.start, end: match_state_id })
      .          .          .          .                   }))?;
      .          .          .          .                   self.patch(unanchored_prefix.end, compiled.start)?;
    700 ( 0.00%) .          .          .                   let nfa = self
19,010,900 ( 5.47%) 32,738 ( 4.04%) 11 ( 3.40%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build (175x)
      .          .          .          .                       .builder
      .          .          .          .                       .borrow_mut()
      .          .          .          .                       .build(compiled.start, unanchored_prefix.start)?;
      .          .          .          .           
      .          .          .          .                   debug!("HIR-to-NFA compilation complete, config: {:?}", self.config);
    525 ( 0.00%) .          .          .                   Ok(nfa)
  1,575 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile an arbitrary HIR expression.
223,884 ( 0.06%) .          .          .               fn c(&self, expr: &Hir) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   use regex_syntax::hir::{Class, HirKind::*};
      .          .          .          .           
309,994 ( 0.09%) .          .          .                   match *expr.kind() {
    570 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::kind (285x)
      .          .          .          .                       Empty => self.c_empty(),
 17,662 ( 0.01%) .          .          .                       Literal(hir::Literal(ref bytes)) => self.c_literal(bytes),
      .          .          .          .                       Class(Class::Bytes(ref c)) => self.c_byte_class(c),
      .          .          .          .                       Class(Class::Unicode(ref c)) => self.c_unicode_class(c),
    245 ( 0.00%) .          .          .                       Look(ref look) => self.c_look(look),
      .          .          .          .                       Repetition(ref rep) => self.c_repetition(rep),
 16,632 ( 0.00%) .          .          .                       Capture(ref c) => self.c_cap(c.index, c.name.as_deref(), &c.sub),
86,151,395 (24.79%) 201,207 (24.83%) 88 (27.16%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (1,386x)
 44,337 ( 0.01%) .          .          .                       Concat(ref es) => self.c_concat(es.iter().map(|e| self.c(e))),
82,888,789 (23.86%) 191,126 (23.59%) 90 (27.78%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (2,839x)
      .          .          .          .                       Alternation(ref es) => self.c_alt_slice(es),
      .          .          .          .                   }
185,632 ( 0.05%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile a concatenation of the sub-expressions yielded by the given
      .          .          .          .               /// iterator. If the iterator yields no elements, then this compiles down
      .          .          .          .               /// to an "empty" state that always matches.
      .          .          .          .               ///
      .          .          .          .               /// If the compiler is in reverse mode, then the expressions given are
      .          .          .          .               /// automatically compiled in reverse.
  3,096 ( 0.00%) .          .          .               fn c_concat<I>(&self, mut it: I) -> Result<ThompsonRef, BuildError>
      .          .          .          .               where
      .          .          .          .                   I: DoubleEndedIterator<Item = Result<ThompsonRef, BuildError>>,
      .          .          .          .               {
188,998 ( 0.05%) .          .          .                   let first = if self.is_reverse() { it.next_back() } else { it.next() };
203,246 ( 0.06%) 536 ( 0.07%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (344x)
  8,406 ( 0.00%) .          .          .                   let ThompsonRef { start, mut end } = match first {
      .          .          .          .                       Some(result) => result?,
      .          .          .          .                       None => return self.c_empty(),
      .          .          .          .                   };
      .          .          .          .                   loop {
      .          .          .          .                       let next =
435,527 ( 0.13%) .          .          .                           if self.is_reverse() { it.next_back() } else { it.next() };
114,583 ( 0.03%) 342 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (236x)
 16,852 ( 0.00%) .          .          .                       let compiled = match next {
      .          .          .          .                           Some(result) => result?,
      .          .          .          .                           None => break,
      .          .          .          .                       };
      .          .          .          .                       self.patch(end, compiled.start)?;
      .          .          .          .                       end = compiled.end;
      .          .          .          .                   }
 52,136 ( 0.02%) .          .          .                   Ok(ThompsonRef { start, end })
  2,752 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile an alternation of the given HIR values.
      .          .          .          .               ///
      .          .          .          .               /// This is like 'c_alt_iter', but it accepts a slice of HIR values instead
      .          .          .          .               /// of an iterator of compiled NFA subgraphs. The point of accepting a
      .          .          .          .               /// slice here is that it opens up some optimization opportunities. For
      .          .          .          .               /// example, if all of the HIR values are literals, then this routine might
      .          .          .          .               /// re-shuffle them to make NFA epsilon closures substantially faster.
      .          .          .          .               fn c_alt_slice(&self, exprs: &[Hir]) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   // self.c_alt_iter(exprs.iter().map(|e| self.c(e)))
      .          .          .          .                   let literal_count = exprs
      .          .          .          .                       .iter()
      .          .          .          .                       .filter(|e| {
166,625 ( 0.05%) .          .          .                           matches!(*e.kind(), hir::HirKind::Literal(hir::Literal(_)))
      4 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::kind (2x)
      .          .          .          .                       })
      .          .          .          .                       .count();
  4,268 ( 0.00%) .          .          .                   if literal_count <= 1 || literal_count < exprs.len() {
 26,995 ( 0.01%) .          .          .                       return self.c_alt_iter(exprs.iter().map(|e| self.c(e)));
 44,110 ( 0.01%) 38 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter (1x)
      .          .          .          .                   }
      .          .          .          .           
    495 ( 0.00%) .          .          .                   let mut trie = if self.is_reverse() {
      .          .          .          .                       LiteralTrie::reverse()
      .          .          .          .                   } else {
      .          .          .          .                       LiteralTrie::forward()
      .          .          .          .                   };
      .          .          .          .                   for expr in exprs.iter() {
106,844 ( 0.03%) .          .          .                       let literal = match *expr.kind() {
 53,422 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::kind (26,711x)
      .          .          .          .                           hir::HirKind::Literal(hir::Literal(ref bytes)) => bytes,
      .          .          .          .                           _ => unreachable!(),
      .          .          .          .                       };
133,555 ( 0.04%) .          .          .                       trie.add(literal)?;
23,663,451 ( 6.81%) 80,011 ( 9.88%) 12 ( 3.70%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add (26,711x)
      .          .          .          .                   }
    495 ( 0.00%) .          .          .                   trie.compile(&mut self.builder.borrow_mut())
16,880,561 ( 4.86%) 46,080 ( 5.69%) 33 (10.19%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile (495x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile an alternation, where each element yielded by the given
      .          .          .          .               /// iterator represents an item in the alternation. If the iterator yields
      .          .          .          .               /// no elements, then this compiles down to a "fail" state.
      .          .          .          .               ///
      .          .          .          .               /// In an alternation, expressions appearing earlier are "preferred" at
      .          .          .          .               /// match time over expressions appearing later. At least, this is true
      .          .          .          .               /// when using "leftmost first" match semantics. (If "leftmost longest" are
      .          .          .          .               /// ever added in the future, then this preference order of priority would
      .          .          .          .               /// not apply in that mode.)
  4,851 ( 0.00%) .          .          .               fn c_alt_iter<I>(&self, mut it: I) -> Result<ThompsonRef, BuildError>
      .          .          .          .               where
      .          .          .          .                   I: Iterator<Item = Result<ThompsonRef, BuildError>>,
      .          .          .          .               {
  1,778 ( 0.00%) .          .          .                   let first = match it.next() {
83,303,615 (23.97%) 191,348 (23.62%) 91 (28.09%) 1 ( 0.07%)  => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/adapters/map.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (175x)
      .          .          .          .                       None => return self.c_fail(),
    175 ( 0.00%) .          .          .                       Some(result) => result?,
      .          .          .          .                   };
  1,778 ( 0.00%) .          .          .                   let second = match it.next() {
  3,675 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/adapters/map.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (175x)
      .          .          .          .                       None => return Ok(first),
      .          .          .          .                       Some(result) => result?,
      .          .          .          .                   };
      .          .          .          .           
      .          .          .          .                   let union = self.add_union()?;
      .          .          .          .                   let end = self.add_empty()?;
  2,156 ( 0.00%) .          .          .                   self.patch(union, first.start)?;
185,098 ( 0.05%) 716 ( 0.09%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (539x)
  2,156 ( 0.00%) .          .          .                   self.patch(first.end, end)?;
 28,043 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (539x)
  2,156 ( 0.00%) .          .          .                   self.patch(union, second.start)?;
 36,113 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (539x)
  2,156 ( 0.00%) .          .          .                   self.patch(second.end, end)?;
 28,073 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (539x)
 27,680 ( 0.01%) .          .          .                   for result in it {
      .          .          .          .                       let compiled = result?;
 22,144 ( 0.01%) .          .          .                       self.patch(union, compiled.start)?;
612,820 ( 0.18%) 1,113 ( 0.14%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (5,536x)
 33,216 ( 0.01%) .          .          .                       self.patch(compiled.end, end)?;
287,917 ( 0.08%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (5,536x)
      .          .          .          .                   }
  2,695 ( 0.00%) .          .          .                   Ok(ThompsonRef { start: union, end })
  4,312 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given capture sub-expression. `expr` should be the
      .          .          .          .               /// sub-expression contained inside the capture. If "capture" states are
      .          .          .          .               /// enabled, then they are added as appropriate.
      .          .          .          .               ///
      .          .          .          .               /// This accepts the pieces of a capture instead of a `hir::Capture` so
      .          .          .          .               /// that it's easy to manufacture a "fake" group when necessary, e.g., for
      .          .          .          .               /// adding the entire pattern as if it were a group in order to create
      .          .          .          .               /// appropriate "capture" states in the NFA.
 18,732 ( 0.01%) .          .          .               fn c_cap(
      .          .          .          .                   &self,
      .          .          .          .                   index: u32,
      .          .          .          .                   name: Option<&str>,
      .          .          .          .                   expr: &Hir,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
  7,805 ( 0.00%) .          .          .                   match self.config.get_which_captures() {
      .          .          .          .                       // No capture states means we always skip them.
      .          .          .          .                       WhichCaptures::None => return self.c(expr),
      .          .          .          .                       // Implicit captures states means we only add when index==0 since
      .          .          .          .                       // index==0 implies the group is implicit.
      .          .          .          .                       WhichCaptures::Implicit if index > 0 => return self.c(expr),
      .          .          .          .                       _ => {}
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   let start = self.add_capture_start(index, name)?;
  2,322 ( 0.00%) .          .          .                   let inner = self.c(expr)?;
52,677,267 (15.16%) 107,961 (13.33%) 89 (27.47%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (81x)
      .          .          .          .                   let end = self.add_capture_end(index)?;
      .          .          .          .                   self.patch(start, inner.start)?;
      .          .          .          .                   self.patch(inner.end, end)?;
  3,096 ( 0.00%) .          .          .                   Ok(ThompsonRef { start, end })
 14,049 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given repetition expression. This handles all types of
      .          .          .          .               /// repetitions and greediness.
      .          .          .          .               fn c_repetition(
      .          .          .          .                   &self,
      .          .          .          .                   rep: &hir::Repetition,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
 33,096 ( 0.01%) .          .          .                   match (rep.min, rep.max) {
  6,568 ( 0.00%) .          .          .                       (0, Some(1)) => self.c_zero_or_one(&rep.sub, rep.greedy),
  1,824 ( 0.00%) .          .          .                       (min, None) => self.c_at_least(&rep.sub, rep.greedy, min),
1,356,033 ( 0.39%) 758 ( 0.09%) 2 ( 0.62%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (142x)
984,177 ( 0.28%) 54 ( 0.01%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least'2 (10x)
    688 ( 0.00%) .          .          .                       (min, Some(max)) if min == max => self.c_exactly(&rep.sub, min),
  1,474 ( 0.00%) .          .          .                       (min, Some(max)) => self.c_bounded(&rep.sub, rep.greedy, min, max),
722,748 ( 0.21%) 2,041 ( 0.25%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (134x)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given expression such that it matches at least `min` times,
      .          .          .          .               /// but no more than `max` times.
      .          .          .          .               ///
      .          .          .          .               /// When `greedy` is true, then the preference is for the expression to
      .          .          .          .               /// match as much as possible. Otherwise, it will match as little as
      .          .          .          .               /// possible.
  1,742 ( 0.00%) .          .          .               fn c_bounded(
      .          .          .          .                   &self,
      .          .          .          .                   expr: &Hir,
      .          .          .          .                   greedy: bool,
      .          .          .          .                   min: u32,
      .          .          .          .                   max: u32,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   let prefix = self.c_exactly(expr, min)?;
    268 ( 0.00%) .          .          .                   if min == max {
      .          .          .          .                       return Ok(prefix);
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // It is tempting here to compile the rest here as a concatenation
      .          .          .          .                   // of zero-or-one matches. i.e., for `a{2,5}`, compile it as if it
      .          .          .          .                   // were `aaa?a?a?`. The problem here is that it leads to this program:
      .          .          .          .                   //
      .          .          .          .                   //     >000000: 61 => 01
-- line 1178 ----------------------------------------
-- line 1198 ----------------------------------------
      .          .          .          .                   //      000006: union(07, 08)
      .          .          .          .                   //      000007: 61 => 08
      .          .          .          .                   //      000008: MATCH
      .          .          .          .                   //
      .          .          .          .                   // So that the epsilon closure of state 2 is now just 3 and 8.
      .          .          .          .                   let empty = self.add_empty()?;
      .          .          .          .                   let mut prev_end = prefix.end;
      .          .          .          .                   for _ in min..max {
  1,052 ( 0.00%) .          .          .                       let union = if greedy {
      .          .          .          .                           self.add_union()
      .          .          .          .                       } else {
      .          .          .          .                           self.add_union_reverse()
      .          .          .          .                       }?;
  2,104 ( 0.00%) .          .          .                       let compiled = self.c(expr)?;
292,111 ( 0.08%) 917 ( 0.11%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (526x)
      .          .          .          .                       self.patch(prev_end, union)?;
      .          .          .          .                       self.patch(union, compiled.start)?;
      .          .          .          .                       self.patch(union, empty)?;
      .          .          .          .                       prev_end = compiled.end;
      .          .          .          .                   }
      .          .          .          .                   self.patch(prev_end, empty)?;
    536 ( 0.00%) .          .          .                   Ok(ThompsonRef { start: prefix.start, end: empty })
  1,072 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given expression such that it may be matched `n` or more
      .          .          .          .               /// times, where `n` can be any integer. (Although a particularly large
      .          .          .          .               /// integer is likely to run afoul of any configured size limits.)
      .          .          .          .               ///
      .          .          .          .               /// When `greedy` is true, then the preference is for the expression to
      .          .          .          .               /// match as much as possible. Otherwise, it will match as little as
      .          .          .          .               /// possible.
  2,882 ( 0.00%) .          .          .               fn c_at_least(
      .          .          .          .                   &self,
      .          .          .          .                   expr: &Hir,
      .          .          .          .                   greedy: bool,
      .          .          .          .                   n: u32,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
    812 ( 0.00%) .          .          .                   if n == 0 {
      .          .          .          .                       // When the expression cannot match the empty string, then we
      .          .          .          .                       // can get away with something much simpler: just one 'alt'
      .          .          .          .                       // instruction that optionally repeats itself. But if the expr
      .          .          .          .                       // can match the empty string... see below.
    720 ( 0.00%) .          .          .                       if expr.properties().minimum_len().map_or(false, |len| len > 0) {
    288 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::properties (144x)
    288 ( 0.00%) .          .          .                           let union = if greedy {
      .          .          .          .                               self.add_union()
      .          .          .          .                           } else {
      .          .          .          .                               self.add_union_reverse()
      .          .          .          .                           }?;
    432 ( 0.00%) .          .          .                           let compiled = self.c(expr)?;
 60,849 ( 0.02%) 88 ( 0.01%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (34x)
 32,450 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (110x)
      .          .          .          .                           self.patch(union, compiled.start)?;
      .          .          .          .                           self.patch(compiled.end, union)?;
    288 ( 0.00%) .          .          .                           return Ok(ThompsonRef { start: union, end: union });
      .          .          .          .                       }
      .          .          .          .           
      .          .          .          .                       // What's going on here? Shouldn't x* be simpler than this? It
      .          .          .          .                       // turns out that when implementing leftmost-first (Perl-like)
      .          .          .          .                       // match semantics, x* results in an incorrect preference order
      .          .          .          .                       // when computing the transitive closure of states if and only if
      .          .          .          .                       // 'x' can match the empty string. So instead, we compile x* as
      .          .          .          .                       // (x+)?, which preserves the correct preference order.
-- line 1256 ----------------------------------------
-- line 1271 ----------------------------------------
      .          .          .          .                           self.add_union_reverse()
      .          .          .          .                       }?;
      .          .          .          .                       let empty = self.add_empty()?;
      .          .          .          .                       self.patch(question, compiled.start)?;
      .          .          .          .                       self.patch(question, empty)?;
      .          .          .          .                       self.patch(plus, empty)?;
      .          .          .          .                       Ok(ThompsonRef { start: question, end: empty })
      .          .          .          .                   } else if n == 1 {
    354 ( 0.00%) .          .          .                       let compiled = self.c(expr)?;
1,225,223 ( 0.35%) 456 ( 0.06%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (108x)
    236 ( 0.00%) .          .          .                       let union = if greedy {
      .          .          .          .                           self.add_union()
      .          .          .          .                       } else {
      .          .          .          .                           self.add_union_reverse()
      .          .          .          .                       }?;
      .          .          .          .                       self.patch(compiled.end, union)?;
      .          .          .          .                       self.patch(union, compiled.start)?;
    236 ( 0.00%) .          .          .                       Ok(ThompsonRef { start: compiled.start, end: union })
      .          .          .          .                   } else {
      .          .          .          .                       let prefix = self.c_exactly(expr, n - 1)?;
      .          .          .          .                       let last = self.c(expr)?;
      .          .          .          .                       let union = if greedy {
      .          .          .          .                           self.add_union()
      .          .          .          .                       } else {
      .          .          .          .                           self.add_union_reverse()
      .          .          .          .                       }?;
      .          .          .          .                       self.patch(prefix.end, last.start)?;
      .          .          .          .                       self.patch(last.end, union)?;
      .          .          .          .                       self.patch(union, last.start)?;
      .          .          .          .                       Ok(ThompsonRef { start: prefix.start, end: union })
      .          .          .          .                   }
  2,358 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given expression such that it may be matched zero or one
      .          .          .          .               /// times.
      .          .          .          .               ///
      .          .          .          .               /// When `greedy` is true, then the preference is for the expression to
      .          .          .          .               /// match as much as possible. Otherwise, it will match as little as
      .          .          .          .               /// possible.
      .          .          .          .               fn c_zero_or_one(
      .          .          .          .                   &self,
      .          .          .          .                   expr: &Hir,
      .          .          .          .                   greedy: bool,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   let union =
 16,420 ( 0.00%) .          .          .                       if greedy { self.add_union() } else { self.add_union_reverse() }?;
     46 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (1x)
  9,852 ( 0.00%) .          .          .                   let compiled = self.c(expr)?;
    911 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (1x)
      .          .          .          .                   let empty = self.add_empty()?;
      .          .          .          .                   self.patch(union, compiled.start)?;
      .          .          .          .                   self.patch(union, empty)?;
      .          .          .          .                   self.patch(compiled.end, empty)?;
 13,136 ( 0.00%) .          .          .                   Ok(ThompsonRef { start: union, end: empty })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given HIR expression exactly `n` times.
      .          .          .          .               fn c_exactly(
      .          .          .          .                   &self,
      .          .          .          .                   expr: &Hir,
      .          .          .          .                   n: u32,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   let it = (0..n).map(|_| self.c(expr));
    764 ( 0.00%) .          .          .                   self.c_concat(it)
247,118 ( 0.07%) 618 ( 0.08%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_concat (210x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given byte oriented character class.
      .          .          .          .               ///
      .          .          .          .               /// This uses "sparse" states to represent an alternation between ranges in
      .          .          .          .               /// this character class. We can use "sparse" states instead of stitching
      .          .          .          .               /// together a "union" state because all ranges in a character class have
      .          .          .          .               /// equal priority *and* are non-overlapping (thus, only one can match, so
-- line 1339 ----------------------------------------
-- line 1341 ----------------------------------------
      .          .          .          .               /// fair bit of overhead when traversing an NFA.
      .          .          .          .               ///
      .          .          .          .               /// This routine compiles an empty character class into a "fail" state.
      .          .          .          .               fn c_byte_class(
      .          .          .          .                   &self,
      .          .          .          .                   cls: &hir::ClassBytes,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   let end = self.add_empty()?;
    330 ( 0.00%) .          .          .                   let mut trans = Vec::with_capacity(cls.ranges().len());
    330 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::ClassBytes::ranges (110x)
  1,430 ( 0.00%) .          .          .                   for r in cls.iter() {
  1,210 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassBytesIter as core::iter::traits::iterator::Iterator>::next (220x)
    440 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::ClassBytes::iter (110x)
    660 ( 0.00%) .          .          .                       trans.push(Transition {
    330 ( 0.00%) .          .          .                           start: r.start(),
    220 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassBytesRange::start (110x)
    330 ( 0.00%) .          .          .                           end: r.end(),
    220 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassBytesRange::end (110x)
      .          .          .          .                           next: end,
      .          .          .          .                       });
      .          .          .          .                   }
      .          .          .          .                   Ok(ThompsonRef { start: self.add_sparse(trans)?, end })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given Unicode character class.
      .          .          .          .               ///
-- line 1361 ----------------------------------------
-- line 1372 ----------------------------------------
      .          .          .          .               /// This routine compiles an empty character class into a "fail" state.
      .          .          .          .               fn c_unicode_class(
      .          .          .          .                   &self,
      .          .          .          .                   cls: &hir::ClassUnicode,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   // If all we have are ASCII ranges wrapped in a Unicode package, then
      .          .          .          .                   // there is zero reason to bring out the big guns. We can fit all ASCII
      .          .          .          .                   // ranges within a single sparse state.
 22,524 ( 0.01%) .          .          .                   if cls.is_ascii() {
     14 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:regex_syntax::hir::ClassUnicode::is_ascii (2x)
      .          .          .          .                       let end = self.add_empty()?;
 16,134 ( 0.00%) .          .          .                       let mut trans = Vec::with_capacity(cls.ranges().len());
      6 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::ClassBytes::ranges (2x)
 88,899 ( 0.03%) .          .          .                       for r in cls.iter() {
     58 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next (10x)
      8 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::ClassUnicode::iter (2x)
      .          .          .          .                           // The unwraps below are OK because we've verified that this
      .          .          .          .                           // class only contains ASCII codepoints.
 36,700 ( 0.01%) .          .          .                           trans.push(Transition {
      .          .          .          .                               // FIXME(1.59): use the 'TryFrom<char> for u8' impl.
 18,350 ( 0.01%) .          .          .                               start: u8::try_from(u32::from(r.start())).unwrap(),
     16 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicodeRange::start (8x)
 18,350 ( 0.01%) .          .          .                               end: u8::try_from(u32::from(r.end())).unwrap(),
     16 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicodeRange::end (8x)
      .          .          .          .                               next: end,
      .          .          .          .                           });
      .          .          .          .                       }
      .          .          .          .                       Ok(ThompsonRef { start: self.add_sparse(trans)?, end })
    253 ( 0.00%) .          .          .                   } else if self.is_reverse() {
    127 ( 0.00%) .          .          .                       if !self.config.get_shrink() {
      .          .          .          .                           // When we don't want to spend the extra time shrinking, we
      .          .          .          .                           // compile the UTF-8 automaton in reverse using something like
      .          .          .          .                           // the "naive" approach, but will attempt to re-use common
      .          .          .          .                           // suffixes.
      .          .          .          .                           self.c_unicode_class_reverse_with_suffix(cls)
      .          .          .          .                       } else {
      .          .          .          .                           // When we want to shrink our NFA for reverse UTF-8 automata,
      .          .          .          .                           // we cannot feed UTF-8 sequences directly to the UTF-8
-- line 1403 ----------------------------------------
-- line 1432 ----------------------------------------
      .          .          .          .                   } else {
      .          .          .          .                       // In the forward direction, we always shrink our UTF-8 automata
      .          .          .          .                       // because we can stream it right into the UTF-8 compiler. There
      .          .          .          .                       // is almost no downside (in either memory or time) to using this
      .          .          .          .                       // approach.
      .          .          .          .                       let mut builder = self.builder.borrow_mut();
      .          .          .          .                       let mut utf8_state = self.utf8_state.borrow_mut();
      .          .          .          .                       let mut utf8c =
    378 ( 0.00%) .          .          .                           Utf8Compiler::new(&mut *builder, &mut *utf8_state)?;
17,664,602 ( 5.08%) 642 ( 0.08%) 40 (12.35%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::new (126x)
  4,463 ( 0.00%) .          .          .                       for rng in cls.iter() {
  4,776 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next (817x)
    504 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::ClassUnicode::iter (126x)
 29,959 ( 0.01%) .          .          .                           for seq in Utf8Sequences::new(rng.start(), rng.end()) {
198,768 ( 0.06%) 125 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next (1,870x)
 82,729 ( 0.02%) 314 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs:regex_syntax::utf8::Utf8Sequences::new (691x)
  1,382 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicodeRange::end (691x)
  1,382 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicodeRange::start (691x)
  8,253 ( 0.00%) .          .          .                               utf8c.add(seq.as_slice())?;
920,256 ( 0.26%) 1,420 ( 0.18%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::add (1,179x)
 10,611 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs:regex_syntax::utf8::Utf8Sequence::as_slice (1,179x)
      .          .          .          .                           }
      .          .          .          .                       }
    126 ( 0.00%) .          .          .                       utf8c.finish()
217,294 ( 0.06%) 406 ( 0.05%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::finish (126x)
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // For reference, the code below is the "naive" version of compiling a
      .          .          .          .                   // UTF-8 automaton. It is deliciously simple (and works for both the
      .          .          .          .                   // forward and reverse cases), but will unfortunately produce very
      .          .          .          .                   // large NFAs. When compiling a forward automaton, the size difference
      .          .          .          .                   // can sometimes be an order of magnitude. For example, the '\w' regex
      .          .          .          .                   // will generate about ~3000 NFA states using the naive approach below,
-- line 1454 ----------------------------------------
-- line 1510 ----------------------------------------
      .          .          .          .                   &self,
      .          .          .          .                   cls: &hir::ClassUnicode,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   // N.B. It would likely be better to cache common *prefixes* in the
      .          .          .          .                   // reverse direction, but it's not quite clear how to do that. The
      .          .          .          .                   // advantage of caching suffixes is that it does give us a win, and
      .          .          .          .                   // has a very small additional overhead.
      .          .          .          .                   let mut cache = self.utf8_suffix.borrow_mut();
    127 ( 0.00%) .          .          .                   cache.clear();
395,455 ( 0.11%) 374 ( 0.05%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/map.rs:regex_automata::nfa::thompson::map::Utf8SuffixMap::clear (127x)
      .          .          .          .           
      .          .          .          .                   let union = self.add_union()?;
      .          .          .          .                   let alt_end = self.add_empty()?;
  6,703 ( 0.00%) .          .          .                   for urng in cls.iter() {
  4,805 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next (822x)
    508 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs:regex_syntax::hir::ClassUnicode::iter (127x)
 23,428 ( 0.01%) .          .          .                       for seq in Utf8Sequences::new(urng.start(), urng.end()) {
203,999 ( 0.06%) 126 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next (1,886x)
 59,088 ( 0.02%) 106 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs:regex_syntax::utf8::Utf8Sequences::new (695x)
  1,390 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicodeRange::end (695x)
  1,390 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicodeRange::start (695x)
      .          .          .          .                           let mut end = alt_end;
  2,382 ( 0.00%) .          .          .                           for brng in seq.as_slice() {
 10,719 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs:regex_syntax::utf8::Utf8Sequence::as_slice (1,191x)
      .          .          .          .                               let key = Utf8SuffixKey {
      .          .          .          .                                   from: end,
      .          .          .          .                                   start: brng.start,
      .          .          .          .                                   end: brng.end,
      .          .          .          .                               };
      .          .          .          .                               let hash = cache.hash(&key);
      .          .          .          .                               if let Some(id) = cache.get(&key, hash) {
      .          .          .          .                                   end = id;
      .          .          .          .                                   continue;
      .          .          .          .                               }
      .          .          .          .           
  5,596 ( 0.00%) .          .          .                               let compiled = self.c_range(brng.start, brng.end)?;
      .          .          .          .                               self.patch(compiled.end, end)?;
      .          .          .          .                               end = compiled.start;
 11,192 ( 0.00%) .          .          .                               cache.set(key, hash, end);
      .          .          .          .                           }
      .          .          .          .                           self.patch(union, end)?;
      .          .          .          .                       }
      .          .          .          .                   }
    508 ( 0.00%) .          .          .                   Ok(ThompsonRef { start: union, end: alt_end })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given HIR look-around assertion to an NFA look-around
      .          .          .          .               /// assertion.
      .          .          .          .               fn c_look(&self, anchor: &hir::Look) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   let look = match *anchor {
      .          .          .          .                       hir::Look::Start => Look::Start,
      .          .          .          .                       hir::Look::End => Look::End,
-- line 1553 ----------------------------------------
-- line 1606 ----------------------------------------
      .          .          .          .           
      .          .          .          .               // The below helpers are meant to be simple wrappers around the
      .          .          .          .               // corresponding Builder methods. For the most part, they let us write
      .          .          .          .               // 'self.add_foo()' instead of 'self.builder.borrow_mut().add_foo()', where
      .          .          .          .               // the latter is a mouthful. Some of the methods do inject a little bit
      .          .          .          .               // of extra logic. e.g., Flipping look-around operators when compiling in
      .          .          .          .               // reverse mode.
      .          .          .          .           
 39,684 ( 0.01%) .          .          .               fn patch(&self, from: StateID, to: StateID) -> Result<(), BuildError> {
185,779 ( 0.05%) .          .          .                   self.builder.borrow_mut().patch(from, to)
  6,300 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (175x)
 66,140 ( 0.02%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn start_pattern(&self) -> Result<PatternID, BuildError> {
      .          .          .          .                   self.builder.borrow_mut().start_pattern()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn finish_pattern(
      .          .          .          .                   &self,
      .          .          .          .                   start_id: StateID,
-- line 1624 ----------------------------------------
-- line 1626 ----------------------------------------
      .          .          .          .                   self.builder.borrow_mut().finish_pattern(start_id)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_empty(&self) -> Result<StateID, BuildError> {
      .          .          .          .                   self.builder.borrow_mut().add_empty()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_range(&self, start: u8, end: u8) -> Result<StateID, BuildError> {
 49,675 ( 0.01%) .          .          .                   self.builder.borrow_mut().add_range(Transition {
      .          .          .          .                       start,
      .          .          .          .                       end,
      .          .          .          .                       next: StateID::ZERO,
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_sparse(
      .          .          .          .                   &self,
      .          .          .          .                   ranges: Vec<Transition>,
      .          .          .          .               ) -> Result<StateID, BuildError> {
      .          .          .          .                   self.builder.borrow_mut().add_sparse(ranges)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_look(&self, mut look: Look) -> Result<StateID, BuildError> {
    490 ( 0.00%) .          .          .                   if self.is_reverse() {
      .          .          .          .                       look = look.reversed();
      .          .          .          .                   }
      .          .          .          .                   self.builder.borrow_mut().add_look(StateID::ZERO, look)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_union(&self) -> Result<StateID, BuildError> {
      .          .          .          .                   self.builder.borrow_mut().add_union(vec![])
      .          .          .          .               }
-- line 1657 ----------------------------------------
-- line 1661 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_capture_start(
      .          .          .          .                   &self,
      .          .          .          .                   capture_index: u32,
      .          .          .          .                   name: Option<&str>,
      .          .          .          .               ) -> Result<StateID, BuildError> {
      .          .          .          .                   let name = name.map(|n| Arc::from(n));
  4,644 ( 0.00%) .          .          .                   self.builder.borrow_mut().add_capture_start(
 39,746 ( 0.01%) 82 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add_capture_start (81x)
      .          .          .          .                       StateID::ZERO,
      .          .          .          .                       capture_index,
      .          .          .          .                       name,
      .          .          .          .                   )
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_capture_end(
      .          .          .          .                   &self,
-- line 1677 ----------------------------------------
-- line 1744 ----------------------------------------
      .          .          .          .           #[derive(Clone, Debug)]
      .          .          .          .           struct Utf8LastTransition {
      .          .          .          .               start: u8,
      .          .          .          .               end: u8,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Utf8State {
      .          .          .          .               fn new() -> Utf8State {
    674 ( 0.00%) .          .          .                   Utf8State { compiled: Utf8BoundedMap::new(10_000), uncompiled: vec![] }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn clear(&mut self) {
    252 ( 0.00%) .          .          .                   self.compiled.clear();
17,634,305 ( 5.08%) 606 ( 0.07%) 40 (12.35%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/map.rs:regex_automata::nfa::thompson::map::Utf8BoundedMap::clear (126x)
      .          .          .          .                   self.uncompiled.clear();
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'a> Utf8Compiler<'a> {
  1,260 ( 0.00%) .          .          .               fn new(
      .          .          .          .                   builder: &'a mut Builder,
      .          .          .          .                   state: &'a mut Utf8State,
      .          .          .          .               ) -> Result<Utf8Compiler<'a>, BuildError> {
      .          .          .          .                   let target = builder.add_empty()?;
      .          .          .          .                   state.clear();
      .          .          .          .                   let mut utf8c = Utf8Compiler { builder, state, target };
      .          .          .          .                   utf8c.add_empty();
    504 ( 0.00%) .          .          .                   Ok(utf8c)
  1,008 ( 0.00%) .          .          .               }
      .          .          .          .           
    756 ( 0.00%) .          .          .               fn finish(&mut self) -> Result<ThompsonRef, BuildError> {
    252 ( 0.00%) .          .          .                   self.compile_from(0)?;
147,182 ( 0.04%) 290 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from (126x)
    126 ( 0.00%) .          .          .                   let node = self.pop_root();
    504 ( 0.00%) .          .          .                   let start = self.compile(node)?;
 64,820 ( 0.02%) 116 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (126x)
    504 ( 0.00%) .          .          .                   Ok(ThompsonRef { start, end: self.target })
    504 ( 0.00%) .          .          .               }
      .          .          .          .           
 11,790 ( 0.00%) .          .          .               fn add(&mut self, ranges: &[Utf8Range]) -> Result<(), BuildError> {
      .          .          .          .                   let prefix_len = ranges
      .          .          .          .                       .iter()
  1,179 ( 0.00%) .          .          .                       .zip(&self.state.uncompiled)
      .          .          .          .                       .take_while(|&(range, node)| {
      .          .          .          .                           node.last.as_ref().map_or(false, |t| {
      .          .          .          .                               (t.start, t.end) == (range.start, range.end)
      .          .          .          .                           })
      .          .          .          .                       })
      .          .          .          .                       .count();
  2,358 ( 0.00%) .          .          .                   assert!(prefix_len < ranges.len());
  2,358 ( 0.00%) .          .          .                   self.compile_from(prefix_len)?;
808,237 ( 0.23%) 1,420 ( 0.18%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from (1,179x)
    878 ( 0.00%) .          .          .                   self.add_suffix(&ranges[prefix_len..]);
      .          .          .          .                   Ok(())
 10,611 ( 0.00%) .          .          .               }
      .          .          .          .           
 11,745 ( 0.00%) .          .          .               fn compile_from(&mut self, from: usize) -> Result<(), BuildError> {
  1,305 ( 0.00%) .          .          .                   let mut next = self.target;
  5,786 ( 0.00%) .          .          .                   while from + 1 < self.state.uncompiled.len() {
      .          .          .          .                       let node = self.pop_freeze(next);
  7,940 ( 0.00%) .          .          .                       next = self.compile(node)?;
451,230 ( 0.13%) 829 ( 0.10%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (1,588x)
      .          .          .          .                   }
      .          .          .          .                   self.top_last_freeze(next);
  2,610 ( 0.00%) .          .          .                   Ok(())
 10,440 ( 0.00%) .          .          .               }
      .          .          .          .           
 17,140 ( 0.00%) .          .          .               fn compile(
      .          .          .          .                   &mut self,
      .          .          .          .                   node: Vec<Transition>,
      .          .          .          .               ) -> Result<StateID, BuildError> {
      .          .          .          .                   let hash = self.state.compiled.hash(&node);
      .          .          .          .                   if let Some(id) = self.state.compiled.get(&node, hash) {
  1,882 ( 0.00%) .          .          .                       return Ok(id);
      .          .          .          .                   }
      .          .          .          .                   let id = self.builder.add_sparse(node.clone())?;
      .          .          .          .                   self.state.compiled.set(node, hash, id);
  2,319 ( 0.00%) .          .          .                   Ok(id)
  6,184 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_suffix(&mut self, ranges: &[Utf8Range]) {
      .          .          .          .                   assert!(!ranges.is_empty());
      .          .          .          .                   let last = self
      .          .          .          .                       .state
      .          .          .          .                       .uncompiled
      .          .          .          .                       .len()
      .          .          .          .                       .checked_sub(1)
      .          .          .          .                       .expect("non-empty nodes");
  3,537 ( 0.00%) .          .          .                   assert!(self.state.uncompiled[last].last.is_none());
  2,358 ( 0.00%) .          .          .                   self.state.uncompiled[last].last = Some(Utf8LastTransition {
  1,179 ( 0.00%) .          .          .                       start: ranges[0].start,
      .          .          .          .                       end: ranges[0].end,
      .          .          .          .                   });
      .          .          .          .                   for r in &ranges[1..] {
      .          .          .          .                       self.state.uncompiled.push(Utf8Node {
      .          .          .          .                           trans: vec![],
  3,176 ( 0.00%) .          .          .                           last: Some(Utf8LastTransition { start: r.start, end: r.end }),
      .          .          .          .                       });
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_empty(&mut self) {
      .          .          .          .                   self.state.uncompiled.push(Utf8Node { trans: vec![], last: None });
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn pop_freeze(&mut self, next: StateID) -> Vec<Transition> {
  1,588 ( 0.00%) .          .          .                   let mut uncompiled = self.state.uncompiled.pop().unwrap();
      .          .          .          .                   uncompiled.set_last_transition(next);
  6,352 ( 0.00%) .          .          .                   uncompiled.trans
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn pop_root(&mut self) -> Vec<Transition> {
    252 ( 0.00%) .          .          .                   assert_eq!(self.state.uncompiled.len(), 1);
    252 ( 0.00%) .          .          .                   assert!(self.state.uncompiled[0].last.is_none());
      .          .          .          .                   self.state.uncompiled.pop().expect("non-empty nodes").trans
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn top_last_freeze(&mut self, next: StateID) {
      .          .          .          .                   let last = self
      .          .          .          .                       .state
      .          .          .          .                       .uncompiled
      .          .          .          .                       .len()
      .          .          .          .                       .checked_sub(1)
      .          .          .          .                       .expect("non-empty nodes");
  3,663 ( 0.00%) .          .          .                   self.state.uncompiled[last].set_last_transition(next);
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Utf8Node {
      .          .          .          .               fn set_last_transition(&mut self, next: StateID) {
  5,786 ( 0.00%) .          .          .                   if let Some(last) = self.last.take() {
  5,534 ( 0.00%) .          .          .                       self.trans.push(Transition {
      .          .          .          .                           start: last.start,
      .          .          .          .                           end: last.end,
      .          .          .          .                           next,
      .          .          .          .                       });
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
-- line 1878 ----------------------------------------

253,413 ( 0.07%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/prefilter.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 137 ----------------------------------------
     .          .          .          .                       .as_packed()
     .          .          .          .                       .map(|kind| packed::Config::new().match_kind(kind).builder());
     .          .          .          .                   Builder {
     .          .          .          .                       count: 0,
     .          .          .          .                       ascii_case_insensitive: false,
     .          .          .          .                       start_bytes: StartBytesBuilder::new(),
     .          .          .          .                       rare_bytes: RareBytesBuilder::new(),
     .          .          .          .                       memmem: MemmemBuilder::default(),
   192 ( 0.00%) .          .          .                       packed: pbuilder,
     .          .          .          .                       enabled: true,
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Enable ASCII case insensitivity. When set, byte strings added to this
     .          .          .          .               /// builder will be interpreted without respect to ASCII case.
     .          .          .          .               pub(crate) fn ascii_case_insensitive(mut self, yes: bool) -> Builder {
     .          .          .          .                   self.ascii_case_insensitive = yes;
     .          .          .          .                   self.start_bytes = self.start_bytes.ascii_case_insensitive(yes);
     .          .          .          .                   self.rare_bytes = self.rare_bytes.ascii_case_insensitive(yes);
    96 ( 0.00%) .          .          .                   self
 2,544 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return a prefilter suitable for quickly finding potential matches.
     .          .          .          .               ///
     .          .          .          .               /// All patterns added to an Aho-Corasick automaton should be added to this
     .          .          .          .               /// builder before attempting to construct the prefilter.
   480 ( 0.00%) .          .          .               pub(crate) fn build(&self) -> Option<Prefilter> {
    96 ( 0.00%) .          .          .                   if !self.enabled {
     .          .          .          .                       debug!("prefilter not enabled, skipping");
     .          .          .          .                       return None;
     .          .          .          .                   }
     .          .          .          .                   // If we only have one pattern, then deferring to memmem is always
     .          .          .          .                   // the best choice. This is kind of a weird case, because, well, why
     .          .          .          .                   // use Aho-Corasick if you only have one pattern? But maybe you don't
     .          .          .          .                   // know exactly how many patterns you'll get up front, and you need to
     .          .          .          .                   // support the option of multiple patterns. So instead of relying on
     .          .          .          .                   // the caller to branch and use memmem explicitly, we just do it for
     .          .          .          .                   // them.
   192 ( 0.00%) .          .          .                   if !self.ascii_case_insensitive {
     .          .          .          .                       if let Some(pre) = self.memmem.build() {
     .          .          .          .                           debug!("using memmem prefilter");
     .          .          .          .                           return Some(pre);
     .          .          .          .                       }
     .          .          .          .                   }
   192 ( 0.00%) .          .          .                   let (packed, patlen, minlen) = if self.ascii_case_insensitive {
     .          .          .          .                       (None, usize::MAX, 0)
     .          .          .          .                   } else {
     .          .          .          .                       let patlen = self.packed.as_ref().map_or(usize::MAX, |p| p.len());
     .          .          .          .                       let minlen = self.packed.as_ref().map_or(0, |p| p.minimum_len());
     .          .          .          .                       let packed =
    48 ( 0.00%) .          .          .                           self.packed.as_ref().and_then(|b| b.build()).map(|s| {
 1,152 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/api.rs:aho_corasick::packed::api::Builder::build (48x)
     .          .          .          .                               let memory_usage = s.memory_usage();
     .          .          .          .                               debug!(
     .          .          .          .                                   "built packed prefilter (len: {}, \
     .          .          .          .                                    minimum pattern len: {}, memory usage: {}) \
     .          .          .          .                                    for consideration",
     .          .          .          .                                   patlen, minlen, memory_usage,
     .          .          .          .                               );
     .          .          .          .                               Prefilter { finder: Arc::new(Packed(s)), memory_usage }
     .          .          .          .                           });
     .          .          .          .                       (packed, patlen, minlen)
     .          .          .          .                   };
   576 ( 0.00%) .          .          .                   match (self.start_bytes.build(), self.rare_bytes.build()) {
     .          .          .          .                       // If we could build both start and rare prefilters, then there are
     .          .          .          .                       // a few cases in which we'd want to use the start-byte prefilter
     .          .          .          .                       // over the rare-byte prefilter, since the former has lower
     .          .          .          .                       // overhead.
     .          .          .          .                       (prestart @ Some(_), prerare @ Some(_)) => {
     .          .          .          .                           debug!(
     .          .          .          .                               "both start (len={}, rank={}) and \
     .          .          .          .                                rare (len={}, rank={}) byte prefilters \
-- line 207 ----------------------------------------
-- line 281 ----------------------------------------
     .          .          .          .                               return packed;
     .          .          .          .                           }
     .          .          .          .                           debug!(
     .          .          .          .                               "have rare byte prefilter but not start byte prefilter, \
     .          .          .          .                                so using rare byte prefilter",
     .          .          .          .                           );
     .          .          .          .                           prerare
     .          .          .          .                       }
    48 ( 0.00%) .          .          .                       (None, None) if self.ascii_case_insensitive => {
     .          .          .          .                           debug!(
     .          .          .          .                               "no start or rare byte prefilter and ASCII case \
     .          .          .          .                                insensitivity was enabled, so skipping prefilter",
     .          .          .          .                           );
     .          .          .          .                           None
     .          .          .          .                       }
     .          .          .          .                       (None, None) => {
     .          .          .          .                           if packed.is_some() {
     .          .          .          .                               debug!("falling back to packed prefilter");
     .          .          .          .                           } else {
     .          .          .          .                               debug!("no prefilter available");
     .          .          .          .                           }
   192 ( 0.00%) .          .          .                           packed
     .          .          .          .                       }
     .          .          .          .                   }
   432 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add a literal string to this prefilter builder.
     .          .          .          .               pub(crate) fn add(&mut self, bytes: &[u8]) {
     .          .          .          .                   if bytes.is_empty() {
     .          .          .          .                       self.enabled = false;
     .          .          .          .                   }
     .          .          .          .                   if !self.enabled {
     .          .          .          .                       return;
-- line 313 ----------------------------------------
-- line 343 ----------------------------------------
     .          .          .          .               /// The singular pattern to search for. This is only set when count==1.
     .          .          .          .               one: Option<Vec<u8>>,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl MemmemBuilder {
     .          .          .          .               fn build(&self) -> Option<Prefilter> {
     .          .          .          .                   #[cfg(all(feature = "std", feature = "perf-literal"))]
     .          .          .          .                   fn imp(builder: &MemmemBuilder) -> Option<Prefilter> {
    48 ( 0.00%) .          .          .                       let pattern = builder.one.as_ref()?;
     .          .          .          .                       assert_eq!(1, builder.count);
     .          .          .          .                       let finder = Arc::new(Memmem(
     .          .          .          .                           memchr::memmem::Finder::new(pattern).into_owned(),
     .          .          .          .                       ));
     .          .          .          .                       let memory_usage = pattern.len();
     .          .          .          .                       Some(Prefilter { finder, memory_usage })
     .          .          .          .                   }
     .          .          .          .           
-- line 359 ----------------------------------------
-- line 446 ----------------------------------------
     .          .          .          .               /// Each entry corresponds to the maximum offset of the corresponding
     .          .          .          .               /// byte across all patterns seen.
     .          .          .          .               set: [RareByteOffset; 256],
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl RareByteOffsets {
     .          .          .          .               /// Create a new empty set of rare byte offsets.
     .          .          .          .               pub(crate) fn empty() -> RareByteOffsets {
   912 ( 0.00%) .          .          .                   RareByteOffsets { set: [RareByteOffset::default(); 256] }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add the given offset for the given byte to this set. If the offset is
     .          .          .          .               /// greater than the existing offset, then it overwrites the previous
     .          .          .          .               /// value and returns false. If there is no previous value set, then this
     .          .          .          .               /// sets it and returns true.
     .          .          .          .               pub(crate) fn set(&mut self, byte: u8, off: RareByteOffset) {
     .          .          .          .                   self.set[byte as usize].max =
-- line 462 ----------------------------------------
-- line 538 ----------------------------------------
     .          .          .          .               /// Build the rare bytes prefilter.
     .          .          .          .               ///
     .          .          .          .               /// If there are more than 3 distinct rare bytes found, or if heuristics
     .          .          .          .               /// otherwise determine that this prefilter should not be used, then `None`
     .          .          .          .               /// is returned.
     .          .          .          .               fn build(&self) -> Option<Prefilter> {
     .          .          .          .                   #[cfg(feature = "perf-literal")]
     .          .          .          .                   fn imp(builder: &RareBytesBuilder) -> Option<Prefilter> {
   240 ( 0.00%) .          .          .                       if !builder.available || builder.count > 3 {
     .          .          .          .                           return None;
     .          .          .          .                       }
   384 ( 0.00%) .          .          .                       let (mut bytes, mut len) = ([0; 3], 0);
     .          .          .          .                       for b in 0..=255 {
12,288 ( 0.00%) .          .          .                           if builder.rare_set.contains(b) {
     .          .          .          .                               bytes[len] = b as u8;
     .          .          .          .                               len += 1;
     .          .          .          .                           }
     .          .          .          .                       }
    96 ( 0.00%) .          .          .                       let finder: Arc<dyn PrefilterI> = match len {
     .          .          .          .                           0 => return None,
     .          .          .          .                           1 => Arc::new(RareBytesOne {
     .          .          .          .                               byte1: bytes[0],
     .          .          .          .                               offset: builder.byte_offsets.set[bytes[0] as usize],
     .          .          .          .                           }),
     .          .          .          .                           2 => Arc::new(RareBytesTwo {
     .          .          .          .                               offsets: builder.byte_offsets,
     .          .          .          .                               byte1: bytes[0],
-- line 564 ----------------------------------------
-- line 777 ----------------------------------------
     .          .          .          .               /// Build the starting bytes prefilter.
     .          .          .          .               ///
     .          .          .          .               /// If there are more than 3 distinct starting bytes, or if heuristics
     .          .          .          .               /// otherwise determine that this prefilter should not be used, then `None`
     .          .          .          .               /// is returned.
     .          .          .          .               fn build(&self) -> Option<Prefilter> {
     .          .          .          .                   #[cfg(feature = "perf-literal")]
     .          .          .          .                   fn imp(builder: &StartBytesBuilder) -> Option<Prefilter> {
   144 ( 0.00%) .          .          .                       if builder.count > 3 {
     .          .          .          .                           return None;
     .          .          .          .                       }
     .          .          .          .                       let (mut bytes, mut len) = ([0; 3], 0);
     .          .          .          .                       for b in 0..256 {
30,720 ( 0.01%) .          .          .                           if !builder.byteset[b] {
     .          .          .          .                               continue;
     .          .          .          .                           }
     .          .          .          .                           // We don't handle non-ASCII bytes for now. Getting non-ASCII
     .          .          .          .                           // bytes right is trickier, since we generally don't want to put
     .          .          .          .                           // a leading UTF-8 code unit into a prefilter that isn't ASCII,
     .          .          .          .                           // since they can frequently. Instead, it would be better to use a
     .          .          .          .                           // continuation byte, but this requires more sophisticated analysis
     .          .          .          .                           // of the automaton and a richer prefilter API.
-- line 798 ----------------------------------------

28,512 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/prefilter.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 215 ----------------------------------------
     .          .          .          .               range: Utf8Range,
     .          .          .          .               /// The next state to transition to.
     .          .          .          .               next_id: StateID,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl RangeTrie {
     .          .          .          .               /// Create a new empty range trie.
     .          .          .          .               pub fn new() -> RangeTrie {
10,110 ( 0.00%) .          .          .                   let mut trie = RangeTrie {
     .          .          .          .                       states: vec![],
     .          .          .          .                       free: vec![],
     .          .          .          .                       iter_stack: RefCell::new(vec![]),
     .          .          .          .                       iter_ranges: RefCell::new(vec![]),
     .          .          .          .                       dupe_stack: vec![],
     .          .          .          .                       insert_stack: vec![],
     .          .          .          .                   };
     .          .          .          .                   trie.clear();
 2,696 ( 0.00%) .          .          .                   trie
 2,430 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (81x)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Clear this range trie such that it is empty. Clearing a range trie
     .          .          .          .               /// and reusing it can beneficial because this may reuse allocations.
     .          .          .          .               pub fn clear(&mut self) {
     .          .          .          .                   self.free.extend(self.states.drain(..));
 1,348 ( 0.00%) .          .          .                   self.add_empty(); // final
11,826 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::nfa::thompson::range_trie::RangeTrie::add_empty (81x)
 1,348 ( 0.00%) .          .          .                   self.add_empty(); // root
 2,268 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/range_trie.rs:regex_automata::nfa::thompson::range_trie::RangeTrie::add_empty (81x)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Iterate over all of the sequences of byte ranges in this trie, and
     .          .          .          .               /// call the provided function for each sequence. Iteration occurs in
     .          .          .          .               /// lexicographic order.
     .          .          .          .               pub fn iter<E, F: FnMut(&[Utf8Range]) -> Result<(), E>>(
     .          .          .          .                   &self,
     .          .          .          .                   mut f: F,
-- line 248 ----------------------------------------
-- line 420 ----------------------------------------
     .          .          .          .                           // no subsequent transitions with any overlap. Therefore, we
     .          .          .          .                           // can stop processing this range and move on to the next one.
     .          .          .          .                           break;
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   self.insert_stack = stack;
     .          .          .          .               }
     .          .          .          .           
 6,740 ( 0.00%) .          .          .               pub fn add_empty(&mut self) -> StateID {
     .          .          .          .                   let id = match StateID::try_from(self.states.len()) {
     .          .          .          .                       Ok(id) => id,
     .          .          .          .                       Err(_) => {
     .          .          .          .                           // This generally should not happen since a range trie is
     .          .          .          .                           // only ever used to compile a single sequence of Unicode
     .          .          .          .                           // scalar values. If we ever got to this point, we would, at
     .          .          .          .                           // *minimum*, be using 96GB in just the range trie alone.
     .          .          .          .                           panic!("too many sequences added to range trie");
-- line 436 ----------------------------------------
-- line 440 ----------------------------------------
     .          .          .          .                   // more allocations.
     .          .          .          .                   if let Some(mut state) = self.free.pop() {
     .          .          .          .                       state.clear();
     .          .          .          .                       self.states.push(state);
     .          .          .          .                   } else {
     .          .          .          .                       self.states.push(State { transitions: vec![] });
     .          .          .          .                   }
     .          .          .          .                   id
 9,436 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Performs a deep clone of the given state and returns the duplicate's
     .          .          .          .               /// state ID.
     .          .          .          .               ///
     .          .          .          .               /// A "deep clone" in this context means that the state given along with
     .          .          .          .               /// recursively all states that it points to are copied. Once complete,
     .          .          .          .               /// the given state ID and the returned state ID share nothing.
     .          .          .          .               ///
-- line 456 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/id.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 159 ----------------------------------------
     .          .          .          .           /// assert_eq!(mat.offset(), 7);
     .          .          .          .           /// let mat = find_leftmost_first(&dfa, &mut cache, &haystack[10..])?.unwrap();
     .          .          .          .           /// assert_eq!(mat.pattern().as_usize(), 1);
     .          .          .          .           /// assert_eq!(mat.offset(), 5);
     .          .          .          .           ///
     .          .          .          .           /// # Ok::<(), Box<dyn std::error::Error>>(())
     .          .          .          .           /// ```
     .          .          .          .           #[derive(
   234 ( 0.00%) .          .          .               Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord,
     .          .          .          .           )]
     .          .          .          .           pub struct LazyStateID(u32);
     .          .          .          .           
     .          .          .          .           impl LazyStateID {
     .          .          .          .               #[cfg(any(target_pointer_width = "32", target_pointer_width = "64"))]
     .          .          .          .               const MAX_BIT: usize = 31;
     .          .          .          .           
     .          .          .          .               #[cfg(target_pointer_width = "16")]
-- line 175 ----------------------------------------
-- line 183 ----------------------------------------
     .          .          .          .               const MAX: usize = LazyStateID::MASK_MATCH - 1;
     .          .          .          .           
     .          .          .          .               /// Create a new lazy state ID.
     .          .          .          .               ///
     .          .          .          .               /// If the given identifier exceeds [`LazyStateID::MAX`], then this returns
     .          .          .          .               /// an error.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn new(id: usize) -> Result<LazyStateID, LazyStateIDError> {
 1,950 ( 0.00%) .          .          .                   if id > LazyStateID::MAX {
     .          .          .          .                       let attempted = u64::try_from(id).unwrap();
     .          .          .          .                       return Err(LazyStateIDError { attempted });
     .          .          .          .                   }
     .          .          .          .                   Ok(LazyStateID::new_unchecked(id))
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Create a new lazy state ID without checking whether the given value
     .          .          .          .               /// exceeds [`LazyStateID::MAX`].
-- line 199 ----------------------------------------
-- line 208 ----------------------------------------
     .          .          .          .           
     .          .          .          .               /// Return this lazy state ID as an untagged `usize`.
     .          .          .          .               ///
     .          .          .          .               /// If this lazy state ID is tagged, then the usize returned is the state
     .          .          .          .               /// ID without the tag. If the ID was not tagged, then the usize returned
     .          .          .          .               /// is equivalent to the state ID.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn as_usize_untagged(&self) -> usize {
68,638 ( 0.02%) .          .          .                   self.as_usize_unchecked() & LazyStateID::MAX
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return this lazy state ID as its raw internal `usize` value, which may
     .          .          .          .               /// be tagged (and thus greater than LazyStateID::MAX).
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) const fn as_usize_unchecked(&self) -> usize {
     .          .          .          .                   // FIXME: Use as_usize() once const functions in traits are stable.
   232 ( 0.00%) .          .          .                   self.0 as usize
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) const fn to_unknown(&self) -> LazyStateID {
     .          .          .          .                   LazyStateID::new_unchecked(
     .          .          .          .                       self.as_usize_unchecked() | LazyStateID::MASK_UNKNOWN,
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) const fn to_dead(&self) -> LazyStateID {
     .          .          .          .                   LazyStateID::new_unchecked(
   117 ( 0.00%) .          .          .                       self.as_usize_unchecked() | LazyStateID::MASK_DEAD,
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) const fn to_quit(&self) -> LazyStateID {
     .          .          .          .                   LazyStateID::new_unchecked(
   117 ( 0.00%) .          .          .                       self.as_usize_unchecked() | LazyStateID::MASK_QUIT,
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return this lazy state ID as a state ID that is tagged as a start
     .          .          .          .               /// state.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) const fn to_start(&self) -> LazyStateID {
     .          .          .          .                   LazyStateID::new_unchecked(
-- line 252 ----------------------------------------
-- line 264 ----------------------------------------
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return true if and only if this lazy state ID is tagged.
     .          .          .          .               ///
     .          .          .          .               /// When a lazy state ID is tagged, then one can conclude that it is one
     .          .          .          .               /// of a match, start, dead, quit or unknown state.
     .          .          .          .               #[inline]
     .          .          .          .               pub const fn is_tagged(&self) -> bool {
   843 ( 0.00%) .          .          .                   self.as_usize_unchecked() > LazyStateID::MAX
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return true if and only if this represents a lazy state ID that is
     .          .          .          .               /// "unknown." That is, the state has not yet been created. When a caller
     .          .          .          .               /// sees this state ID, it generally means that a state has to be computed
     .          .          .          .               /// in order to proceed.
     .          .          .          .               #[inline]
     .          .          .          .               pub const fn is_unknown(&self) -> bool {
 1,130 ( 0.00%) .          .          .                   self.as_usize_unchecked() & LazyStateID::MASK_UNKNOWN > 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return true if and only if this represents a dead state. A dead state
     .          .          .          .               /// is a state that can never transition to any other state except the
     .          .          .          .               /// dead state. When a dead state is seen, it generally indicates that a
     .          .          .          .               /// search should stop.
     .          .          .          .               #[inline]
     .          .          .          .               pub const fn is_dead(&self) -> bool {
    43 ( 0.00%) .          .          .                   self.as_usize_unchecked() & LazyStateID::MASK_DEAD > 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return true if and only if this represents a quit state. A quit state
     .          .          .          .               /// is a state that is representationally equivalent to a dead state,
     .          .          .          .               /// except it indicates the automaton has reached a point at which it can
     .          .          .          .               /// no longer determine whether a match exists or not. In general, this
     .          .          .          .               /// indicates an error during search and the caller must either pass this
     .          .          .          .               /// error up or use a different search technique.
-- line 298 ----------------------------------------
-- line 305 ----------------------------------------
     .          .          .          .               /// start state.
     .          .          .          .               ///
     .          .          .          .               /// Note that if
     .          .          .          .               /// [`Config::specialize_start_states`](crate::hybrid::dfa::Config) is
     .          .          .          .               /// disabled (which is the default), then this will always return false
     .          .          .          .               /// since start states won't be tagged.
     .          .          .          .               #[inline]
     .          .          .          .               pub const fn is_start(&self) -> bool {
     1 ( 0.00%) .          .          .                   self.as_usize_unchecked() & LazyStateID::MASK_START > 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return true if and only if this lazy state ID has been tagged as a
     .          .          .          .               /// match state.
     .          .          .          .               #[inline]
     .          .          .          .               pub const fn is_match(&self) -> bool {
    48 ( 0.00%) .          .          .                   self.as_usize_unchecked() & LazyStateID::MASK_MATCH > 0
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// This error occurs when a lazy state ID could not be constructed.
     .          .          .          .           ///
     .          .          .          .           /// This occurs when given an integer exceeding the maximum lazy state ID
     .          .          .          .           /// value.
     .          .          .          .           ///
-- line 328 ----------------------------------------

 1,165 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/id.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 27 ----------------------------------------
     .          .          .          .               pid: PatternID,
     .          .          .          .               start: *const u8,
     .          .          .          .               end: *const u8,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl Match {
     .          .          .          .               /// Returns the ID of the pattern that matched.
     .          .          .          .               pub(crate) fn pattern(&self) -> PatternID {
     1 ( 0.00%) .          .          .                   self.pid
     1 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns a pointer into the haystack at which the match starts.
     .          .          .          .               pub(crate) fn start(&self) -> *const u8 {
     1 ( 0.00%) .          .          .                   self.start
     1 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns a pointer into the haystack at which the match ends.
     .          .          .          .               pub(crate) fn end(&self) -> *const u8 {
     1 ( 0.00%) .          .          .                   self.end
     1 ( 0.00%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A "slim" Teddy implementation that is generic over both the vector type
     .          .          .          .           /// and the minimum length of the patterns being searched for.
     .          .          .          .           ///
     .          .          .          .           /// Only 1, 2, 3 and 4 bytes are supported as minimum lengths.
     .          .          .          .           #[derive(Clone, Debug)]
     .          .          .          .           pub(crate) struct Slim<V, const BYTES: usize> {
-- line 54 ----------------------------------------
-- line 71 ----------------------------------------
     .          .          .          .               /// Callers must ensure that this is okay to call in the current target for
     .          .          .          .               /// the current CPU.
     .          .          .          .               #[inline(always)]
     .          .          .          .               pub(crate) unsafe fn new(patterns: Arc<Patterns>) -> Slim<V, BYTES> {
     .          .          .          .                   assert!(
     .          .          .          .                       1 <= BYTES && BYTES <= 4,
     .          .          .          .                       "only 1, 2, 3 or 4 bytes are supported"
     .          .          .          .                   );
    90 ( 0.00%) .          .          .                   let teddy = Teddy::new(patterns);
125,295 ( 0.04%) 490 ( 0.06%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (10x)
     .          .          .          .                   let masks = SlimMaskBuilder::from_teddy(&teddy);
   434 ( 0.00%) .          .          .                   Slim { teddy, masks }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the approximate total amount of heap used by this type, in
     .          .          .          .               /// units of bytes.
     .          .          .          .               #[inline(always)]
     .          .          .          .               pub(crate) fn memory_usage(&self) -> usize {
     .          .          .          .                   self.teddy.memory_usage()
     .          .          .          .               }
-- line 89 ----------------------------------------
-- line 243 ----------------------------------------
     .          .          .          .                   start: *const u8,
     .          .          .          .                   end: *const u8,
     .          .          .          .               ) -> Option<Match> {
     .          .          .          .                   let len = end.distance(start);
     .          .          .          .                   debug_assert!(len >= self.minimum_len());
     .          .          .          .                   let mut cur = start.add(2);
     .          .          .          .                   let mut prev0 = V::splat(0xFF);
     .          .          .          .                   let mut prev1 = V::splat(0xFF);
    14 ( 0.00%) .          .          .                   while cur <= end.sub(V::BYTES) {
     .          .          .          .                       if let Some(m) = self.find_one(cur, end, &mut prev0, &mut prev1) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                       cur = cur.add(V::BYTES);
     .          .          .          .                   }
     4 ( 0.00%) .          .          .                   if cur < end {
     .          .          .          .                       cur = end.sub(V::BYTES);
     .          .          .          .                       prev0 = V::splat(0xFF);
     .          .          .          .                       prev1 = V::splat(0xFF);
     .          .          .          .                       if let Some(m) = self.find_one(cur, end, &mut prev0, &mut prev1) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   None
-- line 265 ----------------------------------------
-- line 269 ----------------------------------------
     .          .          .          .               #[inline(always)]
     .          .          .          .               unsafe fn find_one(
     .          .          .          .                   &self,
     .          .          .          .                   cur: *const u8,
     .          .          .          .                   end: *const u8,
     .          .          .          .                   prev0: &mut V,
     .          .          .          .                   prev1: &mut V,
     .          .          .          .               ) -> Option<Match> {
     5 ( 0.00%) .          .          .                   let c = self.candidate(cur, prev0, prev1);
     3 ( 0.00%) .          .          .                   if !c.is_zero() {
     .          .          .          .                       if let Some(m) = self.teddy.verify(cur.sub(2), end, c) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   None
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// See Slim<V, 1>::candidate.
-- line 286 ----------------------------------------
-- line 287 ----------------------------------------
     .          .          .          .               #[inline(always)]
     .          .          .          .               unsafe fn candidate(
     .          .          .          .                   &self,
     .          .          .          .                   cur: *const u8,
     .          .          .          .                   prev0: &mut V,
     .          .          .          .                   prev1: &mut V,
     .          .          .          .               ) -> V {
     .          .          .          .                   let chunk = V::load_unaligned(cur);
    12 ( 0.00%) .          .          .                   let (res0, res1, res2) = Mask::members3(chunk, self.masks);
     .          .          .          .                   let res0prev0 = res0.shift_in_two_bytes(*prev0);
     .          .          .          .                   let res1prev1 = res1.shift_in_one_byte(*prev1);
     .          .          .          .                   let res = res0prev0.and(res1prev1).and(res2);
     .          .          .          .                   *prev0 = res0;
     .          .          .          .                   *prev1 = res1;
     .          .          .          .                   res
     .          .          .          .               }
     .          .          .          .           }
-- line 303 ----------------------------------------
-- line 404 ----------------------------------------
     .          .          .          .               /// Callers must ensure that this is okay to call in the current target for
     .          .          .          .               /// the current CPU.
     .          .          .          .               #[inline(always)]
     .          .          .          .               pub(crate) unsafe fn new(patterns: Arc<Patterns>) -> Fat<V, BYTES> {
     .          .          .          .                   assert!(
     .          .          .          .                       1 <= BYTES && BYTES <= 4,
     .          .          .          .                       "only 1, 2, 3 or 4 bytes are supported"
     .          .          .          .                   );
    21 ( 0.00%) .          .          .                   let teddy = Teddy::new(patterns);
709,589 ( 0.20%) 2,441 ( 0.30%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (21x)
     .          .          .          .                   let masks = FatMaskBuilder::from_teddy(&teddy);
    84 ( 0.00%) .          .          .                   Fat { teddy, masks }
 1,365 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (21x)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the approximate total amount of heap used by this type, in
     .          .          .          .               /// units of bytes.
     .          .          .          .               #[inline(always)]
     .          .          .          .               pub(crate) fn memory_usage(&self) -> usize {
     .          .          .          .                   self.teddy.memory_usage()
     .          .          .          .               }
-- line 422 ----------------------------------------
-- line 576 ----------------------------------------
     .          .          .          .                   start: *const u8,
     .          .          .          .                   end: *const u8,
     .          .          .          .               ) -> Option<Match> {
     .          .          .          .                   let len = end.distance(start);
     .          .          .          .                   debug_assert!(len >= self.minimum_len());
     .          .          .          .                   let mut cur = start.add(2);
     .          .          .          .                   let mut prev0 = V::splat(0xFF);
     .          .          .          .                   let mut prev1 = V::splat(0xFF);
    45 ( 0.00%) .          .          .                   while cur <= end.sub(V::Half::BYTES) {
     .          .          .          .                       if let Some(m) = self.find_one(cur, end, &mut prev0, &mut prev1) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                       cur = cur.add(V::Half::BYTES);
     .          .          .          .                   }
    18 ( 0.00%) .          .          .                   if cur < end {
     .          .          .          .                       cur = end.sub(V::Half::BYTES);
     .          .          .          .                       prev0 = V::splat(0xFF);
     .          .          .          .                       prev1 = V::splat(0xFF);
     .          .          .          .                       if let Some(m) = self.find_one(cur, end, &mut prev0, &mut prev1) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   None
-- line 598 ----------------------------------------
-- line 603 ----------------------------------------
     .          .          .          .               unsafe fn find_one(
     .          .          .          .                   &self,
     .          .          .          .                   cur: *const u8,
     .          .          .          .                   end: *const u8,
     .          .          .          .                   prev0: &mut V,
     .          .          .          .                   prev1: &mut V,
     .          .          .          .               ) -> Option<Match> {
     .          .          .          .                   let c = self.candidate(cur, prev0, prev1);
    18 ( 0.00%) .          .          .                   if !c.is_zero() {
     .          .          .          .                       if let Some(m) = self.teddy.verify(cur.sub(2), end, c) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   None
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// See `Fat<V, 1>::candidate`.
-- line 619 ----------------------------------------
-- line 620 ----------------------------------------
     .          .          .          .               #[inline(always)]
     .          .          .          .               unsafe fn candidate(
     .          .          .          .                   &self,
     .          .          .          .                   cur: *const u8,
     .          .          .          .                   prev0: &mut V,
     .          .          .          .                   prev1: &mut V,
     .          .          .          .               ) -> V {
     .          .          .          .                   let chunk = V::load_half_unaligned(cur);
    54 ( 0.00%) .          .          .                   let (res0, res1, res2) = Mask::members3(chunk, self.masks);
     .          .          .          .                   let res0prev0 = res0.half_shift_in_two_bytes(*prev0);
     .          .          .          .                   let res1prev1 = res1.half_shift_in_one_byte(*prev1);
     .          .          .          .                   let res = res0prev0.and(res1prev1).and(res2);
     .          .          .          .                   *prev0 = res0;
     .          .          .          .                   *prev1 = res1;
     .          .          .          .                   res
     .          .          .          .               }
     .          .          .          .           }
-- line 636 ----------------------------------------
-- line 743 ----------------------------------------
     .          .          .          .               //
     .          .          .          .               // One other avenue I haven't explored is some kind of hashing trick
     .          .          .          .               // that let's us do another high-confidence check before launching into
     .          .          .          .               // `memcmp`.
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<const BUCKETS: usize> Teddy<BUCKETS> {
     .          .          .          .               /// Create a new generic data structure for Teddy verification.
   399 ( 0.00%) .          .          .               fn new(patterns: Arc<Patterns>) -> Teddy<BUCKETS> {
   171 ( 0.00%) .          .          .                   assert_ne!(0, patterns.len(), "Teddy requires at least one pattern");
   114 ( 0.00%) .          .          .                   assert_ne!(
     .          .          .          .                       0,
    57 ( 0.00%) .          .          .                       patterns.minimum_len(),
     .          .          .          .                       "Teddy does not support zero-length patterns"
     .          .          .          .                   );
     .          .          .          .                   assert!(
     .          .          .          .                       BUCKETS == 8 || BUCKETS == 16,
     .          .          .          .                       "Teddy only supports 8 or 16 buckets"
     .          .          .          .                   );
     .          .          .          .                   // MSRV(1.63): Use core::array::from_fn below instead of allocating a
     .          .          .          .                   // superfluous outer Vec. Not a big deal (especially given the BTreeMap
     .          .          .          .                   // allocation below), but nice to not do it.
     .          .          .          .                   let buckets =
     .          .          .          .                       <[Vec<PatternID>; BUCKETS]>::try_from(vec![vec![]; BUCKETS])
     .          .          .          .                           .unwrap();
    57 ( 0.00%) .          .          .                   let mut t = Teddy { patterns, buckets };
     .          .          .          .           
     .          .          .          .                   let mut map: BTreeMap<Box<[u8]>, usize> = BTreeMap::new();
     .          .          .          .                   for (id, pattern) in t.patterns.iter() {
     .          .          .          .                       // We try to be slightly clever in how we assign patterns into
     .          .          .          .                       // buckets. Generally speaking, we want patterns with the same
     .          .          .          .                       // prefix to be in the same bucket, since it minimizes the amount
     .          .          .          .                       // of time we spend churning through buckets in the verification
     .          .          .          .                       // step.
-- line 776 ----------------------------------------
-- line 788 ----------------------------------------
     .          .          .          .                       // same bucket, we ensure that we preserve correct leftmost-first
     .          .          .          .                       // and leftmost-longest match semantics. In addition to the fact
     .          .          .          .                       // that `patterns.iter()` iterates in the correct order, this
     .          .          .          .                       // guarantees that all possible ambiguous matches will occur in
     .          .          .          .                       // the same bucket. The verification routine could be adjusted to
     .          .          .          .                       // support correct leftmost match semantics regardless of bucket
     .          .          .          .                       // allocation, but that results in a performance hit. It's much
     .          .          .          .                       // nicer to be able to just stop as soon as a match is found.
 1,084 ( 0.00%) .          .          .                       let lonybs = pattern.low_nybbles(t.mask_len());
   678 ( 0.00%) .          .          .                       if let Some(&bucket) = map.get(&lonybs) {
 3,390 ( 0.00%) .          .          .                           t.buckets[bucket].push(id);
     .          .          .          .                       } else {
     .          .          .          .                           // N.B. We assign buckets in reverse because it shouldn't have
     .          .          .          .                           // any influence on performance, but it does make it harder to
     .          .          .          .                           // get leftmost match semantics accidentally correct.
   812 ( 0.00%) .          .          .                           let bucket = (BUCKETS - 1) - (id.as_usize() % BUCKETS);
 1,624 ( 0.00%) .          .          .                           t.buckets[bucket].push(id);
 2,030 ( 0.00%) .          .          .                           map.insert(lonybs, bucket);
122,023 ( 0.04%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/map.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert (406x)
     .          .          .          .                       }
     .          .          .          .                   }
   228 ( 0.00%) .          .          .                   t
 2,445 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (57x)
   513 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Verify whether there are any matches starting at or after `cur` in the
     .          .          .          .               /// haystack. The candidate chunk given should correspond to 8-bit bitsets
     .          .          .          .               /// for N buckets.
     .          .          .          .               ///
     .          .          .          .               /// # Safety
     .          .          .          .               ///
     .          .          .          .               /// The given pointers representing the haystack must be valid to read
-- line 817 ----------------------------------------
-- line 818 ----------------------------------------
     .          .          .          .               /// from.
     .          .          .          .               #[inline(always)]
     .          .          .          .               unsafe fn verify64(
     .          .          .          .                   &self,
     .          .          .          .                   cur: *const u8,
     .          .          .          .                   end: *const u8,
     .          .          .          .                   mut candidate_chunk: u64,
     .          .          .          .               ) -> Option<Match> {
    50 ( 0.00%) .          .          .                   while candidate_chunk != 0 {
     .          .          .          .                       let bit = candidate_chunk.trailing_zeros().as_usize();
    48 ( 0.00%) .          .          .                       candidate_chunk &= !(1 << bit);
     .          .          .          .           
     .          .          .          .                       let cur = cur.add(bit / BUCKETS);
    34 ( 0.00%) .          .          .                       let bucket = bit % BUCKETS;
     .          .          .          .                       if let Some(m) = self.verify_bucket(cur, end, bucket) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   None
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Verify whether there are any matches starting at `at` in the given
-- line 839 ----------------------------------------
-- line 885 ----------------------------------------
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the approximate total amount of heap used by this type, in
     .          .          .          .               /// units of bytes.
     .          .          .          .               fn memory_usage(&self) -> usize {
     .          .          .          .                   // This is an upper bound rather than a precise accounting. No
     .          .          .          .                   // particular reason, other than it's probably very close to actual
     .          .          .          .                   // memory usage in practice.
    21 ( 0.00%) .          .          .                   self.patterns.len() * core::mem::size_of::<PatternID>()
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl Teddy<8> {
     .          .          .          .               /// Runs the verification routine for "slim" Teddy.
     .          .          .          .               ///
     .          .          .          .               /// The candidate given should be a collection of 8-bit bitsets (one bitset
     .          .          .          .               /// per lane), where the ith bit is set in the jth lane if and only if the
-- line 901 ----------------------------------------
-- line 1186 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
     .          .          .          .               /// When `bucket >= 8`.
     .          .          .          .               fn add(&mut self, bucket: usize, byte: u8) {
     .          .          .          .                   assert!(bucket < 8);
     .          .          .          .           
     .          .          .          .                   let bucket = u8::try_from(bucket).unwrap();
   606 ( 0.00%) .          .          .                   let byte_lo = usize::from(byte & 0xF);
 1,212 ( 0.00%) .          .          .                   let byte_hi = usize::from((byte >> 4) & 0xF);
     .          .          .          .                   // When using 256-bit vectors, we need to set this bucket assignment in
     .          .          .          .                   // the low and high 128-bit portions of the mask. This allows us to
     .          .          .          .                   // process 32 bytes at a time. Namely, AVX2 shuffles operate on each
     .          .          .          .                   // of the 128-bit lanes, rather than the full 256-bit vector at once.
   606 ( 0.00%) .          .          .                   self.lo[byte_lo] |= 1 << bucket;
   606 ( 0.00%) .          .          .                   self.lo[byte_lo + 16] |= 1 << bucket;
   606 ( 0.00%) .          .          .                   self.hi[byte_hi] |= 1 << bucket;
   606 ( 0.00%) .          .          .                   self.hi[byte_hi + 16] |= 1 << bucket;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Turn this builder into a vector mask.
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
     .          .          .          .               /// When `V` represents a vector bigger than what `MaskBytes` can contain.
     .          .          .          .               ///
-- line 1211 ----------------------------------------
-- line 1237 ----------------------------------------
     .          .          .          .               #[inline(always)]
     .          .          .          .               unsafe fn from_teddy<const BYTES: usize, V: Vector>(
     .          .          .          .                   teddy: &Teddy<8>,
     .          .          .          .               ) -> [Mask<V>; BYTES] {
     .          .          .          .                   // MSRV(1.63): Use core::array::from_fn to just build the array here
     .          .          .          .                   // instead of creating a vector and turning it into an array.
     .          .          .          .                   let mut mask_builders = vec![SlimMaskBuilder::default(); BYTES];
     .          .          .          .                   for (bucket_index, bucket) in teddy.buckets.iter().enumerate() {
   128 ( 0.00%) .          .          .                       for pid in bucket.iter().copied() {
     .          .          .          .                           let pat = teddy.patterns.get(pid);
     .          .          .          .                           for (i, builder) in mask_builders.iter_mut().enumerate() {
 1,818 ( 0.00%) .          .          .                               builder.add(bucket_index, pat.bytes()[i]);
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   let array =
     .          .          .          .                       <[SlimMaskBuilder; BYTES]>::try_from(mask_builders).unwrap();
     .          .          .          .                   array.map(|builder| builder.build())
     .          .          .          .               }
     .          .          .          .           }
-- line 1256 ----------------------------------------
-- line 1296 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
     .          .          .          .               /// When `bucket >= 16`.
     .          .          .          .               fn add(&mut self, bucket: usize, byte: u8) {
     .          .          .          .                   assert!(bucket < 16);
     .          .          .          .           
     .          .          .          .                   let bucket = u8::try_from(bucket).unwrap();
 4,932 ( 0.00%) .          .          .                   let byte_lo = usize::from(byte & 0xF);
 2,466 ( 0.00%) .          .          .                   let byte_hi = usize::from((byte >> 4) & 0xF);
     .          .          .          .                   // Unlike slim teddy, fat teddy only works with AVX2. For fat teddy,
     .          .          .          .                   // the high 128 bits of our mask correspond to buckets 8-15, while the
     .          .          .          .                   // low 128 bits correspond to buckets 0-7.
   368 ( 0.00%) .          .          .                   if bucket < 8 {
 1,206 ( 0.00%) .          .          .                       self.lo[byte_lo] |= 1 << bucket;
     .          .          .          .                       self.hi[byte_hi] |= 1 << bucket;
     .          .          .          .                   } else {
 1,260 ( 0.00%) .          .          .                       self.lo[byte_lo + 16] |= 1 << (bucket % 8);
     .          .          .          .                       self.hi[byte_hi + 16] |= 1 << (bucket % 8);
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Turn this builder into a vector mask.
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
-- line 1321 ----------------------------------------
-- line 1324 ----------------------------------------
     .          .          .          .               /// # Safety
     .          .          .          .               ///
     .          .          .          .               /// Callers must ensure that this is okay to call in the current target for
     .          .          .          .               /// the current CPU.
     .          .          .          .               #[inline(always)]
     .          .          .          .               unsafe fn build<V: Vector>(&self) -> Mask<V> {
     .          .          .          .                   assert!(V::BYTES <= self.lo.len());
     .          .          .          .                   assert!(V::BYTES <= self.hi.len());
     4 ( 0.00%) .          .          .                   Mask {
     .          .          .          .                       lo: V::load_unaligned(self.lo[..].as_ptr()),
     .          .          .          .                       hi: V::load_unaligned(self.hi[..].as_ptr()),
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// A convenience function for building `N` vector masks from a fat
     .          .          .          .               /// `Teddy` value.
     .          .          .          .               ///
-- line 1340 ----------------------------------------
-- line 1348 ----------------------------------------
     .          .          .          .               /// the current CPU.
     .          .          .          .               #[inline(always)]
     .          .          .          .               unsafe fn from_teddy<const BYTES: usize, V: Vector>(
     .          .          .          .                   teddy: &Teddy<16>,
     .          .          .          .               ) -> [Mask<V>; BYTES] {
     .          .          .          .                   // MSRV(1.63): Use core::array::from_fn to just build the array here
     .          .          .          .                   // instead of creating a vector and turning it into an array.
     .          .          .          .                   let mut mask_builders = vec![FatMaskBuilder::default(); BYTES];
    21 ( 0.00%) .          .          .                   for (bucket_index, bucket) in teddy.buckets.iter().enumerate() {
     .          .          .          .                       for pid in bucket.iter().copied() {
     .          .          .          .                           let pat = teddy.patterns.get(pid);
     .          .          .          .                           for (i, builder) in mask_builders.iter_mut().enumerate() {
 7,398 ( 0.00%) .          .          .                               builder.add(bucket_index, pat.bytes()[i]);
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   let array =
     .          .          .          .                       <[FatMaskBuilder; BYTES]>::try_from(mask_builders).unwrap();
     .          .          .          .                   array.map(|builder| builder.build())
     .          .          .          .               }
     .          .          .          .           }
-- line 1368 ----------------------------------------

10,559 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/generic.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 141 ----------------------------------------
      .          .          .          .                   P: AsRef<[u8]>,
      .          .          .          .               {
      .          .          .          .                   DFA::builder().build(patterns)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// A convenience method for returning a new Aho-Corasick DFA builder.
      .          .          .          .               ///
      .          .          .          .               /// This usually permits one to just import the `DFA` type.
     39 ( 0.00%) .          .          .               pub fn builder() -> Builder {
      .          .          .          .                   Builder::new()
     39 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl DFA {
      .          .          .          .               /// A sentinel state ID indicating that a search should stop once it has
      .          .          .          .               /// entered this state. When a search stops, it returns a match if one has
      .          .          .          .               /// been found, otherwise no match. A DFA always has an actual dead state
      .          .          .          .               /// at this ID.
      .          .          .          .               ///
-- line 159 ----------------------------------------
-- line 163 ----------------------------------------
      .          .          .          .               /// failure transitions everywhere, such that failure transitions are no
      .          .          .          .               /// longer used at search time. This, combined with its uniformly dense
      .          .          .          .               /// representation, are the two most important factors in why it's faster
      .          .          .          .               /// than the NFAs in this crate.
      .          .          .          .               const DEAD: StateID = StateID::new_unchecked(0);
      .          .          .          .           
      .          .          .          .               /// Adds the given pattern IDs as matches to the given state and also
      .          .          .          .               /// records the added memory usage.
 16,515 ( 0.00%) .          .          .               fn set_matches(
      .          .          .          .                   &mut self,
      .          .          .          .                   sid: StateID,
      .          .          .          .                   pids: impl Iterator<Item = PatternID>,
      .          .          .          .               ) {
  3,670 ( 0.00%) .          .          .                   let index = (sid.as_usize() >> self.stride2).checked_sub(2).unwrap();
      .          .          .          .                   let mut at_least_one = false;
      .          .          .          .                   for pid in pids {
      .          .          .          .                       self.matches[index].push(pid);
  1,835 ( 0.00%) .          .          .                       self.matches_memory_usage += PatternID::SIZE;
      .          .          .          .                       at_least_one = true;
      .          .          .          .                   }
      .          .          .          .                   assert!(at_least_one, "match state must have non-empty pids");
 14,680 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           // SAFETY: 'start_state' always returns a valid state ID, 'next_state' always
      .          .          .          .           // returns a valid state ID given a valid state ID. We otherwise claim that
      .          .          .          .           // all other methods are correct as well.
      .          .          .          .           unsafe impl Automaton for DFA {
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn start_state(&self, anchored: Anchored) -> Result<StateID, MatchError> {
-- line 192 ----------------------------------------
-- line 389 ----------------------------------------
      .          .          .          .           pub struct Builder {
      .          .          .          .               noncontiguous: noncontiguous::Builder,
      .          .          .          .               start_kind: StartKind,
      .          .          .          .               byte_classes: bool,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Default for Builder {
      .          .          .          .               fn default() -> Builder {
     48 ( 0.00%) .          .          .                   Builder {
      .          .          .          .                       noncontiguous: noncontiguous::Builder::new(),
      .          .          .          .                       start_kind: StartKind::Unanchored,
      .          .          .          .                       byte_classes: true,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Builder {
-- line 405 ----------------------------------------
-- line 411 ----------------------------------------
      .          .          .          .               /// Build an Aho-Corasick DFA from the given iterator of patterns.
      .          .          .          .               ///
      .          .          .          .               /// A builder may be reused to create more DFAs.
      .          .          .          .               pub fn build<I, P>(&self, patterns: I) -> Result<DFA, BuildError>
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = P>,
      .          .          .          .                   P: AsRef<[u8]>,
      .          .          .          .               {
    390 ( 0.00%) .          .          .                   let nnfa = self.noncontiguous.build(patterns)?;
7,483,848 ( 2.15%) 3,482 ( 0.43%) 7 ( 2.16%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (39x)
  3,003 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (39x)
    117 ( 0.00%) .          .          .                   self.build_from_noncontiguous(&nnfa)
7,008,374 ( 2.02%) 1,076 ( 0.13%) 4 ( 1.23%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (39x)
     78 ( 0.00%) .          .          .               }
 30,832 ( 0.01%) 287 ( 0.04%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<aho_corasick::nfa::noncontiguous::NFA> (39x)
      .          .          .          .           
      .          .          .          .               /// Build an Aho-Corasick DFA from the given noncontiguous NFA.
      .          .          .          .               ///
      .          .          .          .               /// Note that when this method is used, only the `start_kind` and
      .          .          .          .               /// `byte_classes` settings on this builder are respected. The other
      .          .          .          .               /// settings only apply to the initial construction of the Aho-Corasick
      .          .          .          .               /// automaton. Since using this method requires that initial construction
      .          .          .          .               /// has already completed, all settings impacting only initial construction
      .          .          .          .               /// are no longer relevant.
    432 ( 0.00%) .          .          .               pub fn build_from_noncontiguous(
      .          .          .          .                   &self,
      .          .          .          .                   nnfa: &noncontiguous::NFA,
      .          .          .          .               ) -> Result<DFA, BuildError> {
      .          .          .          .                   debug!("building DFA");
     96 ( 0.00%) .          .          .                   let byte_classes = if self.byte_classes {
      .          .          .          .                       nnfa.byte_classes().clone()
      .          .          .          .                   } else {
      .          .          .          .                       ByteClasses::singletons()
      .          .          .          .                   };
    240 ( 0.00%) .          .          .                   let state_len = match self.start_kind {
      .          .          .          .                       StartKind::Unanchored | StartKind::Anchored => nnfa.states().len(),
      .          .          .          .                       StartKind::Both => {
      .          .          .          .                           // These unwraps are OK because we know that the number of
      .          .          .          .                           // NFA states is < StateID::LIMIT which is in turn less than
      .          .          .          .                           // i32::MAX. Thus, there is always room to multiply by 2.
      .          .          .          .                           // Finally, the number of states is always at least 4 in the
      .          .          .          .                           // NFA (DEAD, FAIL, START-UNANCHORED, START-ANCHORED), so the
      .          .          .          .                           // subtraction of 4 is okay.
-- line 449 ----------------------------------------
-- line 471 ----------------------------------------
      .          .          .          .                       };
      .          .          .          .                   StateID::new(trans_len.checked_sub(byte_classes.stride()).unwrap())
      .          .          .          .                       .map_err(|e| {
      .          .          .          .                           BuildError::state_id_overflow(
      .          .          .          .                               StateID::MAX.as_u64(),
      .          .          .          .                               e.attempted(),
      .          .          .          .                           )
      .          .          .          .                       })?;
     48 ( 0.00%) .          .          .                   let num_match_states = match self.start_kind {
      .          .          .          .                       StartKind::Unanchored | StartKind::Anchored => {
      .          .          .          .                           nnfa.special().max_match_id.as_usize().checked_sub(1).unwrap()
      .          .          .          .                       }
      .          .          .          .                       StartKind::Both => nnfa
      .          .          .          .                           .special()
      .          .          .          .                           .max_match_id
      .          .          .          .                           .as_usize()
      .          .          .          .                           .checked_sub(1)
      .          .          .          .                           .unwrap()
      .          .          .          .                           .checked_mul(2)
      .          .          .          .                           .unwrap(),
      .          .          .          .                   };
  1,200 ( 0.00%) .          .          .                   let mut dfa = DFA {
      .          .          .          .                       trans: vec![DFA::DEAD; trans_len],
      .          .          .          .                       matches: vec![vec![]; num_match_states],
      .          .          .          .                       matches_memory_usage: 0,
      .          .          .          .                       pattern_lens: nnfa.pattern_lens_raw().to_vec(),
      .          .          .          .                       prefilter: nnfa.prefilter().map(|p| p.clone()),
      .          .          .          .                       match_kind: nnfa.match_kind(),
      .          .          .          .                       state_len,
      .          .          .          .                       alphabet_len: byte_classes.alphabet_len(),
      .          .          .          .                       stride2: byte_classes.stride2(),
  1,824 ( 0.00%) .          .          .                       byte_classes,
      .          .          .          .                       min_pattern_len: nnfa.min_pattern_len(),
      .          .          .          .                       max_pattern_len: nnfa.max_pattern_len(),
      .          .          .          .                       // The special state IDs are set later.
      .          .          .          .                       special: Special::zero(),
      .          .          .          .                   };
    114 ( 0.00%) .          .          .                   match self.start_kind {
      .          .          .          .                       StartKind::Both => {
      .          .          .          .                           self.finish_build_both_starts(nnfa, &mut dfa);
      .          .          .          .                       }
      .          .          .          .                       StartKind::Unanchored => {
      .          .          .          .                           self.finish_build_one_start(Anchored::No, nnfa, &mut dfa);
      .          .          .          .                       }
      .          .          .          .                       StartKind::Anchored => {
     39 ( 0.00%) .          .          .                           self.finish_build_one_start(Anchored::Yes, nnfa, &mut dfa)
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   debug!(
      .          .          .          .                       "DFA built, <states: {:?}, size: {:?}, \
      .          .          .          .                        alphabet len: {:?}, stride: {:?}>",
      .          .          .          .                       dfa.state_len,
      .          .          .          .                       dfa.memory_usage(),
      .          .          .          .                       dfa.byte_classes.alphabet_len(),
-- line 524 ----------------------------------------
-- line 531 ----------------------------------------
      .          .          .          .                   dfa.pattern_lens.shrink_to_fit();
      .          .          .          .                   dfa.matches.shrink_to_fit();
      .          .          .          .                   // TODO: We might also want to shrink each Vec inside of `dfa.matches`,
      .          .          .          .                   // or even better, convert it to one contiguous allocation. But I think
      .          .          .          .                   // I went with nested allocs for good reason (can't remember), so this
      .          .          .          .                   // may be tricky to do. I decided not to shrink them here because it
      .          .          .          .                   // might require a fair bit of work to do. It's unclear whether it's
      .          .          .          .                   // worth it.
    144 ( 0.00%) .          .          .                   Ok(dfa)
  3,696 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x)
    432 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Finishes building a DFA for either unanchored or anchored searches,
      .          .          .          .               /// but NOT both.
    312 ( 0.00%) .          .          .               fn finish_build_one_start(
      .          .          .          .                   &self,
      .          .          .          .                   anchored: Anchored,
      .          .          .          .                   nnfa: &noncontiguous::NFA,
      .          .          .          .                   dfa: &mut DFA,
      .          .          .          .               ) {
      .          .          .          .                   // This function always succeeds because we check above that all of the
      .          .          .          .                   // states in the NFA can be mapped to DFA state IDs.
     78 ( 0.00%) .          .          .                   let stride2 = dfa.stride2;
      .          .          .          .                   let old2new = |oldsid: StateID| {
 11,840 ( 0.00%) .          .          .                       StateID::new_unchecked(oldsid.as_usize() << stride2)
      .          .          .          .                   };
      .          .          .          .                   for (oldsid, state) in nnfa.states().iter().with_state_ids() {
      .          .          .          .                       let newsid = old2new(oldsid);
  2,129 ( 0.00%) .          .          .                       if state.is_match() {
  3,812 ( 0.00%) .          .          .                           dfa.set_matches(newsid, nnfa.iter_matches(oldsid));
251,252 ( 0.07%) 908 ( 0.11%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::DFA::set_matches (953x)
      .          .          .          .                       }
      .          .          .          .                       sparse_iter(
      .          .          .          .                           nnfa,
      .          .          .          .                           oldsid,
      .          .          .          .                           &dfa.byte_classes,
      .          .          .          .                           |byte, class, mut oldnextsid| {
 17,869 ( 0.01%) .          .          .                               if oldnextsid == noncontiguous::NFA::FAIL {
 10,608 ( 0.00%) .          .          .                                   if anchored.is_anchored() {
      .          .          .          .                                       oldnextsid = noncontiguous::NFA::DEAD;
      .          .          .          .                                   } else if state.fail() == noncontiguous::NFA::DEAD {
      .          .          .          .                                       // This is a special case that avoids following
      .          .          .          .                                       // DEAD transitions in a non-contiguous NFA.
      .          .          .          .                                       // Following these transitions is pretty slow
      .          .          .          .                                       // because the non-contiguous NFA will always use
      .          .          .          .                                       // a sparse representation for it (because the
      .          .          .          .                                       // DEAD state is usually treated as a sentinel).
-- line 575 ----------------------------------------
-- line 581 ----------------------------------------
      .          .          .          .                                   } else {
      .          .          .          .                                       oldnextsid = nnfa.next_state(
      .          .          .          .                                           Anchored::No,
      .          .          .          .                                           state.fail(),
      .          .          .          .                                           byte,
      .          .          .          .                                       );
      .          .          .          .                                   }
      .          .          .          .                               }
280,791 ( 0.08%) .          .          .                               dfa.trans[newsid.as_usize() + usize::from(class)] =
      .          .          .          .                                   old2new(oldnextsid);
      .          .          .          .                           },
      .          .          .          .                       );
      .          .          .          .                   }
      .          .          .          .                   // Now that we've remapped all the IDs in our states, all that's left
      .          .          .          .                   // is remapping the special state IDs.
      .          .          .          .                   let old = nnfa.special();
      .          .          .          .                   let new = &mut dfa.special;
     39 ( 0.00%) .          .          .                   new.max_special_id = old2new(old.max_special_id);
     39 ( 0.00%) .          .          .                   new.max_match_id = old2new(old.max_match_id);
    273 ( 0.00%) .          .          .                   if anchored.is_anchored() {
      .          .          .          .                       new.start_unanchored_id = DFA::DEAD;
      .          .          .          .                       new.start_anchored_id = old2new(old.start_anchored_id);
      .          .          .          .                   } else {
      .          .          .          .                       new.start_unanchored_id = old2new(old.start_unanchored_id);
      .          .          .          .                       new.start_anchored_id = DFA::DEAD;
      .          .          .          .                   }
    312 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Finishes building a DFA that supports BOTH unanchored and anchored
      .          .          .          .               /// searches. It works by inter-leaving unanchored states with anchored
      .          .          .          .               /// states in the same transition table. This way, we avoid needing to
      .          .          .          .               /// re-shuffle states afterward to ensure that our states still look like
      .          .          .          .               /// DEAD, MATCH, ..., START-UNANCHORED, START-ANCHORED, NON-MATCH, ...
      .          .          .          .               ///
      .          .          .          .               /// Honestly this is pretty inscrutable... Simplifications are most
      .          .          .          .               /// welcome.
      .          .          .          .               fn finish_build_both_starts(
      .          .          .          .                   &self,
      .          .          .          .                   nnfa: &noncontiguous::NFA,
      .          .          .          .                   dfa: &mut DFA,
      .          .          .          .               ) {
      .          .          .          .                   let stride2 = dfa.stride2;
     18 ( 0.00%) .          .          .                   let stride = 1 << stride2;
      .          .          .          .                   let mut remap_unanchored = vec![DFA::DEAD; nnfa.states().len()];
      .          .          .          .                   let mut remap_anchored = vec![DFA::DEAD; nnfa.states().len()];
      .          .          .          .                   let mut is_anchored = vec![false; dfa.state_len];
      .          .          .          .                   let mut newsid = DFA::DEAD;
      .          .          .          .                   let next_dfa_id =
      .          .          .          .                       |sid: StateID| StateID::new_unchecked(sid.as_usize() + stride);
      .          .          .          .                   for (oldsid, state) in nnfa.states().iter().with_state_ids() {
    495 ( 0.00%) .          .          .                       if oldsid == noncontiguous::NFA::DEAD
      .          .          .          .                           || oldsid == noncontiguous::NFA::FAIL
      .          .          .          .                       {
     18 ( 0.00%) .          .          .                           remap_unanchored[oldsid] = newsid;
     18 ( 0.00%) .          .          .                           remap_anchored[oldsid] = newsid;
      .          .          .          .                           newsid = next_dfa_id(newsid);
    945 ( 0.00%) .          .          .                       } else if oldsid == nnfa.special().start_unanchored_id
      .          .          .          .                           || oldsid == nnfa.special().start_anchored_id
      .          .          .          .                       {
      .          .          .          .                           if oldsid == nnfa.special().start_unanchored_id {
      9 ( 0.00%) .          .          .                               remap_unanchored[oldsid] = newsid;
     18 ( 0.00%) .          .          .                               remap_anchored[oldsid] = DFA::DEAD;
      .          .          .          .                           } else {
      9 ( 0.00%) .          .          .                               remap_unanchored[oldsid] = DFA::DEAD;
      9 ( 0.00%) .          .          .                               remap_anchored[oldsid] = newsid;
     27 ( 0.00%) .          .          .                               is_anchored[newsid.as_usize() >> stride2] = true;
      .          .          .          .                           }
     27 ( 0.00%) .          .          .                           if state.is_match() {
      .          .          .          .                               dfa.set_matches(newsid, nnfa.iter_matches(oldsid));
      .          .          .          .                           }
      .          .          .          .                           sparse_iter(
      .          .          .          .                               nnfa,
      .          .          .          .                               oldsid,
      .          .          .          .                               &dfa.byte_classes,
      .          .          .          .                               |_, class, oldnextsid| {
      .          .          .          .                                   let class = usize::from(class);
    252 ( 0.00%) .          .          .                                   if oldnextsid == noncontiguous::NFA::FAIL {
      .          .          .          .                                       dfa.trans[newsid.as_usize() + class] = DFA::DEAD;
      .          .          .          .                                   } else {
      .          .          .          .                                       dfa.trans[newsid.as_usize() + class] = oldnextsid;
      .          .          .          .                                   }
      .          .          .          .                               },
      .          .          .          .                           );
      .          .          .          .                           newsid = next_dfa_id(newsid);
      .          .          .          .                       } else {
    459 ( 0.00%) .          .          .                           let unewsid = newsid;
      .          .          .          .                           newsid = next_dfa_id(newsid);
    459 ( 0.00%) .          .          .                           let anewsid = newsid;
      .          .          .          .                           newsid = next_dfa_id(newsid);
      .          .          .          .           
    459 ( 0.00%) .          .          .                           remap_unanchored[oldsid] = unewsid;
    918 ( 0.00%) .          .          .                           remap_anchored[oldsid] = anewsid;
    918 ( 0.00%) .          .          .                           is_anchored[anewsid.as_usize() >> stride2] = true;
    459 ( 0.00%) .          .          .                           if state.is_match() {
  1,764 ( 0.00%) .          .          .                               dfa.set_matches(unewsid, nnfa.iter_matches(oldsid));
154,690 ( 0.04%) 812 ( 0.10%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::DFA::set_matches (441x)
  2,205 ( 0.00%) .          .          .                               dfa.set_matches(anewsid, nnfa.iter_matches(oldsid));
156,859 ( 0.05%) 828 ( 0.10%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::DFA::set_matches (441x)
      .          .          .          .                           }
      .          .          .          .                           sparse_iter(
      .          .          .          .                               nnfa,
      .          .          .          .                               oldsid,
      .          .          .          .                               &dfa.byte_classes,
 35,037 ( 0.01%) .          .          .                               |byte, class, oldnextsid| {
      .          .          .          .                                   let class = usize::from(class);
  6,273 ( 0.00%) .          .          .                                   if oldnextsid == noncontiguous::NFA::FAIL {
      .          .          .          .                                       let oldnextsid =
 11,979 ( 0.00%) .          .          .                                           if state.fail() == noncontiguous::NFA::DEAD {
      .          .          .          .                                               noncontiguous::NFA::DEAD
      .          .          .          .                                           } else {
     18 ( 0.00%) .          .          .                                               nnfa.next_state(
      .          .          .          .                                                   Anchored::No,
      .          .          .          .                                                   state.fail(),
      .          .          .          .                                                   byte,
      .          .          .          .                                               )
      .          .          .          .                                           };
 23,958 ( 0.01%) .          .          .                                       dfa.trans[unewsid.as_usize() + class] = oldnextsid;
      .          .          .          .                                   } else {
  2,160 ( 0.00%) .          .          .                                       dfa.trans[unewsid.as_usize() + class] = oldnextsid;
  1,080 ( 0.00%) .          .          .                                       dfa.trans[anewsid.as_usize() + class] = oldnextsid;
      .          .          .          .                                   }
 37,638 ( 0.01%) .          .          .                               },
      .          .          .          .                           );
      .          .          .          .                       }
      .          .          .          .                   }
     36 ( 0.00%) .          .          .                   for i in 0..dfa.state_len {
  1,908 ( 0.00%) .          .          .                       let sid = i << stride2;
  1,908 ( 0.00%) .          .          .                       if is_anchored[i] {
      .          .          .          .                           for next in dfa.trans[sid..][..stride].iter_mut() {
 22,464 ( 0.01%) .          .          .                               *next = remap_anchored[*next];
      .          .          .          .                           }
      .          .          .          .                       } else {
      .          .          .          .                           for next in dfa.trans[sid..][..stride].iter_mut() {
 23,328 ( 0.01%) .          .          .                               *next = remap_unanchored[*next];
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // Now that we've remapped all the IDs in our states, all that's left
      .          .          .          .                   // is remapping the special state IDs.
      .          .          .          .                   let old = nnfa.special();
      .          .          .          .                   let new = &mut dfa.special;
     27 ( 0.00%) .          .          .                   new.max_special_id = remap_anchored[old.max_special_id];
     18 ( 0.00%) .          .          .                   new.max_match_id = remap_anchored[old.max_match_id];
     27 ( 0.00%) .          .          .                   new.start_unanchored_id = remap_unanchored[old.start_unanchored_id];
     27 ( 0.00%) .          .          .                   new.start_anchored_id = remap_anchored[old.start_anchored_id];
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the desired match semantics.
      .          .          .          .               ///
      .          .          .          .               /// This only applies when using [`Builder::build`] and not
      .          .          .          .               /// [`Builder::build_from_noncontiguous`].
      .          .          .          .               ///
      .          .          .          .               /// See
      .          .          .          .               /// [`AhoCorasickBuilder::match_kind`](crate::AhoCorasickBuilder::match_kind)
      .          .          .          .               /// for more documentation and examples.
     39 ( 0.00%) .          .          .               pub fn match_kind(&mut self, kind: MatchKind) -> &mut Builder {
      .          .          .          .                   self.noncontiguous.match_kind(kind);
      .          .          .          .                   self
     39 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable ASCII-aware case insensitive matching.
      .          .          .          .               ///
      .          .          .          .               /// This only applies when using [`Builder::build`] and not
      .          .          .          .               /// [`Builder::build_from_noncontiguous`].
      .          .          .          .               ///
      .          .          .          .               /// See
      .          .          .          .               /// [`AhoCorasickBuilder::ascii_case_insensitive`](crate::AhoCorasickBuilder::ascii_case_insensitive)
-- line 745 ----------------------------------------
-- line 752 ----------------------------------------
      .          .          .          .               /// Enable heuristic prefilter optimizations.
      .          .          .          .               ///
      .          .          .          .               /// This only applies when using [`Builder::build`] and not
      .          .          .          .               /// [`Builder::build_from_noncontiguous`].
      .          .          .          .               ///
      .          .          .          .               /// See
      .          .          .          .               /// [`AhoCorasickBuilder::prefilter`](crate::AhoCorasickBuilder::prefilter)
      .          .          .          .               /// for more documentation and examples.
     39 ( 0.00%) .          .          .               pub fn prefilter(&mut self, yes: bool) -> &mut Builder {
      .          .          .          .                   self.noncontiguous.prefilter(yes);
      .          .          .          .                   self
     39 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets the starting state configuration for the automaton.
      .          .          .          .               ///
      .          .          .          .               /// See
      .          .          .          .               /// [`AhoCorasickBuilder::start_kind`](crate::AhoCorasickBuilder::start_kind)
      .          .          .          .               /// for more documentation and examples.
     39 ( 0.00%) .          .          .               pub fn start_kind(&mut self, kind: StartKind) -> &mut Builder {
     48 ( 0.00%) .          .          .                   self.start_kind = kind;
      .          .          .          .                   self
     39 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// A debug setting for whether to attempt to shrink the size of the
      .          .          .          .               /// automaton's alphabet or not.
      .          .          .          .               ///
      .          .          .          .               /// This should never be enabled unless you're debugging an automaton.
      .          .          .          .               /// Namely, disabling byte classes makes transitions easier to reason
      .          .          .          .               /// about, since they use the actual bytes instead of equivalence classes.
      .          .          .          .               /// Disabling this confers no performance benefit at search time.
-- line 781 ----------------------------------------
-- line 802 ----------------------------------------
      .          .          .          .               nnfa: &noncontiguous::NFA,
      .          .          .          .               oldsid: StateID,
      .          .          .          .               classes: &ByteClasses,
      .          .          .          .               mut f: F,
      .          .          .          .           ) {
      .          .          .          .               let mut prev_class = None;
      .          .          .          .               let mut byte = 0usize;
      .          .          .          .               for t in nnfa.iter_trans(oldsid) {
290,396 ( 0.08%) .          .          .                   while byte < usize::from(t.byte()) {
      .          .          .          .                       let rep = byte.as_u8();
      .          .          .          .                       let class = classes.get(rep);
      .          .          .          .                       byte += 1;
      .          .          .          .                       if prev_class != Some(class) {
      .          .          .          .                           f(rep, class, noncontiguous::NFA::FAIL);
      .          .          .          .                           prev_class = Some(class);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   let rep = t.byte();
      .          .          .          .                   let class = classes.get(rep);
      .          .          .          .                   byte += 1;
      .          .          .          .                   if prev_class != Some(class) {
  1,080 ( 0.00%) .          .          .                       f(rep, class, t.next());
 11,160 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::finish_build_both_starts::{{closure}} (360x)
      .          .          .          .                       prev_class = Some(class);
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .               for b in byte..=255 {
      .          .          .          .                   let rep = b.as_u8();
      .          .          .          .                   let class = classes.get(rep);
      .          .          .          .                   if prev_class != Some(class) {
 29,565 ( 0.01%) .          .          .                       f(rep, class, noncontiguous::NFA::FAIL);
165,924 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::finish_build_both_starts::{{closure}} (5,913x)
      .          .          .          .                       prev_class = Some(class);
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }

916,703 ( 0.26%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/dfa.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 47 ----------------------------------------
        .          .          .          .                       Primitive::Dot(ref span) => span,
        .          .          .          .                       Primitive::Perl(ref x) => &x.span,
        .          .          .          .                       Primitive::Unicode(ref x) => &x.span,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Convert this primitive into a proper AST.
        .          .          .          .               fn into_ast(self) -> Ast {
  496,070 ( 0.14%) .          .          .                   match self {
        .          .          .          .                       Primitive::Literal(lit) => Ast::literal(lit),
        .          .          .          .                       Primitive::Assertion(assert) => Ast::assertion(assert),
        .          .          .          .                       Primitive::Dot(span) => Ast::dot(span),
        .          .          .          .                       Primitive::Perl(cls) => Ast::class_perl(cls),
        .          .          .          .                       Primitive::Unicode(cls) => Ast::class_unicode(cls),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
-- line 63 ----------------------------------------
-- line 67 ----------------------------------------
        .          .          .          .               /// then return an error.
        .          .          .          .               fn into_class_set_item<P: Borrow<Parser>>(
        .          .          .          .                   self,
        .          .          .          .                   p: &ParserI<'_, P>,
        .          .          .          .               ) -> Result<ast::ClassSetItem> {
        .          .          .          .                   use self::Primitive::*;
        .          .          .          .                   use crate::ast::ClassSetItem;
        .          .          .          .           
   24,858 ( 0.01%) .          .          .                   match self {
   35,440 ( 0.01%) .          .          .                       Literal(lit) => Ok(ClassSetItem::Literal(lit)),
       50 ( 0.00%) .          .          .                       Perl(cls) => Ok(ClassSetItem::Perl(cls)),
        .          .          .          .                       Unicode(cls) => Ok(ClassSetItem::Unicode(cls)),
        .          .          .          .                       x => Err(p.error(*x.span(), ast::ErrorKind::ClassEscapeInvalid)),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Convert this primitive into a literal in a character class. In
        .          .          .          .               /// particular, literals are the only valid items that can appear in
        .          .          .          .               /// ranges.
-- line 85 ----------------------------------------
-- line 104 ----------------------------------------
        .          .          .          .               ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// Returns true if the given character is a valid in a capture group name.
        .          .          .          .           ///
        .          .          .          .           /// If `first` is true, then `c` is treated as the first character in the
        .          .          .          .           /// group name (which must be alphabetic or underscore).
        .          .          .          .           fn is_capture_char(c: char, first: bool) -> bool {
    1,758 ( 0.00%) .          .          .               if first {
    1,172 ( 0.00%) .          .          .                   c == '_' || c.is_alphabetic()
        .          .          .          .               } else {
    6,753 ( 0.00%) .          .          .                   c == '_' || c == '.' || c == '[' || c == ']' || c.is_alphanumeric()
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// A builder for a regular expression parser.
        .          .          .          .           ///
        .          .          .          .           /// This builder permits modifying configuration options for the parser.
        .          .          .          .           #[derive(Clone, Debug)]
        .          .          .          .           pub struct ParserBuilder {
-- line 123 ----------------------------------------
-- line 137 ----------------------------------------
        .          .          .          .               /// Create a new parser builder with a default configuration.
        .          .          .          .               pub fn new() -> ParserBuilder {
        .          .          .          .                   ParserBuilder {
        .          .          .          .                       ignore_whitespace: false,
        .          .          .          .                       nest_limit: 250,
        .          .          .          .                       octal: false,
        .          .          .          .                       empty_min_range: false,
        .          .          .          .                   }
      162 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Build a parser from this configuration with the given pattern.
       81 ( 0.00%) .          .          .               pub fn build(&self) -> Parser {
    2,025 ( 0.00%) .          .          .                   Parser {
        .          .          .          .                       pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),
        .          .          .          .                       capture_index: Cell::new(0),
       81 ( 0.00%) .          .          .                       nest_limit: self.nest_limit,
       81 ( 0.00%) .          .          .                       octal: self.octal,
       81 ( 0.00%) .          .          .                       empty_min_range: self.empty_min_range,
       81 ( 0.00%) .          .          .                       initial_ignore_whitespace: self.ignore_whitespace,
        .          .          .          .                       ignore_whitespace: Cell::new(self.ignore_whitespace),
        .          .          .          .                       comments: RefCell::new(vec![]),
        .          .          .          .                       stack_group: RefCell::new(vec![]),
        .          .          .          .                       stack_class: RefCell::new(vec![]),
        .          .          .          .                       capture_names: RefCell::new(vec![]),
        .          .          .          .                       scratch: RefCell::new(String::new()),
        .          .          .          .                   }
       81 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Set the nesting limit for this parser.
        .          .          .          .               ///
        .          .          .          .               /// The nesting limit controls how deep the abstract syntax tree is allowed
        .          .          .          .               /// to be. If the AST exceeds the given limit (e.g., with too many nested
        .          .          .          .               /// groups), then an error is returned by the parser.
        .          .          .          .               ///
        .          .          .          .               /// The purpose of this limit is to act as a heuristic to prevent stack
-- line 171 ----------------------------------------
-- line 182 ----------------------------------------
        .          .          .          .               /// length of the pattern string.
        .          .          .          .               ///
        .          .          .          .               /// Note that a nest limit of `0` will return a nest limit error for most
        .          .          .          .               /// patterns but not all. For example, a nest limit of `0` permits `a` but
        .          .          .          .               /// not `ab`, since `ab` requires a concatenation, which results in a nest
        .          .          .          .               /// depth of `1`. In general, a nest limit is not something that manifests
        .          .          .          .               /// in an obvious way in the concrete syntax, therefore, it should not be
        .          .          .          .               /// used in a granular way.
       81 ( 0.00%) .          .          .               pub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder {
       81 ( 0.00%) .          .          .                   self.nest_limit = limit;
        .          .          .          .                   self
       81 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Whether to support octal syntax or not.
        .          .          .          .               ///
        .          .          .          .               /// Octal syntax is a little-known way of uttering Unicode codepoints in
        .          .          .          .               /// a regular expression. For example, `a`, `\x61`, `\u0061` and
        .          .          .          .               /// `\141` are all equivalent regular expressions, where the last example
        .          .          .          .               /// shows octal syntax.
        .          .          .          .               ///
-- line 201 ----------------------------------------
-- line 202 ----------------------------------------
        .          .          .          .               /// While supporting octal syntax isn't in and of itself a problem, it does
        .          .          .          .               /// make good error messages harder. That is, in PCRE based regex engines,
        .          .          .          .               /// syntax like `\0` invokes a backreference, which is explicitly
        .          .          .          .               /// unsupported in Rust's regex engine. However, many users expect it to
        .          .          .          .               /// be supported. Therefore, when octal support is disabled, the error
        .          .          .          .               /// message will explicitly mention that backreferences aren't supported.
        .          .          .          .               ///
        .          .          .          .               /// Octal syntax is disabled by default.
       81 ( 0.00%) .          .          .               pub fn octal(&mut self, yes: bool) -> &mut ParserBuilder {
       81 ( 0.00%) .          .          .                   self.octal = yes;
        .          .          .          .                   self
       81 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Enable verbose mode in the regular expression.
        .          .          .          .               ///
        .          .          .          .               /// When enabled, verbose mode permits insignificant whitespace in many
        .          .          .          .               /// places in the regular expression, as well as comments. Comments are
        .          .          .          .               /// started using `#` and continue until the end of the line.
        .          .          .          .               ///
        .          .          .          .               /// By default, this is disabled. It may be selectively enabled in the
        .          .          .          .               /// regular expression by using the `x` flag regardless of this setting.
       81 ( 0.00%) .          .          .               pub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder {
       81 ( 0.00%) .          .          .                   self.ignore_whitespace = yes;
        .          .          .          .                   self
       81 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Allow using `{,n}` as an equivalent to `{0,n}`.
        .          .          .          .               ///
        .          .          .          .               /// When enabled, the parser accepts `{,n}` as valid syntax for `{0,n}`.
        .          .          .          .               /// Most regular expression engines don't support the `{,n}` syntax, but
        .          .          .          .               /// some others do it, namely Python's `re` library.
        .          .          .          .               ///
        .          .          .          .               /// This is disabled by default.
-- line 234 ----------------------------------------
-- line 354 ----------------------------------------
        .          .          .          .               /// methods. The parse methods return an abstract syntax tree.
        .          .          .          .               ///
        .          .          .          .               /// To set configuration options on the parser, use [`ParserBuilder`].
        .          .          .          .               pub fn new() -> Parser {
        .          .          .          .                   ParserBuilder::new().build()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse the regular expression into an abstract syntax tree.
      648 ( 0.00%) .          .          .               pub fn parse(&mut self, pattern: &str) -> Result<Ast> {
        .          .          .          .                   ParserI::new(self, pattern).parse()
      729 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse the regular expression and return an abstract syntax tree with
        .          .          .          .               /// all of the comments found in the pattern.
        .          .          .          .               pub fn parse_with_comments(
        .          .          .          .                   &mut self,
        .          .          .          .                   pattern: &str,
        .          .          .          .               ) -> Result<ast::WithComments> {
        .          .          .          .                   ParserI::new(self, pattern).parse_with_comments()
-- line 372 ----------------------------------------
-- line 376 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// This is called at the beginning of every parse. This prevents the
        .          .          .          .               /// parser from running with inconsistent state (say, if a previous
        .          .          .          .               /// invocation returned an error and the parser is reused).
        .          .          .          .               fn reset(&self) {
        .          .          .          .                   // These settings should be in line with the construction
        .          .          .          .                   // in `ParserBuilder::build`.
        .          .          .          .                   self.pos.set(Position { offset: 0, line: 1, column: 1 });
       81 ( 0.00%) .          .          .                   self.ignore_whitespace.set(self.initial_ignore_whitespace);
        .          .          .          .                   self.comments.borrow_mut().clear();
        .          .          .          .                   self.stack_group.borrow_mut().clear();
        .          .          .          .                   self.stack_class.borrow_mut().clear();
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'s, P: Borrow<Parser>> ParserI<'s, P> {
        .          .          .          .               /// Build an internal parser from a parser configuration and a pattern.
        .          .          .          .               fn new(parser: P, pattern: &'s str) -> ParserI<'s, P> {
      243 ( 0.00%) .          .          .                   ParserI { parser, pattern }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return a reference to the parser state.
        .          .          .          .               fn parser(&self) -> &Parser {
  632,573 ( 0.18%) .          .          .                   self.parser.borrow()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return a reference to the pattern being parsed.
        .          .          .          .               fn pattern(&self) -> &str {
    2,782 ( 0.00%) .          .          .                   self.pattern
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Create a new error with the given span and error type.
        .          .          .          .               fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {
        .          .          .          .                   ast::Error { kind, pattern: self.pattern().to_string(), span }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return the current offset of the parser.
-- line 412 ----------------------------------------
-- line 468 ----------------------------------------
        .          .          .          .               /// Return whether the parser should ignore whitespace or not.
        .          .          .          .               fn ignore_whitespace(&self) -> bool {
        .          .          .          .                   self.parser().ignore_whitespace.get()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return the character at the current position of the parser.
        .          .          .          .               ///
        .          .          .          .               /// This panics if the current position does not point to a valid char.
  981,248 ( 0.28%) .          .          .               fn char(&self) -> char {
  981,248 ( 0.28%) .          .          .                   self.char_at(self.offset())
  981,248 ( 0.28%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return the character at the given position.
        .          .          .          .               ///
        .          .          .          .               /// This panics if the given position does not point to a valid char.
        .          .          .          .               fn char_at(&self, i: usize) -> char {
        .          .          .          .                   self.pattern()[i..]
        .          .          .          .                       .chars()
        .          .          .          .                       .next()
        .          .          .          .                       .unwrap_or_else(|| panic!("expected char at offset {}", i))
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Bump the parser to the next Unicode scalar value.
        .          .          .          .               ///
        .          .          .          .               /// If the end of the input has been reached, then `false` is returned.
  646,961 ( 0.19%) .          .          .               fn bump(&self) -> bool {
  277,269 ( 0.08%) .          .          .                   if self.is_eof() {
        .          .          .          .                       return false;
        .          .          .          .                   }
        .          .          .          .                   let Position { mut offset, mut line, mut column } = self.pos();
  277,269 ( 0.08%) .          .          .                   if self.char() == '\n' {
1,941,240 ( 0.56%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (92,423x)
        .          .          .          .                       line = line.checked_add(1).unwrap();
        .          .          .          .                       column = 1;
        .          .          .          .                   } else {
        .          .          .          .                       column = column.checked_add(1).unwrap();
        .          .          .          .                   }
  184,846 ( 0.05%) .          .          .                   offset += self.char().len_utf8();
1,941,240 ( 0.56%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (92,423x)
        .          .          .          .                   self.parser().pos.set(Position { offset, line, column });
   92,423 ( 0.03%) .          .          .                   self.pattern()[self.offset()..].chars().next().is_some()
  739,384 ( 0.21%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// If the substring starting at the current position of the parser has
        .          .          .          .               /// the given prefix, then bump the parser to the character immediately
        .          .          .          .               /// following the prefix and return true. Otherwise, don't bump the parser
        .          .          .          .               /// and return false.
        .          .          .          .               fn bump_if(&self, prefix: &str) -> bool {
    4,589 ( 0.00%) .          .          .                   if self.pattern()[self.offset()..].starts_with(prefix) {
        .          .          .          .                       for _ in 0..prefix.chars().count() {
    6,636 ( 0.00%) .          .          .                           self.bump();
  158,242 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,778x)
        .          .          .          .                       }
        .          .          .          .                       true
        .          .          .          .                   } else {
        .          .          .          .                       false
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns true if and only if the parser is positioned at a look-around
-- line 524 ----------------------------------------
-- line 533 ----------------------------------------
        .          .          .          .                       || self.bump_if("?!")
        .          .          .          .                       || self.bump_if("?<=")
        .          .          .          .                       || self.bump_if("?<!")
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Bump the parser, and if the `x` flag is enabled, bump through any
        .          .          .          .               /// subsequent spaces. Return true if and only if the parser is not at
        .          .          .          .               /// EOF.
      344 ( 0.00%) .          .          .               fn bump_and_bump_space(&self) -> bool {
   13,977 ( 0.00%) .          .          .                   if !self.bump() {
   15,308 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (172x)
        .          .          .          .                       return false;
        .          .          .          .                   }
    6,954 ( 0.00%) .          .          .                   self.bump_space();
    3,096 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (172x)
    3,168 ( 0.00%) .          .          .                   !self.is_eof()
      344 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// If the `x` flag is enabled (i.e., whitespace insensitivity with
        .          .          .          .               /// comments), then this will advance the parser through all whitespace
        .          .          .          .               /// and comments to the next non-whitespace non-comment byte.
        .          .          .          .               ///
        .          .          .          .               /// If the `x` flag is disabled, then this is a no-op.
        .          .          .          .               ///
        .          .          .          .               /// This should be used selectively throughout the parser where
        .          .          .          .               /// arbitrary whitespace is permitted when the `x` flag is enabled. For
        .          .          .          .               /// example, `{   5  , 6}` is equivalent to `{5,6}`.
  625,569 ( 0.18%) .          .          .               fn bump_space(&self) {
   89,367 ( 0.03%) .          .          .                   if !self.ignore_whitespace() {
        .          .          .          .                       return;
        .          .          .          .                   }
        .          .          .          .                   while !self.is_eof() {
        .          .          .          .                       if self.char().is_whitespace() {
        .          .          .          .                           self.bump();
        .          .          .          .                       } else if self.char() == '#' {
        .          .          .          .                           let start = self.pos();
        .          .          .          .                           let mut comment_text = String::new();
-- line 567 ----------------------------------------
-- line 578 ----------------------------------------
        .          .          .          .                               span: Span::new(start, self.pos()),
        .          .          .          .                               comment: comment_text,
        .          .          .          .                           };
        .          .          .          .                           self.parser().comments.borrow_mut().push(comment);
        .          .          .          .                       } else {
        .          .          .          .                           break;
        .          .          .          .                       }
        .          .          .          .                   }
  714,936 ( 0.21%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Peek at the next character in the input without advancing the parser.
        .          .          .          .               ///
        .          .          .          .               /// If the input has been exhausted, then this returns `None`.
        .          .          .          .               fn peek(&self) -> Option<char> {
        .          .          .          .                   if self.is_eof() {
        .          .          .          .                       return None;
        .          .          .          .                   }
-- line 594 ----------------------------------------
-- line 618 ----------------------------------------
        .          .          .          .                           break;
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   self.pattern()[start..].chars().next()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns true if the next call to `bump` would return false.
        .          .          .          .               fn is_eof(&self) -> bool {
  184,272 ( 0.05%) .          .          .                   self.offset() == self.pattern().len()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return the current position of the parser, which includes the offset,
        .          .          .          .               /// line and column.
        .          .          .          .               fn pos(&self) -> Position {
        .          .          .          .                   self.parser().pos.get()
        .          .          .          .               }
        .          .          .          .           
-- line 634 ----------------------------------------
-- line 636 ----------------------------------------
        .          .          .          .               /// and end of the span are set.
        .          .          .          .               fn span(&self) -> Span {
        .          .          .          .                   Span::splat(self.pos())
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Create a span that covers the current character.
        .          .          .          .               fn span_char(&self) -> Span {
        .          .          .          .                   let mut next = Position {
  104,596 ( 0.03%) .          .          .                       offset: self.offset().checked_add(self.char().len_utf8()).unwrap(),
   14,961 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (713x)
        .          .          .          .                       line: self.line(),
        .          .          .          .                       column: self.column().checked_add(1).unwrap(),
        .          .          .          .                   };
  417,700 ( 0.12%) .          .          .                   if self.char() == '\n' {
   14,961 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (713x)
        .          .          .          .                       next.line += 1;
        .          .          .          .                       next.column = 1;
        .          .          .          .                   }
        .          .          .          .                   Span::new(self.pos(), next)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse and push a single alternation on to the parser's internal stack.
        .          .          .          .               /// If the top of the stack already has an alternation, then add to that
-- line 656 ----------------------------------------
-- line 657 ----------------------------------------
        .          .          .          .               /// instead of pushing a new one.
        .          .          .          .               ///
        .          .          .          .               /// The concatenation given corresponds to a single alternation branch.
        .          .          .          .               /// The concatenation returned starts the next branch and is empty.
        .          .          .          .               ///
        .          .          .          .               /// This assumes the parser is currently positioned at `|` and will advance
        .          .          .          .               /// the parser to the character following `|`.
        .          .          .          .               #[inline(never)]
  159,290 ( 0.05%) .          .          .               fn push_alternate(&self, mut concat: ast::Concat) -> Result<ast::Concat> {
   79,645 ( 0.02%) .          .          .                   assert_eq!(self.char(), '|');
  334,509 ( 0.10%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (15,929x)
        .          .          .          .                   concat.span.end = self.pos();
  159,290 ( 0.05%) .          .          .                   self.push_or_add_alternation(concat);
   31,858 ( 0.01%) .          .          .                   self.bump();
1,417,681 ( 0.41%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (15,929x)
   63,716 ( 0.02%) .          .          .                   Ok(ast::Concat { span: self.span(), asts: vec![] })
  127,432 ( 0.04%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Pushes or adds the given branch of an alternation to the parser's
        .          .          .          .               /// internal stack of state.
        .          .          .          .               fn push_or_add_alternation(&self, concat: ast::Concat) {
        .          .          .          .                   use self::GroupState::*;
        .          .          .          .           
        .          .          .          .                   let mut stack = self.parser().stack_group.borrow_mut();
   31,858 ( 0.01%) .          .          .                   if let Some(&mut Alternation(ref mut alts)) = stack.last_mut() {
   32,279 ( 0.01%) .          .          .                       alts.asts.push(concat.into_ast());
3,634,699 ( 1.05%) 21,525 ( 2.66%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (15,417x)
        .          .          .          .                       return;
        .          .          .          .                   }
    3,072 ( 0.00%) .          .          .                   stack.push(Alternation(ast::Alternation {
        .          .          .          .                       span: Span::new(concat.span.start, self.pos()),
    2,560 ( 0.00%) .          .          .                       asts: vec![concat.into_ast()],
  101,838 ( 0.03%) 492 ( 0.06%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (512x)
        .          .          .          .                   }));
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse and push a group AST (and its parent concatenation) on to the
        .          .          .          .               /// parser's internal stack. Return a fresh concatenation corresponding
        .          .          .          .               /// to the group's sub-AST.
        .          .          .          .               ///
        .          .          .          .               /// If a set of flags was found (with no group), then the concatenation
-- line 693 ----------------------------------------
-- line 695 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser is currently positioned on the opening
        .          .          .          .               /// parenthesis. It advances the parser to the character at the start
        .          .          .          .               /// of the sub-expression (or adjoining expression).
        .          .          .          .               ///
        .          .          .          .               /// If there was a problem parsing the start of the group, then an error
        .          .          .          .               /// is returned.
        .          .          .          .               #[inline(never)]
    7,130 ( 0.00%) .          .          .               fn push_group(&self, mut concat: ast::Concat) -> Result<ast::Concat> {
    3,565 ( 0.00%) .          .          .                   assert_eq!(self.char(), '(');
   14,961 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (713x)
    2,852 ( 0.00%) .          .          .                   match self.parse_group()? {
1,445,243 ( 0.42%) 667 ( 0.08%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (713x)
        .          .          .          .                       Either::Left(set) => {
        .          .          .          .                           let ignore = set.flags.flag_state(ast::Flag::IgnoreWhitespace);
        .          .          .          .                           if let Some(v) = ignore {
        .          .          .          .                               self.parser().ignore_whitespace.set(v);
        .          .          .          .                           }
        .          .          .          .           
        .          .          .          .                           concat.asts.push(Ast::flags(set));
      220 ( 0.00%) .          .          .                           Ok(concat)
        .          .          .          .                       }
        .          .          .          .                       Either::Right(group) => {
        .          .          .          .                           let old_ignore_whitespace = self.ignore_whitespace();
        .          .          .          .                           let new_ignore_whitespace = group
        .          .          .          .                               .flags()
        .          .          .          .                               .and_then(|f| f.flag_state(ast::Flag::IgnoreWhitespace))
        .          .          .          .                               .unwrap_or(old_ignore_whitespace);
       81 ( 0.00%) .          .          .                           self.parser().stack_group.borrow_mut().push(
    6,930 ( 0.00%) .          .          .                               GroupState::Group {
        .          .          .          .                                   concat,
        .          .          .          .                                   group,
        .          .          .          .                                   ignore_whitespace: old_ignore_whitespace,
        .          .          .          .                               },
        .          .          .          .                           );
        .          .          .          .                           self.parser().ignore_whitespace.set(new_ignore_whitespace);
    2,079 ( 0.00%) .          .          .                           Ok(ast::Concat { span: self.span(), asts: vec![] })
        .          .          .          .                       }
        .          .          .          .                   }
    5,704 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Pop a group AST from the parser's internal stack and set the group's
        .          .          .          .               /// AST to the given concatenation. Return the concatenation containing
        .          .          .          .               /// the group.
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser is currently positioned on the closing
        .          .          .          .               /// parenthesis and advances the parser to the character following the `)`.
        .          .          .          .               ///
        .          .          .          .               /// If no such group could be popped, then an unopened group error is
        .          .          .          .               /// returned.
        .          .          .          .               #[inline(never)]
    6,930 ( 0.00%) .          .          .               fn pop_group(&self, mut group_concat: ast::Concat) -> Result<ast::Concat> {
        .          .          .          .                   use self::GroupState::*;
        .          .          .          .           
    3,465 ( 0.00%) .          .          .                   assert_eq!(self.char(), ')');
   14,553 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (693x)
        .          .          .          .                   let mut stack = self.parser().stack_group.borrow_mut();
   24,948 ( 0.01%) .          .          .                   let (mut prior_concat, mut group, ignore_whitespace, alt) = match stack
        .          .          .          .                       .pop()
        .          .          .          .                   {
    5,249 ( 0.00%) .          .          .                       Some(Group { concat, group, ignore_whitespace }) => {
        .          .          .          .                           (concat, group, ignore_whitespace, None)
        .          .          .          .                       }
    6,144 ( 0.00%) .          .          .                       Some(Alternation(alt)) => match stack.pop() {
   15,360 ( 0.00%) .          .          .                           Some(Group { concat, group, ignore_whitespace }) => {
    3,072 ( 0.00%) .          .          .                               (concat, group, ignore_whitespace, Some(alt))
        .          .          .          .                           }
        .          .          .          .                           None | Some(Alternation(_)) => {
        .          .          .          .                               return Err(self.error(
        .          .          .          .                                   self.span_char(),
        .          .          .          .                                   ast::ErrorKind::GroupUnopened,
        .          .          .          .                               ));
        .          .          .          .                           }
        .          .          .          .                       },
        .          .          .          .                       None => {
        .          .          .          .                           return Err(self
        .          .          .          .                               .error(self.span_char(), ast::ErrorKind::GroupUnopened));
        .          .          .          .                       }
        .          .          .          .                   };
        .          .          .          .                   self.parser().ignore_whitespace.set(ignore_whitespace);
    2,772 ( 0.00%) .          .          .                   group_concat.span.end = self.pos();
    1,386 ( 0.00%) .          .          .                   self.bump();
   61,677 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (693x)
        .          .          .          .                   group.span.end = self.pos();
    1,386 ( 0.00%) .          .          .                   match alt {
    4,096 ( 0.00%) .          .          .                       Some(mut alt) => {
    2,048 ( 0.00%) .          .          .                           alt.span.end = group_concat.span.end;
    7,680 ( 0.00%) .          .          .                           alt.asts.push(group_concat.into_ast());
  115,078 ( 0.03%) 583 ( 0.07%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (512x)
    6,144 ( 0.00%) .          .          .                           group.ast = Box::new(alt.into_ast());
  109,876 ( 0.03%) 613 ( 0.08%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Alternation::into_ast (512x)
        .          .          .          .                       }
        .          .          .          .                       None => {
    2,172 ( 0.00%) .          .          .                           group.ast = Box::new(group_concat.into_ast());
   44,376 ( 0.01%) 259 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (181x)
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   prior_concat.asts.push(Ast::group(group));
    7,623 ( 0.00%) .          .          .                   Ok(prior_concat)
    5,544 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Pop the last state from the parser's internal stack, if it exists, and
        .          .          .          .               /// add the given concatenation to it. There either must be no state or a
        .          .          .          .               /// single alternation item on the stack. Any other scenario produces an
        .          .          .          .               /// error.
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser has advanced to the end.
        .          .          .          .               #[inline(never)]
      567 ( 0.00%) .          .          .               fn pop_group_end(&self, mut concat: ast::Concat) -> Result<Ast> {
      324 ( 0.00%) .          .          .                   concat.span.end = self.pos();
        .          .          .          .                   let mut stack = self.parser().stack_group.borrow_mut();
        .          .          .          .                   let ast = match stack.pop() {
    1,134 ( 0.00%) .          .          .                       None => Ok(concat.into_ast()),
   22,461 ( 0.01%) 132 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (81x)
        .          .          .          .                       Some(GroupState::Alternation(mut alt)) => {
        .          .          .          .                           alt.span.end = self.pos();
        .          .          .          .                           alt.asts.push(concat.into_ast());
        .          .          .          .                           Ok(Ast::alternation(alt))
        .          .          .          .                       }
        .          .          .          .                       Some(GroupState::Group { group, .. }) => {
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(group.span, ast::ErrorKind::GroupUnclosed)
        .          .          .          .                           );
        .          .          .          .                       }
        .          .          .          .                   };
        .          .          .          .                   // If we try to pop again, there should be nothing.
        .          .          .          .                   match stack.pop() {
    1,296 ( 0.00%) .          .          .                       None => ast,
        .          .          .          .                       Some(GroupState::Alternation(_)) => {
        .          .          .          .                           // This unreachable is unfortunate. This case can't happen
        .          .          .          .                           // because the only way we can be here is if there were two
        .          .          .          .                           // `GroupState::Alternation`s adjacent in the parser's stack,
        .          .          .          .                           // which we guarantee to never happen because we never push a
        .          .          .          .                           // `GroupState::Alternation` if one is already at the top of
        .          .          .          .                           // the stack.
        .          .          .          .                           unreachable!()
        .          .          .          .                       }
        .          .          .          .                       Some(GroupState::Group { group, .. }) => {
        .          .          .          .                           Err(self.error(group.span, ast::ErrorKind::GroupUnclosed))
        .          .          .          .                       }
        .          .          .          .                   }
      648 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse the opening of a character class and push the current class
        .          .          .          .               /// parsing context onto the parser's stack. This assumes that the parser
        .          .          .          .               /// is positioned at an opening `[`. The given union should correspond to
        .          .          .          .               /// the union of set items built up before seeing the `[`.
        .          .          .          .               ///
        .          .          .          .               /// If there was a problem parsing the opening of the class, then an error
        .          .          .          .               /// is returned. Otherwise, a new union of set items for the class is
        .          .          .          .               /// returned (which may be populated with either a `]` or a `-`).
        .          .          .          .               #[inline(never)]
   28,240 ( 0.01%) .          .          .               fn push_class_open(
        .          .          .          .                   &self,
        .          .          .          .                   parent_union: ast::ClassSetUnion,
        .          .          .          .               ) -> Result<ast::ClassSetUnion> {
   14,120 ( 0.00%) .          .          .                   assert_eq!(self.char(), '[');
   59,268 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,824x)
        .          .          .          .           
   53,656 ( 0.02%) .          .          .                   let (nested_set, nested_union) = self.parse_set_class_open()?;
  841,889 ( 0.24%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open (2,824x)
   84,720 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x)
        .          .          .          .                   self.parser()
        .          .          .          .                       .stack_class
        .          .          .          .                       .borrow_mut()
   39,536 ( 0.01%) .          .          .                       .push(ClassState::Open { union: parent_union, set: nested_set });
   84,720 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x)
   31,064 ( 0.01%) .          .          .                   Ok(nested_union)
   22,592 ( 0.01%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse the end of a character class set and pop the character class
        .          .          .          .               /// parser stack. The union given corresponds to the last union built
        .          .          .          .               /// before seeing the closing `]`. The union returned corresponds to the
        .          .          .          .               /// parent character class set with the nested class added to it.
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser is positioned at a `]` and will advance
        .          .          .          .               /// the parser to the byte immediately following the `]`.
-- line 859 ----------------------------------------
-- line 860 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// If the stack is empty after popping, then this returns the final
        .          .          .          .               /// "top-level" character class AST (where a "top-level" character class
        .          .          .          .               /// is one that is not nested inside any other character class).
        .          .          .          .               ///
        .          .          .          .               /// If there is no corresponding opening bracket on the parser's stack,
        .          .          .          .               /// then an error is returned.
        .          .          .          .               #[inline(never)]
   25,416 ( 0.01%) .          .          .               fn pop_class(
        .          .          .          .                   &self,
        .          .          .          .                   nested_union: ast::ClassSetUnion,
        .          .          .          .               ) -> Result<Either<ast::ClassSetUnion, ast::ClassBracketed>> {
   14,120 ( 0.00%) .          .          .                   assert_eq!(self.char(), ']');
   59,304 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,824x)
        .          .          .          .           
        .          .          .          .                   let item = ast::ClassSet::Item(nested_union.into_item());
    8,472 ( 0.00%) .          .          .                   let prevset = self.pop_class_op(item);
  530,912 ( 0.15%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op (2,824x)
        .          .          .          .                   let mut stack = self.parser().stack_class.borrow_mut();
   14,120 ( 0.00%) .          .          .                   match stack.pop() {
        .          .          .          .                       None => {
        .          .          .          .                           // We can never observe an empty stack:
        .          .          .          .                           //
        .          .          .          .                           // 1) We are guaranteed to start with a non-empty stack since
        .          .          .          .                           //    the character class parser is only initiated when it sees
        .          .          .          .                           //    a `[`.
        .          .          .          .                           // 2) If we ever observe an empty stack while popping after
        .          .          .          .                           //    seeing a `]`, then we signal the character class parser
-- line 885 ----------------------------------------
-- line 890 ----------------------------------------
        .          .          .          .                           // This panic is unfortunate, but this case is impossible
        .          .          .          .                           // since we already popped the Op state if one exists above.
        .          .          .          .                           // Namely, every push to the class parser stack is guarded by
        .          .          .          .                           // whether an existing Op is already on the top of the stack.
        .          .          .          .                           // If it is, the existing Op is modified. That is, the stack
        .          .          .          .                           // can never have consecutive Op states.
        .          .          .          .                           panic!("unexpected ClassState::Op")
        .          .          .          .                       }
   42,360 ( 0.01%) .          .          .                       Some(ClassState::Open { mut union, mut set }) => {
   84,720 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x)
    5,648 ( 0.00%) .          .          .                           self.bump();
  251,336 ( 0.07%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (2,824x)
        .          .          .          .                           set.span.end = self.pos();
   19,768 ( 0.01%) .          .          .                           set.kind = prevset;
   84,720 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x)
  183,560 ( 0.05%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSet> (2,824x)
    5,648 ( 0.00%) .          .          .                           if stack.is_empty() {
    8,259 ( 0.00%) .          .          .                               Ok(Either::Right(set))
   82,590 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x)
        .          .          .          .                           } else {
      142 ( 0.00%) .          .          .                               union.push(ast::ClassSetItem::Bracketed(Box::new(set)));
    2,130 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (71x)
      852 ( 0.00%) .          .          .                               Ok(Either::Left(union))
        .          .          .          .                           }
        .          .          .          .                       }
        .          .          .          .                   }
   25,416 ( 0.01%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return an "unclosed class" error whose span points to the most
        .          .          .          .               /// recently opened class.
        .          .          .          .               ///
        .          .          .          .               /// This should only be called while parsing a character class.
        .          .          .          .               #[inline(never)]
        .          .          .          .               fn unclosed_class_error(&self) -> ast::Error {
        .          .          .          .                   for state in self.parser().stack_class.borrow().iter().rev() {
-- line 918 ----------------------------------------
-- line 946 ----------------------------------------
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Pop a character class set from the character class parser stack. If the
        .          .          .          .               /// top of the stack is just an item (not an operation), then return the
        .          .          .          .               /// given set unchanged. If the top of the stack is an operation, then the
        .          .          .          .               /// given set will be used as the rhs of the operation on the top of the
        .          .          .          .               /// stack. In that case, the binary operation is returned as a set.
        .          .          .          .               #[inline(never)]
   22,592 ( 0.01%) .          .          .               fn pop_class_op(&self, rhs: ast::ClassSet) -> ast::ClassSet {
        .          .          .          .                   let mut stack = self.parser().stack_class.borrow_mut();
   11,296 ( 0.00%) .          .          .                   let (kind, lhs) = match stack.pop() {
        .          .          .          .                       Some(ClassState::Op { kind, lhs }) => (kind, lhs),
   59,304 ( 0.02%) .          .          .                       Some(state @ ClassState::Open { .. }) => {
   84,720 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x)
        .          .          .          .                           stack.push(state);
   11,296 ( 0.00%) .          .          .                           return rhs;
   84,720 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x)
        .          .          .          .                       }
        .          .          .          .                       None => unreachable!(),
        .          .          .          .                   };
        .          .          .          .                   let span = Span::new(lhs.span().start, rhs.span().end);
        .          .          .          .                   ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {
        .          .          .          .                       span,
        .          .          .          .                       kind,
        .          .          .          .                       lhs: Box::new(lhs),
        .          .          .          .                       rhs: Box::new(rhs),
        .          .          .          .                   })
   22,592 ( 0.01%) .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'s, P: Borrow<Parser>> ParserI<'s, P> {
        .          .          .          .               /// Parse the regular expression into an abstract syntax tree.
        .          .          .          .               fn parse(&self) -> Result<Ast> {
       81 ( 0.00%) .          .          .                   self.parse_with_comments().map(|astc| astc.ast)
61,112,902 (17.59%) 143,418 (17.70%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (81x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse the regular expression and return an abstract syntax tree with
        .          .          .          .               /// all of the comments found in the pattern.
      567 ( 0.00%) .          .          .               fn parse_with_comments(&self) -> Result<ast::WithComments> {
      162 ( 0.00%) .          .          .                   assert_eq!(self.offset(), 0, "parser can only be used once");
        .          .          .          .                   self.parser().reset();
    1,053 ( 0.00%) .          .          .                   let mut concat = ast::Concat { span: self.span(), asts: vec![] };
        .          .          .          .                   loop {
  143,322 ( 0.04%) .          .          .                       self.bump_space();
1,289,898 ( 0.37%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (71,661x)
   71,661 ( 0.02%) .          .          .                       if self.is_eof() {
        .          .          .          .                           break;
        .          .          .          .                       }
  502,156 ( 0.14%) .          .          .                       match self.char() {
1,502,937 ( 0.43%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (71,580x)
    9,982 ( 0.00%) .          .          .                           '(' => concat = self.push_group(concat)?,
1,560,256 ( 0.45%) 673 ( 0.08%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_group (713x)
    9,702 ( 0.00%) .          .          .                           ')' => concat = self.pop_group(concat)?,
  922,317 ( 0.27%) 2,302 ( 0.28%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x)
  223,006 ( 0.06%) .          .          .                           '|' => concat = self.push_alternate(concat)?,
7,648,664 ( 2.20%) 26,574 ( 3.28%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (15,929x)
        .          .          .          .                           '[' => {
   19,271 ( 0.01%) .          .          .                               let class = self.parse_set_class()?;
9,354,277 ( 2.69%) 1,198 ( 0.15%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (2,753x)
   82,590 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x)
        .          .          .          .                               concat.asts.push(Ast::class_bracketed(class));
        .          .          .          .                           }
        .          .          .          .                           '?' => {
        .          .          .          .                               concat = self.parse_uncounted_repetition(
   16,370 ( 0.00%) .          .          .                                   concat,
    1,637 ( 0.00%) .          .          .                                   ast::RepetitionKind::ZeroOrOne,
        .          .          .          .                               )?;
        .          .          .          .                           }
        .          .          .          .                           '*' => {
        .          .          .          .                               concat = self.parse_uncounted_repetition(
      170 ( 0.00%) .          .          .                                   concat,
       34 ( 0.00%) .          .          .                                   ast::RepetitionKind::ZeroOrMore,
        .          .          .          .                               )?;
        .          .          .          .                           }
        .          .          .          .                           '+' => {
        .          .          .          .                               concat = self.parse_uncounted_repetition(
      590 ( 0.00%) .          .          .                                   concat,
      118 ( 0.00%) .          .          .                                   ast::RepetitionKind::OneOrMore,
        .          .          .          .                               )?;
        .          .          .          .                           }
        .          .          .          .                           '{' => {
    2,408 ( 0.00%) .          .          .                               concat = self.parse_counted_repetition(concat)?;
  248,159 ( 0.07%) 134 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (172x)
        .          .          .          .                           }
        .          .          .          .                           _ => concat.asts.push(self.parse_primitive()?.into_ast()),
        .          .          .          .                       }
        .          .          .          .                   }
    1,377 ( 0.00%) .          .          .                   let ast = self.pop_group_end(concat)?;
   27,645 ( 0.01%) 132 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group_end (81x)
      162 ( 0.00%) .          .          .                   NestLimiter::new(self).check(&ast)?;
6,090,265 ( 1.75%) 304 ( 0.04%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::NestLimiter<P>::check (81x)
      162 ( 0.00%) .          .          .                   Ok(ast::WithComments {
       81 ( 0.00%) .          .          .                       ast,
        .          .          .          .                       comments: mem::replace(
        .          .          .          .                           &mut *self.parser().comments.borrow_mut(),
        .          .          .          .                           vec![],
        .          .          .          .                       ),
        .          .          .          .                   })
      648 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parses an uncounted repetition operation. An uncounted repetition
        .          .          .          .               /// operator includes ?, * and +, but does not include the {m,n} syntax.
        .          .          .          .               /// The given `kind` should correspond to the operator observed by the
        .          .          .          .               /// caller.
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser is currently positioned at the repetition
        .          .          .          .               /// operator and advances the parser to the first character after the
        .          .          .          .               /// operator. (Note that the operator may include a single additional `?`,
        .          .          .          .               /// which makes the operator ungreedy.)
        .          .          .          .               ///
        .          .          .          .               /// The caller should include the concatenation that is being built. The
        .          .          .          .               /// concatenation returned includes the repetition operator applied to the
        .          .          .          .               /// last expression in the given concatenation.
        .          .          .          .               #[inline(never)]
   18,843 ( 0.01%) .          .          .               fn parse_uncounted_repetition(
        .          .          .          .                   &self,
        .          .          .          .                   mut concat: ast::Concat,
        .          .          .          .                   kind: ast::RepetitionKind,
        .          .          .          .               ) -> Result<ast::Concat> {
       59 ( 0.00%) .          .          .                   assert!(
    7,333 ( 0.00%) .          .          .                       self.char() == '?' || self.char() == '*' || self.char() == '+'
   38,808 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (1,848x)
        .          .          .          .                   );
        .          .          .          .                   let op_start = self.pos();
        .          .          .          .                   let ast = match concat.asts.pop() {
    3,426 ( 0.00%) .          .          .                       Some(ast) => ast,
        .          .          .          .                       None => {
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(self.span(), ast::ErrorKind::RepetitionMissing)
        .          .          .          .                           )
        .          .          .          .                       }
        .          .          .          .                   };
    3,426 ( 0.00%) .          .          .                   match ast {
        .          .          .          .                       Ast::Empty(_) | Ast::Flags(_) => {
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(self.span(), ast::ErrorKind::RepetitionMissing)
        .          .          .          .                           )
        .          .          .          .                       }
        .          .          .          .                       _ => {}
        .          .          .          .                   }
        .          .          .          .                   let mut greedy = true;
   13,692 ( 0.00%) .          .          .                   if self.bump() && self.char() == '?' {
  152,457 ( 0.04%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,713x)
   35,910 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (1,710x)
        .          .          .          .                       greedy = false;
        .          .          .          .                       self.bump();
        .          .          .          .                   }
   23,982 ( 0.01%) .          .          .                   concat.asts.push(Ast::repetition(ast::Repetition {
        .          .          .          .                       span: ast.span().with_end(self.pos()),
    6,852 ( 0.00%) .          .          .                       op: ast::RepetitionOp {
        .          .          .          .                           span: Span::new(op_start, self.pos()),
        .          .          .          .                           kind,
        .          .          .          .                       },
        .          .          .          .                       greedy,
        .          .          .          .                       ast: Box::new(ast),
        .          .          .          .                   }));
   18,843 ( 0.01%) .          .          .                   Ok(concat)
   13,704 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parses a counted repetition operation. A counted repetition operator
        .          .          .          .               /// corresponds to the {m,n} syntax, and does not include the ?, * or +
        .          .          .          .               /// operators.
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser is currently positioned at the opening `{`
        .          .          .          .               /// and advances the parser to the first character after the operator.
        .          .          .          .               /// (Note that the operator may include a single additional `?`, which
        .          .          .          .               /// makes the operator ungreedy.)
        .          .          .          .               ///
        .          .          .          .               /// The caller should include the concatenation that is being built. The
        .          .          .          .               /// concatenation returned includes the repetition operator applied to the
        .          .          .          .               /// last expression in the given concatenation.
        .          .          .          .               #[inline(never)]
    1,720 ( 0.00%) .          .          .               fn parse_counted_repetition(
        .          .          .          .                   &self,
        .          .          .          .                   mut concat: ast::Concat,
        .          .          .          .               ) -> Result<ast::Concat> {
      688 ( 0.00%) .          .          .                   assert!(self.char() == '{');
    3,612 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (172x)
        .          .          .          .                   let start = self.pos();
        .          .          .          .                   let ast = match concat.asts.pop() {
      344 ( 0.00%) .          .          .                       Some(ast) => ast,
        .          .          .          .                       None => {
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(self.span(), ast::ErrorKind::RepetitionMissing)
        .          .          .          .                           )
        .          .          .          .                       }
        .          .          .          .                   };
      344 ( 0.00%) .          .          .                   match ast {
        .          .          .          .                       Ast::Empty(_) | Ast::Flags(_) => {
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(self.span(), ast::ErrorKind::RepetitionMissing)
        .          .          .          .                           )
        .          .          .          .                       }
        .          .          .          .                       _ => {}
        .          .          .          .                   }
      172 ( 0.00%) .          .          .                   if !self.bump_and_bump_space() {
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(start, self.pos()),
        .          .          .          .                           ast::ErrorKind::RepetitionCountUnclosed,
        .          .          .          .                       ));
        .          .          .          .                   }
        .          .          .          .                   let count_start = specialize_err(
      344 ( 0.00%) .          .          .                       self.parse_decimal(),
   79,317 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (172x)
        .          .          .          .                       ast::ErrorKind::DecimalEmpty,
        .          .          .          .                       ast::ErrorKind::RepetitionCountDecimalEmpty,
        .          .          .          .                   );
      172 ( 0.00%) .          .          .                   if self.is_eof() {
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(start, self.pos()),
        .          .          .          .                           ast::ErrorKind::RepetitionCountUnclosed,
        .          .          .          .                       ));
        .          .          .          .                   }
      688 ( 0.00%) .          .          .                   let range = if self.char() == ',' {
    3,612 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (172x)
       67 ( 0.00%) .          .          .                       if !self.bump_and_bump_space() {
        .          .          .          .                           return Err(self.error(
        .          .          .          .                               Span::new(start, self.pos()),
        .          .          .          .                               ast::ErrorKind::RepetitionCountUnclosed,
        .          .          .          .                           ));
        .          .          .          .                       }
      268 ( 0.00%) .          .          .                       if self.char() != '}' {
    1,407 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (67x)
      134 ( 0.00%) .          .          .                           let count_start = match count_start {
      201 ( 0.00%) .          .          .                               Ok(c) => c,
        .          .          .          .                               Err(err)
        .          .          .          .                                   if err.kind
        .          .          .          .                                       == ast::ErrorKind::RepetitionCountDecimalEmpty =>
        .          .          .          .                               {
        .          .          .          .                                   if self.parser().empty_min_range {
        .          .          .          .                                       0
        .          .          .          .                                   } else {
        .          .          .          .                                       return Err(err);
        .          .          .          .                                   }
        .          .          .          .                               }
        .          .          .          .                               err => err?,
        .          .          .          .                           };
      134 ( 0.00%) .          .          .                           let count_end = specialize_err(
    1,943 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::specialize_err (67x)
      201 ( 0.00%) .          .          .                               self.parse_decimal(),
   28,414 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (67x)
       67 ( 0.00%) .          .          .                               ast::ErrorKind::DecimalEmpty,
      268 ( 0.00%) .          .          .                               ast::ErrorKind::RepetitionCountDecimalEmpty,
        .          .          .          .                           )?;
        .          .          .          .                           ast::RepetitionRange::Bounded(count_start, count_end)
        .          .          .          .                       } else {
        .          .          .          .                           ast::RepetitionRange::AtLeast(count_start?)
        .          .          .          .                       }
        .          .          .          .                   } else {
      210 ( 0.00%) .          .          .                       ast::RepetitionRange::Exactly(count_start?)
        .          .          .          .                   };
        .          .          .          .           
      860 ( 0.00%) .          .          .                   if self.is_eof() || self.char() != '}' {
    3,612 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (172x)
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(start, self.pos()),
        .          .          .          .                           ast::ErrorKind::RepetitionCountUnclosed,
        .          .          .          .                       ));
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   let mut greedy = true;
    1,720 ( 0.00%) .          .          .                   if self.bump_and_bump_space() && self.char() == '?' {
   20,640 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_and_bump_space (172x)
    3,612 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (172x)
        .          .          .          .                       greedy = false;
        .          .          .          .                       self.bump();
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   let op_span = Span::new(start, self.pos());
      172 ( 0.00%) .          .          .                   if !range.is_valid() {
        .          .          .          .                       return Err(
        .          .          .          .                           self.error(op_span, ast::ErrorKind::RepetitionCountInvalid)
        .          .          .          .                       );
        .          .          .          .                   }
    4,644 ( 0.00%) .          .          .                   concat.asts.push(Ast::repetition(ast::Repetition {
   23,478 ( 0.01%) 82 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Ast::repetition (172x)
    3,096 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::push (172x)
      172 ( 0.00%) .          .          .                       span: ast.span().with_end(self.pos()),
    1,204 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Ast::span (172x)
        .          .          .          .                       op: ast::RepetitionOp {
        .          .          .          .                           span: op_span,
        .          .          .          .                           kind: ast::RepetitionKind::Range(range),
        .          .          .          .                       },
        .          .          .          .                       greedy,
        .          .          .          .                       ast: Box::new(ast),
        .          .          .          .                   }));
    2,064 ( 0.00%) .          .          .                   Ok(concat)
    1,376 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a group (which contains a sub-expression) or a set of flags.
        .          .          .          .               ///
        .          .          .          .               /// If a group was found, then it is returned with an empty AST. If a set
        .          .          .          .               /// of flags is found, then that set is returned.
        .          .          .          .               ///
        .          .          .          .               /// The parser should be positioned at the opening parenthesis.
        .          .          .          .               ///
-- line 1214 ----------------------------------------
-- line 1219 ----------------------------------------
        .          .          .          .               /// # Errors
        .          .          .          .               ///
        .          .          .          .               /// If flags are given and incorrectly specified, then a corresponding
        .          .          .          .               /// error is returned.
        .          .          .          .               ///
        .          .          .          .               /// If a capture name is given and it is incorrectly specified, then a
        .          .          .          .               /// corresponding error is returned.
        .          .          .          .               #[inline(never)]
    6,417 ( 0.00%) .          .          .               fn parse_group(&self) -> Result<Either<ast::SetFlags, ast::Group>> {
    3,565 ( 0.00%) .          .          .                   assert_eq!(self.char(), '(');
   14,961 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (713x)
        .          .          .          .                   let open_span = self.span_char();
    1,426 ( 0.00%) .          .          .                   self.bump();
   63,433 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (713x)
    1,426 ( 0.00%) .          .          .                   self.bump_space();
   12,834 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (713x)
        .          .          .          .                   if self.is_lookaround_prefix() {
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(open_span.start, self.span().end),
        .          .          .          .                           ast::ErrorKind::UnsupportedLookAround,
        .          .          .          .                       ));
        .          .          .          .                   }
        .          .          .          .                   let inner_span = self.span();
        .          .          .          .                   let mut starts_with_p = true;
        .          .          .          .                   if self.bump_if("?P<") || {
        .          .          .          .                       starts_with_p = false;
        .          .          .          .                       self.bump_if("?<")
        .          .          .          .                   } {
        .          .          .          .                       let capture_index = self.next_capture_index(open_span)?;
    4,688 ( 0.00%) .          .          .                       let name = self.parse_capture_name(capture_index)?;
  839,875 ( 0.24%) 314 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (586x)
   15,822 ( 0.00%) .          .          .                       Ok(Either::Right(ast::Group {
        .          .          .          .                           span: open_span,
    2,930 ( 0.00%) .          .          .                           kind: ast::GroupKind::CaptureName { starts_with_p, name },
    1,758 ( 0.00%) .          .          .                           ast: Box::new(Ast::empty(self.span())),
   42,237 ( 0.01%) 10 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Ast::empty (586x)
        .          .          .          .                       }))
        .          .          .          .                   } else if self.bump_if("?") {
       20 ( 0.00%) .          .          .                       if self.is_eof() {
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(open_span, ast::ErrorKind::GroupUnclosed)
        .          .          .          .                           );
        .          .          .          .                       }
      100 ( 0.00%) .          .          .                       let flags = self.parse_flags()?;
   14,280 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_flags (20x)
       80 ( 0.00%) .          .          .                       let char_end = self.char();
      420 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (20x)
       40 ( 0.00%) .          .          .                       self.bump();
    1,780 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (20x)
       40 ( 0.00%) .          .          .                       if char_end == ')' {
        .          .          .          .                           // We don't allow empty flags, e.g., `(?)`. We instead
        .          .          .          .                           // interpret it as a repetition operator missing its argument.
       40 ( 0.00%) .          .          .                           if flags.items.is_empty() {
        .          .          .          .                               return Err(self.error(
        .          .          .          .                                   inner_span,
        .          .          .          .                                   ast::ErrorKind::RepetitionMissing,
        .          .          .          .                               ));
        .          .          .          .                           }
      340 ( 0.00%) .          .          .                           Ok(Either::Left(ast::SetFlags {
       80 ( 0.00%) .          .          .                               span: Span { end: self.pos(), ..open_span },
      120 ( 0.00%) .          .          .                               flags,
        .          .          .          .                           }))
        .          .          .          .                       } else {
        .          .          .          .                           assert_eq!(char_end, ':');
        .          .          .          .                           Ok(Either::Right(ast::Group {
        .          .          .          .                               span: open_span,
        .          .          .          .                               kind: ast::GroupKind::NonCapturing(flags),
        .          .          .          .                               ast: Box::new(Ast::empty(self.span())),
        .          .          .          .                           }))
        .          .          .          .                       }
        .          .          .          .                   } else {
        .          .          .          .                       let capture_index = self.next_capture_index(open_span)?;
    1,498 ( 0.00%) .          .          .                       Ok(Either::Right(ast::Group {
        .          .          .          .                           span: open_span,
        .          .          .          .                           kind: ast::GroupKind::CaptureIndex(capture_index),
      321 ( 0.00%) .          .          .                           ast: Box::new(Ast::empty(self.span())),
   10,562 ( 0.00%) 24 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Ast::empty (107x)
        .          .          .          .                       }))
        .          .          .          .                   }
    5,704 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parses a capture group name. Assumes that the parser is positioned at
        .          .          .          .               /// the first character in the name following the opening `<` (and may
        .          .          .          .               /// possibly be EOF). This advances the parser to the first character
        .          .          .          .               /// following the closing `>`.
        .          .          .          .               ///
        .          .          .          .               /// The caller must provide the capture index of the group for this name.
        .          .          .          .               #[inline(never)]
    5,274 ( 0.00%) .          .          .               fn parse_capture_name(
        .          .          .          .                   &self,
        .          .          .          .                   capture_index: u32,
        .          .          .          .               ) -> Result<ast::CaptureName> {
    1,758 ( 0.00%) .          .          .                   if self.is_eof() {
        .          .          .          .                       return Err(self
        .          .          .          .                           .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));
        .          .          .          .                   }
        .          .          .          .                   let start = self.pos();
        .          .          .          .                   loop {
   13,692 ( 0.00%) .          .          .                       if self.char() == '>' {
   71,883 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (3,423x)
        .          .          .          .                           break;
        .          .          .          .                       }
    8,511 ( 0.00%) .          .          .                       if !is_capture_char(self.char(), self.pos() == start) {
   59,577 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,837x)
        .          .          .          .                           return Err(self.error(
        .          .          .          .                               self.span_char(),
        .          .          .          .                               ast::ErrorKind::GroupNameInvalid,
        .          .          .          .                           ));
        .          .          .          .                       }
   11,348 ( 0.00%) .          .          .                       if !self.bump() {
  252,493 ( 0.07%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (2,837x)
        .          .          .          .                           break;
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   let end = self.pos();
      586 ( 0.00%) .          .          .                   if self.is_eof() {
        .          .          .          .                       return Err(self
        .          .          .          .                           .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));
        .          .          .          .                   }
    3,516 ( 0.00%) .          .          .                   assert_eq!(self.char(), '>');
   12,306 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (586x)
    1,172 ( 0.00%) .          .          .                   self.bump();
   52,154 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (586x)
        .          .          .          .                   let name = &self.pattern()[start.offset..end.offset];
    1,172 ( 0.00%) .          .          .                   if name.is_empty() {
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(start, start),
        .          .          .          .                           ast::ErrorKind::GroupNameEmpty,
        .          .          .          .                       ));
        .          .          .          .                   }
    2,930 ( 0.00%) .          .          .                   let capname = ast::CaptureName {
        .          .          .          .                       span: Span::new(start, end),
        .          .          .          .                       name: name.to_string(),
        .          .          .          .                       index: capture_index,
        .          .          .          .                   };
        .          .          .          .                   self.add_capture_name(&capname)?;
    7,032 ( 0.00%) .          .          .                   Ok(capname)
    4,688 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a sequence of flags starting at the current character.
        .          .          .          .               ///
        .          .          .          .               /// This advances the parser to the character immediately following the
        .          .          .          .               /// flags, which is guaranteed to be either `:` or `)`.
        .          .          .          .               ///
        .          .          .          .               /// # Errors
        .          .          .          .               ///
-- line 1350 ----------------------------------------
-- line 1351 ----------------------------------------
        .          .          .          .               /// If any flags are duplicated, then an error is returned.
        .          .          .          .               ///
        .          .          .          .               /// If the negation operator is used more than once, then an error is
        .          .          .          .               /// returned.
        .          .          .          .               ///
        .          .          .          .               /// If no flags could be found or if the negation operation is not followed
        .          .          .          .               /// by any flags, then an error is returned.
        .          .          .          .               #[inline(never)]
      180 ( 0.00%) .          .          .               fn parse_flags(&self) -> Result<ast::Flags> {
       80 ( 0.00%) .          .          .                   let mut flags = ast::Flags { span: self.span(), items: vec![] };
        .          .          .          .                   let mut last_was_negation = None;
      420 ( 0.00%) .          .          .                   while self.char() != ':' && self.char() != ')' {
    2,100 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (100x)
      120 ( 0.00%) .          .          .                       if self.char() == '-' {
      630 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (30x)
        .          .          .          .                           last_was_negation = Some(self.span_char());
        .          .          .          .                           let item = ast::FlagsItem {
        .          .          .          .                               span: self.span_char(),
        .          .          .          .                               kind: ast::FlagsItemKind::Negation,
        .          .          .          .                           };
        .          .          .          .                           if let Some(i) = flags.add_item(item) {
        .          .          .          .                               return Err(self.error(
        .          .          .          .                                   self.span_char(),
        .          .          .          .                                   ast::ErrorKind::FlagRepeatedNegation {
        .          .          .          .                                       original: flags.items[i].span,
        .          .          .          .                                   },
        .          .          .          .                               ));
        .          .          .          .                           }
        .          .          .          .                       } else {
        .          .          .          .                           last_was_negation = None;
       80 ( 0.00%) .          .          .                           let item = ast::FlagsItem {
        .          .          .          .                               span: self.span_char(),
       60 ( 0.00%) .          .          .                               kind: ast::FlagsItemKind::Flag(self.parse_flag()?),
    1,000 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_flag (20x)
        .          .          .          .                           };
        .          .          .          .                           if let Some(i) = flags.add_item(item) {
        .          .          .          .                               return Err(self.error(
        .          .          .          .                                   self.span_char(),
        .          .          .          .                                   ast::ErrorKind::FlagDuplicate {
        .          .          .          .                                       original: flags.items[i].span,
        .          .          .          .                                   },
        .          .          .          .                               ));
        .          .          .          .                           }
        .          .          .          .                       }
      120 ( 0.00%) .          .          .                       if !self.bump() {
    2,670 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (30x)
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(self.span(), ast::ErrorKind::FlagUnexpectedEof)
        .          .          .          .                           );
        .          .          .          .                       }
        .          .          .          .                   }
       60 ( 0.00%) .          .          .                   if let Some(span) = last_was_negation {
        .          .          .          .                       return Err(self.error(span, ast::ErrorKind::FlagDanglingNegation));
        .          .          .          .                   }
        .          .          .          .                   flags.span.end = self.pos();
      240 ( 0.00%) .          .          .                   Ok(flags)
      160 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse the current character as a flag. Do not advance the parser.
        .          .          .          .               ///
        .          .          .          .               /// # Errors
        .          .          .          .               ///
        .          .          .          .               /// If the flag is not recognized, then an error is returned.
        .          .          .          .               #[inline(never)]
      180 ( 0.00%) .          .          .               fn parse_flag(&self) -> Result<ast::Flag> {
      100 ( 0.00%) .          .          .                   match self.char() {
      420 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (20x)
       40 ( 0.00%) .          .          .                       'i' => Ok(ast::Flag::CaseInsensitive),
        .          .          .          .                       'm' => Ok(ast::Flag::MultiLine),
        .          .          .          .                       's' => Ok(ast::Flag::DotMatchesNewLine),
        .          .          .          .                       'U' => Ok(ast::Flag::SwapGreed),
        .          .          .          .                       'u' => Ok(ast::Flag::Unicode),
        .          .          .          .                       'R' => Ok(ast::Flag::CRLF),
        .          .          .          .                       'x' => Ok(ast::Flag::IgnoreWhitespace),
        .          .          .          .                       _ => {
        .          .          .          .                           Err(self
        .          .          .          .                               .error(self.span_char(), ast::ErrorKind::FlagUnrecognized))
        .          .          .          .                       }
        .          .          .          .                   }
      160 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a primitive AST. e.g., A literal, non-set character class or
        .          .          .          .               /// assertion.
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser expects a primitive at the current
        .          .          .          .               /// location. i.e., All other non-primitive cases have been handled.
        .          .          .          .               /// For example, if the parser's position is at `|`, then `|` will be
        .          .          .          .               /// treated as a literal (e.g., inside a character class).
        .          .          .          .               ///
        .          .          .          .               /// This advances the parser to the first character immediately following
        .          .          .          .               /// the primitive.
        .          .          .          .               fn parse_primitive(&self) -> Result<Primitive> {
  446,351 ( 0.13%) .          .          .                   match self.char() {
1,041,552 ( 0.30%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (49,607x)
        .          .          .          .                       '\\' => self.parse_escape(),
        .          .          .          .                       '.' => {
        .          .          .          .                           let ast = Primitive::Dot(self.span_char());
       10 ( 0.00%) .          .          .                           self.bump();
      445 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (5x)
       10 ( 0.00%) .          .          .                           Ok(ast)
        .          .          .          .                       }
        .          .          .          .                       '^' => {
        .          .          .          .                           let ast = Primitive::Assertion(ast::Assertion {
        .          .          .          .                               span: self.span_char(),
        .          .          .          .                               kind: ast::AssertionKind::StartLine,
        .          .          .          .                           });
      132 ( 0.00%) .          .          .                           self.bump();
    5,484 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (66x)
      132 ( 0.00%) .          .          .                           Ok(ast)
        .          .          .          .                       }
        .          .          .          .                       '$' => {
        .          .          .          .                           let ast = Primitive::Assertion(ast::Assertion {
        .          .          .          .                               span: self.span_char(),
        .          .          .          .                               kind: ast::AssertionKind::EndLine,
        .          .          .          .                           });
      112 ( 0.00%) .          .          .                           self.bump();
    4,984 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (56x)
       56 ( 0.00%) .          .          .                           Ok(ast)
        .          .          .          .                       }
        .          .          .          .                       c => {
        .          .          .          .                           let ast = Primitive::Literal(ast::Literal {
        .          .          .          .                               span: self.span_char(),
        .          .          .          .                               kind: ast::LiteralKind::Verbatim,
        .          .          .          .                               c,
        .          .          .          .                           });
   98,960 ( 0.03%) .          .          .                           self.bump();
4,403,720 ( 1.27%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (49,480x)
  148,440 ( 0.04%) .          .          .                           Ok(ast)
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse an escape sequence as a primitive AST.
        .          .          .          .               ///
        .          .          .          .               /// This assumes the parser is positioned at the start of the escape
        .          .          .          .               /// sequence, i.e., `\`. It advances the parser to the first position
        .          .          .          .               /// immediately following the escape sequence.
        .          .          .          .               #[inline(never)]
   14,508 ( 0.00%) .          .          .               fn parse_escape(&self) -> Result<Primitive> {
    8,060 ( 0.00%) .          .          .                   assert_eq!(self.char(), '\\');
   33,852 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (1,612x)
        .          .          .          .                   let start = self.pos();
    6,448 ( 0.00%) .          .          .                   if !self.bump() {
  143,468 ( 0.04%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,612x)
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(start, self.pos()),
        .          .          .          .                           ast::ErrorKind::EscapeUnexpectedEof,
        .          .          .          .                       ));
        .          .          .          .                   }
    4,836 ( 0.00%) .          .          .                   let c = self.char();
   33,852 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (1,612x)
        .          .          .          .                   // Put some of the more complicated routines into helpers.
    4,836 ( 0.00%) .          .          .                   match c {
    4,836 ( 0.00%) .          .          .                       '0'..='7' => {
        .          .          .          .                           if !self.parser().octal {
        .          .          .          .                               return Err(self.error(
        .          .          .          .                                   Span::new(start, self.span_char().end),
        .          .          .          .                                   ast::ErrorKind::UnsupportedBackreference,
        .          .          .          .                               ));
        .          .          .          .                           }
        .          .          .          .                           let mut lit = self.parse_octal();
        .          .          .          .                           lit.span.start = start;
        .          .          .          .                           return Ok(Primitive::Literal(lit));
        .          .          .          .                       }
    6,448 ( 0.00%) .          .          .                       '8'..='9' if !self.parser().octal => {
        .          .          .          .                           return Err(self.error(
        .          .          .          .                               Span::new(start, self.span_char().end),
        .          .          .          .                               ast::ErrorKind::UnsupportedBackreference,
        .          .          .          .                           ));
        .          .          .          .                       }
        .          .          .          .                       'x' | 'u' | 'U' => {
        .          .          .          .                           let mut lit = self.parse_hex()?;
        .          .          .          .                           lit.span.start = start;
-- line 1510 ----------------------------------------
-- line 1511 ----------------------------------------
        .          .          .          .                           return Ok(Primitive::Literal(lit));
        .          .          .          .                       }
        .          .          .          .                       'p' | 'P' => {
        .          .          .          .                           let mut cls = self.parse_unicode_class()?;
        .          .          .          .                           cls.span.start = start;
        .          .          .          .                           return Ok(Primitive::Unicode(cls));
        .          .          .          .                       }
        .          .          .          .                       'd' | 's' | 'w' | 'D' | 'S' | 'W' => {
       10 ( 0.00%) .          .          .                           let mut cls = self.parse_perl_class();
    1,105 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_perl_class (5x)
       20 ( 0.00%) .          .          .                           cls.span.start = start;
       50 ( 0.00%) .          .          .                           return Ok(Primitive::Perl(cls));
        .          .          .          .                       }
        .          .          .          .                       _ => {}
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   // Handle all of the one letter sequences inline.
    3,214 ( 0.00%) .          .          .                   self.bump();
  143,023 ( 0.04%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,607x)
        .          .          .          .                   let span = Span::new(start, self.pos());
    6,428 ( 0.00%) .          .          .                   if is_meta_character(c) {
   16,069 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/lib.rs:regex_syntax::is_meta_character (1,607x)
    3,212 ( 0.00%) .          .          .                       return Ok(Primitive::Literal(ast::Literal {
    9,636 ( 0.00%) .          .          .                           span,
        .          .          .          .                           kind: ast::LiteralKind::Meta,
        .          .          .          .                           c,
        .          .          .          .                       }));
        .          .          .          .                   }
        .          .          .          .                   if is_escapeable_character(c) {
        .          .          .          .                       return Ok(Primitive::Literal(ast::Literal {
        .          .          .          .                           span,
        .          .          .          .                           kind: ast::LiteralKind::Superfluous,
        .          .          .          .                           c,
        .          .          .          .                       }));
        .          .          .          .                   }
        .          .          .          .                   let special = |kind, c| {
        3 ( 0.00%) .          .          .                       Ok(Primitive::Literal(ast::Literal {
        6 ( 0.00%) .          .          .                           span,
        .          .          .          .                           kind: ast::LiteralKind::Special(kind),
        .          .          .          .                           c,
        .          .          .          .                       }))
        .          .          .          .                   };
        3 ( 0.00%) .          .          .                   match c {
        .          .          .          .                       'a' => special(ast::SpecialLiteralKind::Bell, '\x07'),
        .          .          .          .                       'f' => special(ast::SpecialLiteralKind::FormFeed, '\x0C'),
        .          .          .          .                       't' => special(ast::SpecialLiteralKind::Tab, '\t'),
        .          .          .          .                       'n' => special(ast::SpecialLiteralKind::LineFeed, '\n'),
        .          .          .          .                       'r' => special(ast::SpecialLiteralKind::CarriageReturn, '\r'),
        .          .          .          .                       'v' => special(ast::SpecialLiteralKind::VerticalTab, '\x0B'),
        .          .          .          .                       'A' => Ok(Primitive::Assertion(ast::Assertion {
        .          .          .          .                           span,
-- line 1558 ----------------------------------------
-- line 1588 ----------------------------------------
        .          .          .          .                           kind: ast::AssertionKind::WordBoundaryStartAngle,
        .          .          .          .                       })),
        .          .          .          .                       '>' => Ok(Primitive::Assertion(ast::Assertion {
        .          .          .          .                           span,
        .          .          .          .                           kind: ast::AssertionKind::WordBoundaryEndAngle,
        .          .          .          .                       })),
        .          .          .          .                       _ => Err(self.error(span, ast::ErrorKind::EscapeUnrecognized)),
        .          .          .          .                   }
   12,896 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Attempt to parse a specialty word boundary. That is, `\b{start}`,
        .          .          .          .               /// `\b{end}`, `\b{start-half}` or `\b{end-half}`.
        .          .          .          .               ///
        .          .          .          .               /// This is similar to `maybe_parse_ascii_class` in that, in most cases,
        .          .          .          .               /// if it fails it will just return `None` with no error. This is done
        .          .          .          .               /// because `\b{5}` is a valid expression and we want to let that be parsed
        .          .          .          .               /// by the existing counted repetition parsing code. (I thought about just
-- line 1604 ----------------------------------------
-- line 1835 ----------------------------------------
        .          .          .          .               /// whitespace.
        .          .          .          .               ///
        .          .          .          .               /// This expects the parser to be positioned at the first position where
        .          .          .          .               /// a decimal digit could occur. This will advance the parser to the byte
        .          .          .          .               /// immediately following the last contiguous decimal digit.
        .          .          .          .               ///
        .          .          .          .               /// If no decimal digit could be found or if there was a problem parsing
        .          .          .          .               /// the complete set of digits into a u32, then an error is returned.
    1,673 ( 0.00%) .          .          .               fn parse_decimal(&self) -> Result<u32> {
        .          .          .          .                   let mut scratch = self.parser().scratch.borrow_mut();
        .          .          .          .                   scratch.clear();
        .          .          .          .           
      717 ( 0.00%) .          .          .                   while !self.is_eof() && self.char().is_whitespace() {
    5,019 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (239x)
        .          .          .          .                       self.bump();
        .          .          .          .                   }
        .          .          .          .                   let start = self.pos();
    4,043 ( 0.00%) .          .          .                   while !self.is_eof() && '0' <= self.char() && self.char() <= '9' {
   18,711 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (891x)
      720 ( 0.00%) .          .          .                       scratch.push(self.char());
    5,040 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (240x)
        .          .          .          .                       self.bump_and_bump_space();
        .          .          .          .                   }
        .          .          .          .                   let span = Span::new(start, self.pos());
      717 ( 0.00%) .          .          .                   while !self.is_eof() && self.char().is_whitespace() {
    5,019 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (239x)
        .          .          .          .                       self.bump_and_bump_space();
        .          .          .          .                   }
        .          .          .          .                   let digits = scratch.as_str();
      478 ( 0.00%) .          .          .                   if digits.is_empty() {
        .          .          .          .                       return Err(self.error(span, ast::ErrorKind::DecimalEmpty));
        .          .          .          .                   }
      956 ( 0.00%) .          .          .                   match u32::from_str_radix(digits, 10).ok() {
   10,525 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/uint_macros.rs:core::num::<impl u32>::from_str_radix (239x)
      717 ( 0.00%) .          .          .                       Some(n) => Ok(n),
        .          .          .          .                       None => Err(self.error(span, ast::ErrorKind::DecimalInvalid)),
        .          .          .          .                   }
    1,912 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a standard character class consisting primarily of characters or
        .          .          .          .               /// character ranges, but can also contain nested character classes of
        .          .          .          .               /// any type (sans `.`).
        .          .          .          .               ///
        .          .          .          .               /// This assumes the parser is positioned at the opening `[`. If parsing
        .          .          .          .               /// is successful, then the parser is advanced to the position immediately
        .          .          .          .               /// following the closing `]`.
        .          .          .          .               #[inline(never)]
   24,777 ( 0.01%) .          .          .               fn parse_set_class(&self) -> Result<ast::ClassBracketed> {
   13,765 ( 0.00%) .          .          .                   assert_eq!(self.char(), '[');
   57,777 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,753x)
        .          .          .          .           
        .          .          .          .                   let mut union =
   44,048 ( 0.01%) .          .          .                       ast::ClassSetUnion { span: self.span(), items: vec![] };
        .          .          .          .                   loop {
   19,934 ( 0.01%) .          .          .                       self.bump_space();
  179,406 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (9,967x)
    9,967 ( 0.00%) .          .          .                       if self.is_eof() {
        .          .          .          .                           return Err(self.unclosed_class_error());
        .          .          .          .                       }
   75,934 ( 0.02%) .          .          .                       match self.char() {
  209,871 ( 0.06%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (9,967x)
        .          .          .          .                           '[' => {
        .          .          .          .                               // If we've already parsed the opening bracket, then
        .          .          .          .                               // attempt to treat this as the beginning of an ASCII
        .          .          .          .                               // class. If ASCII class parsing fails, then the parser
        .          .          .          .                               // backs up to `[`.
    3,594 ( 0.00%) .          .          .                               if !self.parser().stack_class.borrow().is_empty() {
   10,365 ( 0.00%) .          .          .                                   if let Some(cls) = self.maybe_parse_ascii_class() {
  943,165 ( 0.27%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::maybe_parse_ascii_class (841x)
        .          .          .          .                                       union.push(ast::ClassSetItem::Ascii(cls));
        .          .          .          .                                       continue;
        .          .          .          .                                   }
        .          .          .          .                               }
   70,600 ( 0.02%) .          .          .                               union = self.push_class_open(union)?;
2,682,187 ( 0.77%) 330 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (2,824x)
        .          .          .          .                           }
   45,184 ( 0.01%) .          .          .                           ']' => match self.pop_class(union)? {
2,185,246 ( 0.63%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x)
      781 ( 0.00%) .          .          .                               Either::Left(nested_union) => {
        .          .          .          .                                   union = nested_union;
        .          .          .          .                               }
   27,530 ( 0.01%) .          .          .                               Either::Right(class) => return Ok(class),
   82,590 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x)
        .          .          .          .                           },
        .          .          .          .                           '&' if self.peek() == Some('&') => {
        .          .          .          .                               assert!(self.bump_if("&&"));
        .          .          .          .                               union = self.push_class_op(
        .          .          .          .                                   ast::ClassSetBinaryOpKind::Intersection,
        .          .          .          .                                   union,
        .          .          .          .                               );
        .          .          .          .                           }
-- line 1913 ----------------------------------------
-- line 1921 ----------------------------------------
        .          .          .          .                           '~' if self.peek() == Some('~') => {
        .          .          .          .                               assert!(self.bump_if("~~"));
        .          .          .          .                               union = self.push_class_op(
        .          .          .          .                                   ast::ClassSetBinaryOpKind::SymmetricDifference,
        .          .          .          .                                   union,
        .          .          .          .                               );
        .          .          .          .                           }
        .          .          .          .                           _ => {
   35,490 ( 0.01%) .          .          .                               union.push(self.parse_set_class_range()?);
1,393,222 ( 0.40%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range (3,549x)
  106,470 ( 0.03%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (3,549x)
        .          .          .          .                           }
        .          .          .          .                       }
        .          .          .          .                   }
   22,024 ( 0.01%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a single primitive item in a character class set. The item to
        .          .          .          .               /// be parsed can either be one of a simple literal character, a range
        .          .          .          .               /// between two simple literal characters or a "primitive" character
        .          .          .          .               /// class like \w or \p{Greek}.
        .          .          .          .               ///
        .          .          .          .               /// If an invalid escape is found, or if a character class is found where
        .          .          .          .               /// a simple literal is expected (e.g., in a range), then an error is
        .          .          .          .               /// returned.
        .          .          .          .               #[inline(never)]
   35,490 ( 0.01%) .          .          .               fn parse_set_class_range(&self) -> Result<ast::ClassSetItem> {
   31,941 ( 0.01%) .          .          .                   let prim1 = self.parse_set_class_item()?;
1,012,864 ( 0.29%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item (3,549x)
    7,098 ( 0.00%) .          .          .                   self.bump_space();
   63,882 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (3,549x)
   10,647 ( 0.00%) .          .          .                   if self.is_eof() {
        .          .          .          .                       return Err(self.unclosed_class_error());
        .          .          .          .                   }
        .          .          .          .                   // If the next char isn't a `-`, then we don't have a range.
        .          .          .          .                   // There are two exceptions. If the char after a `-` is a `]`, then
        .          .          .          .                   // `-` is interpreted as a literal `-`. Alternatively, if the char
        .          .          .          .                   // after a `-` is a `-`, then `--` corresponds to a "difference"
        .          .          .          .                   // operation.
   14,196 ( 0.00%) .          .          .                   if self.char() != '-'
   75,129 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (3,549x)
        .          .          .          .                       || self.peek_space() == Some(']')
        .          .          .          .                       || self.peek_space() == Some('-')
        .          .          .          .                   {
    3,549 ( 0.00%) .          .          .                       return prim1.into_class_set_item(self);
        .          .          .          .                   }
        .          .          .          .                   // OK, now we're parsing a range, so bump past the `-` and parse the
        .          .          .          .                   // second half of the range.
        .          .          .          .                   if !self.bump_and_bump_space() {
        .          .          .          .                       return Err(self.unclosed_class_error());
        .          .          .          .                   }
        .          .          .          .                   let prim2 = self.parse_set_class_item()?;
        .          .          .          .                   let range = ast::ClassSetRange {
-- line 1967 ----------------------------------------
-- line 1970 ----------------------------------------
        .          .          .          .                       end: prim2.into_class_literal(self)?,
        .          .          .          .                   };
        .          .          .          .                   if !range.is_valid() {
        .          .          .          .                       return Err(
        .          .          .          .                           self.error(range.span, ast::ErrorKind::ClassRangeInvalid)
        .          .          .          .                       );
        .          .          .          .                   }
        .          .          .          .                   Ok(ast::ClassSetItem::Range(range))
   28,392 ( 0.01%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a single item in a character class as a primitive, where the
        .          .          .          .               /// primitive either consists of a verbatim literal or a single escape
        .          .          .          .               /// sequence.
        .          .          .          .               ///
        .          .          .          .               /// This assumes the parser is positioned at the beginning of a primitive,
        .          .          .          .               /// and advances the parser to the first position after the primitive if
        .          .          .          .               /// successful.
        .          .          .          .               ///
        .          .          .          .               /// Note that it is the caller's responsibility to report an error if an
        .          .          .          .               /// illegal primitive was parsed.
        .          .          .          .               #[inline(never)]
   31,941 ( 0.01%) .          .          .               fn parse_set_class_item(&self) -> Result<Primitive> {
   14,196 ( 0.00%) .          .          .                   if self.char() == '\\' {
   75,129 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (3,549x)
   16,120 ( 0.00%) .          .          .                       self.parse_escape()
  484,598 ( 0.14%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape (1,612x)
        .          .          .          .                   } else {
        .          .          .          .                       let x = Primitive::Literal(ast::Literal {
        .          .          .          .                           span: self.span_char(),
        .          .          .          .                           kind: ast::LiteralKind::Verbatim,
    5,811 ( 0.00%) .          .          .                           c: self.char(),
   41,277 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (1,937x)
        .          .          .          .                       });
    3,874 ( 0.00%) .          .          .                       self.bump();
  173,833 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,937x)
    7,748 ( 0.00%) .          .          .                       Ok(x)
        .          .          .          .                   }
   15,496 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parses the opening of a character class set. This includes the opening
        .          .          .          .               /// bracket along with `^` if present to indicate negation. This also
        .          .          .          .               /// starts parsing the opening set of unioned items if applicable, since
        .          .          .          .               /// there are special rules applied to certain characters in the opening
        .          .          .          .               /// of a character class. For example, `[^]]` is the class of all
        .          .          .          .               /// characters not equal to `]`. (`]` would need to be escaped in any other
        .          .          .          .               /// position.) Similarly for `-`.
-- line 2011 ----------------------------------------
-- line 2014 ----------------------------------------
        .          .          .          .               /// empty union. This empty union should be replaced with the actual item
        .          .          .          .               /// when it is popped from the parser's stack.
        .          .          .          .               ///
        .          .          .          .               /// This assumes the parser is positioned at the opening `[` and advances
        .          .          .          .               /// the parser to the first non-special byte of the character class.
        .          .          .          .               ///
        .          .          .          .               /// An error is returned if EOF is found.
        .          .          .          .               #[inline(never)]
   25,416 ( 0.01%) .          .          .               fn parse_set_class_open(
        .          .          .          .                   &self,
        .          .          .          .               ) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {
   14,120 ( 0.00%) .          .          .                   assert_eq!(self.char(), '[');
   59,268 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,824x)
        .          .          .          .                   let start = self.pos();
    2,824 ( 0.00%) .          .          .                   if !self.bump_and_bump_space() {
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(start, self.pos()),
        .          .          .          .                           ast::ErrorKind::ClassUnclosed,
        .          .          .          .                       ));
        .          .          .          .                   }
        .          .          .          .           
   16,944 ( 0.00%) .          .          .                   let negated = if self.char() != '^' {
   59,304 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,824x)
        .          .          .          .                       false
        .          .          .          .                   } else {
        1 ( 0.00%) .          .          .                       if !self.bump_and_bump_space() {
        .          .          .          .                           return Err(self.error(
        .          .          .          .                               Span::new(start, self.pos()),
        .          .          .          .                               ast::ErrorKind::ClassUnclosed,
        .          .          .          .                           ));
        .          .          .          .                       }
        .          .          .          .                       true
        .          .          .          .                   };
        .          .          .          .                   // Accept any number of `-` as literal `-`.
        .          .          .          .                   let mut union =
   11,296 ( 0.00%) .          .          .                       ast::ClassSetUnion { span: self.span(), items: vec![] };
   11,300 ( 0.00%) .          .          .                   while self.char() == '-' {
   59,325 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,825x)
        .          .          .          .                       union.push(ast::ClassSetItem::Literal(ast::Literal {
        .          .          .          .                           span: self.span_char(),
        .          .          .          .                           kind: ast::LiteralKind::Verbatim,
        .          .          .          .                           c: '-',
        .          .          .          .                       }));
        1 ( 0.00%) .          .          .                       if !self.bump_and_bump_space() {
        .          .          .          .                           return Err(self.error(
        .          .          .          .                               Span::new(start, start),
        .          .          .          .                               ast::ErrorKind::ClassUnclosed,
        .          .          .          .                           ));
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   // If `]` is the *first* char in a set, then interpret it as a literal
        .          .          .          .                   // `]`. That is, an empty class is impossible to write.
   16,940 ( 0.00%) .          .          .                   if union.items.is_empty() && self.char() == ']' {
   59,283 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,823x)
        .          .          .          .                       union.push(ast::ClassSetItem::Literal(ast::Literal {
        .          .          .          .                           span: self.span_char(),
        .          .          .          .                           kind: ast::LiteralKind::Verbatim,
        .          .          .          .                           c: ']',
        .          .          .          .                       }));
        .          .          .          .                       if !self.bump_and_bump_space() {
        .          .          .          .                           return Err(self.error(
        .          .          .          .                               Span::new(start, self.pos()),
        .          .          .          .                               ast::ErrorKind::ClassUnclosed,
        .          .          .          .                           ));
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   let set = ast::ClassBracketed {
        .          .          .          .                       span: Span::new(start, self.pos()),
        .          .          .          .                       negated,
    5,648 ( 0.00%) .          .          .                       kind: ast::ClassSet::union(ast::ClassSetUnion {
   25,416 ( 0.01%) .          .          .                           span: Span::new(union.span.start, union.span.start),
        .          .          .          .                           items: vec![],
        .          .          .          .                       }),
        .          .          .          .                   };
   56,480 ( 0.02%) .          .          .                   Ok((set, union))
   22,592 ( 0.01%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Attempt to parse an ASCII character class, e.g., `[:alnum:]`.
        .          .          .          .               ///
        .          .          .          .               /// This assumes the parser is positioned at the opening `[`.
        .          .          .          .               ///
        .          .          .          .               /// If no valid ASCII character class could be found, then this does not
        .          .          .          .               /// advance the parser and `None` is returned. Otherwise, the parser is
        .          .          .          .               /// advanced to the first byte following the closing `]` and the
        .          .          .          .               /// corresponding ASCII class is returned.
        .          .          .          .               #[inline(never)]
    7,569 ( 0.00%) .          .          .               fn maybe_parse_ascii_class(&self) -> Option<ast::ClassAscii> {
        .          .          .          .                   // ASCII character classes are interesting from a parsing perspective
        .          .          .          .                   // because parsing cannot fail with any interesting error. For example,
        .          .          .          .                   // in order to use an ASCII character class, it must be enclosed in
        .          .          .          .                   // double brackets, e.g., `[[:alnum:]]`. Alternatively, you might think
        .          .          .          .                   // of it as "ASCII character classes have the syntax `[:NAME:]` which
        .          .          .          .                   // can only appear within character brackets." This means that things
        .          .          .          .                   // like `[[:lower:]A]` are legal constructs.
        .          .          .          .                   //
-- line 2104 ----------------------------------------
-- line 2108 ----------------------------------------
        .          .          .          .                   // should return an error instead since the repeated colons give away
        .          .          .          .                   // the intent to write an ASCII class. But what if the user typed
        .          .          .          .                   // `[[:lower]]` instead? How can we tell that was intended to be an
        .          .          .          .                   // ASCII class and not just a normal nested class?
        .          .          .          .                   //
        .          .          .          .                   // Reasonable people can probably disagree over this, but for better
        .          .          .          .                   // or worse, we implement semantics that never fails at the expense
        .          .          .          .                   // of better failure modes.
    4,205 ( 0.00%) .          .          .                   assert_eq!(self.char(), '[');
   17,661 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (841x)
        .          .          .          .                   // If parsing fails, then we back up the parser to this starting point.
        .          .          .          .                   let start = self.pos();
        .          .          .          .                   let mut negated = false;
    6,728 ( 0.00%) .          .          .                   if !self.bump() || self.char() != ':' {
   74,849 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (841x)
   17,661 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (841x)
        .          .          .          .                       self.parser().pos.set(start);
        .          .          .          .                       return None;
        .          .          .          .                   }
    3,080 ( 0.00%) .          .          .                   if !self.bump() {
   68,530 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (770x)
        .          .          .          .                       self.parser().pos.set(start);
        .          .          .          .                       return None;
        .          .          .          .                   }
    4,620 ( 0.00%) .          .          .                   if self.char() == '^' {
   16,170 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (770x)
        .          .          .          .                       negated = true;
      220 ( 0.00%) .          .          .                       if !self.bump() {
    4,895 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (55x)
        .          .          .          .                           self.parser().pos.set(start);
        .          .          .          .                           return None;
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   let name_start = self.offset();
   33,872 ( 0.01%) .          .          .                   while self.char() != ':' && self.bump() {}
  342,561 ( 0.10%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (3,849x)
   96,999 ( 0.03%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (4,619x)
    1,540 ( 0.00%) .          .          .                   if self.is_eof() {
        .          .          .          .                       self.parser().pos.set(start);
        .          .          .          .                       return None;
        .          .          .          .                   }
        .          .          .          .                   let name = &self.pattern()[name_start..self.offset()];
        .          .          .          .                   if !self.bump_if(":]") {
        .          .          .          .                       self.parser().pos.set(start);
        .          .          .          .                       return None;
        .          .          .          .                   }
    3,080 ( 0.00%) .          .          .                   let kind = match ast::ClassAsciiKind::from_name(name) {
   31,216 ( 0.01%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs:regex_syntax::ast::ClassAsciiKind::from_name (770x)
        .          .          .          .                       Some(kind) => kind,
        .          .          .          .                       None => {
        .          .          .          .                           self.parser().pos.set(start);
        .          .          .          .                           return None;
        .          .          .          .                       }
        .          .          .          .                   };
    2,310 ( 0.00%) .          .          .                   Some(ast::ClassAscii {
        .          .          .          .                       span: Span::new(start, self.pos()),
        .          .          .          .                       kind,
        .          .          .          .                       negated,
        .          .          .          .                   })
    6,728 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a Unicode class in either the single character notation, `\pN`
        .          .          .          .               /// or the multi-character bracketed notation, `\p{Greek}`. This assumes
        .          .          .          .               /// the parser is positioned at the `p` (or `P` for negation) and will
        .          .          .          .               /// advance the parser to the character immediately following the class.
        .          .          .          .               ///
        .          .          .          .               /// Note that this does not check whether the class name is valid or not.
        .          .          .          .               #[inline(never)]
-- line 2166 ----------------------------------------
-- line 2238 ----------------------------------------
        .          .          .          .                       kind,
        .          .          .          .                   })
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a Perl character class, e.g., `\d` or `\W`. This assumes the
        .          .          .          .               /// parser is currently at a valid character class name and will be
        .          .          .          .               /// advanced to the character immediately following the class.
        .          .          .          .               #[inline(never)]
       45 ( 0.00%) .          .          .               fn parse_perl_class(&self) -> ast::ClassPerl {
       10 ( 0.00%) .          .          .                   let c = self.char();
      105 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (5x)
        .          .          .          .                   let span = self.span_char();
       15 ( 0.00%) .          .          .                   self.bump();
      445 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (5x)
       15 ( 0.00%) .          .          .                   let (negated, kind) = match c {
        .          .          .          .                       'd' => (false, ast::ClassPerlKind::Digit),
        .          .          .          .                       'D' => (true, ast::ClassPerlKind::Digit),
        .          .          .          .                       's' => (false, ast::ClassPerlKind::Space),
        .          .          .          .                       'S' => (true, ast::ClassPerlKind::Space),
        .          .          .          .                       'w' => (false, ast::ClassPerlKind::Word),
        .          .          .          .                       'W' => (true, ast::ClassPerlKind::Word),
        .          .          .          .                       c => panic!("expected valid Perl class but got '{}'", c),
        .          .          .          .                   };
       45 ( 0.00%) .          .          .                   ast::ClassPerl { span, kind, negated }
       40 ( 0.00%) .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// A type that traverses a fully parsed Ast and checks whether its depth
        .          .          .          .           /// exceeds the specified nesting limit. If it does, then an error is returned.
        .          .          .          .           #[derive(Debug)]
        .          .          .          .           struct NestLimiter<'p, 's, P> {
        .          .          .          .               /// The parser that is checking the nest limit.
        .          .          .          .               p: &'p ParserI<'s, P>,
-- line 2268 ----------------------------------------
-- line 2271 ----------------------------------------
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'p, 's, P: Borrow<Parser>> NestLimiter<'p, 's, P> {
        .          .          .          .               fn new(p: &'p ParserI<'s, P>) -> NestLimiter<'p, 's, P> {
        .          .          .          .                   NestLimiter { p, depth: 0 }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline(never)]
       81 ( 0.00%) .          .          .               fn check(self, ast: &Ast) -> Result<()> {
      324 ( 0.00%) .          .          .                   ast::visit(ast, self)
6,089,860 ( 1.75%) 304 ( 0.04%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (81x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn increment_depth(&mut self, span: &Span) -> Result<()> {
   22,225 ( 0.01%) .          .          .                   let new = self.depth.checked_add(1).ok_or_else(|| {
        .          .          .          .                       self.p.error(
        .          .          .          .                           span.clone(),
        .          .          .          .                           ast::ErrorKind::NestLimitExceeded(u32::MAX),
        .          .          .          .                       )
        .          .          .          .                   })?;
   22,225 ( 0.01%) .          .          .                   let limit = self.p.parser().nest_limit;
   44,450 ( 0.01%) .          .          .                   if new > limit {
        .          .          .          .                       return Err(self.p.error(
        .          .          .          .                           span.clone(),
        .          .          .          .                           ast::ErrorKind::NestLimitExceeded(limit),
        .          .          .          .                       ));
        .          .          .          .                   }
   44,450 ( 0.01%) .          .          .                   self.depth = new;
        .          .          .          .                   Ok(())
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn decrement_depth(&mut self) {
        .          .          .          .                   // Assuming the correctness of the visitor, this should never drop
        .          .          .          .                   // below 0.
   57,805 ( 0.02%) .          .          .                   self.depth = self.depth.checked_sub(1).unwrap();
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'p, 's, P: Borrow<Parser>> ast::Visitor for NestLimiter<'p, 's, P> {
        .          .          .          .               type Output = ();
        .          .          .          .               type Err = ast::Error;
        .          .          .          .           
        .          .          .          .               fn finish(self) -> Result<()> {
       81 ( 0.00%) .          .          .                   Ok(())
        .          .          .          .               }
        .          .          .          .           
  570,048 ( 0.16%) .          .          .               fn visit_pre(&mut self, ast: &Ast) -> Result<()> {
  356,280 ( 0.10%) .          .          .                   let span = match *ast {
        .          .          .          .                       Ast::Empty(_)
        .          .          .          .                       | Ast::Flags(_)
        .          .          .          .                       | Ast::Literal(_)
        .          .          .          .                       | Ast::Dot(_)
        .          .          .          .                       | Ast::Assertion(_)
        .          .          .          .                       | Ast::ClassUnicode(_)
        .          .          .          .                       | Ast::ClassPerl(_) => {
        .          .          .          .                           // These are all base cases, so we don't increment depth.
        .          .          .          .                           return Ok(());
        .          .          .          .                       }
        .          .          .          .                       Ast::ClassBracketed(ref x) => &x.span,
        .          .          .          .                       Ast::Repetition(ref x) => &x.span,
    1,386 ( 0.00%) .          .          .                       Ast::Group(ref x) => &x.span,
        .          .          .          .                       Ast::Alternation(ref x) => &x.span,
        .          .          .          .                       Ast::Concat(ref x) => &x.span,
        .          .          .          .                   };
        .          .          .          .                   self.increment_depth(span)
  641,304 ( 0.18%) .          .          .               }
        .          .          .          .           
        .          .          .          .               fn visit_post(&mut self, ast: &Ast) -> Result<()> {
   43,258 ( 0.01%) .          .          .                   match *ast {
        .          .          .          .                       Ast::Empty(_)
        .          .          .          .                       | Ast::Flags(_)
        .          .          .          .                       | Ast::Literal(_)
        .          .          .          .                       | Ast::Dot(_)
        .          .          .          .                       | Ast::Assertion(_)
        .          .          .          .                       | Ast::ClassUnicode(_)
        .          .          .          .                       | Ast::ClassPerl(_) => {
        .          .          .          .                           // These are all base cases, so we don't decrement depth.
-- line 2346 ----------------------------------------
-- line 2352 ----------------------------------------
        .          .          .          .                       | Ast::Alternation(_)
        .          .          .          .                       | Ast::Concat(_) => {
        .          .          .          .                           self.decrement_depth();
        .          .          .          .                           Ok(())
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
   44,244 ( 0.01%) .          .          .               fn visit_class_set_item_pre(
        .          .          .          .                   &mut self,
        .          .          .          .                   ast: &ast::ClassSetItem,
        .          .          .          .               ) -> Result<()> {
   30,092 ( 0.01%) .          .          .                   let span = match *ast {
        .          .          .          .                       ast::ClassSetItem::Empty(_)
        .          .          .          .                       | ast::ClassSetItem::Literal(_)
        .          .          .          .                       | ast::ClassSetItem::Range(_)
        .          .          .          .                       | ast::ClassSetItem::Ascii(_)
        .          .          .          .                       | ast::ClassSetItem::Unicode(_)
        .          .          .          .                       | ast::ClassSetItem::Perl(_) => {
        .          .          .          .                           // These are all base cases, so we don't increment depth.
        .          .          .          .                           return Ok(());
        .          .          .          .                       }
       71 ( 0.00%) .          .          .                       ast::ClassSetItem::Bracketed(ref x) => &x.span,
      525 ( 0.00%) .          .          .                       ast::ClassSetItem::Union(ref x) => &x.span,
        .          .          .          .                   };
        .          .          .          .                   self.increment_depth(span)
   44,244 ( 0.01%) .          .          .               }
        .          .          .          .           
        .          .          .          .               fn visit_class_set_item_post(
        .          .          .          .                   &mut self,
        .          .          .          .                   ast: &ast::ClassSetItem,
        .          .          .          .               ) -> Result<()> {
   19,068 ( 0.01%) .          .          .                   match *ast {
        .          .          .          .                       ast::ClassSetItem::Empty(_)
        .          .          .          .                       | ast::ClassSetItem::Literal(_)
        .          .          .          .                       | ast::ClassSetItem::Range(_)
        .          .          .          .                       | ast::ClassSetItem::Ascii(_)
        .          .          .          .                       | ast::ClassSetItem::Unicode(_)
        .          .          .          .                       | ast::ClassSetItem::Perl(_) => {
        .          .          .          .                           // These are all base cases, so we don't decrement depth.
        .          .          .          .                           Ok(())
-- line 2392 ----------------------------------------
-- line 2412 ----------------------------------------
        .          .          .          .                   self.decrement_depth();
        .          .          .          .                   Ok(())
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// When the result is an error, transforms the ast::ErrorKind from the source
        .          .          .          .           /// Result into another one. This function is used to return clearer error
        .          .          .          .           /// messages when possible.
      402 ( 0.00%) .          .          .           fn specialize_err<T>(
        .          .          .          .               result: Result<T>,
        .          .          .          .               from: ast::ErrorKind,
        .          .          .          .               to: ast::ErrorKind,
        .          .          .          .           ) -> Result<T> {
      650 ( 0.00%) .          .          .               if let Err(e) = result {
        .          .          .          .                   if e.kind == from {
        .          .          .          .                       Err(ast::Error { kind: to, pattern: e.pattern, span: e.span })
        .          .          .          .                   } else {
        .          .          .          .                       Err(e)
        .          .          .          .                   }
        .          .          .          .               } else {
        .          .          .          .                   result
        .          .          .          .               }
      335 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #[cfg(test)]
        .          .          .          .           mod tests {
        .          .          .          .               use core::ops::Range;
        .          .          .          .           
        .          .          .          .               use alloc::format;
        .          .          .          .           
        .          .          .          .               use super::*;
-- line 2442 ----------------------------------------

1,328,322 ( 0.38%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/parse.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 280 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// let input = Input::new(b"\xFEfoo\xFFarzz\xE2\x98\xFF\n");
      .          .          .          .               /// let expected = Some(HalfMatch::must(0, 9));
      .          .          .          .               /// let got = re.try_search_fwd(&mut cache, &input)?;
      .          .          .          .               /// assert_eq!(expected, got);
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
    405 ( 0.00%) .          .          .               pub fn builder() -> Builder {
      .          .          .          .                   Builder::new()
    486 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new cache for this lazy DFA.
      .          .          .          .               ///
      .          .          .          .               /// The cache returned should only be used for searches for this
      .          .          .          .               /// lazy DFA. If you want to reuse the cache for another DFA, then
      .          .          .          .               /// you must call [`Cache::reset`] with that DFA (or, equivalently,
      .          .          .          .               /// [`DFA::reset_cache`]).
      .          .          .          .               pub fn create_cache(&self) -> Cache {
-- line 298 ----------------------------------------
-- line 405 ----------------------------------------
      .          .          .          .           
      .          .          .          .               /// Returns this lazy DFA's configuration.
      .          .          .          .               pub fn get_config(&self) -> &Config {
      .          .          .          .                   &self.config
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a reference to the underlying NFA.
      .          .          .          .               pub fn get_nfa(&self) -> &thompson::NFA {
    259 ( 0.00%) .          .          .                   &self.nfa
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the stride, as a base-2 exponent, required for these
      .          .          .          .               /// equivalence classes.
      .          .          .          .               ///
      .          .          .          .               /// The stride is always the smallest power of 2 that is greater than or
      .          .          .          .               /// equal to the alphabet length. This is done so that converting between
      .          .          .          .               /// state IDs and indices can be done with shifts alone, which is much
-- line 421 ----------------------------------------
-- line 423 ----------------------------------------
      .          .          .          .               fn stride2(&self) -> usize {
      .          .          .          .                   self.stride2
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the total stride for every state in this lazy DFA. This
      .          .          .          .               /// corresponds to the total number of transitions used by each state in
      .          .          .          .               /// this DFA's transition table.
      .          .          .          .               fn stride(&self) -> usize {
  2,700 ( 0.00%) .          .          .                   1 << self.stride2()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the memory usage, in bytes, of this lazy DFA.
      .          .          .          .               ///
      .          .          .          .               /// This does **not** include the stack size used up by this lazy DFA. To
      .          .          .          .               /// compute that, use `std::mem::size_of::<DFA>()`. This also does not
      .          .          .          .               /// include the size of the `Cache` used.
      .          .          .          .               ///
-- line 439 ----------------------------------------
-- line 586 ----------------------------------------
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn try_search_fwd(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .               ) -> Result<Option<HalfMatch>, MatchError> {
     45 ( 0.00%) .          .          .                   let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
    270 ( 0.00%) .          .          .                   let hm = match search::find_fwd(self, cache, input)? {
652,940 ( 0.19%) 671 ( 0.08%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/search.rs:regex_automata::hybrid::search::find_fwd (45x)
      .          .          .          .                       None => return Ok(None),
     25 ( 0.00%) .          .          .                       Some(hm) if !utf8empty => return Ok(Some(hm)),
      .          .          .          .                       Some(hm) => hm,
      .          .          .          .                   };
      .          .          .          .                   // We get to this point when we know our DFA can match the empty string
      .          .          .          .                   // AND when UTF-8 mode is enabled. In this case, we skip any matches
      .          .          .          .                   // whose offset splits a codepoint. Such a match is necessarily a
      .          .          .          .                   // zero-width match, because UTF-8 mode requires the underlying NFA
      .          .          .          .                   // to be built such that all non-empty matches span valid UTF-8.
      .          .          .          .                   // Therefore, any match that ends in the middle of a codepoint cannot
-- line 605 ----------------------------------------
-- line 1214 ----------------------------------------
      .          .          .          .               #[inline]
      .          .          .          .               pub fn next_state(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   current: LazyStateID,
      .          .          .          .                   input: u8,
      .          .          .          .               ) -> Result<LazyStateID, CacheError> {
      .          .          .          .                   let class = usize::from(self.classes.get(input));
    221 ( 0.00%) .          .          .                   let offset = current.as_usize_untagged() + class;
    448 ( 0.00%) .          .          .                   let sid = cache.trans[offset];
     21 ( 0.00%) .          .          .                   if !sid.is_unknown() {
      .          .          .          .                       return Ok(sid);
      .          .          .          .                   }
      .          .          .          .                   let unit = alphabet::Unit::u8(input);
    875 ( 0.00%) .          .          .                   Lazy::new(self, cache).cache_next_state(current, unit)
506,084 ( 0.15%) 482 ( 0.06%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (218x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Transitions from the current state to the next state, given the next
      .          .          .          .               /// byte of input and a state ID that is not tagged.
      .          .          .          .               ///
      .          .          .          .               /// The only reason to use this routine is performance. In particular, the
      .          .          .          .               /// `next_state` method needs to do some additional checks, among them is
      .          .          .          .               /// to account for identifiers to states that are not yet computed. In
-- line 1236 ----------------------------------------
-- line 1415 ----------------------------------------
      .          .          .          .               pub unsafe fn next_state_untagged_unchecked(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &Cache,
      .          .          .          .                   current: LazyStateID,
      .          .          .          .                   input: u8,
      .          .          .          .               ) -> LazyStateID {
      .          .          .          .                   debug_assert!(!current.is_tagged());
      .          .          .          .                   let class = usize::from(self.classes.get(input));
    280 ( 0.00%) .          .          .                   let offset = current.as_usize_unchecked() + class;
    313 ( 0.00%) .          .          .                   *cache.trans.get_unchecked(offset)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Transitions from the current state to the next state for the special
      .          .          .          .               /// EOI symbol.
      .          .          .          .               ///
      .          .          .          .               /// The given cache is used to either reuse pre-computed state
      .          .          .          .               /// transitions, or to store this newly computed transition for future
      .          .          .          .               /// reuse. Thus, this routine guarantees that it will never return a state
-- line 1432 ----------------------------------------
-- line 1551 ----------------------------------------
      .          .          .          .               /// error if the given configuration contains an unsupported [`Anchored`]
      .          .          .          .               /// configuration.
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               pub fn start_state(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   config: &start::Config,
      .          .          .          .               ) -> Result<LazyStateID, StartError> {
    135 ( 0.00%) .          .          .                   let lazy = LazyRef::new(self, cache);
      .          .          .          .                   let anchored = config.get_anchored();
      .          .          .          .                   let start = match config.get_look_behind() {
      .          .          .          .                       None => Start::Text,
      .          .          .          .                       Some(byte) => {
      .          .          .          .                           if !self.quitset.is_empty() && self.quitset.contains(byte) {
      .          .          .          .                               return Err(StartError::quit(byte));
      .          .          .          .                           }
      .          .          .          .                           self.start_map.get(byte)
      .          .          .          .                       }
      .          .          .          .                   };
      .          .          .          .                   let start_id = lazy.get_cached_start_id(anchored, start)?;
     45 ( 0.00%) .          .          .                   if !start_id.is_unknown() {
      .          .          .          .                       return Ok(start_id);
      .          .          .          .                   }
    498 ( 0.00%) .          .          .                   Lazy::new(self, cache).cache_start_group(anchored, start)
125,437 ( 0.04%) 189 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the ID of the start state for this lazy DFA when executing a
      .          .          .          .               /// forward search.
      .          .          .          .               ///
      .          .          .          .               /// This is a convenience routine for calling [`DFA::start_state`] that
      .          .          .          .               /// converts the given [`Input`] to a [start configuration](start::Config).
      .          .          .          .               /// Additionally, if an error occurs, it is converted from a [`StartError`]
-- line 1582 ----------------------------------------
-- line 1744 ----------------------------------------
      .          .          .          .                   id: LazyStateID,
      .          .          .          .                   match_index: usize,
      .          .          .          .               ) -> PatternID {
      .          .          .          .                   // This is an optimization for the very common case of a DFA with a
      .          .          .          .                   // single pattern. This conditional avoids a somewhat more costly path
      .          .          .          .                   // that finds the pattern ID from the corresponding `State`, which
      .          .          .          .                   // requires a bit of slicing/pointer-chasing. This optimization tends
      .          .          .          .                   // to only matter when matches are frequent.
     10 ( 0.00%) .          .          .                   if self.pattern_len() == 1 {
      .          .          .          .                       return PatternID::ZERO;
      .          .          .          .                   }
      .          .          .          .                   LazyRef::new(self, cache)
      .          .          .          .                       .get_cached_state(id)
      .          .          .          .                       .match_pattern(match_index)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
-- line 1760 ----------------------------------------
-- line 1868 ----------------------------------------
      .          .          .          .           
      .          .          .          .           impl Cache {
      .          .          .          .               /// Create a new cache for the given lazy DFA.
      .          .          .          .               ///
      .          .          .          .               /// The cache returned should only be used for searches for the given DFA.
      .          .          .          .               /// If you want to reuse the cache for another DFA, then you must call
      .          .          .          .               /// [`Cache::reset`] with that DFA.
      .          .          .          .               pub fn new(dfa: &DFA) -> Cache {
  2,170 ( 0.00%) .          .          .                   let mut cache = Cache {
      .          .          .          .                       trans: alloc::vec![],
      .          .          .          .                       starts: alloc::vec![],
      .          .          .          .                       states: alloc::vec![],
      .          .          .          .                       states_to_id: StateMap::new(),
    117 ( 0.00%) .          .          .                       sparses: SparseSets::new(dfa.get_nfa().states().len()),
388,845 ( 0.11%) 486 ( 0.06%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/sparse_set.rs:regex_automata::util::sparse_set::SparseSets::new (106x)
      .          .          .          .                       stack: alloc::vec![],
      .          .          .          .                       scratch_state_builder: StateBuilderEmpty::new(),
      .          .          .          .                       state_saver: StateSaver::none(),
      .          .          .          .                       memory_usage_state: 0,
      .          .          .          .                       clear_count: 0,
      .          .          .          .                       bytes_searched: 0,
      .          .          .          .                       progress: None,
      .          .          .          .                   };
      .          .          .          .                   debug!("pre-init lazy DFA cache size: {}", cache.memory_usage());
    532 ( 0.00%) .          .          .                   Lazy { dfa, cache: &mut cache }.init_cache();
2,150,787 ( 0.62%) 1,397 ( 0.17%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::init_cache (106x)
      .          .          .          .                   debug!("post-init lazy DFA cache size: {}", cache.memory_usage());
    691 ( 0.00%) .          .          .                   cache
  6,890 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (106x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Reset this cache such that it can be used for searching with the given
      .          .          .          .               /// lazy DFA (and only that DFA).
      .          .          .          .               ///
      .          .          .          .               /// A cache reset permits reusing memory already allocated in this cache
      .          .          .          .               /// with a different lazy DFA.
      .          .          .          .               ///
-- line 1901 ----------------------------------------
-- line 1949 ----------------------------------------
      .          .          .          .               /// Note that keeping track of search progress is _not necessary_
      .          .          .          .               /// for correct implementations of search using a lazy DFA. Keeping
      .          .          .          .               /// track of search progress is only necessary if you want the
      .          .          .          .               /// [`Config::minimum_bytes_per_state`] configuration knob to work.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn search_start(&mut self, at: usize) {
      .          .          .          .                   // If a previous search wasn't marked as finished, then finish it
      .          .          .          .                   // now automatically.
     88 ( 0.00%) .          .          .                   if let Some(p) = self.progress.take() {
      .          .          .          .                       self.bytes_searched += p.len();
      .          .          .          .                   }
    132 ( 0.00%) .          .          .                   self.progress = Some(SearchProgress { start: at, at });
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Updates the current search to indicate that it has search to the
      .          .          .          .               /// current position.
      .          .          .          .               ///
      .          .          .          .               /// No special care needs to be taken for reverse searches. Namely, the
      .          .          .          .               /// position given may be _less than_ the starting position of the search.
      .          .          .          .               ///
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// This panics if no search has been started by [`Cache::search_start`].
      .          .          .          .               #[inline]
      .          .          .          .               pub fn search_update(&mut self, at: usize) {
      .          .          .          .                   let p =
      .          .          .          .                       self.progress.as_mut().expect("no in-progress search to update");
    221 ( 0.00%) .          .          .                   p.at = at;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Indicates that a search has finished at the given position.
      .          .          .          .               ///
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// This panics if no search has been started by [`Cache::search_start`].
      .          .          .          .               #[inline]
      .          .          .          .               pub fn search_finish(&mut self, at: usize) {
      .          .          .          .                   let mut p =
      .          .          .          .                       self.progress.take().expect("no in-progress search to finish");
      .          .          .          .                   p.at = at;
     44 ( 0.00%) .          .          .                   self.bytes_searched += p.len();
     44 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the total number of bytes that have been searched since this
      .          .          .          .               /// cache was last cleared.
      .          .          .          .               ///
      .          .          .          .               /// This is useful for determining the efficiency of the cache. For
      .          .          .          .               /// example, the lazy DFA uses this value in conjunction with the
      .          .          .          .               /// [`Config::minimum_bytes_per_state`] knob to help determine whether it
      .          .          .          .               /// should quit searching.
-- line 1998 ----------------------------------------
-- line 2020 ----------------------------------------
      .          .          .          .               /// compute that, use `std::mem::size_of::<Cache>()`.
      .          .          .          .               pub fn memory_usage(&self) -> usize {
      .          .          .          .                   const ID_SIZE: usize = size_of::<LazyStateID>();
      .          .          .          .                   const STATE_SIZE: usize = size_of::<State>();
      .          .          .          .           
      .          .          .          .                   // NOTE: If you make changes to the below, then
      .          .          .          .                   // 'minimum_cache_capacity' should be updated correspondingly.
      .          .          .          .           
  4,388 ( 0.00%) .          .          .                   self.trans.len() * ID_SIZE
      .          .          .          .                   + self.starts.len() * ID_SIZE
  1,568 ( 0.00%) .          .          .                   + self.states.len() * STATE_SIZE
      .          .          .          .                   // Maps likely use more memory than this, but it's probably close.
    784 ( 0.00%) .          .          .                   + self.states_to_id.len() * (STATE_SIZE + ID_SIZE)
      .          .          .          .                   + self.sparses.memory_usage()
      .          .          .          .                   + self.stack.capacity() * ID_SIZE
      .          .          .          .                   + self.scratch_state_builder.capacity()
      .          .          .          .                   // Heap memory used by 'State' in both 'states' and 'states_to_id'.
      .          .          .          .                   + self.memory_usage_state
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
-- line 2040 ----------------------------------------
-- line 2051 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl SearchProgress {
      .          .          .          .               /// Returns the length, in bytes, of this search so far.
      .          .          .          .               ///
      .          .          .          .               /// This automatically handles the case of a reverse search, where `at`
      .          .          .          .               /// is likely to be less than `start`.
      .          .          .          .               fn len(&self) -> usize {
    220 ( 0.00%) .          .          .                   if self.start <= self.at {
      .          .          .          .                       self.at - self.start
      .          .          .          .                   } else {
      .          .          .          .                       self.start - self.at
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A map from states to state identifiers. When using std, we use a standard
-- line 2067 ----------------------------------------
-- line 2111 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// Where 'all-codepoints-utf8-100x' is the UTF-8 encoding of every
      .          .          .          .               /// codepoint, in sequence, repeated 100 times.
      .          .          .          .               ///
      .          .          .          .               /// With 'inline(never)' hyperfine reports 1.1s per run. With
      .          .          .          .               /// 'inline(always)', hyperfine reports 1.23s. So that's a 10% improvement.
      .          .          .          .               #[cold]
      .          .          .          .               #[inline(never)]
  1,744 ( 0.00%) .          .          .               fn cache_next_state(
      .          .          .          .                   &mut self,
      .          .          .          .                   mut current: LazyStateID,
      .          .          .          .                   unit: alphabet::Unit,
      .          .          .          .               ) -> Result<LazyStateID, CacheError> {
    436 ( 0.00%) .          .          .                   let stride2 = self.dfa.stride2();
    218 ( 0.00%) .          .          .                   let empty_builder = self.get_state_builder();
    872 ( 0.00%) .          .          .                   let builder = determinize::next(
154,889 ( 0.04%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::next (218x)
      .          .          .          .                       self.dfa.get_nfa(),
      .          .          .          .                       self.dfa.get_config().get_match_kind(),
    218 ( 0.00%) .          .          .                       &mut self.cache.sparses,
    218 ( 0.00%) .          .          .                       &mut self.cache.stack,
    872 ( 0.00%) .          .          .                       &self.cache.states[current.as_usize_untagged() >> stride2],
      .          .          .          .                       unit,
  1,308 ( 0.00%) .          .          .                       empty_builder,
      .          .          .          .                   );
      .          .          .          .                   let save_state = !self.as_ref().state_builder_fits_in_cache(&builder);
    218 ( 0.00%) .          .          .                   if save_state {
      .          .          .          .                       self.save_state(current);
      .          .          .          .                   }
  1,002 ( 0.00%) .          .          .                   let next = self.add_builder_state(builder, |sid| sid)?;
    218 ( 0.00%) .          .          .                   if save_state {
      .          .          .          .                       current = self.saved_state_id();
      .          .          .          .                   }
      .          .          .          .                   // This is the payoff. The next time 'next_state' is called with this
      .          .          .          .                   // state and alphabet unit, it will find this transition and avoid
      .          .          .          .                   // having to re-determinize this transition.
  1,090 ( 0.00%) .          .          .                   self.set_transition(current, unit, next);
  7,194 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::set_transition (218x)
      .          .          .          .                   Ok(next)
  2,180 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compute and cache the starting state for the given pattern ID (if
      .          .          .          .               /// present) and the starting configuration.
      .          .          .          .               ///
      .          .          .          .               /// This panics if a pattern ID is given and the DFA isn't configured to
      .          .          .          .               /// build anchored start states for each pattern.
      .          .          .          .               ///
      .          .          .          .               /// This will never return an unknown lazy state ID.
      .          .          .          .               ///
      .          .          .          .               /// If caching this state would otherwise result in a cache that has been
      .          .          .          .               /// cleared too many times, then an error is returned.
      .          .          .          .               #[cold]
      .          .          .          .               #[inline(never)]
    328 ( 0.00%) .          .          .               fn cache_start_group(
      .          .          .          .                   &mut self,
      .          .          .          .                   anchored: Anchored,
      .          .          .          .                   start: Start,
      .          .          .          .               ) -> Result<LazyStateID, StartError> {
     82 ( 0.00%) .          .          .                   let nfa_start_id = match anchored {
     82 ( 0.00%) .          .          .                       Anchored::No => self.dfa.get_nfa().start_unanchored(),
      .          .          .          .                       Anchored::Yes => self.dfa.get_nfa().start_anchored(),
      .          .          .          .                       Anchored::Pattern(pid) => {
      .          .          .          .                           if !self.dfa.get_config().get_starts_for_each_pattern() {
      .          .          .          .                               return Err(StartError::unsupported_anchored(anchored));
      .          .          .          .                           }
      .          .          .          .                           match self.dfa.get_nfa().start_pattern(pid) {
      .          .          .          .                               None => return Ok(self.as_ref().dead_id()),
      .          .          .          .                               Some(sid) => sid,
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   };
      .          .          .          .           
      .          .          .          .                   let id = self
      .          .          .          .                       .cache_start_one(nfa_start_id, start)
      .          .          .          .                       .map_err(StartError::cache)?;
     82 ( 0.00%) .          .          .                   self.set_start_state(anchored, start, id);
      .          .          .          .                   Ok(id)
    451 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compute and cache the starting state for the given NFA state ID and the
      .          .          .          .               /// starting configuration. The NFA state ID might be one of the following:
      .          .          .          .               ///
      .          .          .          .               /// 1) An unanchored start state to match any pattern.
      .          .          .          .               /// 2) An anchored start state to match any pattern.
      .          .          .          .               /// 3) An anchored start state for a particular pattern.
      .          .          .          .               ///
-- line 2194 ----------------------------------------
-- line 2196 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// If caching this state would otherwise result in a cache that has been
      .          .          .          .               /// cleared too many times, then an error is returned.
      .          .          .          .               fn cache_start_one(
      .          .          .          .                   &mut self,
      .          .          .          .                   nfa_start_id: NFAStateID,
      .          .          .          .                   start: Start,
      .          .          .          .               ) -> Result<LazyStateID, CacheError> {
     41 ( 0.00%) .          .          .                   let mut builder_matches = self.get_state_builder().into_matches();
     82 ( 0.00%) .          .          .                   determinize::set_lookbehind_from_start(
  1,378 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::set_lookbehind_from_start (41x)
      .          .          .          .                       self.dfa.get_nfa(),
      .          .          .          .                       &start,
      .          .          .          .                       &mut builder_matches,
      .          .          .          .                   );
      .          .          .          .                   self.cache.sparses.set1.clear();
    164 ( 0.00%) .          .          .                   determinize::epsilon_closure(
 37,318 ( 0.01%) 14 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::epsilon_closure (41x)
      .          .          .          .                       self.dfa.get_nfa(),
      .          .          .          .                       nfa_start_id,
      .          .          .          .                       builder_matches.look_have(),
     41 ( 0.00%) .          .          .                       &mut self.cache.stack,
     41 ( 0.00%) .          .          .                       &mut self.cache.sparses.set1,
      .          .          .          .                   );
    123 ( 0.00%) .          .          .                   let mut builder = builder_matches.into_nfa();
    123 ( 0.00%) .          .          .                   determinize::add_nfa_states(
 39,809 ( 0.01%) 134 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::add_nfa_states (41x)
      .          .          .          .                       &self.dfa.get_nfa(),
      .          .          .          .                       &self.cache.sparses.set1,
      .          .          .          .                       &mut builder,
      .          .          .          .                   );
      .          .          .          .                   let tag_starts = self.dfa.get_config().get_specialize_start_states();
    205 ( 0.00%) .          .          .                   self.add_builder_state(builder, |id| {
     82 ( 0.00%) .          .          .                       if tag_starts {
      .          .          .          .                           id.to_start()
      .          .          .          .                       } else {
      .          .          .          .                           id
      .          .          .          .                       }
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Either add the given builder state to this cache, or return an ID to an
-- line 2234 ----------------------------------------
-- line 2242 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// If caching this state would otherwise result in a cache that has been
      .          .          .          .               /// cleared too many times, then an error is returned.
      .          .          .          .               fn add_builder_state(
      .          .          .          .                   &mut self,
      .          .          .          .                   builder: StateBuilderNFA,
      .          .          .          .                   idmap: impl Fn(LazyStateID) -> LazyStateID,
      .          .          .          .               ) -> Result<LazyStateID, CacheError> {
     44 ( 0.00%) .          .          .                   if let Some(&cached_id) =
      .          .          .          .                       self.cache.states_to_id.get(builder.as_bytes())
      .          .          .          .                   {
      .          .          .          .                       // Since we have a cached state, put the constructed state's
      .          .          .          .                       // memory back into our scratch space, so that it can be reused.
      .          .          .          .                       self.put_state_builder(builder);
      .          .          .          .                       return Ok(cached_id);
      .          .          .          .                   }
      .          .          .          .                   let result = self.add_state(builder.to_state(), idmap);
-- line 2258 ----------------------------------------
-- line 2270 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// If caching this state would otherwise result in a cache that has been
      .          .          .          .               /// cleared too many times, then an error is returned.
      .          .          .          .               fn add_state(
      .          .          .          .                   &mut self,
      .          .          .          .                   state: State,
      .          .          .          .                   idmap: impl Fn(LazyStateID) -> LazyStateID,
      .          .          .          .               ) -> Result<LazyStateID, CacheError> {
    566 ( 0.00%) .          .          .                   if !self.as_ref().state_fits_in_cache(&state) {
      .          .          .          .                       self.try_clear_cache()?;
      .          .          .          .                   }
      .          .          .          .                   // It's important for this to come second, since the above may clear
      .          .          .          .                   // the cache. If we clear the cache after ID generation, then the ID
      .          .          .          .                   // is likely bunk since it would have been generated based on a larger
      .          .          .          .                   // transition table.
    860 ( 0.00%) .          .          .                   let mut id = idmap(self.next_state_id()?);
    451 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::next_state_id (41x)
  1,619 ( 0.00%) .          .          .                   if state.is_match() {
      .          .          .          .                       id = id.to_match();
      .          .          .          .                   }
      .          .          .          .                   // Add room in the transition table. Since this is a fresh state, all
      .          .          .          .                   // of its transitions are unknown.
      .          .          .          .                   self.cache.trans.extend(
    566 ( 0.00%) .          .          .                       iter::repeat(self.as_ref().unknown_id()).take(self.dfa.stride()),
      .          .          .          .                   );
      .          .          .          .                   // When we add a sentinel state, we never want to set any quit
      .          .          .          .                   // transitions. Technically, this is harmless, since sentinel states
      .          .          .          .                   // have all of their transitions set to loop back to themselves. But
      .          .          .          .                   // when creating sentinel states before the quit sentinel state,
      .          .          .          .                   // this will try to call 'set_transition' on a state ID that doesn't
      .          .          .          .                   // actually exist yet, which isn't allowed. So we just skip doing so
      .          .          .          .                   // entirely.
    566 ( 0.00%) .          .          .                   if !self.dfa.quitset.is_empty() && !self.as_ref().is_sentinel(id) {
      .          .          .          .                       let quit_id = self.as_ref().quit_id();
      .          .          .          .                       for b in self.dfa.quitset.iter() {
      .          .          .          .                           self.set_transition(id, alphabet::Unit::u8(b), quit_id);
      .          .          .          .                       }
      .          .          .          .                   }
    566 ( 0.00%) .          .          .                   self.cache.memory_usage_state += state.memory_usage();
    117 ( 0.00%) .          .          .                   self.cache.states.push(state.clone());
  1,132 ( 0.00%) .          .          .                   self.cache.states_to_id.insert(state, id);
      .          .          .          .                   Ok(id)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Allocate a new state ID.
      .          .          .          .               ///
      .          .          .          .               /// This will never return an unknown lazy state ID.
      .          .          .          .               ///
      .          .          .          .               /// If caching this state would otherwise result in a cache that has been
      .          .          .          .               /// cleared too many times, then an error is returned.
    430 ( 0.00%) .          .          .               fn next_state_id(&mut self) -> Result<LazyStateID, CacheError> {
    215 ( 0.00%) .          .          .                   let sid = match LazyStateID::new(self.cache.trans.len()) {
      .          .          .          .                       Ok(sid) => sid,
      .          .          .          .                       Err(_) => {
      .          .          .          .                           self.try_clear_cache()?;
      .          .          .          .                           // This has to pass since we check that ID capacity at
      .          .          .          .                           // construction time can fit at least MIN_STATES states.
      .          .          .          .                           LazyStateID::new(self.cache.trans.len()).unwrap()
      .          .          .          .                       }
      .          .          .          .                   };
      .          .          .          .                   Ok(sid)
    860 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Attempt to clear the cache used by this lazy DFA.
      .          .          .          .               ///
      .          .          .          .               /// If clearing the cache exceeds the minimum number of required cache
      .          .          .          .               /// clearings, then this will return a cache error. In this case,
      .          .          .          .               /// callers should bubble this up as the cache can't be used until it is
      .          .          .          .               /// reset. Implementations of search should convert this error into a
      .          .          .          .               /// [`MatchError::gave_up`].
-- line 2338 ----------------------------------------
-- line 2497 ----------------------------------------
      .          .          .          .               /// Initialize this cache from emptiness to a place where it can be used
      .          .          .          .               /// for search.
      .          .          .          .               ///
      .          .          .          .               /// This is called both at cache creation time and after the cache has been
      .          .          .          .               /// cleared.
      .          .          .          .               ///
      .          .          .          .               /// Primarily, this adds the three sentinel states and allocates some
      .          .          .          .               /// initial memory.
    936 ( 0.00%) .          .          .               fn init_cache(&mut self) {
      .          .          .          .                   // Why multiply by 2 here? Because we make room for both the unanchored
      .          .          .          .                   // and anchored start states. Unanchored is first and then anchored.
      .          .          .          .                   let mut starts_len = Start::len().checked_mul(2).unwrap();
      .          .          .          .                   // ... but if we also want start states for every pattern, we make room
      .          .          .          .                   // for that too.
    234 ( 0.00%) .          .          .                   if self.dfa.get_config().get_starts_for_each_pattern() {
    212 ( 0.00%) .          .          .                       starts_len += Start::len() * self.dfa.pattern_len();
      .          .          .          .                   }
    117 ( 0.00%) .          .          .                   self.cache
      .          .          .          .                       .starts
      .          .          .          .                       .extend(iter::repeat(self.as_ref().unknown_id()).take(starts_len));
      .          .          .          .                   // This is the set of NFA states that corresponds to each of our three
      .          .          .          .                   // sentinel states: the empty set.
    117 ( 0.00%) .          .          .                   let dead = State::dead();
 41,862 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/state.rs:regex_automata::util::determinize::state::State::dead (117x)
      .          .          .          .                   // This sets up some states that we use as sentinels that are present
      .          .          .          .                   // in every DFA. While it would be technically possible to implement
      .          .          .          .                   // this DFA without explicitly putting these states in the transition
      .          .          .          .                   // table, this is convenient to do to make `next_state` correct for all
      .          .          .          .                   // valid state IDs without needing explicit conditionals to special
      .          .          .          .                   // case these sentinel states.
      .          .          .          .                   //
      .          .          .          .                   // All three of these states are "dead" states. That is, all of
      .          .          .          .                   // them transition only to themselves. So once you enter one of
      .          .          .          .                   // these states, it's impossible to leave them. Thus, any correct
      .          .          .          .                   // search routine must explicitly check for these state types. (Sans
      .          .          .          .                   // `unknown`, since that is only used internally to represent missing
      .          .          .          .                   // states.)
      .          .          .          .                   let unk_id =
    117 ( 0.00%) .          .          .                       self.add_state(dead.clone(), |id| id.to_unknown()).unwrap();
    117 ( 0.00%) .          .          .                   let dead_id = self.add_state(dead.clone(), |id| id.to_dead()).unwrap();
    117 ( 0.00%) .          .          .                   let quit_id = self.add_state(dead.clone(), |id| id.to_quit()).unwrap();
    234 ( 0.00%) .          .          .                   assert_eq!(unk_id, self.as_ref().unknown_id());
    234 ( 0.00%) .          .          .                   assert_eq!(dead_id, self.as_ref().dead_id());
    234 ( 0.00%) .          .          .                   assert_eq!(quit_id, self.as_ref().quit_id());
      .          .          .          .                   // The idea here is that if you start in an unknown/dead/quit state and
      .          .          .          .                   // try to transition on them, then you should end up where you started.
      .          .          .          .                   self.set_all_transitions(unk_id, unk_id);
      .          .          .          .                   self.set_all_transitions(dead_id, dead_id);
      .          .          .          .                   self.set_all_transitions(quit_id, quit_id);
      .          .          .          .                   // All of these states are technically equivalent from the FSM
      .          .          .          .                   // perspective, so putting all three of them in the cache isn't
      .          .          .          .                   // possible. (They are distinct merely because we use their
-- line 2547 ----------------------------------------
-- line 2577 ----------------------------------------
      .          .          .          .                   self.cache
      .          .          .          .                       .state_saver
      .          .          .          .                       .take_saved()
      .          .          .          .                       .expect("state saver does not have saved state ID")
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set all transitions on the state 'from' to 'to'.
      .          .          .          .               fn set_all_transitions(&mut self, from: LazyStateID, to: LazyStateID) {
 89,505 ( 0.03%) .          .          .                   for unit in self.dfa.classes.representatives(..) {
134,478 ( 0.04%) .          .          .                       self.set_transition(from, unit, to);
738,576 ( 0.21%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::set_transition (22,413x)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the transition on 'from' for 'unit' to 'to'.
      .          .          .          .               ///
      .          .          .          .               /// This panics if either 'from' or 'to' is invalid.
      .          .          .          .               ///
      .          .          .          .               /// All unit values are OK.
 67,893 ( 0.02%) .          .          .               fn set_transition(
      .          .          .          .                   &mut self,
      .          .          .          .                   from: LazyStateID,
      .          .          .          .                   unit: alphabet::Unit,
      .          .          .          .                   to: LazyStateID,
      .          .          .          .               ) {
 22,631 ( 0.01%) .          .          .                   assert!(self.as_ref().is_valid(from), "invalid 'from' id: {:?}", from);
      .          .          .          .                   assert!(self.as_ref().is_valid(to), "invalid 'to' id: {:?}", to);
      .          .          .          .                   let offset =
 22,631 ( 0.01%) .          .          .                       from.as_usize_untagged() + self.dfa.classes.get_by_unit(unit);
 45,262 ( 0.01%) .          .          .                   self.cache.trans[offset] = to;
 45,262 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the start ID for the given pattern ID (if given) and starting
      .          .          .          .               /// configuration to the ID given.
      .          .          .          .               ///
      .          .          .          .               /// This panics if 'id' is not valid or if a pattern ID is given and
      .          .          .          .               /// 'starts_for_each_pattern' is not enabled.
      .          .          .          .               fn set_start_state(
      .          .          .          .                   &mut self,
      .          .          .          .                   anchored: Anchored,
      .          .          .          .                   start: Start,
      .          .          .          .                   id: LazyStateID,
      .          .          .          .               ) {
     41 ( 0.00%) .          .          .                   assert!(self.as_ref().is_valid(id));
      .          .          .          .                   let start_index = start.as_usize();
     82 ( 0.00%) .          .          .                   let index = match anchored {
      .          .          .          .                       Anchored::No => start_index,
      .          .          .          .                       Anchored::Yes => Start::len() + start_index,
      .          .          .          .                       Anchored::Pattern(pid) => {
      .          .          .          .                           assert!(
      .          .          .          .                               self.dfa.get_config().get_starts_for_each_pattern(),
      .          .          .          .                               "attempted to search for a specific pattern \
      .          .          .          .                                without enabling starts_for_each_pattern",
      .          .          .          .                           );
      .          .          .          .                           let pid = pid.as_usize();
      .          .          .          .                           (2 * Start::len()) + (Start::len() * pid) + start_index
      .          .          .          .                       }
      .          .          .          .                   };
    123 ( 0.00%) .          .          .                   self.cache.starts[index] = id;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a state builder from this DFA that might have existing
      .          .          .          .               /// capacity. This helps avoid allocs in cases where a state is built that
      .          .          .          .               /// turns out to already be cached.
      .          .          .          .               ///
      .          .          .          .               /// Callers must put the state builder back with 'put_state_builder',
      .          .          .          .               /// otherwise the allocation reuse won't work.
-- line 2642 ----------------------------------------
-- line 2679 ----------------------------------------
      .          .          .          .               /// unknown lazy state ID.
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn get_cached_start_id(
      .          .          .          .                   &self,
      .          .          .          .                   anchored: Anchored,
      .          .          .          .                   start: Start,
      .          .          .          .               ) -> Result<LazyStateID, StartError> {
      .          .          .          .                   let start_index = start.as_usize();
    135 ( 0.00%) .          .          .                   let index = match anchored {
      .          .          .          .                       Anchored::No => start_index,
      .          .          .          .                       Anchored::Yes => Start::len() + start_index,
      .          .          .          .                       Anchored::Pattern(pid) => {
      .          .          .          .                           if !self.dfa.get_config().get_starts_for_each_pattern() {
      .          .          .          .                               return Err(StartError::unsupported_anchored(anchored));
      .          .          .          .                           }
      .          .          .          .                           if pid.as_usize() >= self.dfa.pattern_len() {
      .          .          .          .                               return Ok(self.dead_id());
      .          .          .          .                           }
      .          .          .          .                           (2 * Start::len())
      .          .          .          .                               + (Start::len() * pid.as_usize())
      .          .          .          .                               + start_index
      .          .          .          .                       }
      .          .          .          .                   };
    135 ( 0.00%) .          .          .                   Ok(self.cache.starts[index])
     45 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the cached NFA/DFA powerset state for the given ID.
      .          .          .          .               ///
      .          .          .          .               /// This panics if the given ID does not address a valid state.
      .          .          .          .               fn get_cached_state(&self, sid: LazyStateID) -> &State {
      .          .          .          .                   let index = sid.as_usize_untagged() >> self.dfa.stride2();
      .          .          .          .                   &self.cache.states[index]
      .          .          .          .               }
-- line 2711 ----------------------------------------
-- line 2730 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the ID of the dead state for this lazy DFA.
      .          .          .          .               fn dead_id(&self) -> LazyStateID {
      .          .          .          .                   // This unwrap is OK since the maximum value here is 1 * 512 = 512,
      .          .          .          .                   // which is <= 2047 (the maximum state ID on 16-bit systems). Where
      .          .          .          .                   // 512 is the worst case for our equivalence classes (every byte is a
      .          .          .          .                   // distinct class).
    468 ( 0.00%) .          .          .                   LazyStateID::new(1 << self.dfa.stride2()).unwrap().to_dead()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the ID of the quit state for this lazy DFA.
      .          .          .          .               fn quit_id(&self) -> LazyStateID {
      .          .          .          .                   // This unwrap is OK since the maximum value here is 2 * 512 = 1024,
      .          .          .          .                   // which is <= 2047 (the maximum state ID on 16-bit systems). Where
      .          .          .          .                   // 512 is the worst case for our equivalence classes (every byte is a
      .          .          .          .                   // distinct class).
    117 ( 0.00%) .          .          .                   LazyStateID::new(2 << self.dfa.stride2()).unwrap().to_quit()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if the given ID is valid.
      .          .          .          .               ///
      .          .          .          .               /// An ID is valid if it is both a valid index into the transition table
      .          .          .          .               /// and is a multiple of the DFA's stride.
      .          .          .          .               fn is_valid(&self, id: LazyStateID) -> bool {
      .          .          .          .                   let id = id.as_usize_untagged();
203,966 ( 0.06%) .          .          .                   id < self.cache.trans.len() && id % self.dfa.stride() == 0
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if adding the state given would fit in this cache.
      .          .          .          .               fn state_fits_in_cache(&self, state: &State) -> bool {
    781 ( 0.00%) .          .          .                   let needed = self.cache.memory_usage()
      .          .          .          .                       + self.memory_usage_for_one_more_state(state.memory_usage());
      .          .          .          .                   trace!(
      .          .          .          .                       "lazy DFA cache capacity check: {:?} ?<=? {:?}",
      .          .          .          .                       needed,
      .          .          .          .                       self.dfa.cache_capacity
      .          .          .          .                   );
    781 ( 0.00%) .          .          .                   needed <= self.dfa.cache_capacity
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if adding the state to be built by the given builder would
      .          .          .          .               /// fit in this cache.
      .          .          .          .               fn state_builder_fits_in_cache(&self, state: &StateBuilderNFA) -> bool {
    872 ( 0.00%) .          .          .                   let needed = self.cache.memory_usage()
      .          .          .          .                       + self.memory_usage_for_one_more_state(state.as_bytes().len());
    872 ( 0.00%) .          .          .                   needed <= self.dfa.cache_capacity
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the additional memory usage, in bytes, required to add one more
      .          .          .          .               /// state to this cache. The given size should be the heap size, in bytes,
      .          .          .          .               /// that would be used by the new state being added.
      .          .          .          .               fn memory_usage_for_one_more_state(
      .          .          .          .                   &self,
      .          .          .          .                   state_heap_size: usize,
      .          .          .          .               ) -> usize {
      .          .          .          .                   const ID_SIZE: usize = size_of::<LazyStateID>();
      .          .          .          .                   const STATE_SIZE: usize = size_of::<State>();
      .          .          .          .           
  3,351 ( 0.00%) .          .          .                   self.dfa.stride() * ID_SIZE // additional space needed in trans table
      .          .          .          .                   + STATE_SIZE // space in cache.states
      .          .          .          .                   + (STATE_SIZE + ID_SIZE) // space in cache.states_to_id
      .          .          .          .                   + state_heap_size // heap memory used by state itself
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A simple type that encapsulates the saving of a state ID through a cache
      .          .          .          .           /// clearing.
-- line 2797 ----------------------------------------
-- line 2854 ----------------------------------------
      .          .          .          .           ///
      .          .          .          .           /// A lazy DFA configuration is a simple data object that is typically used
      .          .          .          .           /// with [`Builder::configure`].
      .          .          .          .           ///
      .          .          .          .           /// The default configuration guarantees that a search will never return a
      .          .          .          .           /// "gave up" or "quit" error, although it is possible for a search to fail
      .          .          .          .           /// if [`Config::starts_for_each_pattern`] wasn't enabled (which it is not by
      .          .          .          .           /// default) and an [`Anchored::Pattern`] mode is requested via [`Input`].
  2,887 ( 0.00%) .          .          .           #[derive(Clone, Debug, Default)]
      .          .          .          .           pub struct Config {
      .          .          .          .               // As with other configuration types in this crate, we put all our knobs
      .          .          .          .               // in options so that we can distinguish between "default" and "not set."
      .          .          .          .               // This makes it possible to easily combine multiple configurations
      .          .          .          .               // without default values overwriting explicitly specified values. See the
      .          .          .          .               // 'overwrite' method.
      .          .          .          .               //
      .          .          .          .               // For docs on the fields below, see the corresponding method setters.
-- line 2870 ----------------------------------------
-- line 2992 ----------------------------------------
      .          .          .          .               /// let got_rev = dfa_rev.try_search_rev(&mut cache_rev, &input)?.unwrap();
      .          .          .          .               /// assert_eq!(expected_fwd, got_fwd);
      .          .          .          .               /// assert_eq!(expected_rev, got_rev);
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn match_kind(mut self, kind: MatchKind) -> Config {
      .          .          .          .                   self.match_kind = Some(kind);
  1,944 ( 0.00%) .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set a prefilter to be used whenever a start state is entered.
      .          .          .          .               ///
      .          .          .          .               /// A [`Prefilter`] in this context is meant to accelerate searches by
      .          .          .          .               /// looking for literal prefixes that every match for the corresponding
      .          .          .          .               /// pattern (or patterns) must start with. Once a prefilter produces a
      .          .          .          .               /// match, the underlying search routine continues on to try and confirm
-- line 3008 ----------------------------------------
-- line 3067 ----------------------------------------
      .          .          .          .               ///     // No match reported even though there clearly is one!
      .          .          .          .               ///     None,
      .          .          .          .               ///     re.try_search_fwd(&mut cache, &input)?,
      .          .          .          .               /// );
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn prefilter(mut self, pre: Option<Prefilter>) -> Config {
  1,458 ( 0.00%) .          .          .                   self.pre = Some(pre);
    162 ( 0.00%) .          .          .                   if self.specialize_start_states.is_none() {
     81 ( 0.00%) .          .          .                       self.specialize_start_states =
      .          .          .          .                           Some(self.get_prefilter().is_some());
      .          .          .          .                   }
  3,516 ( 0.00%) .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Whether to compile a separate start state for each pattern in the
      .          .          .          .               /// lazy DFA.
      .          .          .          .               ///
      .          .          .          .               /// When enabled, a separate **anchored** start state is added for each
      .          .          .          .               /// pattern in the lazy DFA. When this start state is used, then the DFA
      .          .          .          .               /// will only search for matches for the pattern specified, even if there
-- line 3088 ----------------------------------------
-- line 3442 ----------------------------------------
      .          .          .          .               /// // Start states are not tagged in the default configuration!
      .          .          .          .               /// assert!(!sid.is_tagged());
      .          .          .          .               /// assert!(!sid.is_start());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn specialize_start_states(mut self, yes: bool) -> Config {
      .          .          .          .                   self.specialize_start_states = Some(yes);
    567 ( 0.00%) .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets the maximum amount of heap memory, in bytes, to allocate to the
      .          .          .          .               /// cache for use during a lazy DFA search. If the lazy DFA would otherwise
      .          .          .          .               /// use more heap memory, then, depending on other configuration knobs,
      .          .          .          .               /// either stop the search and return an error or clear the cache and
      .          .          .          .               /// continue the search.
      .          .          .          .               ///
-- line 3458 ----------------------------------------
-- line 3703 ----------------------------------------
      .          .          .          .               /// called.
      .          .          .          .               /// * Call [`Cache::search_finish`] before completing a search. (It is
      .          .          .          .               /// not strictly necessary to call this when an error is returned, as
      .          .          .          .               /// `Cache::search_start` will automatically finish the previous search
      .          .          .          .               /// for you. But calling it where possible before returning helps improve
      .          .          .          .               /// the accuracy of how many bytes have actually been searched.)
      .          .          .          .               pub fn minimum_bytes_per_state(mut self, min: Option<usize>) -> Config {
      .          .          .          .                   self.minimum_bytes_per_state = Some(min);
  2,168 ( 0.00%) .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the match semantics set in this configuration.
      .          .          .          .               pub fn get_match_kind(&self) -> MatchKind {
      .          .          .          .                   self.match_kind.unwrap_or(MatchKind::LeftmostFirst)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the prefilter set in this configuration, if one at all.
-- line 3719 ----------------------------------------
-- line 3755 ----------------------------------------
      .          .          .          .               /// it's in a start state and do some kind of optimization (like run a
      .          .          .          .               /// prefilter).
      .          .          .          .               pub fn get_specialize_start_states(&self) -> bool {
      .          .          .          .                   self.specialize_start_states.unwrap_or(false)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the cache capacity set on this configuration.
      .          .          .          .               pub fn get_cache_capacity(&self) -> usize {
    175 ( 0.00%) .          .          .                   self.cache_capacity.unwrap_or(2 * (1 << 20))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns whether the cache capacity check should be skipped.
      .          .          .          .               pub fn get_skip_cache_capacity_check(&self) -> bool {
      .          .          .          .                   self.skip_cache_capacity_check.unwrap_or(false)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns, if set, the minimum number of times the cache must be cleared
-- line 3771 ----------------------------------------
-- line 3812 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// If byte classes are disabled on this configuration, then a map is
      .          .          .          .               /// returned that puts each byte in its own equivalent class.
      .          .          .          .               fn byte_classes_from_nfa(
      .          .          .          .                   &self,
      .          .          .          .                   nfa: &thompson::NFA,
      .          .          .          .                   quit: &ByteSet,
      .          .          .          .               ) -> ByteClasses {
    175 ( 0.00%) .          .          .                   if !self.get_byte_classes() {
      .          .          .          .                       // The lazy DFA will always use the equivalence class map, but
      .          .          .          .                       // enabling this option is useful for debugging. Namely, this will
      .          .          .          .                       // cause all transitions to be defined over their actual bytes
      .          .          .          .                       // instead of an opaque equivalence class identifier. The former is
      .          .          .          .                       // much easier to grok as a human.
      .          .          .          .                       ByteClasses::singletons()
      .          .          .          .                   } else {
      .          .          .          .                       let mut set = nfa.byte_class_set().clone();
-- line 3828 ----------------------------------------
-- line 3829 ----------------------------------------
      .          .          .          .                       // It is important to distinguish any "quit" bytes from all other
      .          .          .          .                       // bytes. Otherwise, a non-quit byte may end up in the same class
      .          .          .          .                       // as a quit byte, and thus cause the DFA stop when it shouldn't.
      .          .          .          .                       //
      .          .          .          .                       // Test case:
      .          .          .          .                       //
      .          .          .          .                       //   regex-cli find match hybrid --unicode-word-boundary \
      .          .          .          .                       //     -p '^#' -p '\b10\.55\.182\.100\b' -y @conn.json.1000x.log
    175 ( 0.00%) .          .          .                       if !quit.is_empty() {
      .          .          .          .                           set.add_set(&quit);
      .          .          .          .                       }
      .          .          .          .                       set.byte_classes()
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the quit set for this configuration and the given NFA.
      .          .          .          .               ///
-- line 3845 ----------------------------------------
-- line 3846 ----------------------------------------
      .          .          .          .               /// This may return an error if the NFA is incompatible with this
      .          .          .          .               /// configuration's quit set. For example, if the NFA has a Unicode word
      .          .          .          .               /// boundary and the quit set doesn't include non-ASCII bytes.
      .          .          .          .               fn quit_set_from_nfa(
      .          .          .          .                   &self,
      .          .          .          .                   nfa: &thompson::NFA,
      .          .          .          .               ) -> Result<ByteSet, BuildError> {
      .          .          .          .                   let mut quit = self.quitset.unwrap_or(ByteSet::empty());
    175 ( 0.00%) .          .          .                   if nfa.look_set_any().contains_word_unicode() {
      .          .          .          .                       if self.get_unicode_word_boundary() {
      .          .          .          .                           for b in 0x80..=0xFF {
      .          .          .          .                               quit.add(b);
      .          .          .          .                           }
      .          .          .          .                       } else {
      .          .          .          .                           // If heuristic support for Unicode word boundaries wasn't
      .          .          .          .                           // enabled, then we can still check if our quit set is correct.
      .          .          .          .                           // If the caller set their quit bytes in a way that causes the
-- line 3862 ----------------------------------------
-- line 3864 ----------------------------------------
      .          .          .          .                           // we need for heuristic support to work.
      .          .          .          .                           if !quit.contains_range(0x80, 0xFF) {
      .          .          .          .                               return Err(
      .          .          .          .                                   BuildError::unsupported_dfa_word_boundary_unicode(),
      .          .          .          .                               );
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
    350 ( 0.00%) .          .          .                   Ok(quit)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Overwrite the default configuration such that the options in `o` are
      .          .          .          .               /// always used. If an option in `o` is not set, then the corresponding
      .          .          .          .               /// option in `self` is used. If it's not set in `self` either, then it
      .          .          .          .               /// remains not set.
      .          .          .          .               fn overwrite(&self, o: Config) -> Config {
    700 ( 0.00%) .          .          .                   Config {
    175 ( 0.00%) .          .          .                       match_kind: o.match_kind.or(self.match_kind),
    525 ( 0.00%) .          .          .                       pre: o.pre.or_else(|| self.pre.clone()),
    175 ( 0.00%) .          .          .                       starts_for_each_pattern: o
      .          .          .          .                           .starts_for_each_pattern
      .          .          .          .                           .or(self.starts_for_each_pattern),
    175 ( 0.00%) .          .          .                       byte_classes: o.byte_classes.or(self.byte_classes),
    175 ( 0.00%) .          .          .                       unicode_word_boundary: o
      .          .          .          .                           .unicode_word_boundary
      .          .          .          .                           .or(self.unicode_word_boundary),
    525 ( 0.00%) .          .          .                       quitset: o.quitset.or(self.quitset),
    175 ( 0.00%) .          .          .                       specialize_start_states: o
      .          .          .          .                           .specialize_start_states
      .          .          .          .                           .or(self.specialize_start_states),
    175 ( 0.00%) .          .          .                       cache_capacity: o.cache_capacity.or(self.cache_capacity),
    175 ( 0.00%) .          .          .                       skip_cache_capacity_check: o
      .          .          .          .                           .skip_cache_capacity_check
      .          .          .          .                           .or(self.skip_cache_capacity_check),
    175 ( 0.00%) .          .          .                       minimum_cache_clear_count: o
      .          .          .          .                           .minimum_cache_clear_count
      .          .          .          .                           .or(self.minimum_cache_clear_count),
    175 ( 0.00%) .          .          .                       minimum_bytes_per_state: o
      .          .          .          .                           .minimum_bytes_per_state
      .          .          .          .                           .or(self.minimum_bytes_per_state),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A builder for constructing a lazy deterministic finite automaton from
      .          .          .          .           /// regular expressions.
-- line 3909 ----------------------------------------
-- line 3974 ----------------------------------------
      .          .          .          .           pub struct Builder {
      .          .          .          .               config: Config,
      .          .          .          .               #[cfg(feature = "syntax")]
      .          .          .          .               thompson: thompson::Compiler,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Builder {
      .          .          .          .               /// Create a new lazy DFA builder with the default configuration.
    875 ( 0.00%) .          .          .               pub fn new() -> Builder {
  1,792 ( 0.00%) .          .          .                   Builder {
      .          .          .          .                       config: Config::default(),
      .          .          .          .                       #[cfg(feature = "syntax")]
      .          .          .          .                       thompson: thompson::Compiler::new(),
      .          .          .          .                   }
  1,050 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Build a lazy DFA from the given pattern.
      .          .          .          .               ///
      .          .          .          .               /// If there was a problem parsing or compiling the pattern, then an error
      .          .          .          .               /// is returned.
      .          .          .          .               #[cfg(feature = "syntax")]
      .          .          .          .               pub fn build(&self, pattern: &str) -> Result<DFA, BuildError> {
      .          .          .          .                   self.build_many(&[pattern])
-- line 3996 ----------------------------------------
-- line 4047 ----------------------------------------
      .          .          .          .               /// let dfa = DFA::builder().build_from_nfa(nfa)?;
      .          .          .          .               /// let mut cache = dfa.create_cache();
      .          .          .          .               /// let expected = Some(HalfMatch::must(0, 6));
      .          .          .          .               /// let got = dfa.try_search_fwd(&mut cache, &Input::new(haystack))?;
      .          .          .          .               /// assert_eq!(expected, got);
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
  1,925 ( 0.00%) .          .          .               pub fn build_from_nfa(
      .          .          .          .                   &self,
      .          .          .          .                   nfa: thompson::NFA,
      .          .          .          .               ) -> Result<DFA, BuildError> {
    175 ( 0.00%) .          .          .                   let quitset = self.config.quit_set_from_nfa(&nfa)?;
      .          .          .          .                   let classes = self.config.byte_classes_from_nfa(&nfa, &quitset);
      .          .          .          .                   // Check that we can fit at least a few states into our cache,
      .          .          .          .                   // otherwise it's pretty senseless to use the lazy DFA. This does have
      .          .          .          .                   // a possible failure mode though. This assumes the maximum size of a
      .          .          .          .                   // state in powerset space (so, the total number of NFA states), which
      .          .          .          .                   // may never actually materialize, and could be quite a bit larger
      .          .          .          .                   // than the actual biggest state. If this turns out to be a problem,
      .          .          .          .                   // we could expose a knob that disables this check. But if so, we have
-- line 4067 ----------------------------------------
-- line 4069 ----------------------------------------
      .          .          .          .                   // clearing and init code) that tend to assume some minimum useful
      .          .          .          .                   // cache capacity.
      .          .          .          .                   let min_cache = minimum_cache_capacity(
      .          .          .          .                       &nfa,
      .          .          .          .                       &classes,
      .          .          .          .                       self.config.get_starts_for_each_pattern(),
      .          .          .          .                   );
      .          .          .          .                   let mut cache_capacity = self.config.get_cache_capacity();
    350 ( 0.00%) .          .          .                   if cache_capacity < min_cache {
      .          .          .          .                       // When the caller has asked us to skip the cache capacity check,
      .          .          .          .                       // then we simply force the cache capacity to its minimum amount
      .          .          .          .                       // and mush on.
      .          .          .          .                       if self.config.get_skip_cache_capacity_check() {
      .          .          .          .                           debug!(
      .          .          .          .                               "given capacity ({}) is too small, \
      .          .          .          .                                since skip_cache_capacity_check is enabled, \
      .          .          .          .                                setting cache capacity to minimum ({})",
-- line 4085 ----------------------------------------
-- line 4097 ----------------------------------------
      .          .          .          .                   // of states in our state ID space. This is unlikely to trigger in
      .          .          .          .                   // >=32-bit systems, but 16-bit systems have a pretty small state ID
      .          .          .          .                   // space since a number of bits are used up as sentinels.
      .          .          .          .                   if let Err(err) = minimum_lazy_state_id(&classes) {
      .          .          .          .                       return Err(BuildError::insufficient_state_id_capacity(err));
      .          .          .          .                   }
      .          .          .          .                   let stride2 = classes.stride2();
      .          .          .          .                   let start_map = StartByteMap::new(nfa.look_matcher());
  5,950 ( 0.00%) .          .          .                   Ok(DFA {
      .          .          .          .                       config: self.config.clone(),
    175 ( 0.00%) .          .          .                       nfa,
      .          .          .          .                       stride2,
    525 ( 0.00%) .          .          .                       start_map,
  5,250 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x)
  7,000 ( 0.00%) .          .          .                       classes,
    875 ( 0.00%) .          .          .                       quitset,
      .          .          .          .                       cache_capacity,
      .          .          .          .                   })
  1,575 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Apply the given lazy DFA configuration options to this builder.
  1,400 ( 0.00%) .          .          .               pub fn configure(&mut self, config: Config) -> &mut Builder {
  4,900 ( 0.00%) .          .          .                   self.config = self.config.overwrite(config);
      .          .          .          .                   self
  1,575 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the syntax configuration for this builder using
      .          .          .          .               /// [`syntax::Config`](crate::util::syntax::Config).
      .          .          .          .               ///
      .          .          .          .               /// This permits setting things like case insensitivity, Unicode and multi
      .          .          .          .               /// line mode.
      .          .          .          .               ///
      .          .          .          .               /// These settings only apply when constructing a lazy DFA directly from a
-- line 4128 ----------------------------------------
-- line 4282 ----------------------------------------
      .          .          .          .           /// It's not likely for this to have any impact 32-bit systems (or higher), but
      .          .          .          .           /// on 16-bit systems, the lazy state ID space is quite constrained and thus
      .          .          .          .           /// may be insufficient if our MIN_STATES value is (for some reason) too high.
      .          .          .          .           fn minimum_lazy_state_id(
      .          .          .          .               classes: &ByteClasses,
      .          .          .          .           ) -> Result<LazyStateID, LazyStateIDError> {
      .          .          .          .               let stride = 1 << classes.stride2();
      .          .          .          .               let min_state_index = MIN_STATES.checked_sub(1).unwrap();
    175 ( 0.00%) .          .          .               LazyStateID::new(min_state_index * stride)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Based on the minimum number of states required for a useful lazy DFA cache,
      .          .          .          .           /// this returns a heuristic minimum number of bytes of heap space required.
      .          .          .          .           ///
      .          .          .          .           /// This is a "heuristic" because the minimum it returns is likely bigger than
      .          .          .          .           /// the true minimum. Namely, it assumes that each powerset NFA/DFA state uses
      .          .          .          .           /// the maximum number of NFA states (all of them). This is likely bigger
-- line 4298 ----------------------------------------
-- line 4322 ----------------------------------------
      .          .          .          .               starts_for_each_pattern: bool,
      .          .          .          .           ) -> usize {
      .          .          .          .               const ID_SIZE: usize = size_of::<LazyStateID>();
      .          .          .          .               const STATE_SIZE: usize = size_of::<State>();
      .          .          .          .           
      .          .          .          .               let stride = 1 << classes.stride2();
      .          .          .          .               let states_len = nfa.states().len();
      .          .          .          .               let sparses = 2 * states_len * NFAStateID::SIZE;
    175 ( 0.00%) .          .          .               let trans = MIN_STATES * stride * ID_SIZE;
      .          .          .          .           
      .          .          .          .               let mut starts = Start::len() * ID_SIZE;
    175 ( 0.00%) .          .          .               if starts_for_each_pattern {
    324 ( 0.00%) .          .          .                   starts += (Start::len() * nfa.pattern_len()) * ID_SIZE;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               // The min number of states HAS to be at least 4: we have 3 sentinel states
      .          .          .          .               // and then we need space for one more when we save a state after clearing
      .          .          .          .               // the cache. We also need space for one more, otherwise we get stuck in a
      .          .          .          .               // loop where we try to add a 5th state, which gets rejected, which clears
      .          .          .          .               // the cache, which adds back a saved state (4th total state) which then
      .          .          .          .               // tries to add the 5th state again.
-- line 4342 ----------------------------------------
-- line 4350 ----------------------------------------
      .          .          .          .               // Every `State` has 5 bytes for flags, 4 bytes (max) for the number of
      .          .          .          .               // patterns, followed by 32-bit encodings of patterns and then delta
      .          .          .          .               // varint encodings of NFA state IDs. We use the worst case (which isn't
      .          .          .          .               // technically possible) of 5 bytes for each NFA state ID.
      .          .          .          .               //
      .          .          .          .               // HOWEVER, three of the states needed by a lazy DFA are just the sentinel
      .          .          .          .               // unknown, dead and quit states. Those states have a known size and it is
      .          .          .          .               // small.
    700 ( 0.00%) .          .          .               let dead_state_size = State::dead().memory_usage();
 62,626 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/state.rs:regex_automata::util::determinize::state::State::dead (175x)
    700 ( 0.00%) .          .          .               let max_state_size = 5 + 4 + (nfa.pattern_len() * 4) + (states_len * 5);
    350 ( 0.00%) .          .          .               let states = (SENTINEL_STATES * (STATE_SIZE + dead_state_size))
      .          .          .          .                   + (non_sentinel * (STATE_SIZE + max_state_size));
      .          .          .          .               // NOTE: We don't double count heap memory used by State for this map since
      .          .          .          .               // we use reference counting to avoid doubling memory usage. (This tends to
      .          .          .          .               // be where most memory is allocated in the cache.)
      .          .          .          .               let states_to_sid = (MIN_STATES * STATE_SIZE) + (MIN_STATES * ID_SIZE);
      .          .          .          .               let stack = states_len * NFAStateID::SIZE;
      .          .          .          .               let scratch_state_builder = max_state_size;
      .          .          .          .           
  1,225 ( 0.00%) .          .          .               trans
      .          .          .          .                   + starts
      .          .          .          .                   + states
      .          .          .          .                   + states_to_sid
      .          .          .          .                   + sparses
      .          .          .          .                   + stack
      .          .          .          .                   + scratch_state_builder
      .          .          .          .           }
      .          .          .          .           
-- line 4377 ----------------------------------------

120,944 ( 0.03%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/hybrid/dfa.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 56 ----------------------------------------
     .          .          .          .           impl<I: Interval> Eq for IntervalSet<I> {}
     .          .          .          .           
     .          .          .          .           // We implement PartialEq manually so that we don't consider the set's internal
     .          .          .          .           // 'folded' property to be part of its identity. The 'folded' property is
     .          .          .          .           // strictly an optimization.
     .          .          .          .           impl<I: Interval> PartialEq for IntervalSet<I> {
     .          .          .          .               fn eq(&self, other: &IntervalSet<I>) -> bool {
     .          .          .          .                   self.ranges.eq(&other.ranges)
    64 ( 0.00%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<I: Interval> IntervalSet<I> {
     .          .          .          .               /// Create a new set from a sequence of intervals. Each interval is
     .          .          .          .               /// specified as a pair of bounds, where both bounds are inclusive.
     .          .          .          .               ///
     .          .          .          .               /// The given ranges do not need to be in any specific order, and ranges
     .          .          .          .               /// may overlap.
 3,382 ( 0.00%) .          .          .               pub fn new<T: IntoIterator<Item = I>>(intervals: T) -> IntervalSet<I> {
     .          .          .          .                   let ranges: Vec<I> = intervals.into_iter().collect();
     .          .          .          .                   // An empty set is case folded.
     .          .          .          .                   let folded = ranges.is_empty();
28,850 ( 0.01%) .          .          .                   let mut set = IntervalSet { ranges, folded };
 5,994 ( 0.00%) .          .          .                   set.canonicalize();
22,002 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,158x)
23,976 ( 0.01%) .          .          .                   set
 4,507 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add a new interval to this set.
     .          .          .          .               pub fn push(&mut self, interval: I) {
     .          .          .          .                   // TODO: This could be faster. e.g., Push the interval such that
     .          .          .          .                   // it preserves canonicalization.
     .          .          .          .                   self.ranges.push(interval);
 3,545 ( 0.00%) .          .          .                   self.canonicalize();
343,981 ( 0.10%) 336 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (3,545x)
     .          .          .          .                   // We don't know whether the new interval added here is considered
     .          .          .          .                   // case folded, so we conservatively assume that the entire set is
     .          .          .          .                   // no longer case folded if it was previously.
 3,545 ( 0.00%) .          .          .                   self.folded = false;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return an iterator over all intervals in this set.
     .          .          .          .               ///
     .          .          .          .               /// The iterator yields intervals in ascending order.
     .          .          .          .               pub fn iter(&self) -> IntervalSetIter<'_, I> {
     .          .          .          .                   IntervalSetIter(self.ranges.iter())
     .          .          .          .               }
-- line 99 ----------------------------------------
-- line 108 ----------------------------------------
     .          .          .          .               /// Expand this interval set such that it contains all case folded
     .          .          .          .               /// characters. For example, if this class consists of the range `a-z`,
     .          .          .          .               /// then applying case folding will result in the class containing both the
     .          .          .          .               /// ranges `a-z` and `A-Z`.
     .          .          .          .               ///
     .          .          .          .               /// This returns an error if the necessary case mapping data is not
     .          .          .          .               /// available.
     .          .          .          .               pub fn case_fold_simple(&mut self) -> Result<(), unicode::CaseFoldError> {
 2,660 ( 0.00%) .          .          .                   if self.folded {
     .          .          .          .                       return Ok(());
     .          .          .          .                   }
     .          .          .          .                   let len = self.ranges.len();
     .          .          .          .                   for i in 0..len {
 4,760 ( 0.00%) .          .          .                       let range = self.ranges[i];
 5,950 ( 0.00%) .          .          .                       if let Err(err) = range.case_fold_simple(&mut self.ranges) {
941,175 ( 0.27%) 2,240 ( 0.28%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple (1,120x)
     .          .          .          .                           self.canonicalize();
     .          .          .          .                           return Err(err);
     .          .          .          .                       }
     .          .          .          .                   }
 2,310 ( 0.00%) .          .          .                   self.canonicalize();
38,420 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,120x)
 1,260 ( 0.00%) .          .          .                   self.folded = true;
     .          .          .          .                   Ok(())
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Union this set with the given set, in place.
 6,321 ( 0.00%) .          .          .               pub fn union(&mut self, other: &IntervalSet<I>) {
 1,808 ( 0.00%) .          .          .                   if other.ranges.is_empty() || self.ranges == other.ranges {
     .          .          .          .                       return;
     .          .          .          .                   }
     .          .          .          .                   // This could almost certainly be done more efficiently.
     .          .          .          .                   self.ranges.extend(&other.ranges);
 2,711 ( 0.00%) .          .          .                   self.canonicalize();
    44 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1x)
 2,714 ( 0.00%) .          .          .                   self.folded = self.folded && other.folded;
 7,224 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Intersect this set with the given set, in place.
     .          .          .          .               pub fn intersect(&mut self, other: &IntervalSet<I>) {
     .          .          .          .                   if self.ranges.is_empty() {
     .          .          .          .                       return;
     .          .          .          .                   }
     .          .          .          .                   if other.ranges.is_empty() {
     .          .          .          .                       self.ranges.clear();
-- line 149 ----------------------------------------
-- line 288 ----------------------------------------
     .          .          .          .                   self.union(other);
     .          .          .          .                   self.difference(&intersection);
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Negate this interval set.
     .          .          .          .               ///
     .          .          .          .               /// For all `x` where `x` is any element, if `x` was in this set, then it
     .          .          .          .               /// will not be in this set after negation.
   366 ( 0.00%) .          .          .               pub fn negate(&mut self) {
   122 ( 0.00%) .          .          .                   if self.ranges.is_empty() {
     .          .          .          .                       let (min, max) = (I::Bound::min_value(), I::Bound::max_value());
     .          .          .          .                       self.ranges.push(I::create(min, max));
     .          .          .          .                       // The set containing everything must case folded.
     .          .          .          .                       self.folded = true;
     .          .          .          .                       return;
     .          .          .          .                   }
     .          .          .          .           
     .          .          .          .                   // There should be a way to do this in-place with constant memory,
     .          .          .          .                   // but I couldn't figure out a simple way to do it. So just append
     .          .          .          .                   // the negation to the end of this range, and then drain it before
     .          .          .          .                   // we're done.
     .          .          .          .                   let drain_end = self.ranges.len();
     .          .          .          .           
     .          .          .          .                   // We do checked arithmetic below because of the canonical ordering
     .          .          .          .                   // invariant.
   427 ( 0.00%) .          .          .                   if self.ranges[0].lower() > I::Bound::min_value() {
     .          .          .          .                       let upper = self.ranges[0].lower().decrement();
     .          .          .          .                       self.ranges.push(I::create(I::Bound::min_value(), upper));
     .          .          .          .                   }
     .          .          .          .                   for i in 1..drain_end {
   102 ( 0.00%) .          .          .                       let lower = self.ranges[i - 1].upper().increment();
    34 ( 0.00%) .          .          .                       let upper = self.ranges[i].lower().decrement();
     .          .          .          .                       self.ranges.push(I::create(lower, upper));
     .          .          .          .                   }
   244 ( 0.00%) .          .          .                   if self.ranges[drain_end - 1].upper() < I::Bound::max_value() {
     .          .          .          .                       let lower = self.ranges[drain_end - 1].upper().increment();
     .          .          .          .                       self.ranges.push(I::create(lower, I::Bound::max_value()));
     .          .          .          .                   }
     .          .          .          .                   self.ranges.drain(..drain_end);
     .          .          .          .                   // We don't need to update whether this set is folded or not, because
     .          .          .          .                   // it is conservatively preserved through negation. Namely, if a set
     .          .          .          .                   // is not folded, then it is possible that its negation is folded, for
     .          .          .          .                   // example, [^☃]. But we're fine with assuming that the set is not
-- line 330 ----------------------------------------
-- line 332 ----------------------------------------
     .          .          .          .                   // positives.)
     .          .          .          .                   //
     .          .          .          .                   // But what about when a set is folded, is its negation also
     .          .          .          .                   // necessarily folded? Yes. Because if a set is folded, then for every
     .          .          .          .                   // character in the set, it necessarily included its equivalence class
     .          .          .          .                   // of case folded characters. Negating it in turn means that all
     .          .          .          .                   // equivalence classes in the set are negated, and any equivalence
     .          .          .          .                   // class that was previously not in the set is now entirely in the set.
   366 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Converts this set into a canonical ordering.
59,547 ( 0.02%) .          .          .               fn canonicalize(&mut self) {
23,596 ( 0.01%) .          .          .                   if self.is_canonical() {
     .          .          .          .                       return;
     .          .          .          .                   }
     .          .          .          .                   self.ranges.sort();
 1,318 ( 0.00%) .          .          .                   assert!(!self.ranges.is_empty());
     .          .          .          .           
     .          .          .          .                   // Is there a way to do this in-place with constant memory? I couldn't
     .          .          .          .                   // figure out a way to do it. So just append the canonicalization to
     .          .          .          .                   // the end of this range, and then drain it before we're done.
     .          .          .          .                   let drain_end = self.ranges.len();
     .          .          .          .                   for oldi in 0..drain_end {
     .          .          .          .                       // If we've added at least one new range, then check if we can
     .          .          .          .                       // merge this range in the previously added range.
 5,770 ( 0.00%) .          .          .                       if self.ranges.len() > drain_end {
     .          .          .          .                           let (last, rest) = self.ranges.split_last_mut().unwrap();
     .          .          .          .                           if let Some(union) = last.union(&rest[oldi]) {
 2,064 ( 0.00%) .          .          .                               *last = union;
     .          .          .          .                               continue;
     .          .          .          .                           }
     .          .          .          .                       }
 3,706 ( 0.00%) .          .          .                       let range = self.ranges[oldi];
     .          .          .          .                       self.ranges.push(range);
     .          .          .          .                   }
     .          .          .          .                   self.ranges.drain(..drain_end);
59,657 ( 0.02%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this class is in a canonical ordering.
     .          .          .          .               fn is_canonical(&self) -> bool {
34,569 ( 0.01%) .          .          .                   for pair in self.ranges.windows(2) {
 9,222 ( 0.00%) .          .          .                       if pair[0] >= pair[1] {
     .          .          .          .                           return false;
     .          .          .          .                       }
 8,364 ( 0.00%) .          .          .                       if pair[0].is_contiguous(&pair[1]) {
     .          .          .          .                           return false;
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   true
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// An iterator over intervals.
-- line 384 ----------------------------------------
-- line 405 ----------------------------------------
     .          .          .          .               fn case_fold_simple(
     .          .          .          .                   &self,
     .          .          .          .                   intervals: &mut Vec<Self>,
     .          .          .          .               ) -> Result<(), unicode::CaseFoldError>;
     .          .          .          .           
     .          .          .          .               /// Create a new interval.
     .          .          .          .               fn create(lower: Self::Bound, upper: Self::Bound) -> Self {
     .          .          .          .                   let mut int = Self::default();
11,318 ( 0.00%) .          .          .                   if lower <= upper {
     .          .          .          .                       int.set_lower(lower);
     .          .          .          .                       int.set_upper(upper);
     .          .          .          .                   } else {
     .          .          .          .                       int.set_lower(upper);
     .          .          .          .                       int.set_upper(lower);
     .          .          .          .                   }
     .          .          .          .                   int
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Union the given overlapping range into this range.
     .          .          .          .               ///
     .          .          .          .               /// If the two ranges aren't contiguous, then this returns `None`.
     .          .          .          .               fn union(&self, other: &Self) -> Option<Self> {
 1,567 ( 0.00%) .          .          .                   if !self.is_contiguous(other) {
     .          .          .          .                       return None;
     .          .          .          .                   }
     .          .          .          .                   let lower = cmp::min(self.lower(), other.lower());
     .          .          .          .                   let upper = cmp::max(self.upper(), other.upper());
     .          .          .          .                   Some(Self::create(lower, upper))
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Intersect this range with the given range and return the result.
-- line 435 ----------------------------------------
-- line 478 ----------------------------------------
     .          .          .          .                   }
     .          .          .          .                   ret
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if the two ranges are contiguous. Two ranges
     .          .          .          .               /// are contiguous if and only if the ranges are either overlapping or
     .          .          .          .               /// adjacent.
     .          .          .          .               fn is_contiguous(&self, other: &Self) -> bool {
 1,567 ( 0.00%) .          .          .                   let lower1 = self.lower().as_u32();
 5,749 ( 0.00%) .          .          .                   let upper1 = self.upper().as_u32();
 1,567 ( 0.00%) .          .          .                   let lower2 = other.lower().as_u32();
 5,749 ( 0.00%) .          .          .                   let upper2 = other.upper().as_u32();
 5,749 ( 0.00%) .          .          .                   cmp::max(lower1, lower2) <= cmp::min(upper1, upper2).saturating_add(1)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if the intersection of this range and the
     .          .          .          .               /// other range is empty.
     .          .          .          .               fn is_intersection_empty(&self, other: &Self) -> bool {
     .          .          .          .                   let (lower1, upper1) = (self.lower(), self.upper());
     .          .          .          .                   let (lower2, upper2) = (other.lower(), other.upper());
     .          .          .          .                   cmp::max(lower1, lower2) > cmp::min(upper1, upper2)
-- line 498 ----------------------------------------
-- line 542 ----------------------------------------
     .          .          .          .               fn max_value() -> Self {
     .          .          .          .                   '\u{10FFFF}'
     .          .          .          .               }
     .          .          .          .               fn as_u32(self) -> u32 {
     .          .          .          .                   u32::from(self)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               fn increment(self) -> Self {
   190 ( 0.00%) .          .          .                   match self {
     .          .          .          .                       '\u{D7FF}' => '\u{E000}',
   136 ( 0.00%) .          .          .                       c => char::from_u32(u32::from(c).checked_add(1).unwrap()).unwrap(),
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               fn decrement(self) -> Self {
   136 ( 0.00%) .          .          .                   match self {
     .          .          .          .                       '\u{E000}' => '\u{D7FF}',
     .          .          .          .                       c => char::from_u32(u32::from(c).checked_sub(1).unwrap()).unwrap(),
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           // Tests for interval sets are written in src/hir.rs against the public API.

13,520 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/look.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 137 ----------------------------------------
     .          .          .          .           impl Look {
     .          .          .          .               /// Flip the look-around assertion to its equivalent for reverse searches.
     .          .          .          .               /// For example, `StartLF` gets translated to `EndLF`.
     .          .          .          .               ///
     .          .          .          .               /// Some assertions, such as `WordUnicode`, remain the same since they
     .          .          .          .               /// match the same positions regardless of the direction of the search.
     .          .          .          .               #[inline]
     .          .          .          .               pub const fn reversed(self) -> Look {
   246 ( 0.00%) .          .          .                   match self {
     .          .          .          .                       Look::Start => Look::End,
     .          .          .          .                       Look::End => Look::Start,
     .          .          .          .                       Look::StartLF => Look::EndLF,
     .          .          .          .                       Look::EndLF => Look::StartLF,
     .          .          .          .                       Look::StartCRLF => Look::EndCRLF,
     .          .          .          .                       Look::EndCRLF => Look::StartCRLF,
     .          .          .          .                       Look::WordAscii => Look::WordAscii,
     .          .          .          .                       Look::WordAsciiNegate => Look::WordAsciiNegate,
-- line 153 ----------------------------------------
-- line 175 ----------------------------------------
     .          .          .          .                   self as u32
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Given the underlying representation of a `Look` value, return the
     .          .          .          .               /// corresponding `Look` value if the representation is valid. Otherwise
     .          .          .          .               /// `None` is returned.
     .          .          .          .               #[inline]
     .          .          .          .               pub const fn from_repr(repr: u32) -> Option<Look> {
   244 ( 0.00%) .          .          .                   match repr {
     .          .          .          .                       0b00_0000_0000_0000_0001 => Some(Look::Start),
     .          .          .          .                       0b00_0000_0000_0000_0010 => Some(Look::End),
     .          .          .          .                       0b00_0000_0000_0000_0100 => Some(Look::StartLF),
     .          .          .          .                       0b00_0000_0000_0000_1000 => Some(Look::EndLF),
     .          .          .          .                       0b00_0000_0000_0001_0000 => Some(Look::StartCRLF),
     .          .          .          .                       0b00_0000_0000_0010_0000 => Some(Look::EndCRLF),
     .          .          .          .                       0b00_0000_0000_0100_0000 => Some(Look::WordAscii),
     .          .          .          .                       0b00_0000_0000_1000_0000 => Some(Look::WordAsciiNegate),
-- line 191 ----------------------------------------
-- line 284 ----------------------------------------
     .          .          .          .                   // OK because max value always fits in a u8, which in turn always
     .          .          .          .                   // fits in a usize, regardless of target.
     .          .          .          .                   usize::try_from(self.bits.count_ones()).unwrap()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set is empty.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn is_empty(self) -> bool {
   482 ( 0.00%) .          .          .                   self.len() == 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if the given look-around assertion is in this
     .          .          .          .               /// set.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn contains(self, look: Look) -> bool {
    41 ( 0.00%) .          .          .                   self.bits & look.as_repr() != 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set contains any anchor assertions.
     .          .          .          .               /// This includes both "start/end of haystack" and "start/end of line."
     .          .          .          .               #[inline]
     .          .          .          .               pub fn contains_anchor(&self) -> bool {
     .          .          .          .                   self.contains_anchor_haystack() || self.contains_anchor_line()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set contains any "start/end of
     .          .          .          .               /// haystack" anchors. This doesn't include "start/end of line" anchors.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn contains_anchor_haystack(&self) -> bool {
    41 ( 0.00%) .          .          .                   self.contains(Look::Start) || self.contains(Look::End)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set contains any "start/end of line"
     .          .          .          .               /// anchors. This doesn't include "start/end of haystack" anchors. This
     .          .          .          .               /// includes both `\n` line anchors and CRLF (`\r\n`) aware line anchors.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn contains_anchor_line(&self) -> bool {
   259 ( 0.00%) .          .          .                   self.contains(Look::StartLF)
     .          .          .          .                       || self.contains(Look::EndLF)
     .          .          .          .                       || self.contains(Look::StartCRLF)
     .          .          .          .                       || self.contains(Look::EndCRLF)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set contains any "start/end of line"
     .          .          .          .               /// anchors that only treat `\n` as line terminators. This does not include
     .          .          .          .               /// haystack anchors or CRLF aware line anchors.
-- line 329 ----------------------------------------
-- line 332 ----------------------------------------
     .          .          .          .                   self.contains(Look::StartLF) || self.contains(Look::EndLF)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set contains any "start/end of line"
     .          .          .          .               /// anchors that are CRLF-aware. This doesn't include "start/end of
     .          .          .          .               /// haystack" or "start/end of line-feed" anchors.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn contains_anchor_crlf(&self) -> bool {
   393 ( 0.00%) .          .          .                   self.contains(Look::StartCRLF) || self.contains(Look::EndCRLF)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set contains any word boundary or
     .          .          .          .               /// negated word boundary assertions. This include both Unicode and ASCII
     .          .          .          .               /// word boundaries.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn contains_word(self) -> bool {
 1,004 ( 0.00%) .          .          .                   self.contains_word_unicode() || self.contains_word_ascii()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set contains any Unicode word boundary
     .          .          .          .               /// or negated Unicode word boundary assertions.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn contains_word_unicode(self) -> bool {
   175 ( 0.00%) .          .          .                   self.contains(Look::WordUnicode)
     .          .          .          .                       || self.contains(Look::WordUnicodeNegate)
     .          .          .          .                       || self.contains(Look::WordStartUnicode)
     .          .          .          .                       || self.contains(Look::WordEndUnicode)
     .          .          .          .                       || self.contains(Look::WordStartHalfUnicode)
     .          .          .          .                       || self.contains(Look::WordEndHalfUnicode)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set contains any ASCII word boundary
-- line 363 ----------------------------------------
-- line 378 ----------------------------------------
     .          .          .          .                   LookSetIter { set: self }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return a new set that is equivalent to the original, but with the given
     .          .          .          .               /// assertion added to it. If the assertion is already in the set, then the
     .          .          .          .               /// returned set is equivalent to the original.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn insert(self, look: Look) -> LookSet {
   230 ( 0.00%) .          .          .                   LookSet { bits: self.bits | look.as_repr() }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Updates this set in place with the result of inserting the given
     .          .          .          .               /// assertion into this set.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn set_insert(&mut self, look: Look) {
     .          .          .          .                   *self = self.insert(look);
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return a new set that is equivalent to the original, but with the given
     .          .          .          .               /// assertion removed from it. If the assertion is not in the set, then the
     .          .          .          .               /// returned set is equivalent to the original.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn remove(self, look: Look) -> LookSet {
   122 ( 0.00%) .          .          .                   LookSet { bits: self.bits & !look.as_repr() }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Updates this set in place with the result of removing the given
     .          .          .          .               /// assertion from this set.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn set_remove(&mut self, look: Look) {
     .          .          .          .                   *self = self.remove(look);
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns a new set that is the result of subtracting the given set from
     .          .          .          .               /// this set.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn subtract(self, other: LookSet) -> LookSet {
    40 ( 0.00%) .          .          .                   LookSet { bits: self.bits & !other.bits }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Updates this set in place with the result of subtracting the given set
     .          .          .          .               /// from this set.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn set_subtract(&mut self, other: LookSet) {
     .          .          .          .                   *self = self.subtract(other);
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns a new set that is the union of this and the one given.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn union(self, other: LookSet) -> LookSet {
   350 ( 0.00%) .          .          .                   LookSet { bits: self.bits | other.bits }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Updates this set in place with the result of unioning it with the one
     .          .          .          .               /// given.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn set_union(&mut self, other: LookSet) {
     .          .          .          .                   *self = self.union(other);
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns a new set that is the intersection of this and the one given.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn intersect(self, other: LookSet) -> LookSet {
    40 ( 0.00%) .          .          .                   LookSet { bits: self.bits & other.bits }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Updates this set in place with the result of intersecting it with the
     .          .          .          .               /// one given.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn set_intersect(&mut self, other: LookSet) {
     .          .          .          .                   *self = self.intersect(other);
     .          .          .          .               }
-- line 449 ----------------------------------------
-- line 464 ----------------------------------------
     .          .          .          .               /// of the slice given.
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
     .          .          .          .               /// This panics if `slice.len() < 4`.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn write_repr(self, slice: &mut [u8]) {
     .          .          .          .                   let raw = self.bits.to_ne_bytes();
    81 ( 0.00%) .          .          .                   slice[0] = raw[0];
   299 ( 0.00%) .          .          .                   slice[1] = raw[1];
    81 ( 0.00%) .          .          .                   slice[2] = raw[2];
   122 ( 0.00%) .          .          .                   slice[3] = raw[3];
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Checks that all assertions in this set can be matched.
     .          .          .          .               ///
     .          .          .          .               /// Some assertions, such as Unicode word boundaries, require optional (but
     .          .          .          .               /// enabled by default) tables that may not be available. If there are
     .          .          .          .               /// assertions in this set that require tables that are not available, then
     .          .          .          .               /// this will return an error.
-- line 483 ----------------------------------------
-- line 518 ----------------------------------------
     .          .          .          .               set: LookSet,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl Iterator for LookSetIter {
     .          .          .          .               type Item = Look;
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               fn next(&mut self) -> Option<Look> {
   406 ( 0.00%) .          .          .                   if self.set.is_empty() {
     .          .          .          .                       return None;
     .          .          .          .                   }
     .          .          .          .                   // We'll never have more than u8::MAX distinct look-around assertions,
     .          .          .          .                   // so 'bit' will always fit into a u16.
     .          .          .          .                   let bit = u16::try_from(self.set.bits.trailing_zeros()).unwrap();
   366 ( 0.00%) .          .          .                   let look = Look::from_repr(1 << bit)?;
     .          .          .          .                   self.set = self.set.remove(look);
     .          .          .          .                   Some(look)
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A matcher for look-around assertions.
     .          .          .          .           ///
     .          .          .          .           /// This matcher permits configuring aspects of how look-around assertions are
-- line 540 ----------------------------------------
-- line 604 ----------------------------------------
     .          .          .          .               /// Returns the line terminator that was configured for this matcher.
     .          .          .          .               ///
     .          .          .          .               /// If no line terminator was configured, then this returns `\n`.
     .          .          .          .               ///
     .          .          .          .               /// Note that the line terminator should only be used for matching `(?m:^)`
     .          .          .          .               /// and `(?m:$)` assertions. It specifically should _not_ be used for
     .          .          .          .               /// matching the CRLF aware assertions `(?Rm:^)` and `(?Rm:$)`.
     .          .          .          .               pub fn get_line_terminator(&self) -> u8 {
   391 ( 0.00%) .          .          .                   self.lineterm.0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true when the position `at` in `haystack` satisfies the given
     .          .          .          .               /// look-around assertion.
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
     .          .          .          .               /// This panics when testing any Unicode word boundary assertion in this
-- line 620 ----------------------------------------
-- line 656 ----------------------------------------
     .          .          .          .               /// haystack.len()` is legal and guaranteed not to panic.
     .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
     .          .          .          .               pub(crate) fn matches_inline(
     .          .          .          .                   &self,
     .          .          .          .                   look: Look,
     .          .          .          .                   haystack: &[u8],
     .          .          .          .                   at: usize,
     .          .          .          .               ) -> bool {
    10 ( 0.00%) .          .          .                   match look {
     .          .          .          .                       Look::Start => self.is_start(haystack, at),
     .          .          .          .                       Look::End => self.is_end(haystack, at),
     .          .          .          .                       Look::StartLF => self.is_start_lf(haystack, at),
     .          .          .          .                       Look::EndLF => self.is_end_lf(haystack, at),
     .          .          .          .                       Look::StartCRLF => self.is_start_crlf(haystack, at),
     .          .          .          .                       Look::EndCRLF => self.is_end_crlf(haystack, at),
     .          .          .          .                       Look::WordAscii => self.is_word_ascii(haystack, at),
     .          .          .          .                       Look::WordAsciiNegate => self.is_word_ascii_negate(haystack, at),
-- line 672 ----------------------------------------
-- line 834 ----------------------------------------
     .          .          .          .               /// Split up the given byte classes into equivalence classes in a way that
     .          .          .          .               /// is consistent with this look-around assertion.
     .          .          .          .               #[cfg(feature = "alloc")]
     .          .          .          .               pub(crate) fn add_to_byteset(
     .          .          .          .                   &self,
     .          .          .          .                   look: Look,
     .          .          .          .                   set: &mut crate::util::alphabet::ByteClassSet,
     .          .          .          .               ) {
   490 ( 0.00%) .          .          .                   match look {
     .          .          .          .                       Look::Start | Look::End => {}
     .          .          .          .                       Look::StartLF | Look::EndLF => {
     .          .          .          .                           set.set_range(self.lineterm.0, self.lineterm.0);
     .          .          .          .                       }
     .          .          .          .                       Look::StartCRLF | Look::EndCRLF => {
     .          .          .          .                           set.set_range(b'\r', b'\r');
     .          .          .          .                           set.set_range(b'\n', b'\n');
     .          .          .          .                       }
-- line 850 ----------------------------------------
-- line 900 ----------------------------------------
     .          .          .          .               /// in `haystack`.
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
     .          .          .          .               /// This may panic when `at > haystack.len()`. Note that `at ==
     .          .          .          .               /// haystack.len()` is legal and guaranteed not to panic.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn is_start(&self, _haystack: &[u8], at: usize) -> bool {
    10 ( 0.00%) .          .          .                   at == 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true when [`Look::End`] is satisfied `at` the given position in
     .          .          .          .               /// `haystack`.
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
     .          .          .          .               /// This may panic when `at > haystack.len()`. Note that `at ==
-- line 916 ----------------------------------------

21,283 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/look.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/map.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 113 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// Note that this does not allocate. Instead, callers must call `clear`
     .          .          .          .               /// before using this map. `clear` will allocate space if necessary.
     .          .          .          .               ///
     .          .          .          .               /// This avoids the need to pay for the allocation of this map when
     .          .          .          .               /// compiling regexes that lack large Unicode character classes.
     .          .          .          .               pub fn new(capacity: usize) -> Utf8BoundedMap {
     .          .          .          .                   assert!(capacity > 0);
   674 ( 0.00%) .          .          .                   Utf8BoundedMap { version: 0, capacity, map: vec![] }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Clear this map of all entries, but permit the reuse of allocation
     .          .          .          .               /// if possible.
     .          .          .          .               ///
     .          .          .          .               /// This must be called before the map can be used.
   882 ( 0.00%) .          .          .               pub fn clear(&mut self) {
   252 ( 0.00%) .          .          .                   if self.map.is_empty() {
    67 ( 0.00%) .          .          .                       self.map = vec![Utf8BoundedEntry::default(); self.capacity];
     .          .          .          .                   } else {
    59 ( 0.00%) .          .          .                       self.version = self.version.wrapping_add(1);
     .          .          .          .                       // If we loop back to version 0, then we forcefully clear the
     .          .          .          .                       // entire map. Otherwise, it might be possible to incorrectly
     .          .          .          .                       // match entries used to generate other NFAs.
    59 ( 0.00%) .          .          .                       if self.version == 0 {
     .          .          .          .                           self.map = vec![Utf8BoundedEntry::default(); self.capacity];
     .          .          .          .                       }
     .          .          .          .                   }
   882 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return a hash of the given transitions.
     .          .          .          .               pub fn hash(&self, key: &[Transition]) -> usize {
     .          .          .          .                   let mut h = INIT;
     .          .          .          .                   for t in key {
 5,534 ( 0.00%) .          .          .                       h = (h ^ u64::from(t.start)).wrapping_mul(PRIME);
 5,534 ( 0.00%) .          .          .                       h = (h ^ u64::from(t.end)).wrapping_mul(PRIME);
 2,767 ( 0.00%) .          .          .                       h = (h ^ t.next.as_u64()).wrapping_mul(PRIME);
     .          .          .          .                   }
 6,856 ( 0.00%) .          .          .                   (h % self.map.len().as_u64()).as_usize()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Retrieve the cached state ID corresponding to the given key. The hash
     .          .          .          .               /// given must have been computed with `hash` using the same key value.
     .          .          .          .               ///
     .          .          .          .               /// If there is no cached state with the given transitions, then None is
     .          .          .          .               /// returned.
     .          .          .          .               pub fn get(&mut self, key: &[Transition], hash: usize) -> Option<StateID> {
 1,714 ( 0.00%) .          .          .                   let entry = &self.map[hash];
 8,570 ( 0.00%) .          .          .                   if entry.version != self.version {
     .          .          .          .                       return None;
     .          .          .          .                   }
     .          .          .          .                   // There may be a hash collision, so we need to confirm real equality.
     .          .          .          .                   if entry.key != key {
     .          .          .          .                       return None;
     .          .          .          .                   }
   941 ( 0.00%) .          .          .                   Some(entry.val)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add a cached state to this map with the given key. Callers should
     .          .          .          .               /// ensure that `state_id` points to a state that contains precisely the
     .          .          .          .               /// NFA transitions given.
     .          .          .          .               ///
     .          .          .          .               /// `hash` must have been computed using the `hash` method with the same
     .          .          .          .               /// key.
     .          .          .          .               pub fn set(
     .          .          .          .                   &mut self,
     .          .          .          .                   key: Vec<Transition>,
     .          .          .          .                   hash: usize,
     .          .          .          .                   state_id: StateID,
     .          .          .          .               ) {
 6,184 ( 0.00%) .          .          .                   self.map[hash] =
   773 ( 0.00%) .          .          .                       Utf8BoundedEntry { version: self.version, key, val: state_id };
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A cache of suffixes used to modestly compress UTF-8 automata for large
     .          .          .          .           /// Unicode character classes.
     .          .          .          .           #[derive(Clone, Debug)]
     .          .          .          .           pub struct Utf8SuffixMap {
     .          .          .          .               /// The current version of this map. Only entries with matching versions
-- line 191 ----------------------------------------
-- line 196 ----------------------------------------
     .          .          .          .               capacity: usize,
     .          .          .          .               /// The actual entries, keyed by hash. Collisions between different states
     .          .          .          .               /// result in the old state being dropped.
     .          .          .          .               map: Vec<Utf8SuffixEntry>,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A key that uniquely identifies an NFA state. It is a triple that represents
     .          .          .          .           /// a transition from one state for a particular byte range.
 3,726 ( 0.00%) .          .          .           #[derive(Clone, Debug, Default, Eq, PartialEq)]
     .          .          .          .           pub struct Utf8SuffixKey {
     .          .          .          .               pub from: StateID,
     .          .          .          .               pub start: u8,
     .          .          .          .               pub end: u8,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// An entry in this map.
     .          .          .          .           #[derive(Clone, Debug, Default)]
-- line 212 ----------------------------------------
-- line 227 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// Note that this does not allocate. Instead, callers must call `clear`
     .          .          .          .               /// before using this map. `clear` will allocate space if necessary.
     .          .          .          .               ///
     .          .          .          .               /// This avoids the need to pay for the allocation of this map when
     .          .          .          .               /// compiling regexes that lack large Unicode character classes.
     .          .          .          .               pub fn new(capacity: usize) -> Utf8SuffixMap {
     .          .          .          .                   assert!(capacity > 0);
 3,370 ( 0.00%) .          .          .                   Utf8SuffixMap { version: 0, capacity, map: vec![] }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Clear this map of all entries, but permit the reuse of allocation
     .          .          .          .               /// if possible.
     .          .          .          .               ///
     .          .          .          .               /// This must be called before the map can be used.
   762 ( 0.00%) .          .          .               pub fn clear(&mut self) {
   254 ( 0.00%) .          .          .                   if self.map.is_empty() {
    68 ( 0.00%) .          .          .                       self.map = vec![Utf8SuffixEntry::default(); self.capacity];
     .          .          .          .                   } else {
    59 ( 0.00%) .          .          .                       self.version = self.version.wrapping_add(1);
    59 ( 0.00%) .          .          .                       if self.version == 0 {
     .          .          .          .                           self.map = vec![Utf8SuffixEntry::default(); self.capacity];
     .          .          .          .                       }
     .          .          .          .                   }
   762 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return a hash of the given transition.
     .          .          .          .               pub fn hash(&self, key: &Utf8SuffixKey) -> usize {
     .          .          .          .                   // Basic FNV-1a hash as described:
     .          .          .          .                   // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
     .          .          .          .                   const PRIME: u64 = 1099511628211;
     .          .          .          .                   const INIT: u64 = 14695981039346656037;
     .          .          .          .           
     .          .          .          .                   let mut h = INIT;
 9,786 ( 0.00%) .          .          .                   h = (h ^ key.from.as_u64()).wrapping_mul(PRIME);
 3,262 ( 0.00%) .          .          .                   h = (h ^ u64::from(key.start)).wrapping_mul(PRIME);
 3,262 ( 0.00%) .          .          .                   h = (h ^ u64::from(key.end)).wrapping_mul(PRIME);
19,003 ( 0.01%) .          .          .                   (h % self.map.len().as_u64()).as_usize()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Retrieve the cached state ID corresponding to the given key. The hash
     .          .          .          .               /// given must have been computed with `hash` using the same key value.
     .          .          .          .               ///
     .          .          .          .               /// If there is no cached state with the given key, then None is returned.
     .          .          .          .               pub fn get(
     .          .          .          .                   &mut self,
     .          .          .          .                   key: &Utf8SuffixKey,
     .          .          .          .                   hash: usize,
     .          .          .          .               ) -> Option<StateID> {
 3,262 ( 0.00%) .          .          .                   let entry = &self.map[hash];
 9,786 ( 0.00%) .          .          .                   if entry.version != self.version {
     .          .          .          .                       return None;
     .          .          .          .                   }
   464 ( 0.00%) .          .          .                   if key != &entry.key {
     .          .          .          .                       return None;
     .          .          .          .                   }
   464 ( 0.00%) .          .          .                   Some(entry.val)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add a cached state to this map with the given key. Callers should
     .          .          .          .               /// ensure that `state_id` points to a state that contains precisely the
     .          .          .          .               /// NFA transition given.
     .          .          .          .               ///
     .          .          .          .               /// `hash` must have been computed using the `hash` method with the same
     .          .          .          .               /// key.
     .          .          .          .               pub fn set(&mut self, key: Utf8SuffixKey, hash: usize, state_id: StateID) {
16,788 ( 0.00%) .          .          .                   self.map[hash] =
 2,798 ( 0.00%) .          .          .                       Utf8SuffixEntry { version: self.version, key, val: state_id };
     .          .          .          .               }
     .          .          .          .           }

21,818 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/map.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 126 ----------------------------------------
        .          .          .          .               /// to the pattern's index (starting at 0).
        .          .          .          .               Match { pattern_id: PatternID },
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl State {
        .          .          .          .               /// If this state is an unconditional epsilon transition, then this returns
        .          .          .          .               /// the target of the transition.
        .          .          .          .               fn goto(&self) -> Option<StateID> {
  356,674 ( 0.10%) .          .          .                   match *self {
    5,208 ( 0.00%) .          .          .                       State::Empty { next } => Some(next),
        .          .          .          .                       State::Union { ref alternates } if alternates.len() == 1 => {
        .          .          .          .                           Some(alternates[0])
        .          .          .          .                       }
        .          .          .          .                       State::UnionReverse { ref alternates }
        .          .          .          .                           if alternates.len() == 1 =>
        .          .          .          .                       {
        .          .          .          .                           Some(alternates[0])
        .          .          .          .                       }
-- line 143 ----------------------------------------
-- line 151 ----------------------------------------
        .          .          .          .                       State::Empty { .. }
        .          .          .          .                       | State::ByteRange { .. }
        .          .          .          .                       | State::Look { .. }
        .          .          .          .                       | State::CaptureStart { .. }
        .          .          .          .                       | State::CaptureEnd { .. }
        .          .          .          .                       | State::Fail
        .          .          .          .                       | State::Match { .. } => 0,
        .          .          .          .                       State::Sparse { ref transitions } => {
   13,278 ( 0.00%) .          .          .                           transitions.len() * mem::size_of::<Transition>()
        .          .          .          .                       }
        .          .          .          .                       State::Union { ref alternates } => {
        .          .          .          .                           alternates.len() * mem::size_of::<StateID>()
        .          .          .          .                       }
        .          .          .          .                       State::UnionReverse { ref alternates } => {
        .          .          .          .                           alternates.len() * mem::size_of::<StateID>()
        .          .          .          .                       }
        .          .          .          .                   }
-- line 167 ----------------------------------------
-- line 304 ----------------------------------------
        .          .          .          .           /// let mut cache = re.create_cache();
        .          .          .          .           /// let mut caps = re.create_captures();
        .          .          .          .           /// let expected = Some(Match::must(0, 0..3));
        .          .          .          .           /// re.captures(&mut cache, "foo0", &mut caps);
        .          .          .          .           /// assert_eq!(expected, caps.get_match());
        .          .          .          .           ///
        .          .          .          .           /// # Ok::<(), Box<dyn std::error::Error>>(())
        .          .          .          .           /// ```
    7,414 ( 0.00%) .          .          .           #[derive(Clone, Debug, Default)]
        .          .          .          .           pub struct Builder {
        .          .          .          .               /// The ID of the pattern that we're currently building.
        .          .          .          .               ///
        .          .          .          .               /// Callers are required to set (and unset) this by calling
        .          .          .          .               /// {start,finish}_pattern. Otherwise, most methods will panic.
        .          .          .          .               pattern_id: Option<PatternID>,
        .          .          .          .               /// A sequence of intermediate NFA states. Once a state is added to this
        .          .          .          .               /// sequence, it is assigned a state ID equivalent to its index. Once a
-- line 320 ----------------------------------------
-- line 363 ----------------------------------------
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Clear this builder.
        .          .          .          .               ///
        .          .          .          .               /// Clearing removes all state associated with building an NFA, but does
        .          .          .          .               /// not reset configuration (such as size limits and whether the NFA
        .          .          .          .               /// should only match UTF-8). After clearing, the builder can be reused to
        .          .          .          .               /// assemble an entirely new NFA.
    1,400 ( 0.00%) .          .          .               pub fn clear(&mut self) {
      175 ( 0.00%) .          .          .                   self.pattern_id = None;
        .          .          .          .                   self.states.clear();
        .          .          .          .                   self.start_pattern.clear();
        .          .          .          .                   self.captures.clear();
      175 ( 0.00%) .          .          .                   self.memory_states = 0;
    1,400 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Assemble a [`NFA`] from the states added so far.
        .          .          .          .               ///
        .          .          .          .               /// After building an NFA, more states may be added and `build` may be
        .          .          .          .               /// called again. To reuse a builder to produce an entirely new NFA from
        .          .          .          .               /// scratch, call the [`clear`](Builder::clear) method first.
        .          .          .          .               ///
        .          .          .          .               /// `start_anchored` refers to the ID of the starting state that anchored
-- line 385 ----------------------------------------
-- line 402 ----------------------------------------
        .          .          .          .               /// # Panics
        .          .          .          .               ///
        .          .          .          .               /// If `start_pattern` was called, then `finish_pattern` must be called
        .          .          .          .               /// before `build`, otherwise this panics.
        .          .          .          .               ///
        .          .          .          .               /// This may panic for other invalid uses of a builder. For example, if
        .          .          .          .               /// a "start capture" state was added without a corresponding "end capture"
        .          .          .          .               /// state.
    1,225 ( 0.00%) .          .          .               pub fn build(
        .          .          .          .                   &self,
        .          .          .          .                   start_anchored: StateID,
        .          .          .          .                   start_unanchored: StateID,
        .          .          .          .               ) -> Result<NFA, BuildError> {
      175 ( 0.00%) .          .          .                   assert!(self.pattern_id.is_none(), "must call 'finish_pattern' first");
        .          .          .          .                   debug!(
        .          .          .          .                       "intermediate NFA compilation via builder is complete, \
        .          .          .          .                        intermediate NFA size: {} states, {} bytes on heap",
        .          .          .          .                       self.states.len(),
        .          .          .          .                       self.memory_usage(),
        .          .          .          .                   );
        .          .          .          .           
        .          .          .          .                   let mut nfa = nfa::Inner::default();
      175 ( 0.00%) .          .          .                   nfa.set_utf8(self.utf8);
      175 ( 0.00%) .          .          .                   nfa.set_reverse(self.reverse);
        .          .          .          .                   nfa.set_look_matcher(self.look_matcher.clone());
        .          .          .          .                   // A set of compiler internal state IDs that correspond to states
        .          .          .          .                   // that are exclusively epsilon transitions, i.e., goto instructions,
        .          .          .          .                   // combined with the state that they point to. This is used to
        .          .          .          .                   // record said states while transforming the compiler's internal NFA
        .          .          .          .                   // representation to the external form.
        .          .          .          .                   let mut empties = vec![];
        .          .          .          .                   // A map used to re-map state IDs when translating this builder's
-- line 433 ----------------------------------------
-- line 437 ----------------------------------------
        .          .          .          .           
        .          .          .          .                   nfa.set_starts(start_anchored, start_unanchored, &self.start_pattern);
        .          .          .          .                   nfa.set_captures(&self.captures).map_err(BuildError::captures)?;
        .          .          .          .                   // The idea here is to convert our intermediate states to their final
        .          .          .          .                   // form. The only real complexity here is the process of converting
        .          .          .          .                   // transitions, which are expressed in terms of state IDs. The new
        .          .          .          .                   // set of states will be smaller because of partial epsilon removal,
        .          .          .          .                   // so the state IDs will not be the same.
      175 ( 0.00%) .          .          .                   for (sid, state) in self.states.iter().with_state_ids() {
  446,285 ( 0.13%) .          .          .                       match *state {
   10,258 ( 0.00%) .          .          .                           State::Empty { next } => {
        .          .          .          .                               // Since we're removing empty states, we need to handle
        .          .          .          .                               // them later since we don't yet know which new state this
        .          .          .          .                               // empty state will be mapped to.
        .          .          .          .                               empties.push((sid, next));
        .          .          .          .                           }
   42,560 ( 0.01%) .          .          .                           State::ByteRange { trans } => {
  212,800 ( 0.06%) .          .          .                               remap[sid] = nfa.add(nfa::State::ByteRange { trans });
4,093,904 ( 1.18%) 2,055 ( 0.25%) 5 ( 1.54%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (42,560x)
        .          .          .          .                           }
        .          .          .          .                           State::Sparse { ref transitions } => {
   53,112 ( 0.02%) .          .          .                               remap[sid] = match transitions.len() {
        .          .          .          .                                   0 => nfa.add(nfa::State::Fail),
    8,652 ( 0.00%) .          .          .                                   1 => nfa.add(nfa::State::ByteRange {
    5,768 ( 0.00%) .          .          .                                       trans: transitions[0],
        .          .          .          .                                   }),
        .          .          .          .                                   _ => {
        .          .          .          .                                       let transitions =
   10,394 ( 0.00%) .          .          .                                           transitions.to_vec().into_boxed_slice();
        .          .          .          .                                       let sparse = SparseTransitions { transitions };
   31,182 ( 0.01%) .          .          .                                       nfa.add(nfa::State::Sparse(sparse))
        .          .          .          .                                   }
        .          .          .          .                               }
        .          .          .          .                           }
      245 ( 0.00%) .          .          .                           State::Look { look, next } => {
    1,225 ( 0.00%) .          .          .                               remap[sid] = nfa.add(nfa::State::Look { look, next });
   24,739 ( 0.01%) 32 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (245x)
        .          .          .          .                           }
      774 ( 0.00%) .          .          .                           State::CaptureStart { pattern_id, group_index, next } => {
        .          .          .          .                               // We can't remove this empty state because of the side
        .          .          .          .                               // effect of capturing an offset for this capture slot.
      774 ( 0.00%) .          .          .                               let slot = nfa
        .          .          .          .                                   .group_info()
        .          .          .          .                                   .slot(pattern_id, group_index.as_usize())
        .          .          .          .                                   .expect("invalid capture index");
        .          .          .          .                               let slot =
        .          .          .          .                                   SmallIndex::new(slot).expect("a small enough slot");
    6,192 ( 0.00%) .          .          .                               remap[sid] = nfa.add(nfa::State::Capture {
   54,283 ( 0.02%) 42 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (774x)
        .          .          .          .                                   next,
        .          .          .          .                                   pattern_id,
        .          .          .          .                                   group_index,
        .          .          .          .                                   slot,
        .          .          .          .                               });
        .          .          .          .                           }
      774 ( 0.00%) .          .          .                           State::CaptureEnd { pattern_id, group_index, next } => {
        .          .          .          .                               // We can't remove this empty state because of the side
        .          .          .          .                               // effect of capturing an offset for this capture slot.
        .          .          .          .                               // Also, this always succeeds because we check that all
        .          .          .          .                               // slot indices are valid for all capture indices when they
        .          .          .          .                               // are initially added.
      774 ( 0.00%) .          .          .                               let slot = nfa
        .          .          .          .                                   .group_info()
        .          .          .          .                                   .slot(pattern_id, group_index.as_usize())
        .          .          .          .                                   .expect("invalid capture index")
        .          .          .          .                                   .checked_add(1)
        .          .          .          .                                   .unwrap();
        .          .          .          .                               let slot =
        .          .          .          .                                   SmallIndex::new(slot).expect("a small enough slot");
    6,192 ( 0.00%) .          .          .                               remap[sid] = nfa.add(nfa::State::Capture {
   47,668 ( 0.01%) 66 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (774x)
        .          .          .          .                                   next,
        .          .          .          .                                   pattern_id,
        .          .          .          .                                   group_index,
        .          .          .          .                                   slot,
        .          .          .          .                               });
        .          .          .          .                           }
        .          .          .          .                           State::Union { ref alternates } => {
   97,328 ( 0.03%) .          .          .                               if alternates.is_empty() {
        .          .          .          .                                   remap[sid] = nfa.add(nfa::State::Fail);
        .          .          .          .                               } else if alternates.len() == 1 {
   29,170 ( 0.01%) .          .          .                                   empties.push((sid, alternates[0]));
        .          .          .          .                                   remap[sid] = alternates[0];
        .          .          .          .                               } else if alternates.len() == 2 {
   25,190 ( 0.01%) .          .          .                                   remap[sid] = nfa.add(nfa::State::BinaryUnion {
  335,742 ( 0.10%) 516 ( 0.06%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (5,038x)
   10,076 ( 0.00%) .          .          .                                       alt1: alternates[0],
        .          .          .          .                                       alt2: alternates[1],
        .          .          .          .                                   });
        .          .          .          .                               } else {
        .          .          .          .                                   let alternates =
    1,460 ( 0.00%) .          .          .                                       alternates.to_vec().into_boxed_slice();
    8,760 ( 0.00%) .          .          .                                   remap[sid] = nfa.add(nfa::State::Union { alternates });
  105,053 ( 0.03%) 90 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (1,460x)
        .          .          .          .                               }
        .          .          .          .                           }
        .          .          .          .                           State::UnionReverse { ref alternates } => {
      660 ( 0.00%) .          .          .                               if alternates.is_empty() {
        .          .          .          .                                   remap[sid] = nfa.add(nfa::State::Fail);
        .          .          .          .                               } else if alternates.len() == 1 {
        .          .          .          .                                   empties.push((sid, alternates[0]));
        .          .          .          .                                   remap[sid] = alternates[0];
        .          .          .          .                               } else if alternates.len() == 2 {
      660 ( 0.00%) .          .          .                                   remap[sid] = nfa.add(nfa::State::BinaryUnion {
   18,399 ( 0.01%) 4 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (110x)
      110 ( 0.00%) .          .          .                                       alt1: alternates[1],
      110 ( 0.00%) .          .          .                                       alt2: alternates[0],
        .          .          .          .                                   });
        .          .          .          .                               } else {
        .          .          .          .                                   let mut alternates =
        .          .          .          .                                       alternates.to_vec().into_boxed_slice();
        .          .          .          .                                   alternates.reverse();
        .          .          .          .                                   remap[sid] = nfa.add(nfa::State::Union { alternates });
        .          .          .          .                               }
        .          .          .          .                           }
        .          .          .          .                           State::Fail => {
        .          .          .          .                               remap[sid] = nfa.add(nfa::State::Fail);
        .          .          .          .                           }
      175 ( 0.00%) .          .          .                           State::Match { pattern_id } => {
      875 ( 0.00%) .          .          .                               remap[sid] = nfa.add(nfa::State::Match { pattern_id });
    9,151 ( 0.00%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (175x)
        .          .          .          .                           }
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   // Some of the new states still point to empty state IDs, so we need to
        .          .          .          .                   // follow each of them and remap the empty state IDs to their non-empty
        .          .          .          .                   // state IDs.
        .          .          .          .                   //
        .          .          .          .                   // We also keep track of which states we've already mapped. This helps
        .          .          .          .                   // avoid quadratic behavior in a long chain of empty states. For
        .          .          .          .                   // example, in 'a{0}{50000}'.
        .          .          .          .                   let mut remapped = vec![false; self.states.len()];
   24,843 ( 0.01%) .          .          .                   for &(empty_id, empty_next) in empties.iter() {
   49,686 ( 0.01%) .          .          .                       if remapped[empty_id] {
        .          .          .          .                           continue;
        .          .          .          .                       }
        .          .          .          .                       // empty states can point to other empty states, forming a chain.
        .          .          .          .                       // So we must follow the chain until the end, which must end at
        .          .          .          .                       // a non-empty state, and therefore, a state that is correctly
        .          .          .          .                       // remapped. We are guaranteed to terminate because our compiler
        .          .          .          .                       // never builds a loop among only empty states.
        .          .          .          .                       let mut new_next = empty_next;
        .          .          .          .                       while let Some(next) = self.states[new_next].goto() {
        .          .          .          .                           new_next = next;
        .          .          .          .                       }
   47,708 ( 0.01%) .          .          .                       remap[empty_id] = remap[new_next];
   23,854 ( 0.01%) .          .          .                       remapped[empty_id] = true;
        .          .          .          .           
        .          .          .          .                       // Now that we've remapped the main 'empty_id' above, we re-follow
        .          .          .          .                       // the chain from above and remap every empty state we found along
        .          .          .          .                       // the way to our ultimate non-empty target. We are careful to set
        .          .          .          .                       // 'remapped' to true for each such state. We thus will not need
        .          .          .          .                       // to re-compute this chain for any subsequent empty states in
        .          .          .          .                       // 'empties' that are part of this chain.
        .          .          .          .                       let mut next2 = empty_next;
        .          .          .          .                       while let Some(next) = self.states[next2].goto() {
    5,694 ( 0.00%) .          .          .                           remap[next2] = remap[new_next];
    2,847 ( 0.00%) .          .          .                           remapped[next2] = true;
        .          .          .          .                           next2 = next;
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   // Finally remap all of the state IDs.
      700 ( 0.00%) .          .          .                   nfa.remap(&remap);
1,236,667 ( 0.36%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::remap (175x)
    1,050 ( 0.00%) .          .          .                   let final_nfa = nfa.into_nfa();
1,610,640 ( 0.46%) 1,255 ( 0.15%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x)
   11,375 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x)
        .          .          .          .                   debug!(
        .          .          .          .                       "NFA compilation via builder complete, \
        .          .          .          .                        final NFA size: {} states, {} bytes on heap, \
        .          .          .          .                        has empty? {:?}, utf8? {:?}",
        .          .          .          .                       final_nfa.states().len(),
        .          .          .          .                       final_nfa.memory_usage(),
        .          .          .          .                       final_nfa.has_empty(),
        .          .          .          .                       final_nfa.is_utf8(),
        .          .          .          .                   );
      350 ( 0.00%) .          .          .                   Ok(final_nfa)
    1,575 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Start the assembly of a pattern in this NFA.
        .          .          .          .               ///
        .          .          .          .               /// Upon success, this returns the identifier for the new pattern.
        .          .          .          .               /// Identifiers start at `0` and are incremented by 1 for each new pattern.
        .          .          .          .               ///
        .          .          .          .               /// It is necessary to call this routine before adding capturing states.
        .          .          .          .               /// Otherwise, any other NFA state may be added before starting a pattern.
-- line 611 ----------------------------------------
-- line 615 ----------------------------------------
        .          .          .          .               /// If the pattern identifier space is exhausted, then this returns an
        .          .          .          .               /// error.
        .          .          .          .               ///
        .          .          .          .               /// # Panics
        .          .          .          .               ///
        .          .          .          .               /// If this is called while assembling another pattern (i.e., before
        .          .          .          .               /// `finish_pattern` is called), then this panics.
        .          .          .          .               pub fn start_pattern(&mut self) -> Result<PatternID, BuildError> {
      175 ( 0.00%) .          .          .                   assert!(self.pattern_id.is_none(), "must call 'finish_pattern' first");
        .          .          .          .           
        .          .          .          .                   let proposed = self.start_pattern.len();
        .          .          .          .                   let pid = PatternID::new(proposed)
        .          .          .          .                       .map_err(|_| BuildError::too_many_patterns(proposed))?;
      350 ( 0.00%) .          .          .                   self.pattern_id = Some(pid);
        .          .          .          .                   // This gets filled in when 'finish_pattern' is called.
        .          .          .          .                   self.start_pattern.push(StateID::ZERO);
        .          .          .          .                   Ok(pid)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Finish the assembly of a pattern in this NFA.
        .          .          .          .               ///
        .          .          .          .               /// Upon success, this returns the identifier for the new pattern.
-- line 636 ----------------------------------------
-- line 650 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// If this is called without a corresponding `start_pattern` call, then
        .          .          .          .               /// this panics.
        .          .          .          .               pub fn finish_pattern(
        .          .          .          .                   &mut self,
        .          .          .          .                   start_id: StateID,
        .          .          .          .               ) -> Result<PatternID, BuildError> {
        .          .          .          .                   let pid = self.current_pattern_id();
      175 ( 0.00%) .          .          .                   self.start_pattern[pid] = start_id;
      175 ( 0.00%) .          .          .                   self.pattern_id = None;
        .          .          .          .                   Ok(pid)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the pattern identifier of the current pattern.
        .          .          .          .               ///
        .          .          .          .               /// # Panics
        .          .          .          .               ///
        .          .          .          .               /// If this doesn't occur after a `start_pattern` call and before the
        .          .          .          .               /// corresponding `finish_pattern` call, then this panics.
        .          .          .          .               pub fn current_pattern_id(&self) -> PatternID {
    1,124 ( 0.00%) .          .          .                   self.pattern_id.expect("must call 'start_pattern' first")
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the number of patterns added to this builder so far.
        .          .          .          .               ///
        .          .          .          .               /// This only includes patterns that have had `finish_pattern` called
        .          .          .          .               /// for them.
        .          .          .          .               pub fn pattern_len(&self) -> usize {
        .          .          .          .                   self.start_pattern.len()
-- line 678 ----------------------------------------
-- line 685 ----------------------------------------
        .          .          .          .               /// building the final [`NFA`] (which has no such "empty" states), but they
        .          .          .          .               /// can be quite useful in the construction process of an NFA.
        .          .          .          .               ///
        .          .          .          .               /// # Errors
        .          .          .          .               ///
        .          .          .          .               /// This returns an error if the state identifier space is exhausted, or if
        .          .          .          .               /// the configured heap size limit has been exceeded.
        .          .          .          .               pub fn add_empty(&mut self) -> Result<StateID, BuildError> {
   51,229 ( 0.01%) .          .          .                   self.add(State::Empty { next: StateID::ZERO })
   26,901 ( 0.01%) 12 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (495x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Add a "union" NFA state.
        .          .          .          .               ///
        .          .          .          .               /// A "union" NFA state that contains zero or more unconditional epsilon
        .          .          .          .               /// transitions to other NFA states. The order of these transitions
        .          .          .          .               /// reflects a priority order where earlier transitions are preferred over
        .          .          .          .               /// later transitions.
-- line 701 ----------------------------------------
-- line 709 ----------------------------------------
        .          .          .          .               /// # Errors
        .          .          .          .               ///
        .          .          .          .               /// This returns an error if the state identifier space is exhausted, or if
        .          .          .          .               /// the configured heap size limit has been exceeded.
        .          .          .          .               pub fn add_union(
        .          .          .          .                   &mut self,
        .          .          .          .                   alternates: Vec<StateID>,
        .          .          .          .               ) -> Result<StateID, BuildError> {
   98,157 ( 0.03%) .          .          .                   self.add(State::Union { alternates })
1,292,333 ( 0.37%) 564 ( 0.07%) 9 ( 2.78%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (16,455x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Add a "reverse union" NFA state.
        .          .          .          .               ///
        .          .          .          .               /// A "reverse union" NFA state contains zero or more unconditional epsilon
        .          .          .          .               /// transitions to other NFA states. The order of these transitions
        .          .          .          .               /// reflects a priority order where later transitions are preferred
        .          .          .          .               /// over earlier transitions. This is an inverted priority order when
-- line 725 ----------------------------------------
-- line 735 ----------------------------------------
        .          .          .          .               /// # Errors
        .          .          .          .               ///
        .          .          .          .               /// This returns an error if the state identifier space is exhausted, or if
        .          .          .          .               /// the configured heap size limit has been exceeded.
        .          .          .          .               pub fn add_union_reverse(
        .          .          .          .                   &mut self,
        .          .          .          .                   alternates: Vec<StateID>,
        .          .          .          .               ) -> Result<StateID, BuildError> {
      220 ( 0.00%) .          .          .                   self.add(State::UnionReverse { alternates })
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Add a "range" NFA state.
        .          .          .          .               ///
        .          .          .          .               /// A "range" NFA state is a state with one outgoing transition to another
        .          .          .          .               /// state, where that transition may only be followed if the current input
        .          .          .          .               /// byte falls between a range of bytes given.
        .          .          .          .               ///
-- line 751 ----------------------------------------
-- line 752 ----------------------------------------
        .          .          .          .               /// # Errors
        .          .          .          .               ///
        .          .          .          .               /// This returns an error if the state identifier space is exhausted, or if
        .          .          .          .               /// the configured heap size limit has been exceeded.
        .          .          .          .               pub fn add_range(
        .          .          .          .                   &mut self,
        .          .          .          .                   trans: Transition,
        .          .          .          .               ) -> Result<StateID, BuildError> {
  215,002 ( 0.06%) .          .          .                   self.add(State::ByteRange { trans })
2,584,325 ( 0.74%) 1,790 ( 0.22%) 2 ( 0.62%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (32,051x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Add a "sparse" NFA state.
        .          .          .          .               ///
        .          .          .          .               /// A "sparse" NFA state contains zero or more outgoing transitions, where
        .          .          .          .               /// the transition to be followed (if any) is chosen based on whether the
        .          .          .          .               /// current input byte falls in the range of one such transition. The
        .          .          .          .               /// transitions given *must* be non-overlapping and in ascending order. (A
-- line 768 ----------------------------------------
-- line 789 ----------------------------------------
        .          .          .          .               /// # Panics
        .          .          .          .               ///
        .          .          .          .               /// This routine _may_ panic if the transitions given overlap or are not
        .          .          .          .               /// in ascending order.
        .          .          .          .               pub fn add_sparse(
        .          .          .          .                   &mut self,
        .          .          .          .                   transitions: Vec<Transition>,
        .          .          .          .               ) -> Result<StateID, BuildError> {
   13,201 ( 0.00%) .          .          .                   self.add(State::Sparse { transitions })
  103,353 ( 0.03%) 46 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (773x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Add a "look" NFA state.
        .          .          .          .               ///
        .          .          .          .               /// A "look" NFA state corresponds to a state with exactly one
        .          .          .          .               /// *conditional* epsilon transition to another NFA state. Namely, it
        .          .          .          .               /// represents one of a small set of simplistic look-around operators.
        .          .          .          .               ///
-- line 805 ----------------------------------------
-- line 810 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// This returns an error if the state identifier space is exhausted, or if
        .          .          .          .               /// the configured heap size limit has been exceeded.
        .          .          .          .               pub fn add_look(
        .          .          .          .                   &mut self,
        .          .          .          .                   next: StateID,
        .          .          .          .                   look: Look,
        .          .          .          .               ) -> Result<StateID, BuildError> {
      490 ( 0.00%) .          .          .                   self.add(State::Look { look, next })
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Add a "start capture" NFA state.
        .          .          .          .               ///
        .          .          .          .               /// A "start capture" NFA state corresponds to a state with exactly one
        .          .          .          .               /// outgoing unconditional epsilon transition to another state. Unlike
        .          .          .          .               /// "empty" states, a "start capture" state also carries with it an
        .          .          .          .               /// instruction for saving the current position of input to a particular
-- line 826 ----------------------------------------
-- line 983 ----------------------------------------
        .          .          .          .               /// assert_eq!(Some(PatternID::must(1)), caps[3].pattern());
        .          .          .          .               /// assert_eq!(Some(Span::from(7..8)), caps[3].get_group_by_name("foo"));
        .          .          .          .               ///
        .          .          .          .               /// assert_eq!(Some(PatternID::must(1)), caps[4].pattern());
        .          .          .          .               /// assert_eq!(Some(Span::from(8..9)), caps[4].get_group_by_name("foo"));
        .          .          .          .               ///
        .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
        .          .          .          .               /// ```
    5,418 ( 0.00%) .          .          .               pub fn add_capture_start(
        .          .          .          .                   &mut self,
        .          .          .          .                   next: StateID,
        .          .          .          .                   group_index: u32,
        .          .          .          .                   name: Option<Arc<str>>,
        .          .          .          .               ) -> Result<StateID, BuildError> {
        .          .          .          .                   let pid = self.current_pattern_id();
        .          .          .          .                   let group_index = match SmallIndex::try_from(group_index) {
        .          .          .          .                       Err(_) => {
        .          .          .          .                           return Err(BuildError::invalid_capture_index(group_index))
        .          .          .          .                       }
        .          .          .          .                       Ok(group_index) => group_index,
        .          .          .          .                   };
        .          .          .          .                   // Make sure we have space to insert our (pid,index)|-->name mapping.
    2,322 ( 0.00%) .          .          .                   if pid.as_usize() >= self.captures.len() {
        .          .          .          .                       for _ in 0..=(pid.as_usize() - self.captures.len()) {
        .          .          .          .                           self.captures.push(vec![]);
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   // In the case where 'group_index < self.captures[pid].len()', it means
        .          .          .          .                   // that we are adding a duplicate capture group. This is somewhat
        .          .          .          .                   // weird, but permissible because the capture group itself can be
        .          .          .          .                   // repeated in the syntax. For example, '([a-z]){4}' will produce 4
        .          .          .          .                   // capture groups. In practice, only the last will be set at search
        .          .          .          .                   // time when a match occurs. For duplicates, we don't need to push
        .          .          .          .                   // anything other than a CaptureStart NFA state.
    2,322 ( 0.00%) .          .          .                   if group_index.as_usize() >= self.captures[pid].len() {
        .          .          .          .                       // For discontiguous indices, push placeholders for earlier capture
        .          .          .          .                       // groups that weren't explicitly added.
        .          .          .          .                       for _ in 0..(group_index.as_usize() - self.captures[pid].len()) {
        .          .          .          .                           self.captures[pid].push(None);
        .          .          .          .                       }
    1,548 ( 0.00%) .          .          .                       self.captures[pid].push(name);
        .          .          .          .                   }
    7,740 ( 0.00%) .          .          .                   self.add(State::CaptureStart { pattern_id: pid, group_index, next })
   54,218 ( 0.02%) 52 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (774x)
    6,966 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Add a "end capture" NFA state.
        .          .          .          .               ///
        .          .          .          .               /// A "end capture" NFA state corresponds to a state with exactly one
        .          .          .          .               /// outgoing unconditional epsilon transition to another state. Unlike
        .          .          .          .               /// "empty" states, a "end capture" state also carries with it an
        .          .          .          .               /// instruction for saving the current position of input to a particular
        .          .          .          .               /// location in memory. NFA simulations, like the Pike VM, may use this
-- line 1034 ----------------------------------------
-- line 1062 ----------------------------------------
        .          .          .          .               ) -> Result<StateID, BuildError> {
        .          .          .          .                   let pid = self.current_pattern_id();
        .          .          .          .                   let group_index = match SmallIndex::try_from(group_index) {
        .          .          .          .                       Err(_) => {
        .          .          .          .                           return Err(BuildError::invalid_capture_index(group_index))
        .          .          .          .                       }
        .          .          .          .                       Ok(group_index) => group_index,
        .          .          .          .                   };
    6,192 ( 0.00%) .          .          .                   self.add(State::CaptureEnd { pattern_id: pid, group_index, next })
    7,072 ( 0.00%) 12 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (81x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Adds a "fail" NFA state.
        .          .          .          .               ///
        .          .          .          .               /// A "fail" state is simply a state that has no outgoing transitions. It
        .          .          .          .               /// acts as a way to cause a search to stop without reporting a match.
        .          .          .          .               /// For example, one way to represent an NFA with zero patterns is with a
        .          .          .          .               /// single "fail" state.
-- line 1078 ----------------------------------------
-- line 1099 ----------------------------------------
        .          .          .          .               /// the configured heap size limit has been exceeded.
        .          .          .          .               ///
        .          .          .          .               /// # Panics
        .          .          .          .               ///
        .          .          .          .               /// This must be called after a `start_pattern` call but before the
        .          .          .          .               /// corresponding `finish_pattern` call. Otherwise, it panics.
        .          .          .          .               pub fn add_match(&mut self) -> Result<StateID, BuildError> {
        .          .          .          .                   let pattern_id = self.current_pattern_id();
    1,050 ( 0.00%) .          .          .                   let sid = self.add(State::Match { pattern_id })?;
   10,831 ( 0.00%) 12 ( 0.00%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (175x)
        .          .          .          .                   Ok(sid)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// The common implementation of "add a state." It handles the common
        .          .          .          .               /// error cases of state ID exhausting (by owning state ID allocation) and
        .          .          .          .               /// whether the size limit has been exceeded.
  624,799 ( 0.18%) .          .          .               fn add(&mut self, state: State) -> Result<StateID, BuildError> {
        .          .          .          .                   let id = StateID::new(self.states.len())
        .          .          .          .                       .map_err(|_| BuildError::too_many_states(self.states.len()))?;
  624,799 ( 0.18%) .          .          .                   self.memory_states += state.memory_usage();
        .          .          .          .                   self.states.push(state);
        .          .          .          .                   self.check_size_limit()?;
  178,514 ( 0.05%) .          .          .                   Ok(id)
  535,542 ( 0.15%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Add a transition from one state to another.
        .          .          .          .               ///
        .          .          .          .               /// This routine is called "patch" since it is very common to add the
        .          .          .          .               /// states you want, typically with "dummy" state ID transitions, and then
        .          .          .          .               /// "patch" in the real state IDs later. This is because you don't always
        .          .          .          .               /// know all of the necessary state IDs to add because they might not
        .          .          .          .               /// exist yet.
-- line 1129 ----------------------------------------
-- line 1135 ----------------------------------------
        .          .          .          .               /// new transition (as in the case of a "union" state).
        .          .          .          .               ///
        .          .          .          .               /// # Panics
        .          .          .          .               ///
        .          .          .          .               /// This panics if `from` corresponds to a "sparse" state. When "sparse"
        .          .          .          .               /// states are added, there is no way to patch them after-the-fact. (If you
        .          .          .          .               /// have a use case where this would be helpful, please file an issue. It
        .          .          .          .               /// will likely require a new API.)
  480,408 ( 0.14%) .          .          .               pub fn patch(
        .          .          .          .                   &mut self,
        .          .          .          .                   from: StateID,
        .          .          .          .                   to: StateID,
        .          .          .          .               ) -> Result<(), BuildError> {
        .          .          .          .                   let old_memory_states = self.memory_states;
   60,051 ( 0.02%) .          .          .                   match self.states[from] {
        .          .          .          .                       State::Empty { ref mut next } => {
        .          .          .          .                           *next = to;
        .          .          .          .                       }
        .          .          .          .                       State::ByteRange { ref mut trans } => {
        .          .          .          .                           trans.next = to;
        .          .          .          .                       }
        .          .          .          .                       State::Sparse { .. } => {
        .          .          .          .                           panic!("cannot patch from a sparse NFA state")
-- line 1157 ----------------------------------------
-- line 1175 ----------------------------------------
        .          .          .          .                       }
        .          .          .          .                       State::Fail => {}
        .          .          .          .                       State::Match { .. } => {}
        .          .          .          .                   }
        .          .          .          .                   if old_memory_states != self.memory_states {
        .          .          .          .                       self.check_size_limit()?;
        .          .          .          .                   }
        .          .          .          .                   Ok(())
  540,459 ( 0.16%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Set whether the NFA produced by this builder should only match UTF-8.
        .          .          .          .               ///
        .          .          .          .               /// This should be set when both of the following are true:
        .          .          .          .               ///
        .          .          .          .               /// 1. The caller guarantees that the NFA created by this build will only
        .          .          .          .               /// report non-empty matches with spans that are valid UTF-8.
        .          .          .          .               /// 2. The caller desires regex engines using this NFA to avoid reporting
-- line 1191 ----------------------------------------
-- line 1212 ----------------------------------------
        .          .          .          .               /// UTF-8, you almost certainly do not want to enable this option.
        .          .          .          .               /// Similarly, if you are running the NFA on strings that *are* guaranteed
        .          .          .          .               /// to be valid UTF-8, then you almost certainly want to enable this option
        .          .          .          .               /// unless you can guarantee that your NFA will never produce a zero-width
        .          .          .          .               /// match.
        .          .          .          .               ///
        .          .          .          .               /// It is disabled by default.
        .          .          .          .               pub fn set_utf8(&mut self, yes: bool) {
      175 ( 0.00%) .          .          .                   self.utf8 = yes;
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns whether UTF-8 mode is enabled for this builder.
        .          .          .          .               ///
        .          .          .          .               /// See [`Builder::set_utf8`] for more details about what "UTF-8 mode" is.
        .          .          .          .               pub fn get_utf8(&self) -> bool {
        .          .          .          .                   self.utf8
        .          .          .          .               }
-- line 1228 ----------------------------------------
-- line 1232 ----------------------------------------
        .          .          .          .               /// should be matched by moving backwards through a haystack, from a higher
        .          .          .          .               /// memory address to a lower memory address.
        .          .          .          .               ///
        .          .          .          .               /// See also [`NFA::is_reverse`] for more details.
        .          .          .          .               ///
        .          .          .          .               /// This is disabled by default, which means NFAs are by default matched
        .          .          .          .               /// in the forward direction.
        .          .          .          .               pub fn set_reverse(&mut self, yes: bool) {
      175 ( 0.00%) .          .          .                   self.reverse = yes;
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns whether reverse mode is enabled for this builder.
        .          .          .          .               ///
        .          .          .          .               /// See [`Builder::set_reverse`] for more details about what "reverse mode"
        .          .          .          .               /// is.
        .          .          .          .               pub fn get_reverse(&self) -> bool {
        .          .          .          .                   self.reverse
-- line 1248 ----------------------------------------
-- line 1250 ----------------------------------------
        .          .          .          .           
        .          .          .          .               /// Sets the look-around matcher that should be used for the resulting NFA.
        .          .          .          .               ///
        .          .          .          .               /// A look-around matcher can be used to configure how look-around
        .          .          .          .               /// assertions are matched. For example, a matcher might carry
        .          .          .          .               /// configuration that changes the line terminator used for `(?m:^)` and
        .          .          .          .               /// `(?m:$)` assertions.
        .          .          .          .               pub fn set_look_matcher(&mut self, m: LookMatcher) {
      175 ( 0.00%) .          .          .                   self.look_matcher = m;
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the look-around matcher used for this builder.
        .          .          .          .               ///
        .          .          .          .               /// If a matcher was not explicitly set, then `LookMatcher::default()` is
        .          .          .          .               /// returned.
        .          .          .          .               pub fn get_look_matcher(&self) -> &LookMatcher {
        .          .          .          .                   &self.look_matcher
-- line 1266 ----------------------------------------
-- line 1272 ----------------------------------------
        .          .          .          .               /// fits within the given size limit. If it doesn't, then an error is
        .          .          .          .               /// returned.
        .          .          .          .               ///
        .          .          .          .               /// By default, there is no configured size limit.
        .          .          .          .               pub fn set_size_limit(
        .          .          .          .                   &mut self,
        .          .          .          .                   limit: Option<usize>,
        .          .          .          .               ) -> Result<(), BuildError> {
      350 ( 0.00%) .          .          .                   self.size_limit = limit;
        .          .          .          .                   self.check_size_limit()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return the currently configured size limit.
        .          .          .          .               ///
        .          .          .          .               /// By default, this returns `None`, which corresponds to no configured
        .          .          .          .               /// size limit.
        .          .          .          .               pub fn get_size_limit(&self) -> Option<usize> {
-- line 1288 ----------------------------------------
-- line 1292 ----------------------------------------
        .          .          .          .               /// Returns the heap memory usage, in bytes, used by the NFA states added
        .          .          .          .               /// so far.
        .          .          .          .               ///
        .          .          .          .               /// Note that this is an approximation of how big the final NFA will be.
        .          .          .          .               /// In practice, the final NFA will likely be a bit smaller because of
        .          .          .          .               /// its simpler state representation. (For example, using things like
        .          .          .          .               /// `Box<[StateID]>` instead of `Vec<StateID>`.)
        .          .          .          .               pub fn memory_usage(&self) -> usize {
  210,762 ( 0.06%) .          .          .                   self.states.len() * mem::size_of::<State>() + self.memory_states
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn check_size_limit(&self) -> Result<(), BuildError> {
  315,968 ( 0.09%) .          .          .                   if let Some(limit) = self.size_limit {
  210,762 ( 0.06%) .          .          .                       if self.memory_usage() > limit {
        .          .          .          .                           return Err(BuildError::exceeded_size_limit(limit));
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   Ok(())
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[cfg(test)]
-- line 1313 ----------------------------------------

1,222,428 ( 0.35%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/builder.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/api.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 18 ----------------------------------------
    .          .          .          .           /// and instead only supports leftmost-first or leftmost-longest. Namely,
    .          .          .          .           /// "standard" semantics cannot be easily supported by packed searchers.
    .          .          .          .           ///
    .          .          .          .           /// For more information on the distinction between leftmost-first and
    .          .          .          .           /// leftmost-longest, see the docs on the top-level `MatchKind` type.
    .          .          .          .           ///
    .          .          .          .           /// Unlike the top-level `MatchKind` type, the default match semantics for this
    .          .          .          .           /// type are leftmost-first.
   48 ( 0.00%) .          .          .           #[derive(Clone, Copy, Debug, Eq, PartialEq)]
    .          .          .          .           #[non_exhaustive]
    .          .          .          .           pub enum MatchKind {
    .          .          .          .               /// Use leftmost-first match semantics, which reports leftmost matches.
    .          .          .          .               /// When there are multiple possible leftmost matches, the match
    .          .          .          .               /// corresponding to the pattern that appeared earlier when constructing
    .          .          .          .               /// the automaton is reported.
    .          .          .          .               ///
    .          .          .          .               /// This is the default.
-- line 34 ----------------------------------------
-- line 78 ----------------------------------------
    .          .          .          .           /// # if cfg!(all(feature = "std", any(
    .          .          .          .           /// #     target_arch = "x86_64", target_arch = "aarch64",
    .          .          .          .           /// # ))) {
    .          .          .          .           /// #     example().unwrap()
    .          .          .          .           /// # } else {
    .          .          .          .           /// #     assert!(example().is_none());
    .          .          .          .           /// # }
    .          .          .          .           /// ```
  144 ( 0.00%) .          .          .           #[derive(Clone, Debug)]
    .          .          .          .           pub struct Config {
    .          .          .          .               kind: MatchKind,
    .          .          .          .               force: Option<ForceAlgorithm>,
    .          .          .          .               only_teddy_fat: Option<bool>,
    .          .          .          .               only_teddy_256bit: Option<bool>,
    .          .          .          .               heuristic_pattern_limits: bool,
    .          .          .          .           }
    .          .          .          .           
-- line 94 ----------------------------------------
-- line 107 ----------------------------------------
    .          .          .          .               fn default() -> Config {
    .          .          .          .                   Config::new()
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl Config {
    .          .          .          .               /// Create a new default configuration. A default configuration uses
    .          .          .          .               /// leftmost-first match semantics.
   48 ( 0.00%) .          .          .               pub fn new() -> Config {
    .          .          .          .                   Config {
    .          .          .          .                       kind: MatchKind::LeftmostFirst,
    .          .          .          .                       force: None,
    .          .          .          .                       only_teddy_fat: None,
    .          .          .          .                       only_teddy_256bit: None,
    .          .          .          .                       heuristic_pattern_limits: true,
    .          .          .          .                   }
   48 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Create a packed builder from this configuration. The builder can be
    .          .          .          .               /// used to accumulate patterns and create a [`Searcher`] from them.
   48 ( 0.00%) .          .          .               pub fn builder(&self) -> Builder {
    .          .          .          .                   Builder::from_config(self.clone())
   48 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Set the match semantics for this configuration.
   48 ( 0.00%) .          .          .               pub fn match_kind(&mut self, kind: MatchKind) -> &mut Config {
   48 ( 0.00%) .          .          .                   self.kind = kind;
    .          .          .          .                   self
   48 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// An undocumented method for forcing the use of the Teddy algorithm.
    .          .          .          .               ///
    .          .          .          .               /// This is only exposed for more precise testing and benchmarks. Callers
    .          .          .          .               /// should not use it as it is not part of the API stability guarantees of
    .          .          .          .               /// this crate.
    .          .          .          .               #[doc(hidden)]
    .          .          .          .               pub fn only_teddy(&mut self, yes: bool) -> &mut Config {
-- line 143 ----------------------------------------
-- line 241 ----------------------------------------
    .          .          .          .           impl Builder {
    .          .          .          .               /// Create a new builder for constructing a multi-pattern searcher. This
    .          .          .          .               /// constructor uses the default configuration.
    .          .          .          .               pub fn new() -> Builder {
    .          .          .          .                   Builder::from_config(Config::new())
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               fn from_config(config: Config) -> Builder {
  192 ( 0.00%) .          .          .                   Builder { config, inert: false, patterns: Patterns::new() }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Build a searcher from the patterns added to this builder so far.
  768 ( 0.00%) .          .          .               pub fn build(&self) -> Option<Searcher> {
  384 ( 0.00%) .          .          .                   if self.inert || self.patterns.is_empty() {
   96 ( 0.00%) .          .          .                       return None;
    .          .          .          .                   }
    .          .          .          .                   let mut patterns = self.patterns.clone();
   96 ( 0.00%) .          .          .                   patterns.set_match_kind(self.config.kind);
  528 ( 0.00%) .          .          .                   let patterns = Arc::new(patterns);
    .          .          .          .                   let rabinkarp = RabinKarp::new(&patterns);
    .          .          .          .                   // Effectively, we only want to return a searcher if we can use Teddy,
    .          .          .          .                   // since Teddy is our only fast packed searcher at the moment.
    .          .          .          .                   // Rabin-Karp is only used when searching haystacks smaller than what
    .          .          .          .                   // Teddy can support. Thus, the only way to get a Rabin-Karp searcher
    .          .          .          .                   // is to force it using undocumented APIs (for tests/benchmarks).
  174 ( 0.00%) .          .          .                   let (search_kind, minimum_len) = match self.config.force {
    .          .          .          .                       None | Some(ForceAlgorithm::Teddy) => {
    .          .          .          .                           debug!("trying to build Teddy packed matcher");
  144 ( 0.00%) .          .          .                           let teddy = match self.build_teddy(Arc::clone(&patterns)) {
    9 ( 0.00%) .          .          .                               None => return None,
  117 ( 0.00%) .          .          .                               Some(teddy) => teddy,
    .          .          .          .                           };
    .          .          .          .                           let minimum_len = teddy.minimum_len();
    .          .          .          .                           (SearchKind::Teddy(teddy), minimum_len)
    .          .          .          .                       }
    .          .          .          .                       Some(ForceAlgorithm::RabinKarp) => {
    .          .          .          .                           debug!("using Rabin-Karp packed matcher");
    .          .          .          .                           (SearchKind::RabinKarp, 0)
    .          .          .          .                       }
    .          .          .          .                   };
  516 ( 0.00%) .          .          .                   Some(Searcher { patterns, rabinkarp, search_kind, minimum_len })
  864 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               fn build_teddy(&self, patterns: Arc<Patterns>) -> Option<teddy::Searcher> {
   48 ( 0.00%) .          .          .                   teddy::Builder::new()
1,016,373 ( 0.29%) 3,469 ( 0.43%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/teddy/builder.rs:aho_corasick::packed::teddy::builder::Builder::build (48x)
   48 ( 0.00%) .          .          .                       .only_256bit(self.config.only_teddy_256bit)
   48 ( 0.00%) .          .          .                       .only_fat(self.config.only_teddy_fat)
   48 ( 0.00%) .          .          .                       .heuristic_pattern_limits(self.config.heuristic_pattern_limits)
    .          .          .          .                       .build(patterns)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Add the given pattern to this set to match.
    .          .          .          .               ///
    .          .          .          .               /// The order in which patterns are added is significant. Namely, when
    .          .          .          .               /// using leftmost-first match semantics, then when multiple patterns can
    .          .          .          .               /// match at a particular location, the pattern that was added first is
    .          .          .          .               /// used as the match.
    .          .          .          .               ///
    .          .          .          .               /// If the number of patterns added exceeds the amount supported by packed
    .          .          .          .               /// searchers, then the builder will stop accumulating patterns and render
    .          .          .          .               /// itself inert. At this point, constructing a searcher will always return
    .          .          .          .               /// `None`.
    .          .          .          .               pub fn add<P: AsRef<[u8]>>(&mut self, pattern: P) -> &mut Builder {
5,912 ( 0.00%) .          .          .                   if self.inert {
    .          .          .          .                       return self;
5,576 ( 0.00%) .          .          .                   } else if self.patterns.len() >= PATTERN_LIMIT {
2,788 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::packed::pattern::Patterns::len (1,394x)
    .          .          .          .                       self.inert = true;
    .          .          .          .                       self.patterns.reset();
    .          .          .          .                       return self;
    .          .          .          .                   }
    .          .          .          .                   // Just in case PATTERN_LIMIT increases beyond u16::MAX.
5,576 ( 0.00%) .          .          .                   assert!(self.patterns.len() <= core::u16::MAX as usize);
2,788 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:aho_corasick::packed::pattern::Patterns::len (1,394x)
    .          .          .          .           
    .          .          .          .                   let pattern = pattern.as_ref();
2,788 ( 0.00%) .          .          .                   if pattern.is_empty() {
    .          .          .          .                       self.inert = true;
    .          .          .          .                       self.patterns.reset();
    .          .          .          .                       return self;
    .          .          .          .                   }
5,576 ( 0.00%) .          .          .                   self.patterns.add(pattern);
642,264 ( 0.18%) 3,137 ( 0.39%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/pattern.rs:aho_corasick::packed::pattern::Patterns::add (1,394x)
    .          .          .          .                   self
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Add the given iterator of patterns to this set to match.
    .          .          .          .               ///
    .          .          .          .               /// The iterator must yield elements that can be converted into a `&[u8]`.
    .          .          .          .               ///
    .          .          .          .               /// The order in which patterns are added is significant. Namely, when
-- line 328 ----------------------------------------
-- line 329 ----------------------------------------
    .          .          .          .               /// using leftmost-first match semantics, then when multiple patterns can
    .          .          .          .               /// match at a particular location, the pattern that was added first is
    .          .          .          .               /// used as the match.
    .          .          .          .               ///
    .          .          .          .               /// If the number of patterns added exceeds the amount supported by packed
    .          .          .          .               /// searchers, then the builder will stop accumulating patterns and render
    .          .          .          .               /// itself inert. At this point, constructing a searcher will always return
    .          .          .          .               /// `None`.
  384 ( 0.00%) .          .          .               pub fn extend<I, P>(&mut self, patterns: I) -> &mut Builder
    .          .          .          .               where
    .          .          .          .                   I: IntoIterator<Item = P>,
    .          .          .          .                   P: AsRef<[u8]>,
    .          .          .          .               {
    .          .          .          .                   for p in patterns {
    .          .          .          .                       self.add(p);
    .          .          .          .                   }
    .          .          .          .                   self
  432 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the number of patterns added to this builder.
    .          .          .          .               pub fn len(&self) -> usize {
    .          .          .          .                   self.patterns.len()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the length, in bytes, of the shortest pattern added.
    .          .          .          .               pub fn minimum_len(&self) -> usize {
-- line 354 ----------------------------------------
-- line 527 ----------------------------------------
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn find_in<B: AsRef<[u8]>>(
    .          .          .          .                   &self,
    .          .          .          .                   haystack: B,
    .          .          .          .                   span: Span,
    .          .          .          .               ) -> Option<Match> {
    .          .          .          .                   let haystack = haystack.as_ref();
   39 ( 0.00%) .          .          .                   match self.search_kind {
    .          .          .          .                       SearchKind::Teddy(ref teddy) => {
   26 ( 0.00%) .          .          .                           if haystack[span].len() < teddy.minimum_len() {
    2 ( 0.00%) .          .          .                               return self.find_in_slow(haystack, span);
  199 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/api.rs:aho_corasick::packed::api::Searcher::find_in_slow (1x)
    .          .          .          .                           }
    .          .          .          .                           teddy.find(&haystack[..span.end], span.start)
    .          .          .          .                       }
    .          .          .          .                       SearchKind::RabinKarp => {
    .          .          .          .                           self.rabinkarp.find_at(&haystack[..span.end], span.start)
    .          .          .          .                       }
    .          .          .          .                   }
    .          .          .          .               }
-- line 546 ----------------------------------------
-- line 638 ----------------------------------------
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Use a slow (non-packed) searcher.
    .          .          .          .               ///
    .          .          .          .               /// This is useful when a packed searcher could be constructed, but could
    .          .          .          .               /// not be used to search a specific haystack. For example, if Teddy was
    .          .          .          .               /// built but the haystack is smaller than ~34 bytes, then Teddy might not
    .          .          .          .               /// be able to run.
    1 ( 0.00%) .          .          .               fn find_in_slow(&self, haystack: &[u8], span: Span) -> Option<Match> {
    3 ( 0.00%) .          .          .                   self.rabinkarp.find_at(&haystack[..span.end], span.start)
  189 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/rabinkarp.rs:aho_corasick::packed::rabinkarp::RabinKarp::find_at (1x)
    3 ( 0.00%) .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl SearchKind {
    .          .          .          .               fn memory_usage(&self) -> usize {
    .          .          .          .                   match *self {
    .          .          .          .                       SearchKind::Teddy(ref ted) => ted.memory_usage(),
    .          .          .          .                       SearchKind::RabinKarp => 0,
    .          .          .          .                   }
-- line 656 ----------------------------------------

1,635 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/api.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/primitives.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 133 ----------------------------------------
      .          .          .          .           ///
      .          .          .          .           /// While a `SmallIndex` is meant to guarantee that its value fits into `usize`
      .          .          .          .           /// without using as much space as a `usize` on all targets, callers must
      .          .          .          .           /// not rely on this property for safety. Callers may choose to rely on this
      .          .          .          .           /// property for correctness however. For example, creating a `SmallIndex` with
      .          .          .          .           /// an invalid value can be done in entirely safe code. This may in turn result
      .          .          .          .           /// in panics or silent logical errors.
      .          .          .          .           #[derive(
 11,224 ( 0.00%) .          .          .               Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord,
      .          .          .          .           )]
      .          .          .          .           #[repr(transparent)]
      .          .          .          .           pub struct SmallIndex(u32);
      .          .          .          .           
      .          .          .          .           impl SmallIndex {
      .          .          .          .               /// The maximum index value.
      .          .          .          .               #[cfg(any(target_pointer_width = "32", target_pointer_width = "64"))]
      .          .          .          .               pub const MAX: SmallIndex =
-- line 149 ----------------------------------------
-- line 181 ----------------------------------------
      .          .          .          .               /// invalid index value is likely to cause panics or possibly even silent
      .          .          .          .               /// logical errors.
      .          .          .          .               ///
      .          .          .          .               /// Callers must never rely on a `SmallIndex` to be within a certain range
      .          .          .          .               /// for memory safety.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn new_unchecked(index: usize) -> SmallIndex {
      .          .          .          .                   // FIXME: Use as_u32() once const functions in traits are stable.
     27 ( 0.00%) .          .          .                   SmallIndex(index as u32)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Like [`SmallIndex::new`], but panics if the given index is not valid.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn must(index: usize) -> SmallIndex {
      .          .          .          .                   SmallIndex::new(index).expect("invalid small index")
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return this small index as a `usize`. This is guaranteed to never
      .          .          .          .               /// overflow `usize`.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn as_usize(&self) -> usize {
      .          .          .          .                   // FIXME: Use as_usize() once const functions in traits are stable.
176,933 ( 0.05%) .          .          .                   self.0 as usize
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return this small index as a `u64`. This is guaranteed to never
      .          .          .          .               /// overflow.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn as_u64(&self) -> u64 {
      .          .          .          .                   // FIXME: Use u64::from() once const functions in traits are stable.
 12,023 ( 0.00%) .          .          .                   self.0 as u64
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the internal `u32` of this small index. This is guaranteed to
      .          .          .          .               /// never overflow `u32`.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn as_u32(&self) -> u32 {
      .          .          .          .                   self.0
      .          .          .          .               }
-- line 219 ----------------------------------------
-- line 227 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns one more than this small index as a usize.
      .          .          .          .               ///
      .          .          .          .               /// Since a small index has constraints on its maximum value, adding `1` to
      .          .          .          .               /// it will always fit in a `usize`, `u32` and a `i32`.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn one_more(&self) -> usize {
  2,160 ( 0.00%) .          .          .                   self.as_usize() + 1
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Decode this small index from the bytes given using the native endian
      .          .          .          .               /// byte order for the current target.
      .          .          .          .               ///
      .          .          .          .               /// If the decoded integer is not representable as a small index for the
      .          .          .          .               /// current target, then this returns an error.
      .          .          .          .               #[inline]
-- line 243 ----------------------------------------
-- line 319 ----------------------------------------
      .          .          .          .                   Ok(SmallIndex::new_unchecked(index.as_usize()))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl TryFrom<u32> for SmallIndex {
      .          .          .          .               type Error = SmallIndexError;
      .          .          .          .           
      .          .          .          .               fn try_from(index: u32) -> Result<SmallIndex, SmallIndexError> {
  3,096 ( 0.00%) .          .          .                   if index > SmallIndex::MAX.as_u32() {
      .          .          .          .                       return Err(SmallIndexError { attempted: u64::from(index) });
      .          .          .          .                   }
      .          .          .          .                   Ok(SmallIndex::new_unchecked(index.as_usize()))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl TryFrom<u64> for SmallIndex {
      .          .          .          .               type Error = SmallIndexError;
-- line 335 ----------------------------------------
-- line 341 ----------------------------------------
      .          .          .          .                   Ok(SmallIndex::new_unchecked(index.as_usize()))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl TryFrom<usize> for SmallIndex {
      .          .          .          .               type Error = SmallIndexError;
      .          .          .          .           
      .          .          .          .               fn try_from(index: usize) -> Result<SmallIndex, SmallIndexError> {
400,388 ( 0.12%) .          .          .                   if index > SmallIndex::MAX.as_usize() {
      .          .          .          .                       return Err(SmallIndexError { attempted: index.as_u64() });
      .          .          .          .                   }
      .          .          .          .                   Ok(SmallIndex::new_unchecked(index))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[cfg(test)]
      .          .          .          .           impl quickcheck::Arbitrary for SmallIndex {
-- line 357 ----------------------------------------
-- line 402 ----------------------------------------
      .          .          .          .           pub(crate) struct SmallIndexIter {
      .          .          .          .               rng: core::ops::Range<usize>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Iterator for SmallIndexIter {
      .          .          .          .               type Item = SmallIndex;
      .          .          .          .           
      .          .          .          .               fn next(&mut self) -> Option<SmallIndex> {
179,739 ( 0.05%) .          .          .                   if self.rng.start >= self.rng.end {
      .          .          .          .                       return None;
      .          .          .          .                   }
     81 ( 0.00%) .          .          .                   let next_id = self.rng.start + 1;
      .          .          .          .                   let id = core::mem::replace(&mut self.rng.start, next_id);
      .          .          .          .                   // new_unchecked is OK since we asserted that the number of
      .          .          .          .                   // elements in this iterator will fit in an ID at construction.
      .          .          .          .                   Some(SmallIndex::new_unchecked(id))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           macro_rules! index_type_impls {
-- line 421 ----------------------------------------
-- line 661 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   #[derive(Clone, Debug)]
      .          .          .          .                   pub(crate) struct $iter(SmallIndexIter);
      .          .          .          .           
      .          .          .          .                   impl $iter {
      .          .          .          .                       fn new(len: usize) -> $iter {
    432 ( 0.00%) .          .          .                           assert!(
    432 ( 0.00%) .          .          .                               len <= $name::LIMIT,
      .          .          .          .                               "cannot create iterator for {} when number of \
      .          .          .          .                                elements exceed {:?}",
      .          .          .          .                               stringify!($name),
      .          .          .          .                               $name::LIMIT,
      .          .          .          .                           );
      .          .          .          .                           $iter(SmallIndexIter { rng: 0..len })
      .          .          .          .                       }
      .          .          .          .                   }
-- line 678 ----------------------------------------
-- line 745 ----------------------------------------
      .          .          .          .           /// much more memory efficient to define state IDs as small indices.
      .          .          .          .           ///
      .          .          .          .           /// See the [`SmallIndex`] type for more information about what it means for
      .          .          .          .           /// a state ID to be a "small index."
      .          .          .          .           #[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]
      .          .          .          .           #[repr(transparent)]
      .          .          .          .           pub struct StateID(SmallIndex);
      .          .          .          .           
  5,842 ( 0.00%) .          .          .           index_type_impls!(PatternID, PatternIDError, PatternIDIter, WithPatternIDIter);
697,757 ( 0.20%) .          .          .           index_type_impls!(StateID, StateIDError, StateIDIter, WithStateIDIter);
      .          .          .          .           
      .          .          .          .           /// A utility trait that defines a couple of adapters for making it convenient
      .          .          .          .           /// to access indices as "small index" types. We require ExactSizeIterator so
      .          .          .          .           /// that iterator construction can do a single check to make sure the index of
      .          .          .          .           /// each element is representable by its small index type.
      .          .          .          .           pub(crate) trait IteratorIndexExt: Iterator {
      .          .          .          .               fn with_pattern_ids(self) -> WithPatternIDIter<Self>
      .          .          .          .               where
-- line 762 ----------------------------------------

 68,317 ( 0.02%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/primitives.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/unicode.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 116 ----------------------------------------
      .          .          .          .               /// no entry in the underlying case folding table), then this returns an
      .          .          .          .               /// empty slice.
      .          .          .          .               ///
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// This panics when called with a `c` that is less than or equal to the
      .          .          .          .               /// previous call. In other words, callers need to use this method with
      .          .          .          .               /// strictly increasing values of `c`.
  3,360 ( 0.00%) .          .          .               pub fn mapping(&mut self, c: char) -> &'static [char] {
  3,360 ( 0.00%) .          .          .                   if let Some(last) = self.last {
      .          .          .          .                       assert!(
      .          .          .          .                           last < c,
      .          .          .          .                           "got codepoint U+{:X} which occurs before \
      .          .          .          .                            last codepoint U+{:X}",
      .          .          .          .                           u32::from(c),
      .          .          .          .                           u32::from(last),
      .          .          .          .                       );
      .          .          .          .                   }
  1,120 ( 0.00%) .          .          .                   self.last = Some(c);
  5,600 ( 0.00%) .          .          .                   if self.next >= self.table.len() {
      .          .          .          .                       return &[];
      .          .          .          .                   }
  2,400 ( 0.00%) .          .          .                   let (k, v) = self.table[self.next];
  2,240 ( 0.00%) .          .          .                   if k == c {
    160 ( 0.00%) .          .          .                       self.next += 1;
      .          .          .          .                       return v;
      .          .          .          .                   }
      .          .          .          .                   match self.get(c) {
      .          .          .          .                       Err(i) => {
      .          .          .          .                           self.next = i;
      .          .          .          .                           &[]
      .          .          .          .                       }
      .          .          .          .                       Ok(i) => {
      .          .          .          .                           // Since we require lookups to proceed
      .          .          .          .                           // in order, anything we find should be
      .          .          .          .                           // after whatever we thought might be
      .          .          .          .                           // next. Otherwise, the caller is either
      .          .          .          .                           // going out of order or we would have
      .          .          .          .                           // found our next key at 'self.next'.
  2,080 ( 0.00%) .          .          .                           assert!(i > self.next);
  2,080 ( 0.00%) .          .          .                           self.next = i + 1;
  2,080 ( 0.00%) .          .          .                           self.table[i].1
      .          .          .          .                       }
      .          .          .          .                   }
  4,480 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if the given range overlaps with any region
      .          .          .          .               /// of the underlying case folding table. That is, when true, there exists
      .          .          .          .               /// at least one codepoint in the inclusive range `[start, end]` that has
      .          .          .          .               /// a non-trivial equivalence class of case folded codepoints. Conversely,
      .          .          .          .               /// when this returns false, all codepoints in the range `[start, end]`
      .          .          .          .               /// correspond to the trivial equivalence class of case folded codepoints,
      .          .          .          .               /// i.e., itself.
-- line 168 ----------------------------------------
-- line 170 ----------------------------------------
      .          .          .          .               /// This is useful to call before iterating over the codepoints in the
      .          .          .          .               /// range and looking up the mapping for each. If you know none of the
      .          .          .          .               /// mappings will return anything, then you might be able to skip doing it
      .          .          .          .               /// altogether.
      .          .          .          .               ///
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// This panics when `end < start`.
  1,120 ( 0.00%) .          .          .               pub fn overlaps(&self, start: char, end: char) -> bool {
      .          .          .          .                   use core::cmp::Ordering;
      .          .          .          .           
  4,620 ( 0.00%) .          .          .                   assert!(start <= end);
  1,120 ( 0.00%) .          .          .                   self.table
      .          .          .          .                       .binary_search_by(|&(c, _)| {
120,300 ( 0.03%) .          .          .                           if start <= c && c <= end {
      .          .          .          .                               Ordering::Equal
      .          .          .          .                           } else if c > end {
      .          .          .          .                               Ordering::Greater
      .          .          .          .                           } else {
      .          .          .          .                               Ordering::Less
      .          .          .          .                           }
      .          .          .          .                       })
      .          .          .          .                       .is_ok()
  2,240 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the index at which `c` occurs in the simple case fold table. If
      .          .          .          .               /// `c` does not occur, then this returns an `i` such that `table[i-1].0 <
      .          .          .          .               /// c` and `table[i].0 > c`.
      .          .          .          .               fn get(&self, c: char) -> Result<usize, usize> {
      .          .          .          .                   self.table.binary_search_by_key(&c, |&(c1, _)| c1)
      .          .          .          .               }
      .          .          .          .           }
-- line 201 ----------------------------------------
-- line 422 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               imp()
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Returns a Unicode aware class for \d.
      .          .          .          .           ///
      .          .          .          .           /// This returns an error if the data is not available for \d.
     15 ( 0.00%) .          .          .           pub fn perl_digit() -> Result<hir::ClassUnicode, Error> {
      .          .          .          .               #[cfg(not(any(feature = "unicode-perl", feature = "unicode-gencat")))]
      .          .          .          .               fn imp() -> Result<hir::ClassUnicode, Error> {
      .          .          .          .                   Err(Error::PerlClassNotFound)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg(all(feature = "unicode-perl", not(feature = "unicode-gencat")))]
      .          .          .          .               fn imp() -> Result<hir::ClassUnicode, Error> {
      .          .          .          .                   use crate::unicode_tables::perl_decimal::DECIMAL_NUMBER;
-- line 438 ----------------------------------------
-- line 441 ----------------------------------------
      .          .          .          .           
      .          .          .          .               #[cfg(feature = "unicode-gencat")]
      .          .          .          .               fn imp() -> Result<hir::ClassUnicode, Error> {
      .          .          .          .                   use crate::unicode_tables::general_category::DECIMAL_NUMBER;
      .          .          .          .                   Ok(hir_class(DECIMAL_NUMBER))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               imp()
     20 ( 0.00%) .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Build a Unicode HIR class from a sequence of Unicode scalar value ranges.
      .          .          .          .           pub fn hir_class(ranges: &[(char, char)]) -> hir::ClassUnicode {
      .          .          .          .               let hir_ranges: Vec<hir::ClassUnicodeRange> = ranges
      .          .          .          .                   .iter()
      .          .          .          .                   .map(|&(s, e)| hir::ClassUnicodeRange::new(s, e))
      .          .          .          .                   .collect();
      .          .          .          .               hir::ClassUnicode::new(hir_ranges)
-- line 457 ----------------------------------------

 32,480 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/unicode.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 107 ----------------------------------------
     .          .          .          .           
     .          .          .          .           impl Utf8Sequence {
     .          .          .          .               /// Creates a new UTF-8 sequence from the encoded bytes of a scalar value
     .          .          .          .               /// range.
     .          .          .          .               ///
     .          .          .          .               /// This assumes that `start` and `end` have the same length.
     .          .          .          .               fn from_encoded_range(start: &[u8], end: &[u8]) -> Self {
     .          .          .          .                   assert_eq!(start.len(), end.len());
 9,020 ( 0.00%) .          .          .                   match start.len() {
     .          .          .          .                       2 => Utf8Sequence::Two([
     .          .          .          .                           Utf8Range::new(start[0], end[0]),
     .          .          .          .                           Utf8Range::new(start[1], end[1]),
     .          .          .          .                       ]),
     .          .          .          .                       3 => Utf8Sequence::Three([
     .          .          .          .                           Utf8Range::new(start[0], end[0]),
     .          .          .          .                           Utf8Range::new(start[1], end[1]),
     .          .          .          .                           Utf8Range::new(start[2], end[2]),
-- line 123 ----------------------------------------
-- line 128 ----------------------------------------
     .          .          .          .                           Utf8Range::new(start[2], end[2]),
     .          .          .          .                           Utf8Range::new(start[3], end[3]),
     .          .          .          .                       ]),
     .          .          .          .                       n => unreachable!("invalid encoded length: {}", n),
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the underlying sequence of byte ranges as a slice.
 2,370 ( 0.00%) .          .          .               pub fn as_slice(&self) -> &[Utf8Range] {
     .          .          .          .                   use self::Utf8Sequence::*;
11,850 ( 0.00%) .          .          .                   match *self {
     .          .          .          .                       One(ref r) => slice::from_ref(r),
   386 ( 0.00%) .          .          .                       Two(ref r) => &r[..],
 1,804 ( 0.00%) .          .          .                       Three(ref r) => &r[..],
 1,418 ( 0.00%) .          .          .                       Four(ref r) => &r[..],
     .          .          .          .                   }
 2,370 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the number of byte ranges in this sequence.
     .          .          .          .               ///
     .          .          .          .               /// The length is guaranteed to be in the closed interval `[1, 4]`.
     .          .          .          .               pub fn len(&self) -> usize {
     .          .          .          .                   self.as_slice().len()
     .          .          .          .               }
     .          .          .          .           
-- line 152 ----------------------------------------
-- line 296 ----------------------------------------
     .          .          .          .           #[derive(Debug)]
     .          .          .          .           pub struct Utf8Sequences {
     .          .          .          .               range_stack: Vec<ScalarRange>,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl Utf8Sequences {
     .          .          .          .               /// Create a new iterator over UTF-8 byte ranges for the scalar value range
     .          .          .          .               /// given.
 8,316 ( 0.00%) .          .          .               pub fn new(start: char, end: char) -> Self {
     .          .          .          .                   let range =
     .          .          .          .                       ScalarRange { start: u32::from(start), end: u32::from(end) };
 2,772 ( 0.00%) .          .          .                   Utf8Sequences { range_stack: vec![range] }
 6,930 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// reset resets the scalar value range.
     .          .          .          .               /// Any existing state is cleared, but resources may be reused.
     .          .          .          .               ///
     .          .          .          .               /// N.B. Benchmarks say that this method is dubious.
     .          .          .          .               #[doc(hidden)]
     .          .          .          .               pub fn reset(&mut self, start: char, end: char) {
     .          .          .          .                   self.range_stack.clear();
-- line 316 ----------------------------------------
-- line 331 ----------------------------------------
     .          .          .          .               fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
     .          .          .          .                   write!(f, "ScalarRange({:X}, {:X})", self.start, self.end)
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl Iterator for Utf8Sequences {
     .          .          .          .               type Item = Utf8Sequence;
     .          .          .          .           
33,804 ( 0.01%) .          .          .               fn next(&mut self) -> Option<Self::Item> {
     .          .          .          .                   'TOP: while let Some(mut r) = self.range_stack.pop() {
     .          .          .          .                       'INNER: loop {
     .          .          .          .                           if let Some((r1, r2)) = r.split() {
     .          .          .          .                               self.push(r2.start, r2.end);
     .          .          .          .                               r.start = r1.start;
     .          .          .          .                               r.end = r1.end;
     .          .          .          .                               continue 'INNER;
     .          .          .          .                           }
 2,862 ( 0.00%) .          .          .                           if !r.is_valid() {
     .          .          .          .                               continue 'TOP;
     .          .          .          .                           }
     .          .          .          .                           for i in 1..MAX_UTF8_BYTES {
     .          .          .          .                               let max = max_scalar_value(i);
11,534 ( 0.00%) .          .          .                               if r.start <= max && max < r.end {
   123 ( 0.00%) .          .          .                                   self.push(max + 1, r.end);
     .          .          .          .                                   r.end = max;
     .          .          .          .                                   continue 'INNER;
     .          .          .          .                               }
     .          .          .          .                           }
 2,173 ( 0.00%) .          .          .                           if let Some(ascii_range) = r.as_ascii() {
 2,264 ( 0.00%) .          .          .                               return Some(Utf8Sequence::One(ascii_range));
     .          .          .          .                           }
     .          .          .          .                           for i in 1..MAX_UTF8_BYTES {
     .          .          .          .                               let m = (1 << (6 * i)) - 1;
26,568 ( 0.01%) .          .          .                               if (r.start & !m) != (r.end & !m) {
 2,952 ( 0.00%) .          .          .                                   if (r.start & m) != 0 {
   492 ( 0.00%) .          .          .                                       self.push((r.start | m) + 1, r.end);
     .          .          .          .                                       r.end = r.start | m;
     .          .          .          .                                       continue 'INNER;
     .          .          .          .                                   }
10,947 ( 0.00%) .          .          .                                   if (r.end & m) != m {
     .          .          .          .                                       self.push(r.end & !m, r.end);
   246 ( 0.00%) .          .          .                                       r.end = (r.end & !m) - 1;
     .          .          .          .                                       continue 'INNER;
     .          .          .          .                                   }
     .          .          .          .                               }
     .          .          .          .                           }
     .          .          .          .                           let mut start = [0; MAX_UTF8_BYTES];
     .          .          .          .                           let mut end = [0; MAX_UTF8_BYTES];
     .          .          .          .                           let n = r.encode(&mut start, &mut end);
16,236 ( 0.00%) .          .          .                           return Some(Utf8Sequence::from_encoded_range(
     .          .          .          .                               &start[0..n],
     .          .          .          .                               &end[0..n],
     .          .          .          .                           ));
     .          .          .          .                       }
     .          .          .          .                   }
 2,772 ( 0.00%) .          .          .                   None
30,048 ( 0.01%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl FusedIterator for Utf8Sequences {}
     .          .          .          .           
     .          .          .          .           impl ScalarRange {
     .          .          .          .               /// split splits this range if it overlaps with a surrogate codepoint.
     .          .          .          .               ///
     .          .          .          .               /// Either or both ranges may be invalid.
     .          .          .          .               fn split(&self) -> Option<(ScalarRange, ScalarRange)> {
 6,779 ( 0.00%) .          .          .                   if self.start < 0xE000 && self.end > 0xD7FF {
     .          .          .          .                       Some((
     .          .          .          .                           ScalarRange { start: self.start, end: 0xD7FF },
     .          .          .          .                           ScalarRange { start: 0xE000, end: self.end },
     .          .          .          .                       ))
     .          .          .          .                   } else {
     .          .          .          .                       None
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// is_valid returns true if and only if start <= end.
     .          .          .          .               fn is_valid(&self) -> bool {
 2,862 ( 0.00%) .          .          .                   self.start <= self.end
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// as_ascii returns this range as a Utf8Range if and only if all scalar
     .          .          .          .               /// values in this range can be encoded as a single byte.
     .          .          .          .               fn as_ascii(&self) -> Option<Utf8Range> {
     .          .          .          .                   if self.is_ascii() {
     .          .          .          .                       let start = u8::try_from(self.start).unwrap();
     .          .          .          .                       let end = u8::try_from(self.end).unwrap();
-- line 417 ----------------------------------------
-- line 419 ----------------------------------------
     .          .          .          .                   } else {
     .          .          .          .                       None
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// is_ascii returns true if the range is ASCII only (i.e., takes a single
     .          .          .          .               /// byte to encode any scalar value).
     .          .          .          .               fn is_ascii(&self) -> bool {
 2,173 ( 0.00%) .          .          .                   self.is_valid() && self.end <= 0x7f
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// encode writes the UTF-8 encoding of the start and end of this range
     .          .          .          .               /// to the corresponding destination slices, and returns the number of
     .          .          .          .               /// bytes written.
     .          .          .          .               ///
     .          .          .          .               /// The slices should have room for at least `MAX_UTF8_BYTES`.
     .          .          .          .               fn encode(&self, start: &mut [u8], end: &mut [u8]) -> usize {
 5,412 ( 0.00%) .          .          .                   let cs = char::from_u32(self.start).unwrap();
 5,412 ( 0.00%) .          .          .                   let ce = char::from_u32(self.end).unwrap();
     .          .          .          .                   let ss = cs.encode_utf8(start);
     .          .          .          .                   let se = ce.encode_utf8(end);
 3,608 ( 0.00%) .          .          .                   assert_eq!(ss.len(), se.len());
     .          .          .          .                   ss.len()
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           fn max_scalar_value(nbytes: usize) -> u32 {
     .          .          .          .               match nbytes {
     .          .          .          .                   1 => 0x007F,
     .          .          .          .                   2 => 0x07FF,
-- line 448 ----------------------------------------

23,713 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/utf8.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 248 ----------------------------------------
      .          .          .          .                   &self.special
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Swaps the states at `id1` and `id2`.
      .          .          .          .               ///
      .          .          .          .               /// This does not update the transitions of any state to account for the
      .          .          .          .               /// state swap.
      .          .          .          .               pub(crate) fn swap_states(&mut self, id1: StateID, id2: StateID) {
  1,446 ( 0.00%) .          .          .                   self.states.swap(id1.as_usize(), id2.as_usize());
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Re-maps all state IDs in this NFA according to the `map` function
      .          .          .          .               /// given.
      .          .          .          .               pub(crate) fn remap(&mut self, map: impl Fn(StateID) -> StateID) {
      .          .          .          .                   let alphabet_len = self.byte_classes.alphabet_len();
      .          .          .          .                   for state in self.states.iter_mut() {
  5,248 ( 0.00%) .          .          .                       state.fail = map(state.fail);
      .          .          .          .                       let mut link = state.sparse;
 42,682 ( 0.01%) .          .          .                       while link != StateID::ZERO {
      .          .          .          .                           let t = &mut self.sparse[link];
116,412 ( 0.03%) .          .          .                           t.next = map(t.next);
      .          .          .          .                           link = t.link;
      .          .          .          .                       }
  2,624 ( 0.00%) .          .          .                       if state.dense != StateID::ZERO {
      .          .          .          .                           let start = state.dense.as_usize();
      .          .          .          .                           for next in self.dense[start..][..alphabet_len].iter_mut() {
186,694 ( 0.05%) .          .          .                               *next = map(*next);
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Iterate over all of the transitions for the given state ID.
  3,680 ( 0.00%) .          .          .               pub(crate) fn iter_trans(
      .          .          .          .                   &self,
      .          .          .          .                   sid: StateID,
      .          .          .          .               ) -> impl Iterator<Item = Transition> + '_ {
  6,286 ( 0.00%) .          .          .                   let mut link = self.states[sid].sparse;
      .          .          .          .                   core::iter::from_fn(move || {
145,950 ( 0.04%) .          .          .                       if link == StateID::ZERO {
      .          .          .          .                           return None;
      .          .          .          .                       }
141,718 ( 0.04%) .          .          .                       let t = self.sparse[link];
      .          .          .          .                       link = t.link;
178,218 ( 0.05%) .          .          .                       Some(t)
      .          .          .          .                   })
  3,680 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Iterate over all of the matches for the given state ID.
      .          .          .          .               pub(crate) fn iter_matches(
      .          .          .          .                   &self,
      .          .          .          .                   sid: StateID,
      .          .          .          .               ) -> impl Iterator<Item = PatternID> + '_ {
  8,364 ( 0.00%) .          .          .                   let mut link = self.states[sid].matches;
      .          .          .          .                   core::iter::from_fn(move || {
  5,505 ( 0.00%) .          .          .                       if link == StateID::ZERO {
      .          .          .          .                           return None;
      .          .          .          .                       }
  3,670 ( 0.00%) .          .          .                       let m = self.matches[link];
      .          .          .          .                       link = m.link;
      .          .          .          .                       Some(m.pid)
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the link following the one given. If the one given is the last
      .          .          .          .               /// link for the given state, then return `None`.
      .          .          .          .               ///
-- line 314 ----------------------------------------
-- line 320 ----------------------------------------
      .          .          .          .               /// the NFA during iteration. Namely, one can access the transition pointed
      .          .          .          .               /// to by the link via `self.sparse[link]`.
      .          .          .          .               fn next_link(
      .          .          .          .                   &self,
      .          .          .          .                   sid: StateID,
      .          .          .          .                   prev: Option<StateID>,
      .          .          .          .               ) -> Option<StateID> {
      .          .          .          .                   let link =
110,484 ( 0.03%) .          .          .                       prev.map_or(self.states[sid].sparse, |p| self.sparse[p].link);
 65,833 ( 0.02%) .          .          .                   if link == StateID::ZERO {
      .          .          .          .                       None
      .          .          .          .                   } else {
      .          .          .          .                       Some(link)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Follow the transition for the given byte in the given state. If no such
      .          .          .          .               /// transition exists, then the FAIL state ID is returned.
-- line 337 ----------------------------------------
-- line 346 ----------------------------------------
      .          .          .          .                   // since we only do this for a small number of states (by default), the
      .          .          .          .                   // memory usage is usually minimal.
      .          .          .          .                   //
      .          .          .          .                   // This has *massive* benefit when executing searches because the
      .          .          .          .                   // unanchored starting state is by far the hottest state and is
      .          .          .          .                   // frequently visited. Moreover, the 'for' loop below that works
      .          .          .          .                   // decently on an actually sparse state is disastrous on a state that
      .          .          .          .                   // is nearly or completely dense.
  4,443 ( 0.00%) .          .          .                   if s.dense == StateID::ZERO {
      .          .          .          .                       self.follow_transition_sparse(sid, byte)
      .          .          .          .                   } else {
      .          .          .          .                       let class = usize::from(self.byte_classes.get(byte));
  1,436 ( 0.00%) .          .          .                       self.dense[s.dense.as_usize() + class]
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Like `follow_transition`, but always uses the sparse representation.
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn follow_transition_sparse(&self, sid: StateID, byte: u8) -> StateID {
 14,720 ( 0.00%) .          .          .                   for t in self.iter_trans(sid) {
 33,120 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::iter_trans (3,680x)
210,436 ( 0.06%) .          .          .                       if byte <= t.byte {
  4,108 ( 0.00%) .          .          .                           if byte == t.byte {
      .          .          .          .                               return t.next;
      .          .          .          .                           }
      .          .          .          .                           break;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   NFA::FAIL
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the transition for the given byte to the state ID given.
      .          .          .          .               ///
      .          .          .          .               /// Note that one should not set transitions to the FAIL state. It is not
      .          .          .          .               /// technically incorrect, but it wastes space. If a transition is not
      .          .          .          .               /// defined, then it is automatically assumed to lead to the FAIL state.
 19,456 ( 0.01%) .          .          .               fn add_transition(
      .          .          .          .                   &mut self,
      .          .          .          .                   prev: StateID,
      .          .          .          .                   byte: u8,
      .          .          .          .                   next: StateID,
      .          .          .          .               ) -> Result<(), BuildError> {
  2,432 ( 0.00%) .          .          .                   if self.states[prev].dense != StateID::ZERO {
      .          .          .          .                       let dense = self.states[prev].dense;
      .          .          .          .                       let class = usize::from(self.byte_classes.get(byte));
      .          .          .          .                       self.dense[dense.as_usize() + class] = next;
      .          .          .          .                   }
      .          .          .          .           
  4,864 ( 0.00%) .          .          .                   let head = self.states[prev].sparse;
  6,398 ( 0.00%) .          .          .                   if head == StateID::ZERO || byte < self.sparse[head].byte {
      .          .          .          .                       let new_link = self.alloc_transition()?;
  4,140 ( 0.00%) .          .          .                       self.sparse[new_link] = Transition { byte, next, link: head };
  1,380 ( 0.00%) .          .          .                       self.states[prev].sparse = new_link;
      .          .          .          .                       return Ok(());
  1,052 ( 0.00%) .          .          .                   } else if byte == self.sparse[head].byte {
      .          .          .          .                       self.sparse[head].next = next;
      .          .          .          .                       return Ok(());
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // We handled the only cases where the beginning of the transition
      .          .          .          .                   // chain needs to change. At this point, we now know that there is
      .          .          .          .                   // at least one entry in the transition chain and the byte for that
      .          .          .          .                   // transition is less than the byte for the transition we're adding.
      .          .          .          .                   let (mut link_prev, mut link_next) = (head, self.sparse[head].link);
124,632 ( 0.04%) .          .          .                   while link_next != StateID::ZERO && byte > self.sparse[link_next].byte
      .          .          .          .                   {
      .          .          .          .                       link_prev = link_next;
      .          .          .          .                       link_next = self.sparse[link_next].link;
      .          .          .          .                   }
    536 ( 0.00%) .          .          .                   if link_next == StateID::ZERO || byte < self.sparse[link_next].byte {
      .          .          .          .                       let link = self.alloc_transition()?;
  1,680 ( 0.00%) .          .          .                       self.sparse[link] = Transition { byte, next, link: link_next };
  1,680 ( 0.00%) .          .          .                       self.sparse[link_prev].link = link;
      .          .          .          .                   } else {
      .          .          .          .                       assert_eq!(byte, self.sparse[link_next].byte);
      .          .          .          .                       self.sparse[link_next].next = next;
      .          .          .          .                   }
      .          .          .          .                   Ok(())
 21,888 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// This sets every possible transition (all 255 of them) for the given
      .          .          .          .               /// state to the name `next` value.
      .          .          .          .               ///
      .          .          .          .               /// This is useful for efficiently initializing start/dead states.
      .          .          .          .               ///
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// This requires that the state has no transitions added to it already.
      .          .          .          .               /// If it has any transitions, then this panics. It will also panic if
      .          .          .          .               /// the state has been densified prior to calling this.
  1,152 ( 0.00%) .          .          .               fn init_full_state(
      .          .          .          .                   &mut self,
      .          .          .          .                   prev: StateID,
      .          .          .          .                   next: StateID,
      .          .          .          .               ) -> Result<(), BuildError> {
    144 ( 0.00%) .          .          .                   assert_eq!(
      .          .          .          .                       StateID::ZERO,
      .          .          .          .                       self.states[prev].dense,
      .          .          .          .                       "state must not be dense yet"
      .          .          .          .                   );
    144 ( 0.00%) .          .          .                   assert_eq!(
      .          .          .          .                       StateID::ZERO,
      .          .          .          .                       self.states[prev].sparse,
      .          .          .          .                       "state must have zero transitions"
      .          .          .          .                   );
      .          .          .          .                   let mut prev_link = StateID::ZERO;
      .          .          .          .                   for byte in 0..=255 {
      .          .          .          .                       let new_link = self.alloc_transition()?;
110,592 ( 0.03%) .          .          .                       self.sparse[new_link] =
      .          .          .          .                           Transition { byte, next, link: StateID::ZERO };
 73,728 ( 0.02%) .          .          .                       if prev_link == StateID::ZERO {
    144 ( 0.00%) .          .          .                           self.states[prev].sparse = new_link;
      .          .          .          .                       } else {
 73,440 ( 0.02%) .          .          .                           self.sparse[prev_link].link = new_link;
      .          .          .          .                       }
      .          .          .          .                       prev_link = new_link;
      .          .          .          .                   }
    144 ( 0.00%) .          .          .                   Ok(())
  1,152 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add a match for the given pattern ID to the state for the given ID.
 11,152 ( 0.00%) .          .          .               fn add_match(
      .          .          .          .                   &mut self,
      .          .          .          .                   sid: StateID,
      .          .          .          .                   pid: PatternID,
      .          .          .          .               ) -> Result<(), BuildError> {
  1,394 ( 0.00%) .          .          .                   let head = self.states[sid].matches;
      .          .          .          .                   let mut link = head;
  1,394 ( 0.00%) .          .          .                   while self.matches[link].link != StateID::ZERO {
      .          .          .          .                       link = self.matches[link].link;
      .          .          .          .                   }
      .          .          .          .                   let new_match_link = self.alloc_match()?;
  1,394 ( 0.00%) .          .          .                   self.matches[new_match_link].pid = pid;
  2,788 ( 0.00%) .          .          .                   if link == StateID::ZERO {
  2,788 ( 0.00%) .          .          .                       self.states[sid].matches = new_match_link;
      .          .          .          .                   } else {
      .          .          .          .                       self.matches[link].link = new_match_link;
      .          .          .          .                   }
      .          .          .          .                   Ok(())
 12,546 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Copy matches from the `src` state to the `dst` state. This is useful
      .          .          .          .               /// when a match state can be reached via a failure transition. In which
      .          .          .          .               /// case, you'll want to copy the matches (if any) from the state reached
      .          .          .          .               /// by the failure transition to the original state you were at.
  5,768 ( 0.00%) .          .          .               fn copy_matches(
      .          .          .          .                   &mut self,
      .          .          .          .                   src: StateID,
      .          .          .          .                   dst: StateID,
      .          .          .          .               ) -> Result<(), BuildError> {
  1,442 ( 0.00%) .          .          .                   let head_dst = self.states[dst].matches;
      .          .          .          .                   let mut link_dst = head_dst;
    721 ( 0.00%) .          .          .                   while self.matches[link_dst].link != StateID::ZERO {
      .          .          .          .                       link_dst = self.matches[link_dst].link;
      .          .          .          .                   }
    721 ( 0.00%) .          .          .                   let mut link_src = self.states[src].matches;
    721 ( 0.00%) .          .          .                   while link_src != StateID::ZERO {
      .          .          .          .                       let new_match_link =
      .          .          .          .                           StateID::new(self.matches.len()).map_err(|e| {
      .          .          .          .                               BuildError::state_id_overflow(
      .          .          .          .                                   StateID::MAX.as_u64(),
      .          .          .          .                                   e.attempted(),
      .          .          .          .                               )
      .          .          .          .                           })?;
      .          .          .          .                       self.matches.push(Match {
-- line 509 ----------------------------------------
-- line 515 ----------------------------------------
      .          .          .          .                       } else {
      .          .          .          .                           self.matches[link_dst].link = new_match_link;
      .          .          .          .                       }
      .          .          .          .           
      .          .          .          .                       link_dst = new_match_link;
      .          .          .          .                       link_src = self.matches[link_src].link;
      .          .          .          .                   }
      .          .          .          .                   Ok(())
  5,768 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new entry in `NFA::trans`, if there's room, and return that
      .          .          .          .               /// entry's ID. If there's no room, then an error is returned.
      .          .          .          .               fn alloc_transition(&mut self) -> Result<StateID, BuildError> {
      .          .          .          .                   let id = StateID::new(self.sparse.len()).map_err(|e| {
      .          .          .          .                       BuildError::state_id_overflow(StateID::MAX.as_u64(), e.attempted())
      .          .          .          .                   })?;
      .          .          .          .                   self.sparse.push(Transition::default());
-- line 531 ----------------------------------------
-- line 560 ----------------------------------------
      .          .          .          .                           .take(self.byte_classes.alphabet_len()),
      .          .          .          .                   );
      .          .          .          .                   Ok(id)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Allocate and add a fresh state to the underlying NFA and return its
      .          .          .          .               /// ID (guaranteed to be one more than the ID of the previously allocated
      .          .          .          .               /// state). If the ID would overflow `StateID`, then this returns an error.
 18,368 ( 0.01%) .          .          .               fn alloc_state(&mut self, depth: usize) -> Result<StateID, BuildError> {
      .          .          .          .                   // This is OK because we error when building the trie if we see a
      .          .          .          .                   // pattern whose length cannot fit into a 'SmallIndex', and the longest
      .          .          .          .                   // possible depth corresponds to the length of the longest pattern.
      .          .          .          .                   let depth = SmallIndex::new(depth)
      .          .          .          .                       .expect("patterns longer than SmallIndex::MAX are not allowed");
      .          .          .          .                   let id = StateID::new(self.states.len()).map_err(|e| {
      .          .          .          .                       BuildError::state_id_overflow(StateID::MAX.as_u64(), e.attempted())
      .          .          .          .                   })?;
      .          .          .          .                   self.states.push(State {
      .          .          .          .                       sparse: StateID::ZERO,
      .          .          .          .                       dense: StateID::ZERO,
      .          .          .          .                       matches: StateID::ZERO,
  2,624 ( 0.00%) .          .          .                       fail: self.special.start_unanchored_id,
      .          .          .          .                       depth,
      .          .          .          .                   });
  5,248 ( 0.00%) .          .          .                   Ok(id)
 20,992 ( 0.01%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           // SAFETY: 'start_state' always returns a valid state ID, 'next_state' always
      .          .          .          .           // returns a valid state ID given a valid state ID. We otherwise claim that
      .          .          .          .           // all other methods are correct as well.
      .          .          .          .           unsafe impl Automaton for NFA {
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn start_state(&self, anchored: Anchored) -> Result<StateID, MatchError> {
-- line 593 ----------------------------------------
-- line 606 ----------------------------------------
      .          .          .          .               ) -> StateID {
      .          .          .          .                   // This terminates since:
      .          .          .          .                   //
      .          .          .          .                   // 1. state.fail never points to the FAIL state.
      .          .          .          .                   // 2. All state.fail values point to a state closer to the start state.
      .          .          .          .                   // 3. The start state has no transitions to the FAIL state.
      .          .          .          .                   loop {
      .          .          .          .                       let next = self.follow_transition(sid, byte);
     90 ( 0.00%) .          .          .                       if next != NFA::FAIL {
      .          .          .          .                           return next;
      .          .          .          .                       }
      .          .          .          .                       // For an anchored search, we never follow failure transitions
      .          .          .          .                       // because failure transitions lead us down a path to matching
      .          .          .          .                       // a *proper* suffix of the path we were on. Thus, it can only
      .          .          .          .                       // produce matches that appear after the beginning of the search.
      .          .          .          .                       if anchored.is_anchored() {
      .          .          .          .                           return NFA::DEAD;
-- line 622 ----------------------------------------
-- line 647 ----------------------------------------
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn is_start(&self, sid: StateID) -> bool {
      .          .          .          .                   sid == self.special.start_unanchored_id
      .          .          .          .                       || sid == self.special.start_anchored_id
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn match_kind(&self) -> MatchKind {
     48 ( 0.00%) .          .          .                   self.match_kind
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn patterns_len(&self) -> usize {
      .          .          .          .                   self.pattern_lens.len()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn pattern_len(&self, pid: PatternID) -> usize {
      .          .          .          .                   self.pattern_lens[pid].as_usize()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn min_pattern_len(&self) -> usize {
     48 ( 0.00%) .          .          .                   self.min_pattern_len
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn max_pattern_len(&self) -> usize {
      .          .          .          .                   self.max_pattern_len
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline(always)]
-- line 678 ----------------------------------------
-- line 746 ----------------------------------------
      .          .          .          .               /// information, which we need when building the contiguous NFA.
      .          .          .          .               depth: SmallIndex,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl State {
      .          .          .          .               /// Return true if and only if this state is a match state.
      .          .          .          .               pub(crate) fn is_match(&self) -> bool {
      .          .          .          .                   self.matches != StateID::ZERO
  3,680 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the failure transition for this state.
      .          .          .          .               pub(crate) fn fail(&self) -> StateID {
 12,132 ( 0.00%) .          .          .                   self.fail
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the depth of this state. That is, the number of transitions
      .          .          .          .               /// this state is from the start state of the NFA.
      .          .          .          .               pub(crate) fn depth(&self) -> SmallIndex {
      .          .          .          .                   self.depth
      .          .          .          .               }
      .          .          .          .           }
-- line 766 ----------------------------------------
-- line 777 ----------------------------------------
      .          .          .          .           impl Transition {
      .          .          .          .               /// Return the byte for which this transition is defined.
      .          .          .          .               pub(crate) fn byte(&self) -> u8 {
      .          .          .          .                   self.byte
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the ID of the state that this transition points to.
      .          .          .          .               pub(crate) fn next(&self) -> StateID {
 12,288 ( 0.00%) .          .          .                   self.next
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the ID of the next transition.
      .          .          .          .               fn link(&self) -> StateID {
      .          .          .          .                   self.link
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
-- line 793 ----------------------------------------
-- line 843 ----------------------------------------
      .          .          .          .               match_kind: MatchKind,
      .          .          .          .               prefilter: bool,
      .          .          .          .               ascii_case_insensitive: bool,
      .          .          .          .               dense_depth: usize,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Default for Builder {
      .          .          .          .               fn default() -> Builder {
    198 ( 0.00%) .          .          .                   Builder {
      .          .          .          .                       match_kind: MatchKind::default(),
      .          .          .          .                       prefilter: true,
      .          .          .          .                       ascii_case_insensitive: false,
      .          .          .          .                       dense_depth: 3,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
-- line 859 ----------------------------------------
-- line 862 ----------------------------------------
      .          .          .          .               pub fn new() -> Builder {
      .          .          .          .                   Builder::default()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Build an Aho-Corasick noncontiguous NFA from the given iterator of
      .          .          .          .               /// patterns.
      .          .          .          .               ///
      .          .          .          .               /// A builder may be reused to create more NFAs.
    528 ( 0.00%) .          .          .               pub fn build<I, P>(&self, patterns: I) -> Result<NFA, BuildError>
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = P>,
      .          .          .          .                   P: AsRef<[u8]>,
      .          .          .          .               {
      .          .          .          .                   debug!("building non-contiguous NFA");
    336 ( 0.00%) .          .          .                   let nfa = Compiler::new(self)?.compile(patterns)?;
 32,264 ( 0.01%) 94 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::new (48x)
  6,000 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x)
      .          .          .          .                   debug!(
      .          .          .          .                       "non-contiguous NFA built, <states: {:?}, size: {:?}>",
      .          .          .          .                       nfa.states.len(),
      .          .          .          .                       nfa.memory_usage()
      .          .          .          .                   );
    288 ( 0.00%) .          .          .                   Ok(nfa)
    432 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the desired match semantics.
      .          .          .          .               ///
      .          .          .          .               /// See
      .          .          .          .               /// [`AhoCorasickBuilder::match_kind`](crate::AhoCorasickBuilder::match_kind)
      .          .          .          .               /// for more documentation and examples.
      .          .          .          .               pub fn match_kind(&mut self, kind: MatchKind) -> &mut Builder {
     66 ( 0.00%) .          .          .                   self.match_kind = kind;
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable ASCII-aware case insensitive matching.
      .          .          .          .               ///
      .          .          .          .               /// See
      .          .          .          .               /// [`AhoCorasickBuilder::ascii_case_insensitive`](crate::AhoCorasickBuilder::ascii_case_insensitive)
      .          .          .          .               /// for more documentation and examples.
-- line 899 ----------------------------------------
-- line 914 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable heuristic prefilter optimizations.
      .          .          .          .               ///
      .          .          .          .               /// See
      .          .          .          .               /// [`AhoCorasickBuilder::prefilter`](crate::AhoCorasickBuilder::prefilter)
      .          .          .          .               /// for more documentation and examples.
      .          .          .          .               pub fn prefilter(&mut self, yes: bool) -> &mut Builder {
     66 ( 0.00%) .          .          .                   self.prefilter = yes;
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A compiler uses a builder configuration and builds up the NFA formulation
      .          .          .          .           /// of an Aho-Corasick automaton. This roughly corresponds to the standard
      .          .          .          .           /// formulation described in textbooks, with some tweaks to support leftmost
      .          .          .          .           /// searching.
-- line 930 ----------------------------------------
-- line 932 ----------------------------------------
      .          .          .          .           struct Compiler<'a> {
      .          .          .          .               builder: &'a Builder,
      .          .          .          .               prefilter: prefilter::Builder,
      .          .          .          .               nfa: NFA,
      .          .          .          .               byteset: ByteClassSet,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'a> Compiler<'a> {
    432 ( 0.00%) .          .          .               fn new(builder: &'a Builder) -> Result<Compiler<'a>, BuildError> {
     96 ( 0.00%) .          .          .                   let prefilter = prefilter::Builder::new(builder.match_kind)
     48 ( 0.00%) .          .          .                       .ascii_case_insensitive(builder.ascii_case_insensitive);
  2,400 ( 0.00%) .          .          .                   Ok(Compiler {
  2,544 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x)
      .          .          .          .                       builder,
      .          .          .          .                       prefilter,
      .          .          .          .                       nfa: NFA {
      .          .          .          .                           match_kind: builder.match_kind,
      .          .          .          .                           states: vec![],
      .          .          .          .                           sparse: vec![],
      .          .          .          .                           dense: vec![],
      .          .          .          .                           matches: vec![],
-- line 951 ----------------------------------------
-- line 953 ----------------------------------------
      .          .          .          .                           prefilter: None,
      .          .          .          .                           byte_classes: ByteClasses::singletons(),
      .          .          .          .                           min_pattern_len: usize::MAX,
      .          .          .          .                           max_pattern_len: 0,
      .          .          .          .                           special: Special::zero(),
      .          .          .          .                       },
      .          .          .          .                       byteset: ByteClassSet::empty(),
      .          .          .          .                   })
    432 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn compile<I, P>(mut self, patterns: I) -> Result<NFA, BuildError>
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = P>,
      .          .          .          .                   P: AsRef<[u8]>,
      .          .          .          .               {
      .          .          .          .                   // Add dummy transition/match links, so that no valid link will point
      .          .          .          .                   // to another link at index 0.
     48 ( 0.00%) .          .          .                   self.nfa.sparse.push(Transition::default());
     48 ( 0.00%) .          .          .                   self.nfa.matches.push(Match::default());
      .          .          .          .                   // Add a dummy dense transition so that no states can have dense==0
      .          .          .          .                   // represent a valid pointer to dense transitions. This permits
      .          .          .          .                   // dense==0 to be a sentinel indicating "no dense transitions."
     48 ( 0.00%) .          .          .                   self.nfa.dense.push(NFA::DEAD);
      .          .          .          .                   // the dead state, only used for leftmost and fixed to id==0
    144 ( 0.00%) .          .          .                   self.nfa.alloc_state(0)?;
  8,560 ( 0.00%) 12 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (48x)
      .          .          .          .                   // the fail state, which is never entered and fixed to id==1
    144 ( 0.00%) .          .          .                   self.nfa.alloc_state(0)?;
  1,728 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (48x)
      .          .          .          .                   // unanchored start state, initially fixed to id==2 but later shuffled
      .          .          .          .                   // to appear after all non-start match states.
    240 ( 0.00%) .          .          .                   self.nfa.special.start_unanchored_id = self.nfa.alloc_state(0)?;
  1,728 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (48x)
      .          .          .          .                   // anchored start state, initially fixed to id==3 but later shuffled
      .          .          .          .                   // to appear after unanchored start state.
    288 ( 0.00%) .          .          .                   self.nfa.special.start_anchored_id = self.nfa.alloc_state(0)?;
  1,728 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (48x)
      .          .          .          .                   // Initialize the unanchored starting state in order to make it dense,
      .          .          .          .                   // and thus make transition lookups on this state faster.
     48 ( 0.00%) .          .          .                   self.init_unanchored_start_state()?;
1,354,850 ( 0.39%) 1,230 ( 0.15%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::init_unanchored_start_state (48x)
      .          .          .          .                   // Set all transitions on the DEAD state to point to itself. This way,
      .          .          .          .                   // the DEAD state can never be escaped. It MUST be used as a sentinel
      .          .          .          .                   // in any correct search.
     48 ( 0.00%) .          .          .                   self.add_dead_state_loop()?;
457,056 ( 0.13%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::add_dead_state_loop (48x)
      .          .          .          .                   // Build the base trie from the given patterns.
      .          .          .          .                   self.build_trie(patterns)?;
     96 ( 0.00%) .          .          .                   self.nfa.states.shrink_to_fit();
 11,105 ( 0.00%) 66 ( 0.01%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::shrink_to_fit (48x)
      .          .          .          .                   // Turn our set of bytes into equivalent classes. This NFA
      .          .          .          .                   // implementation uses byte classes only for states that use a dense
      .          .          .          .                   // representation of transitions. (And that's why this comes before
      .          .          .          .                   // `self.densify()`, as the byte classes need to be set first.)
    528 ( 0.00%) .          .          .                   self.nfa.byte_classes = self.byteset.byte_classes();
238,270 ( 0.07%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::byte_classes (48x)
  1,440 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x)
      .          .          .          .                   // Add transitions (and maybe matches) to the anchored starting state.
      .          .          .          .                   // The anchored starting state is used for anchored searches. The only
      .          .          .          .                   // mechanical difference between it and the unanchored start state is
      .          .          .          .                   // that missing transitions map to the DEAD state instead of the FAIL
      .          .          .          .                   // state.
     96 ( 0.00%) .          .          .                   self.set_anchored_start_state()?;
385,728 ( 0.11%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state (48x)
      .          .          .          .                   // Rewrite transitions to the FAIL state on the unanchored start state
      .          .          .          .                   // as self-transitions. This keeps the start state active at all times.
    144 ( 0.00%) .          .          .                   self.add_unanchored_start_state_loop();
158,544 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::add_unanchored_start_state_loop (48x)
      .          .          .          .                   // Make some (possibly zero) states use a dense representation for
      .          .          .          .                   // transitions. It's important to do this right after the states
      .          .          .          .                   // and non-failure transitions are solidified. That way, subsequent
      .          .          .          .                   // accesses (particularly `fill_failure_transitions`) will benefit from
      .          .          .          .                   // the faster transition lookup in densified states.
     96 ( 0.00%) .          .          .                   self.densify()?;
921,773 ( 0.27%) 796 ( 0.10%) 6 ( 1.85%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::densify (48x)
      .          .          .          .                   // The meat of the Aho-Corasick algorithm: compute and write failure
      .          .          .          .                   // transitions. i.e., the state to move to when a transition isn't
      .          .          .          .                   // defined in the current state. These are epsilon transitions and thus
      .          .          .          .                   // make this formulation an NFA.
     48 ( 0.00%) .          .          .                   self.fill_failure_transitions()?;
564,716 ( 0.16%) 384 ( 0.05%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions (48x)
      .          .          .          .                   // Handle a special case under leftmost semantics when at least one
      .          .          .          .                   // of the patterns is the empty string.
     96 ( 0.00%) .          .          .                   self.close_start_state_loop_for_leftmost();
    816 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::close_start_state_loop_for_leftmost (48x)
      .          .          .          .                   // Shuffle states so that we have DEAD, FAIL, MATCH, ..., START, START,
      .          .          .          .                   // NON-MATCH, ... This permits us to very quickly query the type of
      .          .          .          .                   // the state we're currently in during a search.
     96 ( 0.00%) .          .          .                   self.shuffle();
1,870,849 ( 0.54%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle (48x)
    432 ( 0.00%) .          .          .                   self.nfa.prefilter = self.prefilter.build();
298,368 ( 0.09%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/prefilter.rs:aho_corasick::util::prefilter::Builder::build (48x)
      .          .          .          .                   // Store the maximum ID of all *relevant* special states. Start states
      .          .          .          .                   // are only relevant when we have a prefilter, otherwise, there is zero
      .          .          .          .                   // reason to care about whether a state is a start state or not during
      .          .          .          .                   // a search. Indeed, without a prefilter, we are careful to explicitly
      .          .          .          .                   // NOT care about start states, otherwise the search can ping pong
      .          .          .          .                   // between the unrolled loop and the handling of special-status states
      .          .          .          .                   // and destroy perf.
     48 ( 0.00%) .          .          .                   self.nfa.special.max_special_id = if self.nfa.prefilter.is_some() {
      .          .          .          .                       // Why the anchored starting state? Because we always put it
      .          .          .          .                       // after the unanchored starting state and it is therefore the
      .          .          .          .                       // maximum. Why put unanchored followed by anchored? No particular
      .          .          .          .                       // reason, but that's how the states are logically organized in the
      .          .          .          .                       // Thompson NFA implementation found in regex-automata. ¯\_(ツ)_/¯
      .          .          .          .                       self.nfa.special.start_anchored_id
      .          .          .          .                   } else {
      .          .          .          .                       self.nfa.special.max_match_id
      .          .          .          .                   };
     96 ( 0.00%) .          .          .                   self.nfa.sparse.shrink_to_fit();
 16,461 ( 0.00%) 134 ( 0.02%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::shrink_to_fit (48x)
     96 ( 0.00%) .          .          .                   self.nfa.dense.shrink_to_fit();
 17,765 ( 0.01%) 227 ( 0.03%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::shrink_to_fit (48x)
     96 ( 0.00%) .          .          .                   self.nfa.matches.shrink_to_fit();
 12,872 ( 0.00%) 94 ( 0.01%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::shrink_to_fit (48x)
     96 ( 0.00%) .          .          .                   self.nfa.pattern_lens.shrink_to_fit();
  9,978 ( 0.00%) 81 ( 0.01%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::shrink_to_fit (48x)
    624 ( 0.00%) .          .          .                   Ok(self.nfa)
  3,696 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x)
     96 ( 0.00%) .          .          .               }
  9,501 ( 0.00%) 94 ( 0.01%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<aho_corasick::util::prefilter::Builder> (48x)
      .          .          .          .           
      .          .          .          .               /// This sets up the initial prefix trie that makes up the Aho-Corasick
      .          .          .          .               /// automaton. Effectively, it creates the basic structure of the
      .          .          .          .               /// automaton, where every pattern given has a path from the start state to
      .          .          .          .               /// the end of the pattern.
      .          .          .          .               fn build_trie<I, P>(&mut self, patterns: I) -> Result<(), BuildError>
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = P>,
      .          .          .          .                   P: AsRef<[u8]>,
      .          .          .          .               {
  1,394 ( 0.00%) .          .          .                   'PATTERNS: for (i, pat) in patterns.into_iter().enumerate() {
      .          .          .          .                       let pid = PatternID::new(i).map_err(|e| {
      .          .          .          .                           BuildError::pattern_id_overflow(
      .          .          .          .                               PatternID::MAX.as_u64(),
      .          .          .          .                               e.attempted(),
      .          .          .          .                           )
      .          .          .          .                       })?;
      .          .          .          .                       let pat = pat.as_ref();
      .          .          .          .                       let patlen = SmallIndex::new(pat.len())
      .          .          .          .                           .map_err(|_| BuildError::pattern_too_long(pid, pat.len()))?;
  1,394 ( 0.00%) .          .          .                       self.nfa.min_pattern_len =
  1,394 ( 0.00%) .          .          .                           core::cmp::min(self.nfa.min_pattern_len, pat.len());
  1,394 ( 0.00%) .          .          .                       self.nfa.max_pattern_len =
  1,394 ( 0.00%) .          .          .                           core::cmp::max(self.nfa.max_pattern_len, pat.len());
  5,576 ( 0.00%) .          .          .                       assert_eq!(
      .          .          .          .                           i,
      .          .          .          .                           self.nfa.pattern_lens.len(),
      .          .          .          .                           "expected number of patterns to match pattern ID"
      .          .          .          .                       );
      .          .          .          .                       self.nfa.pattern_lens.push(patlen);
      .          .          .          .                       // We add the pattern to the prefilter here because the pattern
      .          .          .          .                       // ID in the prefilter is determined with respect to the patterns
      .          .          .          .                       // added to the prefilter. That is, it isn't the ID we have here,
-- line 1084 ----------------------------------------
-- line 1086 ----------------------------------------
      .          .          .          .                       // To ensure they line up, we add every pattern we see to the
      .          .          .          .                       // prefilter, even if some patterns ultimately are impossible to
      .          .          .          .                       // match (in leftmost-first semantics specifically).
      .          .          .          .                       //
      .          .          .          .                       // Another way of doing this would be to expose an API in the
      .          .          .          .                       // prefilter to permit setting your own pattern IDs. Or to just use
      .          .          .          .                       // our own map and go between them. But this case is sufficiently
      .          .          .          .                       // rare that we don't bother and just make sure they're in sync.
  4,182 ( 0.00%) .          .          .                       if self.builder.prefilter {
      .          .          .          .                           self.prefilter.add(pat);
      .          .          .          .                       }
      .          .          .          .           
  1,394 ( 0.00%) .          .          .                       let mut prev = self.nfa.special.start_unanchored_id;
      .          .          .          .                       let mut saw_match = false;
  3,680 ( 0.00%) .          .          .                       for (depth, &b) in pat.iter().enumerate() {
      .          .          .          .                           // When leftmost-first match semantics are requested, we
      .          .          .          .                           // specifically stop adding patterns when a previously added
      .          .          .          .                           // pattern is a prefix of it. We avoid adding it because
      .          .          .          .                           // leftmost-first semantics imply that the pattern can never
      .          .          .          .                           // match. This is not just an optimization to save space! It
      .          .          .          .                           // is necessary for correctness. In fact, this is the only
      .          .          .          .                           // difference in the automaton between the implementations for
      .          .          .          .                           // leftmost-first and leftmost-longest.
 14,720 ( 0.00%) .          .          .                           saw_match = saw_match || self.nfa.states[prev].is_match();
 11,040 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::State::is_match (3,680x)
  7,360 ( 0.00%) .          .          .                           if self.builder.match_kind.is_leftmost_first() && saw_match {
      .          .          .          .                               // Skip to the next pattern immediately. This avoids
      .          .          .          .                               // incorrectly adding a match after this loop terminates.
      .          .          .          .                               continue 'PATTERNS;
      .          .          .          .                           }
      .          .          .          .           
      .          .          .          .                           // Add this byte to our equivalence classes. These don't
      .          .          .          .                           // get used while building the trie, but other Aho-Corasick
      .          .          .          .                           // implementations may use them.
 14,720 ( 0.00%) .          .          .                           self.byteset.set_range(b, b);
125,120 ( 0.04%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::set_range (3,680x)
 11,040 ( 0.00%) .          .          .                           if self.builder.ascii_case_insensitive {
      .          .          .          .                               let b = opposite_ascii_case(b);
      .          .          .          .                               self.byteset.set_range(b, b);
      .          .          .          .                           }
      .          .          .          .           
      .          .          .          .                           // If the transition from prev using the current byte already
      .          .          .          .                           // exists, then just move through it. Otherwise, add a new
      .          .          .          .                           // state. We track the depth here so that we can determine
      .          .          .          .                           // how to represent transitions. States near the start state
      .          .          .          .                           // use a dense representation that uses more memory but is
      .          .          .          .                           // faster. Other states use a sparse representation that uses
      .          .          .          .                           // less memory but is slower.
      .          .          .          .                           let next = self.nfa.follow_transition(prev, b);
  1,740 ( 0.00%) .          .          .                           if next != NFA::FAIL {
      .          .          .          .                               prev = next;
      .          .          .          .                           } else {
 14,592 ( 0.00%) .          .          .                               let next = self.nfa.alloc_state(depth)?;
201,040 ( 0.06%) 597 ( 0.07%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (2,432x)
 14,592 ( 0.00%) .          .          .                               self.nfa.add_transition(prev, b, next)?;
652,804 ( 0.19%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::add_transition (2,432x)
  7,296 ( 0.00%) .          .          .                               if self.builder.ascii_case_insensitive {
      .          .          .          .                                   let b = opposite_ascii_case(b);
      .          .          .          .                                   self.nfa.add_transition(prev, b, next)?;
      .          .          .          .                               }
      .          .          .          .                               prev = next;
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       // Once the pattern has been added, log the match in the final
      .          .          .          .                       // state that it reached.
  6,970 ( 0.00%) .          .          .                       self.nfa.add_match(prev, pid)?;
168,663 ( 0.05%) 305 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::add_match (1,394x)
      .          .          .          .                   }
      .          .          .          .                   Ok(())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// This routine creates failure transitions according to the standard
      .          .          .          .               /// textbook formulation of the Aho-Corasick algorithm, with a couple small
      .          .          .          .               /// tweaks to support "leftmost" semantics.
      .          .          .          .               ///
-- line 1155 ----------------------------------------
-- line 1267 ----------------------------------------
      .          .          .          .               /// N.B. I came up with this algorithm on my own, and after scouring all of
      .          .          .          .               /// the other AC implementations I know of (Perl, Snort, many on GitHub).
      .          .          .          .               /// I couldn't find any that implement leftmost semantics like this.
      .          .          .          .               /// Perl of course needs leftmost-first semantics, but they implement it
      .          .          .          .               /// with a seeming hack at *search* time instead of encoding it into the
      .          .          .          .               /// automaton. There are also a couple Java libraries that support leftmost
      .          .          .          .               /// longest semantics, but they do it by building a queue of matches at
      .          .          .          .               /// search time, which is even worse than what Perl is doing. ---AG
    384 ( 0.00%) .          .          .               fn fill_failure_transitions(&mut self) -> Result<(), BuildError> {
     48 ( 0.00%) .          .          .                   let is_leftmost = self.builder.match_kind.is_leftmost();
     48 ( 0.00%) .          .          .                   let start_uid = self.nfa.special.start_unanchored_id;
      .          .          .          .                   // Initialize the queue for breadth first search with all transitions
      .          .          .          .                   // out of the start state. We handle the start state specially because
      .          .          .          .                   // we only want to follow non-self transitions. If we followed self
      .          .          .          .                   // transitions, then this would never terminate.
      .          .          .          .                   let mut queue = VecDeque::new();
      .          .          .          .                   let mut seen = self.queued_set();
      .          .          .          .                   let mut prev_link = None;
 12,336 ( 0.00%) .          .          .                   while let Some(link) = self.nfa.next_link(start_uid, prev_link) {
      .          .          .          .                       prev_link = Some(link);
 36,864 ( 0.01%) .          .          .                       let t = self.nfa.sparse[link];
      .          .          .          .           
      .          .          .          .                       // Skip anything we've seen before and any self-transitions on the
      .          .          .          .                       // start state.
 12,288 ( 0.00%) .          .          .                       if start_uid == t.next() || seen.contains(t.next) {
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       queue.push_back(t.next);
      .          .          .          .                       seen.insert(t.next);
      .          .          .          .                       // Under leftmost semantics, if a state immediately following
      .          .          .          .                       // the start state is a match state, then we never want to
      .          .          .          .                       // follow its failure transition since the failure transition
      .          .          .          .                       // necessarily leads back to the start state, which we never
      .          .          .          .                       // want to do for leftmost matching after a match has been
      .          .          .          .                       // found.
      .          .          .          .                       //
      .          .          .          .                       // We apply the same logic to non-start states below as well.
    540 ( 0.00%) .          .          .                       if is_leftmost && self.nfa.states[t.next].is_match() {
    127 ( 0.00%) .          .          .                           self.nfa.states[t.next].fail = NFA::DEAD;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   while let Some(id) = queue.pop_front() {
      .          .          .          .                       let mut prev_link = None;
  1,940 ( 0.00%) .          .          .                       while let Some(link) = self.nfa.next_link(id, prev_link) {
      .          .          .          .                           prev_link = Some(link);
  3,880 ( 0.00%) .          .          .                           let t = self.nfa.sparse[link];
      .          .          .          .           
      .          .          .          .                           if seen.contains(t.next) {
      .          .          .          .                               // The only way to visit a duplicate state in a transition
      .          .          .          .                               // list is when ASCII case insensitivity is enabled. In
      .          .          .          .                               // this case, we want to skip it since it's redundant work.
      .          .          .          .                               // But it would also end up duplicating matches, which
      .          .          .          .                               // results in reporting duplicate matches in some cases.
      .          .          .          .                               // See the 'acasei010' regression test.
-- line 1320 ----------------------------------------
-- line 1339 ----------------------------------------
      .          .          .          .                           // otherwise require passing through a match state.
      .          .          .          .                           //
      .          .          .          .                           // Note that for correctness, the failure transition has to be
      .          .          .          .                           // set to the dead state for ALL states following a match, not
      .          .          .          .                           // just the match state itself. However, by setting the failure
      .          .          .          .                           // transition to the dead state on all match states, the dead
      .          .          .          .                           // state will automatically propagate to all subsequent states
      .          .          .          .                           // via the failure state computation below.
  4,553 ( 0.00%) .          .          .                           if is_leftmost && self.nfa.states[t.next].is_match() {
  1,267 ( 0.00%) .          .          .                               self.nfa.states[t.next].fail = NFA::DEAD;
      .          .          .          .                               continue;
      .          .          .          .                           }
      .          .          .          .                           let mut fail = self.nfa.states[id].fail;
  2,019 ( 0.00%) .          .          .                           while self.nfa.follow_transition(fail, t.byte) == NFA::FAIL {
      .          .          .          .                               fail = self.nfa.states[fail].fail;
      .          .          .          .                           }
      .          .          .          .                           fail = self.nfa.follow_transition(fail, t.byte);
  1,346 ( 0.00%) .          .          .                           self.nfa.states[t.next].fail = fail;
  2,692 ( 0.00%) .          .          .                           self.nfa.copy_matches(fail, t.next)?;
 32,304 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::copy_matches (673x)
      .          .          .          .                       }
      .          .          .          .                       // If the start state is a match state, then this automaton can
      .          .          .          .                       // match the empty string. This implies all states are match states
      .          .          .          .                       // since every position matches the empty string, so copy the
      .          .          .          .                       // matches from the start state to every state. Strictly speaking,
      .          .          .          .                       // this is only necessary for overlapping matches since each
      .          .          .          .                       // non-empty non-start match state needs to report empty matches
      .          .          .          .                       // in addition to its own. For the non-overlapping case, such
      .          .          .          .                       // states only report the first match, which is never empty since
      .          .          .          .                       // it isn't a start state.
  2,432 ( 0.00%) .          .          .                       if !is_leftmost {
      .          .          .          .                           self.nfa
      .          .          .          .                               .copy_matches(self.nfa.special.start_unanchored_id, id)?;
      .          .          .          .                       }
      .          .          .          .                   }
     48 ( 0.00%) .          .          .                   Ok(())
    432 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Shuffle the states so that they appear in this sequence:
      .          .          .          .               ///
      .          .          .          .               ///   DEAD, FAIL, MATCH..., START, START, NON-MATCH...
      .          .          .          .               ///
      .          .          .          .               /// The idea here is that if we know how special states are laid out in our
      .          .          .          .               /// transition table, then we can determine what "kind" of state we're in
      .          .          .          .               /// just by comparing our current state ID with a particular value. In this
-- line 1382 ----------------------------------------
-- line 1391 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               ///   DEAD, FAIL, START, START, MATCH... NON-MATCH...
      .          .          .          .               ///
      .          .          .          .               /// Then it's just a simple matter of swapping the two START states with
      .          .          .          .               /// the last two MATCH states.
      .          .          .          .               ///
      .          .          .          .               /// (This is the same technique used for fully compiled DFAs in
      .          .          .          .               /// regex-automata.)
    336 ( 0.00%) .          .          .               fn shuffle(&mut self) {
     48 ( 0.00%) .          .          .                   let old_start_uid = self.nfa.special.start_unanchored_id;
     48 ( 0.00%) .          .          .                   let old_start_aid = self.nfa.special.start_anchored_id;
     48 ( 0.00%) .          .          .                   assert!(old_start_uid < old_start_aid);
     96 ( 0.00%) .          .          .                   assert_eq!(
      .          .          .          .                       3,
      .          .          .          .                       old_start_aid.as_usize(),
      .          .          .          .                       "anchored start state should be at index 3"
      .          .          .          .                   );
      .          .          .          .                   // We implement shuffling by a sequence of pairwise swaps of states.
      .          .          .          .                   // Since we have a number of things referencing states via their
      .          .          .          .                   // IDs and swapping them changes their IDs, we need to record every
      .          .          .          .                   // swap we make so that we can remap IDs. The remapper handles this
-- line 1411 ----------------------------------------
-- line 1416 ----------------------------------------
      .          .          .          .                   // START-UNANCHORED, START-ANCHORED, MATCH, ..., NON-MATCH, ...
      .          .          .          .                   //
      .          .          .          .                   // To do that, we proceed forward through all states after
      .          .          .          .                   // START-ANCHORED and swap match states so that they appear before all
      .          .          .          .                   // non-match states.
      .          .          .          .                   let mut next_avail = StateID::from(4u8);
      .          .          .          .                   for i in next_avail.as_usize()..self.nfa.states.len() {
      .          .          .          .                       let sid = StateID::new(i).unwrap();
  7,296 ( 0.00%) .          .          .                       if !self.nfa.states[sid].is_match() {
      .          .          .          .                           continue;
      .          .          .          .                       }
  8,364 ( 0.00%) .          .          .                       remapper.swap(&mut self.nfa, sid, next_avail);
 56,920 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::swap (1,394x)
      .          .          .          .                       // The key invariant here is that only non-match states exist
      .          .          .          .                       // between 'next_avail' and 'sid' (with them being potentially
      .          .          .          .                       // equivalent). Thus, incrementing 'next_avail' by 1 is guaranteed
      .          .          .          .                       // to land on the leftmost non-match state. (Unless 'next_avail'
      .          .          .          .                       // and 'sid' are equivalent, in which case, a swap will occur but
      .          .          .          .                       // it is a no-op.)
      .          .          .          .                       next_avail = StateID::new(next_avail.one_more()).unwrap();
      .          .          .          .                   }
-- line 1435 ----------------------------------------
-- line 1455 ----------------------------------------
      .          .          .          .                   // or not. And indeed, if we did check for it, this very hot loop would
      .          .          .          .                   // ping pong between the special state handling and the main state
      .          .          .          .                   // transition logic. This in turn stalls the CPU by killing branch
      .          .          .          .                   // prediction.
      .          .          .          .                   //
      .          .          .          .                   // So essentially, we really want to be able to "forget" that start
      .          .          .          .                   // states even exist and this is why we put them at the end.
      .          .          .          .                   let new_start_aid =
     48 ( 0.00%) .          .          .                       StateID::new(next_avail.as_usize().checked_sub(1).unwrap())
      .          .          .          .                           .unwrap();
    192 ( 0.00%) .          .          .                   remapper.swap(&mut self.nfa, old_start_aid, new_start_aid);
  2,016 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::swap (48x)
      .          .          .          .                   let new_start_uid =
      .          .          .          .                       StateID::new(next_avail.as_usize().checked_sub(2).unwrap())
      .          .          .          .                           .unwrap();
    192 ( 0.00%) .          .          .                   remapper.swap(&mut self.nfa, old_start_uid, new_start_uid);
  2,016 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::swap (48x)
      .          .          .          .                   let new_max_match_id =
      .          .          .          .                       StateID::new(next_avail.as_usize().checked_sub(3).unwrap())
      .          .          .          .                           .unwrap();
     48 ( 0.00%) .          .          .                   self.nfa.special.max_match_id = new_max_match_id;
     48 ( 0.00%) .          .          .                   self.nfa.special.start_unanchored_id = new_start_uid;
     48 ( 0.00%) .          .          .                   self.nfa.special.start_anchored_id = new_start_aid;
      .          .          .          .                   // If one start state is a match state, then they both are.
     48 ( 0.00%) .          .          .                   if self.nfa.states[self.nfa.special.start_anchored_id].is_match() {
      .          .          .          .                       self.nfa.special.max_match_id = self.nfa.special.start_anchored_id;
      .          .          .          .                   }
    336 ( 0.00%) .          .          .                   remapper.remap(&mut self.nfa);
1,738,425 ( 0.50%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::remap (48x)
    384 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Attempts to convert the transition representation of a subset of states
      .          .          .          .               /// in this NFA from sparse to dense. This can greatly improve search
      .          .          .          .               /// performance since states with a higher number of transitions tend to
      .          .          .          .               /// correlate with very active states.
      .          .          .          .               ///
      .          .          .          .               /// We generally only densify states that are close to the start state.
      .          .          .          .               /// These tend to be the most active states and thus benefit from a dense
-- line 1489 ----------------------------------------
-- line 1492 ----------------------------------------
      .          .          .          .               /// This tends to best balance between memory usage and performance. In
      .          .          .          .               /// particular, the *vast majority* of all states in a typical Aho-Corasick
      .          .          .          .               /// automaton have only 1 transition and are usually farther from the start
      .          .          .          .               /// state and thus don't get densified.
      .          .          .          .               ///
      .          .          .          .               /// Note that this doesn't remove the sparse representation of transitions
      .          .          .          .               /// for states that are densified. It could be done, but actually removing
      .          .          .          .               /// entries from `NFA::sparse` is likely more expensive than it's worth.
    336 ( 0.00%) .          .          .               fn densify(&mut self) -> Result<(), BuildError> {
      .          .          .          .                   for i in 0..self.nfa.states.len() {
      .          .          .          .                       let sid = StateID::new(i).unwrap();
      .          .          .          .                       // Don't bother densifying states that are only used as sentinels.
  5,248 ( 0.00%) .          .          .                       if sid == NFA::DEAD || sid == NFA::FAIL {
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       // Only densify states that are "close enough" to the start state.
  5,056 ( 0.00%) .          .          .                       if self.nfa.states[sid].depth.as_usize()
      .          .          .          .                           >= self.builder.dense_depth
      .          .          .          .                       {
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       let dense = self.nfa.alloc_dense_state()?;
      .          .          .          .                       let mut prev_link = None;
 28,921 ( 0.01%) .          .          .                       while let Some(link) = self.nfa.next_link(sid, prev_link) {
      .          .          .          .                           prev_link = Some(link);
 53,014 ( 0.02%) .          .          .                           let t = self.nfa.sparse[link];
      .          .          .          .           
      .          .          .          .                           let class = usize::from(self.nfa.byte_classes.get(t.byte));
 26,507 ( 0.01%) .          .          .                           let index = dense.as_usize() + class;
 26,507 ( 0.01%) .          .          .                           self.nfa.dense[index] = t.next;
      .          .          .          .                       }
  2,414 ( 0.00%) .          .          .                       self.nfa.states[sid].dense = dense;
      .          .          .          .                   }
      .          .          .          .                   Ok(())
    432 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a set that tracked queued states.
      .          .          .          .               ///
      .          .          .          .               /// This is only necessary when ASCII case insensitivity is enabled, since
      .          .          .          .               /// it is the only way to visit the same state twice. Otherwise, this
      .          .          .          .               /// returns an inert set that nevers adds anything and always reports
      .          .          .          .               /// `false` for every member test.
      .          .          .          .               fn queued_set(&self) -> QueuedSet {
     96 ( 0.00%) .          .          .                   if self.builder.ascii_case_insensitive {
      .          .          .          .                       QueuedSet::active()
      .          .          .          .                   } else {
      .          .          .          .                       QueuedSet::inert()
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Initializes the unanchored start state by making it dense. This is
      .          .          .          .               /// achieved by explicitly setting every transition to the FAIL state.
      .          .          .          .               /// This isn't necessary for correctness, since any missing transition is
      .          .          .          .               /// automatically assumed to be mapped to the FAIL state. We do this to
      .          .          .          .               /// make the unanchored starting state dense, and thus in turn make
      .          .          .          .               /// transition lookups on it faster. (Which is worth doing because it's
      .          .          .          .               /// the most active state.)
    240 ( 0.00%) .          .          .               fn init_unanchored_start_state(&mut self) -> Result<(), BuildError> {
     96 ( 0.00%) .          .          .                   let start_uid = self.nfa.special.start_unanchored_id;
     48 ( 0.00%) .          .          .                   let start_aid = self.nfa.special.start_anchored_id;
    144 ( 0.00%) .          .          .                   self.nfa.init_full_state(start_uid, NFA::FAIL)?;
852,338 ( 0.25%) 1,126 ( 0.14%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state (48x)
    192 ( 0.00%) .          .          .                   self.nfa.init_full_state(start_aid, NFA::FAIL)?;
500,976 ( 0.14%) 104 ( 0.01%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state (48x)
      .          .          .          .                   Ok(())
    288 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Setup the anchored start state by copying all of the transitions and
      .          .          .          .               /// matches from the unanchored starting state with one change: the failure
      .          .          .          .               /// transition is changed to the DEAD state, so that for any undefined
      .          .          .          .               /// transitions, the search will stop.
    288 ( 0.00%) .          .          .               fn set_anchored_start_state(&mut self) -> Result<(), BuildError> {
     48 ( 0.00%) .          .          .                   let start_uid = self.nfa.special.start_unanchored_id;
      .          .          .          .                   let start_aid = self.nfa.special.start_anchored_id;
      .          .          .          .                   let (mut uprev_link, mut aprev_link) = (None, None);
      .          .          .          .                   loop {
      .          .          .          .                       let unext = self.nfa.next_link(start_uid, uprev_link);
      .          .          .          .                       let anext = self.nfa.next_link(start_aid, aprev_link);
 24,720 ( 0.01%) .          .          .                       let (ulink, alink) = match (unext, anext) {
      .          .          .          .                           (Some(ulink), Some(alink)) => (ulink, alink),
      .          .          .          .                           (None, None) => break,
      .          .          .          .                           _ => unreachable!(),
      .          .          .          .                       };
      .          .          .          .                       uprev_link = Some(ulink);
      .          .          .          .                       aprev_link = Some(alink);
 49,152 ( 0.01%) .          .          .                       self.nfa.sparse[alink].next = self.nfa.sparse[ulink].next;
      .          .          .          .                   }
    144 ( 0.00%) .          .          .                   self.nfa.copy_matches(start_uid, start_aid)?;
  2,304 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::copy_matches (48x)
      .          .          .          .                   // This is the main difference between the unanchored and anchored
      .          .          .          .                   // starting states. If a lookup on an anchored starting state fails,
      .          .          .          .                   // then the search should stop.
      .          .          .          .                   //
      .          .          .          .                   // N.B. This assumes that the loop on the unanchored starting state
      .          .          .          .                   // hasn't been created yet.
     96 ( 0.00%) .          .          .                   self.nfa.states[start_aid].fail = NFA::DEAD;
      .          .          .          .                   Ok(())
    384 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the failure transitions on the start state to loop back to the
      .          .          .          .               /// start state. This effectively permits the Aho-Corasick automaton to
      .          .          .          .               /// match at any position. This is also required for finding the next
      .          .          .          .               /// state to terminate, namely, finding the next state should never return
      .          .          .          .               /// a fail_id.
      .          .          .          .               ///
      .          .          .          .               /// This must be done after building the initial trie, since trie
      .          .          .          .               /// construction depends on transitions to `fail_id` to determine whether a
      .          .          .          .               /// state already exists or not.
     96 ( 0.00%) .          .          .               fn add_unanchored_start_state_loop(&mut self) {
     48 ( 0.00%) .          .          .                   let start_uid = self.nfa.special.start_unanchored_id;
      .          .          .          .                   let mut prev_link = None;
 12,336 ( 0.00%) .          .          .                   while let Some(link) = self.nfa.next_link(start_uid, prev_link) {
      .          .          .          .                       prev_link = Some(link);
 24,576 ( 0.01%) .          .          .                       if self.nfa.sparse[link].next() == NFA::FAIL {
 23,592 ( 0.01%) .          .          .                           self.nfa.sparse[link].next = start_uid;
      .          .          .          .                       }
      .          .          .          .                   }
     96 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Remove the start state loop by rewriting any transitions on the start
      .          .          .          .               /// state back to the start state with transitions to the dead state.
      .          .          .          .               ///
      .          .          .          .               /// The loop is only closed when two conditions are met: the start state
      .          .          .          .               /// is a match state and the match kind is leftmost-first or
      .          .          .          .               /// leftmost-longest.
      .          .          .          .               ///
      .          .          .          .               /// The reason for this is that under leftmost semantics, a start state
      .          .          .          .               /// that is also a match implies that we should never restart the search
      .          .          .          .               /// process. We allow normal transitions out of the start state, but if
      .          .          .          .               /// none exist, we transition to the dead state, which signals that
      .          .          .          .               /// searching should stop.
     96 ( 0.00%) .          .          .               fn close_start_state_loop_for_leftmost(&mut self) {
     48 ( 0.00%) .          .          .                   let start_uid = self.nfa.special.start_unanchored_id;
      .          .          .          .                   let start = &mut self.nfa.states[start_uid];
      .          .          .          .                   let dense = start.dense;
    144 ( 0.00%) .          .          .                   if self.builder.match_kind.is_leftmost() && start.is_match() {
      .          .          .          .                       let mut prev_link = None;
      .          .          .          .                       while let Some(link) = self.nfa.next_link(start_uid, prev_link) {
      .          .          .          .                           prev_link = Some(link);
      .          .          .          .                           if self.nfa.sparse[link].next() == start_uid {
      .          .          .          .                               self.nfa.sparse[link].next = NFA::DEAD;
      .          .          .          .                               if dense != StateID::ZERO {
      .          .          .          .                                   let b = self.nfa.sparse[link].byte;
      .          .          .          .                                   let class = usize::from(self.nfa.byte_classes.get(b));
      .          .          .          .                                   self.nfa.dense[dense.as_usize() + class] = NFA::DEAD;
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
     96 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets all transitions on the dead state to point back to the dead state.
      .          .          .          .               /// Normally, missing transitions map back to the failure state, but the
      .          .          .          .               /// point of the dead state is to act as a sink that can never be escaped.
    144 ( 0.00%) .          .          .               fn add_dead_state_loop(&mut self) -> Result<(), BuildError> {
    192 ( 0.00%) .          .          .                   self.nfa.init_full_state(NFA::DEAD, NFA::DEAD)?;
456,288 ( 0.13%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state (48x)
      .          .          .          .                   Ok(())
    192 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A set of state identifiers used to avoid revisiting the same state multiple
      .          .          .          .           /// times when filling in failure transitions.
      .          .          .          .           ///
      .          .          .          .           /// This set has an "inert" and an "active" mode. When inert, the set never
      .          .          .          .           /// stores anything and always returns `false` for every member test. This is
      .          .          .          .           /// useful to avoid the performance and memory overhead of maintaining this
-- line 1654 ----------------------------------------
-- line 1668 ----------------------------------------
      .          .          .          .               /// Return an active set that tracks state ID membership.
      .          .          .          .               fn active() -> QueuedSet {
      .          .          .          .                   QueuedSet { set: Some(BTreeSet::new()) }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Inserts the given state ID into this set. (If the set is inert, then
      .          .          .          .               /// this is a no-op.)
      .          .          .          .               fn insert(&mut self, state_id: StateID) {
  4,864 ( 0.00%) .          .          .                   if let Some(ref mut set) = self.set {
      .          .          .          .                       set.insert(state_id);
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if the given state ID is in this set. If the
      .          .          .          .               /// set is inert, this always returns false.
      .          .          .          .               fn contains(&self, state_id: StateID) -> bool {
  4,864 ( 0.00%) .          .          .                   match self.set {
      .          .          .          .                       None => false,
      .          .          .          .                       Some(ref set) => set.contains(&state_id),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl core::fmt::Debug for NFA {
      .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-- line 1692 ----------------------------------------

605,676 ( 0.17%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/sparse_set.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 37 ----------------------------------------
     .          .          .          .               pub(crate) set1: SparseSet,
     .          .          .          .               pub(crate) set2: SparseSet,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl SparseSets {
     .          .          .          .               /// Create a new pair of sparse sets where each set has the given capacity.
     .          .          .          .               ///
     .          .          .          .               /// This panics if the capacity given is bigger than `StateID::LIMIT`.
   819 ( 0.00%) .          .          .               pub(crate) fn new(capacity: usize) -> SparseSets {
     .          .          .          .                   SparseSets {
     .          .          .          .                       set1: SparseSet::new(capacity),
     .          .          .          .                       set2: SparseSet::new(capacity),
     .          .          .          .                   }
 1,053 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Resizes these sparse sets to have the new capacity given.
     .          .          .          .               ///
     .          .          .          .               /// The sets are automatically cleared.
     .          .          .          .               ///
     .          .          .          .               /// This panics if the capacity given is bigger than `StateID::LIMIT`.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn resize(&mut self, new_capacity: usize) {
-- line 58 ----------------------------------------
-- line 68 ----------------------------------------
     .          .          .          .           
     .          .          .          .               /// Swap set1 with set2.
     .          .          .          .               pub(crate) fn swap(&mut self) {
     .          .          .          .                   core::mem::swap(&mut self.set1, &mut self.set2);
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the memory usage, in bytes, used by this pair of sparse sets.
     .          .          .          .               pub(crate) fn memory_usage(&self) -> usize {
 1,467 ( 0.00%) .          .          .                   self.set1.memory_usage() + self.set2.memory_usage()
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A sparse set used for representing ordered NFA states.
     .          .          .          .           ///
     .          .          .          .           /// This supports constant time addition and membership testing. Clearing an
     .          .          .          .           /// entire set can also be done in constant time. Iteration yields elements
     .          .          .          .           /// in the order in which they were inserted.
-- line 84 ----------------------------------------
-- line 110 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// Sparse sets have a fixed size and they cannot grow. Attempting to
     .          .          .          .               /// insert more distinct elements than the total capacity of the set will
     .          .          .          .               /// result in a panic.
     .          .          .          .               ///
     .          .          .          .               /// This panics if the capacity given is bigger than `StateID::LIMIT`.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn new(capacity: usize) -> SparseSet {
 2,392 ( 0.00%) .          .          .                   let mut set = SparseSet { len: 0, dense: vec![], sparse: vec![] };
     .          .          .          .                   set.resize(capacity);
 5,425 ( 0.00%) .          .          .                   set
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Resizes this sparse set to have the new capacity given.
     .          .          .          .               ///
     .          .          .          .               /// This set is automatically cleared.
     .          .          .          .               ///
     .          .          .          .               /// This panics if the capacity given is bigger than `StateID::LIMIT`.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn resize(&mut self, new_capacity: usize) {
   479 ( 0.00%) .          .          .                   assert!(
   677 ( 0.00%) .          .          .                       new_capacity <= StateID::LIMIT,
     .          .          .          .                       "sparse set capacity cannot excced {:?}",
     .          .          .          .                       StateID::LIMIT
     .          .          .          .                   );
     .          .          .          .                   self.clear();
     .          .          .          .                   self.dense.resize(new_capacity, StateID::ZERO);
     .          .          .          .                   self.sparse.resize(new_capacity, StateID::ZERO);
     .          .          .          .               }
     .          .          .          .           
-- line 139 ----------------------------------------
-- line 144 ----------------------------------------
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn capacity(&self) -> usize {
     .          .          .          .                   self.dense.len()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the number of elements in this set.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn len(&self) -> usize {
10,476 ( 0.00%) .          .          .                   self.len
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set is empty.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn is_empty(&self) -> bool {
   436 ( 0.00%) .          .          .                   self.len() == 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Insert the state ID value into this set and return true if the given
     .          .          .          .               /// state ID was not previously in this set.
     .          .          .          .               ///
     .          .          .          .               /// This operation is idempotent. If the given value is already in this
     .          .          .          .               /// set, then this is a no-op.
     .          .          .          .               ///
     .          .          .          .               /// If more than `capacity` ids are inserted, then this panics.
     .          .          .          .               ///
     .          .          .          .               /// This is marked as inline(always) since the compiler won't inline it
     .          .          .          .               /// otherwise, and it's a fairly hot piece of code in DFA determinization.
     .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
     .          .          .          .               pub(crate) fn insert(&mut self, id: StateID) -> bool {
 5,308 ( 0.00%) .          .          .                   if self.contains(id) {
     .          .          .          .                       return false;
     .          .          .          .                   }
     .          .          .          .           
     .          .          .          .                   let i = self.len();
 7,016 ( 0.00%) .          .          .                   assert!(
 7,016 ( 0.00%) .          .          .                       i < self.capacity(),
     .          .          .          .                       "{:?} exceeds capacity of {:?} when inserting {:?}",
     .          .          .          .                       i,
     .          .          .          .                       self.capacity(),
     .          .          .          .                       id,
     .          .          .          .                   );
     .          .          .          .                   // OK since i < self.capacity() and self.capacity() is guaranteed to
     .          .          .          .                   // be <= StateID::LIMIT.
     .          .          .          .                   let index = StateID::new_unchecked(i);
 7,016 ( 0.00%) .          .          .                   self.dense[index] = id;
14,032 ( 0.00%) .          .          .                   self.sparse[id] = index;
 9,899 ( 0.00%) .          .          .                   self.len += 1;
     .          .          .          .                   true
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set contains the given value.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn contains(&self, id: StateID) -> bool {
 7,016 ( 0.00%) .          .          .                   let index = self.sparse[id];
14,032 ( 0.00%) .          .          .                   index.as_usize() < self.len() && self.dense[index] == id
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Clear this set such that it has no members.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn clear(&mut self) {
 1,566 ( 0.00%) .          .          .                   self.len = 0;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn iter(&self) -> SparseSetIter<'_> {
   477 ( 0.00%) .          .          .                   SparseSetIter(self.dense[..self.len()].iter())
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the heap memory usage, in bytes, used by this sparse set.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn memory_usage(&self) -> usize {
 1,568 ( 0.00%) .          .          .                   self.dense.len() * StateID::SIZE + self.sparse.len() * StateID::SIZE
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl core::fmt::Debug for SparseSet {
     .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
     .          .          .          .                   let elements: Vec<StateID> = self.iter().collect();
     .          .          .          .                   f.debug_tuple("SparseSet").field(&elements).finish()
     .          .          .          .               }
-- line 223 ----------------------------------------
-- line 229 ----------------------------------------
     .          .          .          .           #[derive(Debug)]
     .          .          .          .           pub(crate) struct SparseSetIter<'a>(core::slice::Iter<'a, StateID>);
     .          .          .          .           
     .          .          .          .           impl<'a> Iterator for SparseSetIter<'a> {
     .          .          .          .               type Item = StateID;
     .          .          .          .           
     .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
     .          .          .          .               fn next(&mut self) -> Option<StateID> {
 2,231 ( 0.00%) .          .          .                   self.0.next().map(|&id| id)
     .          .          .          .               }
     .          .          .          .           }

 1,643 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/sparse_set.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 85 ----------------------------------------
      .          .          .          .           ///
      .          .          .          .           /// While a `SmallIndex` is meant to guarantee that its value fits into `usize`
      .          .          .          .           /// without using as much space as a `usize` on all targets, callers must
      .          .          .          .           /// not rely on this property for safety. Callers may choose to rely on this
      .          .          .          .           /// property for correctness however. For example, creating a `SmallIndex` with
      .          .          .          .           /// an invalid value can be done in entirely safe code. This may in turn result
      .          .          .          .           /// in panics or silent logical errors.
      .          .          .          .           #[derive(
305,176 ( 0.09%) .          .          .               Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord,
      .          .          .          .           )]
      .          .          .          .           #[repr(transparent)]
      .          .          .          .           pub(crate) struct SmallIndex(u32);
      .          .          .          .           
      .          .          .          .           impl SmallIndex {
      .          .          .          .               /// The maximum index value.
      .          .          .          .               #[cfg(any(target_pointer_width = "32", target_pointer_width = "64"))]
      .          .          .          .               pub const MAX: SmallIndex =
-- line 101 ----------------------------------------
-- line 117 ----------------------------------------
      .          .          .          .               pub const SIZE: usize = core::mem::size_of::<SmallIndex>();
      .          .          .          .           
      .          .          .          .               /// Create a new small index.
      .          .          .          .               ///
      .          .          .          .               /// If the given index exceeds [`SmallIndex::MAX`], then this returns
      .          .          .          .               /// an error.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn new(index: usize) -> Result<SmallIndex, SmallIndexError> {
  8,364 ( 0.00%) .          .          .                   SmallIndex::try_from(index)
 19,516 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs:<aho_corasick::util::primitives::SmallIndex as core::convert::TryFrom<usize>>::try_from (2,788x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new small index without checking whether the given value
      .          .          .          .               /// exceeds [`SmallIndex::MAX`].
      .          .          .          .               ///
      .          .          .          .               /// Using this routine with an invalid index value will result in
      .          .          .          .               /// unspecified behavior, but *not* undefined behavior. In particular, an
      .          .          .          .               /// invalid index value is likely to cause panics or possibly even silent
      .          .          .          .               /// logical errors.
      .          .          .          .               ///
      .          .          .          .               /// Callers must never rely on a `SmallIndex` to be within a certain range
      .          .          .          .               /// for memory safety.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn new_unchecked(index: usize) -> SmallIndex {
      .          .          .          .                   // FIXME: Use as_u32() once const functions in traits are stable.
  2,768 ( 0.00%) .          .          .                   SmallIndex::from_u32_unchecked(index as u32)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new small index from a `u32` without checking whether the
      .          .          .          .               /// given value exceeds [`SmallIndex::MAX`].
      .          .          .          .               ///
      .          .          .          .               /// Using this routine with an invalid index value will result in
      .          .          .          .               /// unspecified behavior, but *not* undefined behavior. In particular, an
      .          .          .          .               /// invalid index value is likely to cause panics or possibly even silent
-- line 149 ----------------------------------------
-- line 162 ----------------------------------------
      .          .          .          .                   SmallIndex::new(index).expect("invalid small index")
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return this small index as a `usize`. This is guaranteed to never
      .          .          .          .               /// overflow `usize`.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn as_usize(&self) -> usize {
      .          .          .          .                   // FIXME: Use as_usize() once const functions in traits are stable.
337,540 ( 0.10%) .          .          .                   self.0 as usize
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return this small index as a `u64`. This is guaranteed to never
      .          .          .          .               /// overflow.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn as_u64(&self) -> u64 {
      .          .          .          .                   // FIXME: Use u64::from() once const functions in traits are stable.
      .          .          .          .                   self.0 as u64
-- line 178 ----------------------------------------
-- line 317 ----------------------------------------
      .          .          .          .                   }
      .          .          .          .                   Ok(SmallIndex::new_unchecked(index.as_usize()))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl TryFrom<usize> for SmallIndex {
      .          .          .          .               type Error = SmallIndexError;
      .          .          .          .           
  2,788 ( 0.00%) .          .          .               fn try_from(index: usize) -> Result<SmallIndex, SmallIndexError> {
151,300 ( 0.04%) .          .          .                   if index > SmallIndex::MAX.as_usize() {
      .          .          .          .                       return Err(SmallIndexError { attempted: index.as_u64() });
      .          .          .          .                   }
  5,576 ( 0.00%) .          .          .                   Ok(SmallIndex::new_unchecked(index))
  2,788 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// This error occurs when a small index could not be constructed.
      .          .          .          .           ///
      .          .          .          .           /// This occurs when given an integer exceeding the maximum small index value.
      .          .          .          .           ///
      .          .          .          .           /// When the `std` feature is enabled, this implements the `Error` trait.
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
-- line 338 ----------------------------------------
-- line 365 ----------------------------------------
      .          .          .          .           pub(crate) struct SmallIndexIter {
      .          .          .          .               rng: core::ops::Range<usize>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Iterator for SmallIndexIter {
      .          .          .          .               type Item = SmallIndex;
      .          .          .          .           
      .          .          .          .               fn next(&mut self) -> Option<SmallIndex> {
  5,248 ( 0.00%) .          .          .                   if self.rng.start >= self.rng.end {
      .          .          .          .                       return None;
      .          .          .          .                   }
      .          .          .          .                   let next_id = self.rng.start + 1;
      .          .          .          .                   let id = core::mem::replace(&mut self.rng.start, next_id);
      .          .          .          .                   // new_unchecked is OK since we asserted that the number of
      .          .          .          .                   // elements in this iterator will fit in an ID at construction.
      .          .          .          .                   Some(SmallIndex::new_unchecked(id))
      .          .          .          .               }
-- line 381 ----------------------------------------
-- line 636 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   #[derive(Clone, Debug)]
      .          .          .          .                   pub(crate) struct $iter(SmallIndexIter);
      .          .          .          .           
      .          .          .          .                   impl $iter {
      .          .          .          .                       fn new(len: usize) -> $iter {
     48 ( 0.00%) .          .          .                           assert!(
     48 ( 0.00%) .          .          .                               len <= $name::LIMIT,
      .          .          .          .                               "cannot create iterator for {} when number of \
      .          .          .          .                                elements exceed {:?}",
      .          .          .          .                               stringify!($name),
      .          .          .          .                               $name::LIMIT,
      .          .          .          .                           );
      .          .          .          .                           $iter(SmallIndexIter { rng: 0..len })
      .          .          .          .                       }
      .          .          .          .                   }
-- line 653 ----------------------------------------
-- line 728 ----------------------------------------
      .          .          .          .           /// not rely on this property for safety. Callers may choose to rely on this
      .          .          .          .           /// property for correctness however. For example, creating a `StateID` with an
      .          .          .          .           /// invalid value can be done in entirely safe code. This may in turn result in
      .          .          .          .           /// panics or silent logical errors.
      .          .          .          .           #[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]
      .          .          .          .           #[repr(transparent)]
      .          .          .          .           pub struct StateID(SmallIndex);
      .          .          .          .           
  3,562 ( 0.00%) .          .          .           index_type_impls!(PatternID, PatternIDError, PatternIDIter, WithPatternIDIter);
394,329 ( 0.11%) .          .          .           index_type_impls!(StateID, StateIDError, StateIDIter, WithStateIDIter);
      .          .          .          .           
      .          .          .          .           /// A utility trait that defines a couple of adapters for making it convenient
      .          .          .          .           /// to access indices as "small index" types. We require ExactSizeIterator so
      .          .          .          .           /// that iterator construction can do a single check to make sure the index of
      .          .          .          .           /// each element is representable by its small index type.
      .          .          .          .           pub(crate) trait IteratorIndexExt: Iterator {
      .          .          .          .               fn with_pattern_ids(self) -> WithPatternIDIter<Self>
      .          .          .          .               where
-- line 745 ----------------------------------------

 94,578 ( 0.03%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/primitives.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/remapper.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 83 ----------------------------------------
     .          .          .          .               /// A mapper from state index to state ID (and back).
     .          .          .          .               idxmap: IndexMapper,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl Remapper {
     .          .          .          .               /// Create a new remapper from the given remappable implementation. The
     .          .          .          .               /// remapper can then be used to swap states. The remappable value given
     .          .          .          .               /// here must the same one given to `swap` and `remap`.
     4 ( 0.00%) .          .          .               pub(super) fn new(r: &impl Remappable) -> Remapper {
     .          .          .          .                   let idxmap = IndexMapper { stride2: r.stride2() };
     .          .          .          .                   let map = (0..r.state_len()).map(|i| idxmap.to_state_id(i)).collect();
     1 ( 0.00%) .          .          .                   Remapper { map, idxmap }
     5 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Swap two states. Once this is called, callers must follow through to
     .          .          .          .               /// call `remap`, or else it's possible for the underlying remappable
     .          .          .          .               /// value to be in a corrupt state.
     3 ( 0.00%) .          .          .               pub(super) fn swap(
     .          .          .          .                   &mut self,
     .          .          .          .                   r: &mut impl Remappable,
     .          .          .          .                   id1: StateID,
     .          .          .          .                   id2: StateID,
     .          .          .          .               ) {
     1 ( 0.00%) .          .          .                   if id1 == id2 {
     .          .          .          .                       return;
     .          .          .          .                   }
     .          .          .          .                   r.swap_states(id1, id2);
     1 ( 0.00%) .          .          .                   self.map.swap(self.idxmap.to_index(id1), self.idxmap.to_index(id2));
     4 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Complete the remapping process by rewriting all state IDs in the
     .          .          .          .               /// remappable value according to the swaps performed.
     9 ( 0.00%) .          .          .               pub(super) fn remap(mut self, r: &mut impl Remappable) {
     .          .          .          .                   // Update the map to account for states that have been swapped
     .          .          .          .                   // multiple times. For example, if (A, C) and (C, G) are swapped, then
     .          .          .          .                   // transitions previously pointing to A should now point to G. But if
     .          .          .          .                   // we don't update our map, they will erroneously be set to C. All we
     .          .          .          .                   // do is follow the swaps in our map until we see our original state
     .          .          .          .                   // ID.
     .          .          .          .                   //
     .          .          .          .                   // The intuition here is to think about how changes are made to the
-- line 123 ----------------------------------------
-- line 128 ----------------------------------------
     .          .          .          .                   //
     .          .          .          .                   // We are also careful to clone the map before starting in order to
     .          .          .          .                   // freeze it. We use the frozen map to find our loops, since we need to
     .          .          .          .                   // update our map as well. Without freezing it, our updates could break
     .          .          .          .                   // the loops referenced above and produce incorrect results.
     .          .          .          .                   let oldmap = self.map.clone();
     .          .          .          .                   for i in 0..r.state_len() {
     .          .          .          .                       let cur_id = self.idxmap.to_state_id(i);
    74 ( 0.00%) .          .          .                       let mut new_id = oldmap[i];
    76 ( 0.00%) .          .          .                       if cur_id == new_id {
     .          .          .          .                           continue;
     .          .          .          .                       }
     .          .          .          .                       loop {
     4 ( 0.00%) .          .          .                           let id = oldmap[self.idxmap.to_index(new_id)];
     2 ( 0.00%) .          .          .                           if cur_id == id {
     8 ( 0.00%) .          .          .                               self.map[i] = new_id;
     .          .          .          .                               break;
     .          .          .          .                           }
     .          .          .          .                           new_id = id;
     .          .          .          .                       }
     .          .          .          .                   }
     6 ( 0.00%) .          .          .                   r.remap(|next| self.map[self.idxmap.to_index(next)]);
102,562 ( 0.03%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/remapper.rs:regex_automata::dfa::remapper::onepass::<impl regex_automata::dfa::remapper::Remappable for regex_automata::dfa::onepass::DFA>::remap (1x)
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A simple type for mapping between state indices and state IDs.
     .          .          .          .           ///
     .          .          .          .           /// The reason why this exists is because state IDs are "premultiplied." That
     .          .          .          .           /// is, in order to get to the transitions for a particular state, one need
     .          .          .          .           /// only use the state ID as-is, instead of having to multiple it by transition
-- line 157 ----------------------------------------
-- line 171 ----------------------------------------
     .          .          .          .               /// transition table. 'id >> stride2' de-multiplies an ID while 'index <<
     .          .          .          .               /// stride2' pre-multiplies an index to an ID.
     .          .          .          .               stride2: usize,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl IndexMapper {
     .          .          .          .               /// Convert a state ID to a state index.
     .          .          .          .               fn to_index(&self, id: StateID) -> usize {
11,995 ( 0.00%) .          .          .                   id.as_usize() >> self.stride2
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Convert a state index to a state ID.
     .          .          .          .               fn to_state_id(&self, index: usize) -> StateID {
     .          .          .          .                   // CORRECTNESS: If the given index is not valid, then it is not
     .          .          .          .                   // required for this to panic or return a valid state ID. We'll "just"
     .          .          .          .                   // wind up with panics or silent logic errors at some other point.
   296 ( 0.00%) .          .          .                   StateID::new_unchecked(index << self.stride2)
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[cfg(feature = "dfa-build")]
     .          .          .          .           mod dense {
     .          .          .          .               use crate::{dfa::dense::OwnedDFA, util::primitives::StateID};
     .          .          .          .           
     .          .          .          .               use super::Remappable;
-- line 195 ----------------------------------------
-- line 230 ----------------------------------------
     .          .          .          .                       // equivalent.
     .          .          .          .                       0
     .          .          .          .                   }
     .          .          .          .           
     .          .          .          .                   fn swap_states(&mut self, id1: StateID, id2: StateID) {
     .          .          .          .                       DFA::swap_states(self, id1, id2)
     .          .          .          .                   }
     .          .          .          .           
     9 ( 0.00%) .          .          .                   fn remap(&mut self, map: impl Fn(StateID) -> StateID) {
     .          .          .          .                       DFA::remap(self, map)
     8 ( 0.00%) .          .          .                   }
     .          .          .          .               }
     .          .          .          .           }

     4 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/dfa/remapper.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 90 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// The given stride should be the stride of the transition table expressed
      .          .          .          .               /// as a power of 2. This stride is used to map between state IDs and state
      .          .          .          .               /// indices. If state IDs and state indices are equivalent, then provide
      .          .          .          .               /// a `stride2` of `0`, which acts as an identity.
      .          .          .          .               pub(crate) fn new(r: &impl Remappable, stride2: usize) -> Remapper {
      .          .          .          .                   let idx = IndexMapper { stride2 };
      .          .          .          .                   let map = (0..r.state_len()).map(|i| idx.to_state_id(i)).collect();
    192 ( 0.00%) .          .          .                   Remapper { map, idx }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Swap two states. Once this is called, callers must follow through to
      .          .          .          .               /// call `remap`, or else it's possible for the underlying remappable
      .          .          .          .               /// value to be in a corrupt state.
  1,490 ( 0.00%) .          .          .               pub(crate) fn swap(
      .          .          .          .                   &mut self,
      .          .          .          .                   r: &mut impl Remappable,
      .          .          .          .                   id1: StateID,
      .          .          .          .                   id2: StateID,
      .          .          .          .               ) {
  1,490 ( 0.00%) .          .          .                   if id1 == id2 {
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .                   r.swap_states(id1, id2);
  1,446 ( 0.00%) .          .          .                   self.map.swap(self.idx.to_index(id1), self.idx.to_index(id2));
  2,980 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Complete the remapping process by rewriting all state IDs in the
      .          .          .          .               /// remappable value according to the swaps performed.
    432 ( 0.00%) .          .          .               pub(crate) fn remap(mut self, r: &mut impl Remappable) {
      .          .          .          .                   // Update the map to account for states that have been swapped
      .          .          .          .                   // multiple times. For example, if (A, C) and (C, G) are swapped, then
      .          .          .          .                   // transitions previously pointing to A should now point to G. But if
      .          .          .          .                   // we don't update our map, they will erroneously be set to C. All we
      .          .          .          .                   // do is follow the swaps in our map until we see our original state
      .          .          .          .                   // ID.
      .          .          .          .                   //
      .          .          .          .                   // The intuition here is to think about how changes are made to the
-- line 127 ----------------------------------------
-- line 131 ----------------------------------------
      .          .          .          .                   // 0 swaps).
      .          .          .          .                   //
      .          .          .          .                   // We are also careful to clone the map before starting in order to
      .          .          .          .                   // freeze it. We use the frozen map to find our loops, since we need to
      .          .          .          .                   // update our map as well. Without freezing it, our updates could break
      .          .          .          .                   // the loops referenced above and produce incorrect results.
      .          .          .          .                   let oldmap = self.map.clone();
      .          .          .          .                   for i in 0..r.state_len() {
  2,624 ( 0.00%) .          .          .                       let cur_id = self.idx.to_state_id(i);
  2,624 ( 0.00%) .          .          .                       let mut new_id = oldmap[i];
  4,596 ( 0.00%) .          .          .                       if cur_id == new_id {
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       loop {
 23,470 ( 0.01%) .          .          .                           let id = oldmap[self.idx.to_index(new_id)];
 23,470 ( 0.01%) .          .          .                           if cur_id == id {
  7,888 ( 0.00%) .          .          .                               self.map[i] = new_id;
      .          .          .          .                               break;
      .          .          .          .                           }
      .          .          .          .                           new_id = id;
      .          .          .          .                       }
      .          .          .          .                   }
134,967 ( 0.04%) .          .          .                   r.remap(|sid| self.map[self.idx.to_index(sid)]);
1,488,569 ( 0.43%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap (48x)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A simple type for mapping between state indices and state IDs.
      .          .          .          .           ///
      .          .          .          .           /// The reason why this exists is because state IDs are "premultiplied" in a
      .          .          .          .           /// DFA. That is, in order to get to the transitions for a particular state,
      .          .          .          .           /// one need only use the state ID as-is, instead of having to multiply it by
-- line 161 ----------------------------------------
-- line 179 ----------------------------------------
      .          .          .          .               /// transition table. 'id >> stride2' de-multiplies an ID while 'index <<
      .          .          .          .               /// stride2' pre-multiplies an index to an ID.
      .          .          .          .               stride2: usize,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl IndexMapper {
      .          .          .          .               /// Convert a state ID to a state index.
      .          .          .          .               fn to_index(&self, id: StateID) -> usize {
162,583 ( 0.05%) .          .          .                   id.as_usize() >> self.stride2
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Convert a state index to a state ID.
      .          .          .          .               fn to_state_id(&self, index: usize) -> StateID {
      .          .          .          .                   // CORRECTNESS: If the given index is not valid, then it is not
      .          .          .          .                   // required for this to panic or return a valid state ID. We'll "just"
      .          .          .          .                   // wind up with panics or silent logic errors at some other point. But
      .          .          .          .                   // this is OK because if Remappable::state_len is correct and so is
      .          .          .          .                   // 'to_index', then all inputs to 'to_state_id' should be valid indices
      .          .          .          .                   // and thus transform into valid state IDs.
  7,872 ( 0.00%) .          .          .                   StateID::new_unchecked(index << self.stride2)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Remappable for noncontiguous::NFA {
      .          .          .          .               fn state_len(&self) -> usize {
      .          .          .          .                   noncontiguous::NFA::states(self).len()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn swap_states(&mut self, id1: StateID, id2: StateID) {
  2,892 ( 0.00%) .          .          .                   noncontiguous::NFA::swap_states(self, id1, id2)
      .          .          .          .               }
      .          .          .          .           
    336 ( 0.00%) .          .          .               fn remap(&mut self, map: impl Fn(StateID) -> StateID) {
      .          .          .          .                   noncontiguous::NFA::remap(self, map)
    384 ( 0.00%) .          .          .               }
      .          .          .          .           }

 29,246 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/util/remapper.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 196 ----------------------------------------
      .          .          .          .           /// expression pattern string, and uses constant stack space and heap space
      .          .          .          .           /// proportional to the size of the `Hir`. The regex it prints is guaranteed to
      .          .          .          .           /// be _semantically_ equivalent to the original concrete syntax, but it may
      .          .          .          .           /// look very different. (And potentially not practically readable by a human.)
      .          .          .          .           ///
      .          .          .          .           /// An `Hir`'s `fmt::Debug` implementation currently does not use constant
      .          .          .          .           /// stack space. The implementation will also suppress some details (such as
      .          .          .          .           /// the `Properties` inlined into every `Hir` value to make it less noisy).
    897 ( 0.00%) .          .          .           #[derive(Clone, Eq, PartialEq)]
      .          .          .          .           pub struct Hir {
      .          .          .          .               /// The underlying HIR kind.
      .          .          .          .               kind: HirKind,
      .          .          .          .               /// Analysis info about this HIR, computed during construction.
    194 ( 0.00%) .          .          .               props: Properties,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Methods for accessing the underlying `HirKind` and `Properties`.
      .          .          .          .           impl Hir {
      .          .          .          .               /// Returns a reference to the underlying HIR kind.
 87,468 ( 0.03%) .          .          .               pub fn kind(&self) -> &HirKind {
      .          .          .          .                   &self.kind
 87,468 ( 0.03%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Consumes ownership of this HIR expression and returns its underlying
      .          .          .          .               /// `HirKind`.
     65 ( 0.00%) .          .          .               pub fn into_kind(mut self) -> HirKind {
      .          .          .          .                   core::mem::replace(&mut self.kind, HirKind::Empty)
     65 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the properties computed for this `Hir`.
      .          .          .          .               pub fn properties(&self) -> &Properties {
    549 ( 0.00%) .          .          .                   &self.props
    549 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Splits this HIR into its constituent parts.
      .          .          .          .               ///
      .          .          .          .               /// This is useful because `let Hir { kind, props } = hir;` does not work
      .          .          .          .               /// because of `Hir`'s custom `Drop` implementation.
194,215 ( 0.06%) .          .          .               fn into_parts(mut self) -> (HirKind, Properties) {
272,037 ( 0.08%) .          .          .                   (
      .          .          .          .                       core::mem::replace(&mut self.kind, HirKind::Empty),
      .          .          .          .                       core::mem::replace(&mut self.props, Properties::empty()),
      .          .          .          .                   )
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Smart constructors for HIR values.
      .          .          .          .           ///
-- line 243 ----------------------------------------
-- line 334 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// let ch = '☃';
      .          .          .          .               /// let got = Hir::literal(ch.encode_utf8(&mut [0; 4]).as_bytes());
      .          .          .          .               ///
      .          .          .          .               /// let expected = HirKind::Literal(Literal(Box::from("☃".as_bytes())));
      .          .          .          .               /// assert_eq!(&expected, got.kind());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
107,842 ( 0.03%) .          .          .               pub fn literal<B: Into<Box<[u8]>>>(lit: B) -> Hir {
      .          .          .          .                   let bytes = lit.into();
 31,997 ( 0.01%) .          .          .                   if bytes.is_empty() {
      .          .          .          .                       return Hir::empty();
      .          .          .          .                   }
      .          .          .          .           
  5,736 ( 0.00%) .          .          .                   let lit = Literal(bytes);
  1,912 ( 0.00%) .          .          .                   let props = Properties::literal(&lit);
667,227 ( 0.19%) 3,638 ( 0.45%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::literal (1,912x)
 75,088 ( 0.02%) .          .          .                   Hir { kind: HirKind::Literal(lit), props }
 92,436 ( 0.03%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates a class HIR expression. The class may either be defined over
      .          .          .          .               /// ranges of Unicode codepoints or ranges of raw byte values.
      .          .          .          .               ///
      .          .          .          .               /// Note that an empty class is permitted. An empty class is equivalent to
      .          .          .          .               /// `Hir::fail()`.
      .          .          .          .               #[inline]
 34,911 ( 0.01%) .          .          .               pub fn class(class: Class) -> Hir {
  4,981 ( 0.00%) .          .          .                   if class.is_empty() {
    330 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Class::is_empty (110x)
      .          .          .          .                       return Hir::fail();
 15,756 ( 0.00%) .          .          .                   } else if let Some(bytes) = class.literal() {
  2,090 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Class::literal (110x)
      .          .          .          .                       return Hir::literal(bytes);
      .          .          .          .                   }
  5,153 ( 0.00%) .          .          .                   let props = Properties::class(&class);
707,635 ( 0.20%) 4,020 ( 0.50%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::class (2,425x)
 21,714 ( 0.01%) .          .          .                   Hir { kind: HirKind::Class(class), props }
 31,032 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates a look-around assertion HIR expression.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn look(look: Look) -> Hir {
      4 ( 0.00%) .          .          .                   let props = Properties::look(look);
    333 ( 0.00%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::look (2x)
      8 ( 0.00%) .          .          .                   Hir { kind: HirKind::Look(look), props }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates a repetition HIR expression.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn repetition(mut rep: Repetition) -> Hir {
      .          .          .          .                   // If the sub-expression of a repetition can only match the empty
      .          .          .          .                   // string, then we force its maximum to be at most 1.
  2,479 ( 0.00%) .          .          .                   if rep.sub.properties().maximum_len() == Some(0) {
    150 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::properties (75x)
      .          .          .          .                       rep.min = cmp::min(rep.min, 1);
      .          .          .          .                       rep.max = rep.max.map(|n| cmp::min(n, 1)).or(Some(1));
      .          .          .          .                   }
      .          .          .          .                   // The regex 'a{0}' is always equivalent to the empty regex. This is
      .          .          .          .                   // true even when 'a' is an expression that never matches anything
      .          .          .          .                   // (like '\P{any}').
      .          .          .          .                   //
      .          .          .          .                   // Additionally, the regex 'a{1}' is always equivalent to 'a'.
  6,779 ( 0.00%) .          .          .                   if rep.min == 0 && rep.max == Some(0) {
      .          .          .          .                       return Hir::empty();
    159 ( 0.00%) .          .          .                   } else if rep.min == 1 && rep.max == Some(1) {
      .          .          .          .                       return *rep.sub;
      .          .          .          .                   }
  3,919 ( 0.00%) .          .          .                   let props = Properties::repetition(&rep);
 24,579 ( 0.01%) 138 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::repetition (75x)
 12,353 ( 0.00%) .          .          .                   Hir { kind: HirKind::Repetition(rep), props }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates a capture HIR expression.
      .          .          .          .               ///
      .          .          .          .               /// Note that there is no explicit HIR value for a non-capturing group.
      .          .          .          .               /// Since a non-capturing group only exists to override precedence in the
      .          .          .          .               /// concrete syntax and since an HIR already does its own grouping based on
      .          .          .          .               /// what is parsed, there is no need to explicitly represent non-capturing
      .          .          .          .               /// groups in the HIR.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn capture(capture: Capture) -> Hir {
  1,386 ( 0.00%) .          .          .                   let props = Properties::capture(&capture);
209,714 ( 0.06%) 1,132 ( 0.14%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::capture (693x)
  3,465 ( 0.00%) .          .          .                   Hir { kind: HirKind::Capture(capture), props }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the concatenation of the given expressions.
      .          .          .          .               ///
      .          .          .          .               /// This attempts to flatten and simplify the concatenation as appropriate.
      .          .          .          .               ///
      .          .          .          .               /// # Example
      .          .          .          .               ///
-- line 417 ----------------------------------------
-- line 431 ----------------------------------------
      .          .          .          .               ///         Hir::literal([b'x']),
      .          .          .          .               ///         Hir::literal([b'y']),
      .          .          .          .               ///         Hir::literal([b'z']),
      .          .          .          .               ///     ]),
      .          .          .          .               /// ]);
      .          .          .          .               /// let expected = Hir::literal("abcxyz".as_bytes());
      .          .          .          .               /// assert_eq!(expected, hir);
      .          .          .          .               /// ```
127,544 ( 0.04%) .          .          .               pub fn concat(subs: Vec<Hir>) -> Hir {
      .          .          .          .                   // We rebuild the concatenation by simplifying it. Would be nice to do
      .          .          .          .                   // it in place, but that seems a little tricky?
      .          .          .          .                   let mut new = vec![];
      .          .          .          .                   // This gobbles up any adjacent literals in a concatenation and smushes
      .          .          .          .                   // them together. Basically, when we see a literal, we add its bytes
      .          .          .          .                   // to 'prior_lit', and whenever we see anything else, we first take
      .          .          .          .                   // any bytes in 'prior_lit' and add it to the 'new' concatenation.
 15,943 ( 0.00%) .          .          .                   let mut prior_lit: Option<Vec<u8>> = None;
205,500 ( 0.06%) .          .          .                   for sub in subs {
226,050 ( 0.07%) .          .          .                       let (kind, props) = sub.into_parts();
8,066,965 ( 2.32%) 29,389 ( 3.63%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::into_parts (20,550x)
215,788 ( 0.06%) .          .          .                       match kind {
 30,812 ( 0.01%) .          .          .                           HirKind::Literal(Literal(bytes)) => {
 46,218 ( 0.01%) .          .          .                               if let Some(ref mut prior_bytes) = prior_lit {
      .          .          .          .                                   prior_bytes.extend_from_slice(&bytes);
      .          .          .          .                               } else {
 61,624 ( 0.02%) .          .          .                                   prior_lit = Some(bytes.to_vec());
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                           // We also flatten concats that are direct children of another
      .          .          .          .                           // concat. We only need to do this one level deep since
      .          .          .          .                           // Hir::concat is the only way to build concatenations, and so
      .          .          .          .                           // flattening happens inductively.
    116 ( 0.00%) .          .          .                           HirKind::Concat(subs2) => {
    738 ( 0.00%) .          .          .                               for sub2 in subs2 {
      .          .          .          .                                   let (kind2, props2) = sub2.into_parts();
    136 ( 0.00%) .          .          .                                   match kind2 {
      .          .          .          .                                       HirKind::Literal(Literal(bytes)) => {
      4 ( 0.00%) .          .          .                                           if let Some(ref mut prior_bytes) = prior_lit {
      .          .          .          .                                               prior_bytes.extend_from_slice(&bytes);
      .          .          .          .                                           } else {
      6 ( 0.00%) .          .          .                                               prior_lit = Some(bytes.to_vec());
      .          .          .          .                                           }
      .          .          .          .                                       }
    132 ( 0.00%) .          .          .                                       kind2 => {
    132 ( 0.00%) .          .          .                                           if let Some(prior_bytes) = prior_lit.take() {
      .          .          .          .                                               new.push(Hir::literal(prior_bytes));
      .          .          .          .                                           }
      .          .          .          .                                           new.push(Hir { kind: kind2, props: props2 });
      .          .          .          .                                       }
      .          .          .          .                                   }
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                           // We can just skip empty HIRs.
      .          .          .          .                           HirKind::Empty => {}
      .          .          .          .                           kind => {
 17,880 ( 0.01%) .          .          .                               if let Some(prior_bytes) = prior_lit.take() {
  4,590 ( 0.00%) .          .          .                                   new.push(Hir::literal(prior_bytes));
234,391 ( 0.07%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::literal (1,530x)
      .          .          .          .                               }
      .          .          .          .                               new.push(Hir { kind, props });
      .          .          .          .                           }
      .          .          .          .                       }
138,857 ( 0.04%) .          .          .                   }
117,209 ( 0.03%) .          .          .                   if let Some(prior_bytes) = prior_lit.take() {
 13,876 ( 0.00%) .          .          .                       new.push(Hir::literal(prior_bytes));
2,147,152 ( 0.62%) 10 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::literal (13,876x)
      .          .          .          .                   }
 36,032 ( 0.01%) .          .          .                   if new.is_empty() {
      .          .          .          .                       return Hir::empty();
      .          .          .          .                   } else if new.len() == 1 {
      .          .          .          .                       return new.pop().unwrap();
      .          .          .          .                   }
      .          .          .          .                   let props = Properties::concat(&new);
 14,511 ( 0.00%) .          .          .                   Hir { kind: HirKind::Concat(new), props }
143,487 ( 0.04%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the alternation of the given expressions.
      .          .          .          .               ///
      .          .          .          .               /// This flattens and simplifies the alternation as appropriate. This may
      .          .          .          .               /// include factoring out common prefixes or even rewriting the alternation
      .          .          .          .               /// as a character class.
      .          .          .          .               ///
      .          .          .          .               /// Note that an empty alternation is equivalent to `Hir::fail()`. (It
-- line 510 ----------------------------------------
-- line 564 ----------------------------------------
      .          .          .          .               ///             ClassUnicodeRange::new('a', 'z'),
      .          .          .          .               ///         ]))),
      .          .          .          .               ///     ]),
      .          .          .          .               /// ]);
      .          .          .          .               /// assert_eq!(expected, hir);
      .          .          .          .               /// ```
      .          .          .          .               ///
      .          .          .          .               /// Note that these sorts of simplifications are not guaranteed.
  5,220 ( 0.00%) .          .          .               pub fn alternation(subs: Vec<Hir>) -> Hir {
      .          .          .          .                   // We rebuild the alternation by simplifying it. We proceed similarly
      .          .          .          .                   // as the concatenation case. But in this case, there's no literal
      .          .          .          .                   // simplification happening. We're just flattening alternations.
      .          .          .          .                   let mut new = Vec::with_capacity(subs.len());
165,797 ( 0.05%) .          .          .                   for sub in subs {
146,344 ( 0.04%) .          .          .                       let (kind, props) = sub.into_parts();
4,715,984 ( 1.36%) 956 ( 0.12%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::into_parts (18,288x)
 36,586 ( 0.01%) .          .          .                       match kind {
      .          .          .          .                           HirKind::Alternation(subs2) => {
      .          .          .          .                               new.extend(subs2);
      .          .          .          .                           }
      .          .          .          .                           kind => {
      .          .          .          .                               new.push(Hir { kind, props });
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
  2,320 ( 0.00%) .          .          .                   if new.is_empty() {
      .          .          .          .                       return Hir::fail();
      .          .          .          .                   } else if new.len() == 1 {
      .          .          .          .                       return new.pop().unwrap();
      .          .          .          .                   }
      .          .          .          .                   // Now that it's completely flattened, look for the special case of
      .          .          .          .                   // 'char1|char2|...|charN' and collapse that into a class. Note that
      .          .          .          .                   // we look for 'char' first and then bytes. The issue here is that if
      .          .          .          .                   // we find both non-ASCII codepoints and non-ASCII singleton bytes,
      .          .          .          .                   // then it isn't actually possible to smush them into a single class.
      .          .          .          .                   // (Because classes are either "all codepoints" or "all bytes." You
      .          .          .          .                   // can have a class that both matches non-ASCII but valid UTF-8 and
      .          .          .          .                   // invalid UTF-8.) So we look for all chars and then all bytes, and
      .          .          .          .                   // don't handle anything else.
      2 ( 0.00%) .          .          .                   if let Some(singletons) = singleton_chars(&new) {
      .          .          .          .                       let it = singletons
      .          .          .          .                           .into_iter()
      .          .          .          .                           .map(|ch| ClassUnicodeRange { start: ch, end: ch });
      2 ( 0.00%) .          .          .                       return Hir::class(Class::Unicode(ClassUnicode::new(it)));
      .          .          .          .                   }
      .          .          .          .                   if let Some(singletons) = singleton_bytes(&new) {
      .          .          .          .                       let it = singletons
      .          .          .          .                           .into_iter()
      .          .          .          .                           .map(|b| ClassBytesRange { start: b, end: b });
      .          .          .          .                       return Hir::class(Class::Bytes(ClassBytes::new(it)));
      .          .          .          .                   }
      .          .          .          .                   // Similar to singleton chars, we can also look for alternations of
-- line 614 ----------------------------------------
-- line 618 ----------------------------------------
      .          .          .          .                   }
      .          .          .          .                   if let Some(cls) = class_bytes(&new) {
      .          .          .          .                       return Hir::class(cls);
      .          .          .          .                   }
      .          .          .          .                   // Factor out a common prefix if we can, which might potentially
      .          .          .          .                   // simplify the expression and unlock other optimizations downstream.
      .          .          .          .                   // It also might generally make NFA matching and DFA construction
      .          .          .          .                   // faster by reducing the scope of branching in the regex.
  3,476 ( 0.00%) .          .          .                   new = match lift_common_prefix(new) {
      8 ( 0.00%) .          .          .                       Ok(hir) => return hir,
  3,468 ( 0.00%) .          .          .                       Err(unchanged) => unchanged,
      .          .          .          .                   };
    578 ( 0.00%) .          .          .                   let props = Properties::alternation(&new);
  4,624 ( 0.00%) .          .          .                   Hir { kind: HirKind::Alternation(new), props }
  4,640 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns an HIR expression for `.`.
      .          .          .          .               ///
      .          .          .          .               /// * [`Dot::AnyChar`] maps to `(?su-R:.)`.
      .          .          .          .               /// * [`Dot::AnyByte`] maps to `(?s-Ru:.)`.
      .          .          .          .               /// * [`Dot::AnyCharExceptLF`] maps to `(?u-Rs:.)`.
      .          .          .          .               /// * [`Dot::AnyCharExceptCRLF`] maps to `(?Ru-s:.)`.
      .          .          .          .               /// * [`Dot::AnyByteExceptLF`] maps to `(?-Rsu:.)`.
-- line 640 ----------------------------------------
-- line 651 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// let hir = Hir::dot(Dot::AnyByte);
      .          .          .          .               /// let expected = Hir::class(Class::Bytes(ClassBytes::new([
      .          .          .          .               ///     ClassBytesRange::new(0x00, 0xFF),
      .          .          .          .               /// ])));
      .          .          .          .               /// assert_eq!(expected, hir);
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
    440 ( 0.00%) .          .          .               pub fn dot(dot: Dot) -> Hir {
      .          .          .          .                   match dot {
      .          .          .          .                       Dot::AnyChar => Hir::class(Class::Unicode(ClassUnicode::new([
      .          .          .          .                           ClassUnicodeRange::new('\0', '\u{10FFFF}'),
      .          .          .          .                       ]))),
    220 ( 0.00%) .          .          .                       Dot::AnyByte => Hir::class(Class::Bytes(ClassBytes::new([
    330 ( 0.00%) .          .          .                           ClassBytesRange::new(b'\0', b'\xFF'),
    660 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassBytesRange::new (110x)
      .          .          .          .                       ]))),
      .          .          .          .                       Dot::AnyCharExcept(ch) => {
      .          .          .          .                           let mut cls =
      .          .          .          .                               ClassUnicode::new([ClassUnicodeRange::new(ch, ch)]);
      .          .          .          .                           cls.negate();
     25 ( 0.00%) .          .          .                           Hir::class(Class::Unicode(cls))
      .          .          .          .                       }
      .          .          .          .                       Dot::AnyCharExceptLF => {
      .          .          .          .                           Hir::class(Class::Unicode(ClassUnicode::new([
      .          .          .          .                               ClassUnicodeRange::new('\0', '\x09'),
      .          .          .          .                               ClassUnicodeRange::new('\x0B', '\u{10FFFF}'),
      .          .          .          .                           ])))
      .          .          .          .                       }
      .          .          .          .                       Dot::AnyCharExceptCRLF => {
-- line 679 ----------------------------------------
-- line 698 ----------------------------------------
      .          .          .          .                       Dot::AnyByteExceptCRLF => {
      .          .          .          .                           Hir::class(Class::Bytes(ClassBytes::new([
      .          .          .          .                               ClassBytesRange::new(b'\0', b'\x09'),
      .          .          .          .                               ClassBytesRange::new(b'\x0B', b'\x0C'),
      .          .          .          .                               ClassBytesRange::new(b'\x0E', b'\xFF'),
      .          .          .          .                           ])))
      .          .          .          .                       }
      .          .          .          .                   }
    440 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// The underlying kind of an arbitrary [`Hir`] expression.
      .          .          .          .           ///
      .          .          .          .           /// An `HirKind` is principally useful for doing case analysis on the type
      .          .          .          .           /// of a regular expression. If you're looking to build new `Hir` values,
      .          .          .          .           /// then you _must_ use the smart constructors defined on `Hir`, like
      .          .          .          .           /// [`Hir::repetition`], to build new `Hir` values. The API intentionally does
      .          .          .          .           /// not expose any way of building an `Hir` directly from an `HirKind`.
    966 ( 0.00%) .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           pub enum HirKind {
      .          .          .          .               /// The empty regular expression, which matches everything, including the
      .          .          .          .               /// empty string.
      .          .          .          .               Empty,
      .          .          .          .               /// A literalstring that matches exactly these bytes.
      .          .          .          .               Literal(Literal),
      .          .          .          .               /// A single character class that matches any of the characters in the
      .          .          .          .               /// class. A class can either consist of Unicode scalar values as
-- line 724 ----------------------------------------
-- line 751 ----------------------------------------
      .          .          .          .               Alternation(Vec<Hir>),
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl HirKind {
      .          .          .          .               /// Returns a slice of this kind's sub-expressions, if any.
      .          .          .          .               pub fn subs(&self) -> &[Hir] {
      .          .          .          .                   use core::slice::from_ref;
      .          .          .          .           
 19,089 ( 0.01%) .          .          .                   match *self {
      .          .          .          .                       HirKind::Empty
      .          .          .          .                       | HirKind::Literal(_)
      .          .          .          .                       | HirKind::Class(_)
      .          .          .          .                       | HirKind::Look(_) => &[],
      .          .          .          .                       HirKind::Repetition(Repetition { ref sub, .. }) => from_ref(sub),
      .          .          .          .                       HirKind::Capture(Capture { ref sub, .. }) => from_ref(sub),
      .          .          .          .                       HirKind::Concat(ref subs) => subs,
      .          .          .          .                       HirKind::Alternation(ref subs) => subs,
-- line 767 ----------------------------------------
-- line 821 ----------------------------------------
      .          .          .          .           /// regex `(?-u:a|\xc2\xa0)` will compile down to HIR for the Unicode class
      .          .          .          .           /// `[a\u00A0]` due to optimizations.
      .          .          .          .           ///
      .          .          .          .           /// Note that `Bytes` variant may be produced even when it exclusively matches
      .          .          .          .           /// valid UTF-8. This is because a `Bytes` variant represents an intention by
      .          .          .          .           /// the author of the regular expression to disable Unicode mode, which in turn
      .          .          .          .           /// impacts the semantics of case insensitive matching. For example, `(?i)k`
      .          .          .          .           /// and `(?i-u)k` will not match the same set of strings.
  1,414 ( 0.00%) .          .          .           #[derive(Clone, Eq, PartialEq)]
      .          .          .          .           pub enum Class {
      .          .          .          .               /// A set of characters represented by Unicode scalar values.
      .          .          .          .               Unicode(ClassUnicode),
      .          .          .          .               /// A set of characters represented by arbitrary bytes (one byte per
      .          .          .          .               /// character).
      .          .          .          .               Bytes(ClassBytes),
      .          .          .          .           }
      .          .          .          .           
-- line 837 ----------------------------------------
-- line 943 ----------------------------------------
      .          .          .          .               /// assert_eq!(Some(1), hir.properties().minimum_len());
      .          .          .          .               /// // But sometimes Unicode classes might be bigger!
      .          .          .          .               /// let hir = parse(r"\p{Cyrillic}")?;
      .          .          .          .               /// assert_eq!(Some(2), hir.properties().minimum_len());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn minimum_len(&self) -> Option<usize> {
  5,456 ( 0.00%) .          .          .                   match *self {
      .          .          .          .                       Class::Unicode(ref x) => x.minimum_len(),
      .          .          .          .                       Class::Bytes(ref x) => x.minimum_len(),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length, in bytes, of the longest string matched by this
      .          .          .          .               /// character class.
      .          .          .          .               ///
-- line 959 ----------------------------------------
-- line 1005 ----------------------------------------
      .          .          .          .               /// it has no elements.
      .          .          .          .               ///
      .          .          .          .               /// An empty character can never match anything, including an empty string.
      .          .          .          .               pub fn is_empty(&self) -> bool {
      .          .          .          .                   match *self {
      .          .          .          .                       Class::Unicode(ref x) => x.ranges().is_empty(),
      .          .          .          .                       Class::Bytes(ref x) => x.ranges().is_empty(),
      .          .          .          .                   }
    303 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// If this class consists of exactly one element (whether a codepoint or a
      .          .          .          .               /// byte), then return it as a literal byte string.
      .          .          .          .               ///
      .          .          .          .               /// If this class is empty or contains more than one element, then `None`
      .          .          .          .               /// is returned.
  1,212 ( 0.00%) .          .          .               pub fn literal(&self) -> Option<Vec<u8>> {
 12,243 ( 0.00%) .          .          .                   match *self {
  4,265 ( 0.00%) .          .          .                       Class::Unicode(ref x) => x.literal(),
447,821 ( 0.13%) 589 ( 0.07%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::literal (3,879x)
      .          .          .          .                       Class::Bytes(ref x) => x.literal(),
      .          .          .          .                   }
  1,515 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl core::fmt::Debug for Class {
      .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      .          .          .          .                   use crate::debug::Byte;
      .          .          .          .           
      .          .          .          .                   let mut fmter = f.debug_set();
      .          .          .          .                   match *self {
-- line 1033 ----------------------------------------
-- line 1042 ----------------------------------------
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   fmter.finish()
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A set of characters represented by Unicode scalar values.
     64 ( 0.00%) .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
  1,810 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/partial_eq.rs:<regex_syntax::hir::interval::IntervalSet<I> as core::cmp::PartialEq>::eq (60x)
      .          .          .          .           pub struct ClassUnicode {
      .          .          .          .               set: IntervalSet<ClassUnicodeRange>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ClassUnicode {
      .          .          .          .               /// Create a new class from a sequence of ranges.
      .          .          .          .               ///
      .          .          .          .               /// The given ranges do not need to be in any specific order, and ranges
      .          .          .          .               /// may overlap. Ranges will automatically be sorted into a canonical
      .          .          .          .               /// non-overlapping order.
      .          .          .          .               pub fn new<I>(ranges: I) -> ClassUnicode
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = ClassUnicodeRange>,
      .          .          .          .               {
  2,270 ( 0.00%) .          .          .                   ClassUnicode { set: IntervalSet::new(ranges) }
 41,130 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::new (1,125x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new class with no ranges.
      .          .          .          .               ///
      .          .          .          .               /// An empty class matches nothing. That is, it is equivalent to
      .          .          .          .               /// [`Hir::fail`].
      .          .          .          .               pub fn empty() -> ClassUnicode {
      .          .          .          .                   ClassUnicode::new(vec![])
-- line 1073 ----------------------------------------
-- line 1078 ----------------------------------------
      .          .          .          .                   self.set.push(range);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return an iterator over all ranges in this class.
      .          .          .          .               ///
      .          .          .          .               /// The iterator yields ranges in ascending order.
      .          .          .          .               pub fn iter(&self) -> ClassUnicodeIter<'_> {
      .          .          .          .                   ClassUnicodeIter(self.set.iter())
  5,631 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the underlying ranges as a slice.
      .          .          .          .               pub fn ranges(&self) -> &[ClassUnicodeRange] {
      .          .          .          .                   self.set.intervals()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Expand this character class such that it contains all case folded
      .          .          .          .               /// characters, according to Unicode's "simple" mapping. For example, if
-- line 1094 ----------------------------------------
-- line 1114 ----------------------------------------
      .          .          .          .               /// this class consists of the range `a-z`, then applying case folding will
      .          .          .          .               /// result in the class containing both the ranges `a-z` and `A-Z`.
      .          .          .          .               ///
      .          .          .          .               /// # Error
      .          .          .          .               ///
      .          .          .          .               /// This routine returns an error when the case mapping data necessary
      .          .          .          .               /// for this routine to complete is unavailable. This occurs when the
      .          .          .          .               /// `unicode-case` feature is not enabled.
  6,720 ( 0.00%) .          .          .               pub fn try_case_fold_simple(
      .          .          .          .                   &mut self,
      .          .          .          .               ) -> core::result::Result<(), CaseFoldError> {
      .          .          .          .                   self.set.case_fold_simple()
  7,840 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Negate this character class.
      .          .          .          .               ///
      .          .          .          .               /// For all `c` where `c` is a Unicode scalar value, if `c` was in this
      .          .          .          .               /// set, then it will not be in this set after negation.
      .          .          .          .               pub fn negate(&mut self) {
     66 ( 0.00%) .          .          .                   self.set.negate();
  3,211 ( 0.00%) 10 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::negate (6x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Union this character class with the given character class, in place.
      .          .          .          .               pub fn union(&mut self, other: &ClassUnicode) {
    960 ( 0.00%) .          .          .                   self.set.union(&other.set);
 15,320 ( 0.00%) 28 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::union (57x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Intersect this character class with the given character class, in
      .          .          .          .               /// place.
      .          .          .          .               pub fn intersect(&mut self, other: &ClassUnicode) {
      .          .          .          .                   self.set.intersect(&other.set);
      .          .          .          .               }
      .          .          .          .           
-- line 1146 ----------------------------------------
-- line 1160 ----------------------------------------
      .          .          .          .               pub fn symmetric_difference(&mut self, other: &ClassUnicode) {
      .          .          .          .                   self.set.symmetric_difference(&other.set);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this character class will either match
      .          .          .          .               /// nothing or only ASCII bytes. Stated differently, this returns false
      .          .          .          .               /// if and only if this class contains a non-ASCII codepoint.
      .          .          .          .               pub fn is_ascii(&self) -> bool {
 11,319 ( 0.00%) .          .          .                   self.set.intervals().last().map_or(true, |r| r.end <= '\x7F')
  5,631 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length, in bytes, of the smallest string matched by this
      .          .          .          .               /// character class.
      .          .          .          .               ///
      .          .          .          .               /// Returns `None` when the class is empty.
      .          .          .          .               pub fn minimum_len(&self) -> Option<usize> {
  2,618 ( 0.00%) .          .          .                   let first = self.ranges().get(0)?;
      .          .          .          .                   // Correct because c1 < c2 implies c1.len_utf8() < c2.len_utf8().
  2,618 ( 0.00%) .          .          .                   Some(first.start.len_utf8())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length, in bytes, of the longest string matched by this
      .          .          .          .               /// character class.
      .          .          .          .               ///
      .          .          .          .               /// Returns `None` when the class is empty.
      .          .          .          .               pub fn maximum_len(&self) -> Option<usize> {
      .          .          .          .                   let last = self.ranges().last()?;
      .          .          .          .                   // Correct because c1 < c2 implies c1.len_utf8() < c2.len_utf8().
  2,618 ( 0.00%) .          .          .                   Some(last.end.len_utf8())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// If this class consists of exactly one codepoint, then return it as
      .          .          .          .               /// a literal byte string.
      .          .          .          .               ///
      .          .          .          .               /// If this class is empty or contains more than one codepoint, then `None`
      .          .          .          .               /// is returned.
 20,360 ( 0.01%) .          .          .               pub fn literal(&self) -> Option<Vec<u8>> {
      .          .          .          .                   let rs = self.ranges();
 15,080 ( 0.00%) .          .          .                   if rs.len() == 1 && rs[0].start == rs[0].end {
  1,454 ( 0.00%) .          .          .                       Some(rs[0].start.encode_utf8(&mut [0; 4]).to_string().into_bytes())
      .          .          .          .                   } else {
  5,236 ( 0.00%) .          .          .                       None
      .          .          .          .                   }
 24,432 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// If this class consists of only ASCII ranges, then return its
      .          .          .          .               /// corresponding and equivalent byte class.
      .          .          .          .               pub fn to_byte_class(&self) -> Option<ClassBytes> {
     57 ( 0.00%) .          .          .                   if !self.is_ascii() {
      .          .          .          .                       return None;
      .          .          .          .                   }
      .          .          .          .                   Some(ClassBytes::new(self.ranges().iter().map(|r| {
      .          .          .          .                       // Since we are guaranteed that our codepoint range is ASCII, the
      .          .          .          .                       // 'u8::try_from' calls below are guaranteed to be correct.
      .          .          .          .                       ClassBytesRange {
      .          .          .          .                           start: u8::try_from(r.start).unwrap(),
      .          .          .          .                           end: u8::try_from(r.end).unwrap(),
-- line 1216 ----------------------------------------
-- line 1225 ----------------------------------------
      .          .          .          .           #[derive(Debug)]
      .          .          .          .           pub struct ClassUnicodeIter<'a>(IntervalSetIter<'a, ClassUnicodeRange>);
      .          .          .          .           
      .          .          .          .           impl<'a> Iterator for ClassUnicodeIter<'a> {
      .          .          .          .               type Item = &'a ClassUnicodeRange;
      .          .          .          .           
      .          .          .          .               fn next(&mut self) -> Option<&'a ClassUnicodeRange> {
      .          .          .          .                   self.0.next()
 16,192 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A single range of characters represented by Unicode scalar values.
      .          .          .          .           ///
      .          .          .          .           /// The range is closed. That is, the start and end of the range are included
      .          .          .          .           /// in the range.
      .          .          .          .           #[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]
      .          .          .          .           pub struct ClassUnicodeRange {
-- line 1241 ----------------------------------------
-- line 1282 ----------------------------------------
      .          .          .          .               fn set_upper(&mut self, bound: char) {
      .          .          .          .                   self.end = bound;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Apply simple case folding to this Unicode scalar value range.
      .          .          .          .               ///
      .          .          .          .               /// Additional ranges are appended to the given vector. Canonical ordering
      .          .          .          .               /// is *not* maintained in the given vector.
  8,330 ( 0.00%) .          .          .               fn case_fold_simple(
      .          .          .          .                   &self,
      .          .          .          .                   ranges: &mut Vec<ClassUnicodeRange>,
      .          .          .          .               ) -> Result<(), unicode::CaseFoldError> {
  1,190 ( 0.00%) .          .          .                   let mut folder = unicode::SimpleCaseFolder::new()?;
  2,380 ( 0.00%) .          .          .                   if !folder.overlaps(self.start, self.end) {
      .          .          .          .                       return Ok(());
      .          .          .          .                   }
      .          .          .          .                   let (start, end) = (u32::from(self.start), u32::from(self.end));
  2,240 ( 0.00%) .          .          .                   for cp in (start..=end).filter_map(char::from_u32) {
  3,380 ( 0.00%) .          .          .                       for &cp_folded in folder.mapping(cp) {
165,920 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::SimpleCaseFolder::mapping (1,120x)
      .          .          .          .                           ranges.push(ClassUnicodeRange::new(cp_folded, cp_folded));
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Ok(())
 10,710 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ClassUnicodeRange {
      .          .          .          .               /// Create a new Unicode scalar value range for a character class.
      .          .          .          .               ///
      .          .          .          .               /// The returned range is always in a canonical form. That is, the range
      .          .          .          .               /// returned always satisfies the invariant that `start <= end`.
      .          .          .          .               pub fn new(start: char, end: char) -> ClassUnicodeRange {
-- line 1313 ----------------------------------------
-- line 1314 ----------------------------------------
      .          .          .          .                   ClassUnicodeRange::create(start, end)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the start of this range.
      .          .          .          .               ///
      .          .          .          .               /// The start of a range is always less than or equal to the end of the
      .          .          .          .               /// range.
      .          .          .          .               pub fn start(&self) -> char {
 11,021 ( 0.00%) .          .          .                   self.start
 10,561 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the end of this range.
      .          .          .          .               ///
      .          .          .          .               /// The end of a range is always greater than or equal to the start of the
      .          .          .          .               /// range.
      .          .          .          .               pub fn end(&self) -> char {
 10,791 ( 0.00%) .          .          .                   self.end
 10,561 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the number of codepoints in this range.
      .          .          .          .               pub fn len(&self) -> usize {
    738 ( 0.00%) .          .          .                   let diff = 1 + u32::from(self.end) - u32::from(self.start);
      .          .          .          .                   // This is likely to panic in 16-bit targets since a usize can only fit
      .          .          .          .                   // 2^16. It's not clear what to do here, other than to return an error
      .          .          .          .                   // when building a Unicode class that contains a range whose length
      .          .          .          .                   // overflows usize. (Which, to be honest, is probably quite common on
      .          .          .          .                   // 16-bit targets. For example, this would imply that '.' and '\p{any}'
      .          .          .          .                   // would be impossible to build.)
      .          .          .          .                   usize::try_from(diff).expect("char class len fits in usize")
      .          .          .          .               }
-- line 1343 ----------------------------------------
-- line 1356 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// The given ranges do not need to be in any specific order, and ranges
      .          .          .          .               /// may overlap. Ranges will automatically be sorted into a canonical
      .          .          .          .               /// non-overlapping order.
      .          .          .          .               pub fn new<I>(ranges: I) -> ClassBytes
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = ClassBytesRange>,
      .          .          .          .               {
    442 ( 0.00%) .          .          .                   ClassBytes { set: IntervalSet::new(ranges) }
    156 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::new (1x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new class with no ranges.
      .          .          .          .               ///
      .          .          .          .               /// An empty class matches nothing. That is, it is equivalent to
      .          .          .          .               /// [`Hir::fail`].
      .          .          .          .               pub fn empty() -> ClassBytes {
      .          .          .          .                   ClassBytes::new(vec![])
-- line 1372 ----------------------------------------
-- line 1377 ----------------------------------------
      .          .          .          .                   self.set.push(range);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return an iterator over all ranges in this class.
      .          .          .          .               ///
      .          .          .          .               /// The iterator yields ranges in ascending order.
      .          .          .          .               pub fn iter(&self) -> ClassBytesIter<'_> {
      .          .          .          .                   ClassBytesIter(self.set.iter())
    110 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the underlying ranges as a slice.
      .          .          .          .               pub fn ranges(&self) -> &[ClassBytesRange] {
      .          .          .          .                   self.set.intervals()
  5,488 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Expand this character class such that it contains all case folded
      .          .          .          .               /// characters. For example, if this class consists of the range `a-z`,
      .          .          .          .               /// then applying case folding will result in the class containing both the
      .          .          .          .               /// ranges `a-z` and `A-Z`.
      .          .          .          .               ///
      .          .          .          .               /// Note that this only applies ASCII case folding, which is limited to the
      .          .          .          .               /// characters `a-z` and `A-Z`.
-- line 1398 ----------------------------------------
-- line 1441 ----------------------------------------
      .          .          .          .                   self.set.intervals().last().map_or(true, |r| r.end <= 0x7F)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length, in bytes, of the smallest string matched by this
      .          .          .          .               /// character class.
      .          .          .          .               ///
      .          .          .          .               /// Returns `None` when the class is empty.
      .          .          .          .               pub fn minimum_len(&self) -> Option<usize> {
    220 ( 0.00%) .          .          .                   if self.ranges().is_empty() {
      .          .          .          .                       None
      .          .          .          .                   } else {
      .          .          .          .                       Some(1)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length, in bytes, of the longest string matched by this
      .          .          .          .               /// character class.
-- line 1457 ----------------------------------------
-- line 1467 ----------------------------------------
      .          .          .          .           
      .          .          .          .               /// If this class consists of exactly one byte, then return it as
      .          .          .          .               /// a literal byte string.
      .          .          .          .               ///
      .          .          .          .               /// If this class is empty or contains more than one byte, then `None`
      .          .          .          .               /// is returned.
      .          .          .          .               pub fn literal(&self) -> Option<Vec<u8>> {
      .          .          .          .                   let rs = self.ranges();
    550 ( 0.00%) .          .          .                   if rs.len() == 1 && rs[0].start == rs[0].end {
      .          .          .          .                       Some(vec![rs[0].start])
      .          .          .          .                   } else {
    220 ( 0.00%) .          .          .                       None
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// If this class consists of only ASCII ranges, then return its
      .          .          .          .               /// corresponding and equivalent Unicode class.
      .          .          .          .               pub fn to_unicode_class(&self) -> Option<ClassUnicode> {
      .          .          .          .                   if !self.is_ascii() {
      .          .          .          .                       return None;
-- line 1486 ----------------------------------------
-- line 1503 ----------------------------------------
      .          .          .          .           #[derive(Debug)]
      .          .          .          .           pub struct ClassBytesIter<'a>(IntervalSetIter<'a, ClassBytesRange>);
      .          .          .          .           
      .          .          .          .           impl<'a> Iterator for ClassBytesIter<'a> {
      .          .          .          .               type Item = &'a ClassBytesRange;
      .          .          .          .           
      .          .          .          .               fn next(&mut self) -> Option<&'a ClassBytesRange> {
      .          .          .          .                   self.0.next()
    220 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A single range of characters represented by arbitrary bytes.
      .          .          .          .           ///
      .          .          .          .           /// The range is closed. That is, the start and end of the range are included
      .          .          .          .           /// in the range.
      .          .          .          .           #[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]
      .          .          .          .           pub struct ClassBytesRange {
-- line 1519 ----------------------------------------
-- line 1564 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ClassBytesRange {
      .          .          .          .               /// Create a new byte range for a character class.
      .          .          .          .               ///
      .          .          .          .               /// The returned range is always in a canonical form. That is, the range
      .          .          .          .               /// returned always satisfies the invariant that `start <= end`.
    110 ( 0.00%) .          .          .               pub fn new(start: u8, end: u8) -> ClassBytesRange {
      .          .          .          .                   ClassBytesRange::create(start, end)
    110 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the start of this range.
      .          .          .          .               ///
      .          .          .          .               /// The start of a range is always less than or equal to the end of the
      .          .          .          .               /// range.
      .          .          .          .               pub fn start(&self) -> u8 {
    110 ( 0.00%) .          .          .                   self.start
    110 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the end of this range.
      .          .          .          .               ///
      .          .          .          .               /// The end of a range is always greater than or equal to the start of the
      .          .          .          .               /// range.
      .          .          .          .               pub fn end(&self) -> u8 {
    110 ( 0.00%) .          .          .                   self.end
    110 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the number of bytes in this range.
      .          .          .          .               pub fn len(&self) -> usize {
      .          .          .          .                   usize::from(self.end.checked_sub(self.start).unwrap())
      .          .          .          .                       .checked_add(1)
      .          .          .          .                       .unwrap()
      .          .          .          .               }
      .          .          .          .           }
-- line 1598 ----------------------------------------
-- line 1604 ----------------------------------------
      .          .          .          .                       .field("end", &crate::debug::Byte(self.end))
      .          .          .          .                       .finish()
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// The high-level intermediate representation for a look-around assertion.
      .          .          .          .           ///
      .          .          .          .           /// An assertion match is always zero-length. Also called an "empty match."
      2 ( 0.00%) .          .          .           #[derive(Clone, Copy, Debug, Eq, PartialEq)]
      .          .          .          .           pub enum Look {
      .          .          .          .               /// Match the beginning of text. Specifically, this matches at the starting
      .          .          .          .               /// position of the input.
      .          .          .          .               Start = 1 << 0,
      .          .          .          .               /// Match the end of text. Specifically, this matches at the ending
      .          .          .          .               /// position of the input.
      .          .          .          .               End = 1 << 1,
      .          .          .          .               /// Match the beginning of a line or the beginning of text. Specifically,
-- line 1620 ----------------------------------------
-- line 1813 ----------------------------------------
      .          .          .          .           pub struct Repetition {
      .          .          .          .               /// The minimum range of the repetition.
      .          .          .          .               ///
      .          .          .          .               /// Note that special cases like `?`, `+` and `*` all get translated into
      .          .          .          .               /// the ranges `{0,1}`, `{1,}` and `{0,}`, respectively.
      .          .          .          .               ///
      .          .          .          .               /// When `min` is zero, this expression can match the empty string
      .          .          .          .               /// regardless of what its sub-expression is.
      8 ( 0.00%) .          .          .               pub min: u32,
      .          .          .          .               /// The maximum range of the repetition.
      .          .          .          .               ///
      .          .          .          .               /// Note that when `max` is `None`, `min` acts as a lower bound but where
      .          .          .          .               /// there is no upper bound. For something like `x{5}` where the min and
      .          .          .          .               /// max are equivalent, `min` will be set to `5` and `max` will be set to
      .          .          .          .               /// `Some(5)`.
      4 ( 0.00%) .          .          .               pub max: Option<u32>,
      .          .          .          .               /// Whether this repetition operator is greedy or not. A greedy operator
      .          .          .          .               /// will match as much as it can. A non-greedy operator will match as
      .          .          .          .               /// little as it can.
      .          .          .          .               ///
      .          .          .          .               /// Typically, operators are greedy by default and are only non-greedy when
      .          .          .          .               /// a `?` suffix is used, e.g., `(expr)*` is greedy while `(expr)*?` is
      .          .          .          .               /// not. However, this can be inverted via the `U` "ungreedy" flag.
     24 ( 0.00%) .          .          .               pub greedy: bool,
      .          .          .          .               /// The expression being repeated.
      4 ( 0.00%) .          .          .               pub sub: Box<Hir>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Repetition {
      .          .          .          .               /// Returns a new repetition with the same `min`, `max` and `greedy`
      .          .          .          .               /// values, but with its sub-expression replaced with the one given.
  1,043 ( 0.00%) .          .          .               pub fn with(&self, sub: Hir) -> Repetition {
    745 ( 0.00%) .          .          .                   Repetition {
    149 ( 0.00%) .          .          .                       min: self.min,
    298 ( 0.00%) .          .          .                       max: self.max,
    149 ( 0.00%) .          .          .                       greedy: self.greedy,
      .          .          .          .                       sub: Box::new(sub),
      .          .          .          .                   }
  1,043 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A type describing the different flavors of `.`.
      .          .          .          .           ///
      .          .          .          .           /// This type is meant to be used with [`Hir::dot`], which is a convenience
      .          .          .          .           /// routine for building HIR values derived from the `.` regex.
      .          .          .          .           #[non_exhaustive]
      .          .          .          .           #[derive(Clone, Copy, Debug, Eq, PartialEq)]
-- line 1859 ----------------------------------------
-- line 1906 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// This is equivalent to `(?R-su:.)` and also `(?-u:[[\x00-\xFF]--\r\n])`.
      .          .          .          .               AnyByteExceptCRLF,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A custom `Drop` impl is used for `HirKind` such that it uses constant stack
      .          .          .          .           /// space but heap space proportional to the depth of the total `Hir`.
      .          .          .          .           impl Drop for Hir {
555,360 ( 0.16%) .          .          .               fn drop(&mut self) {
      .          .          .          .                   use core::mem;
      .          .          .          .           
624,780 ( 0.18%) .          .          .                   match *self.kind() {
      .          .          .          .                       HirKind::Empty
      .          .          .          .                       | HirKind::Literal(_)
      .          .          .          .                       | HirKind::Class(_)
      .          .          .          .                       | HirKind::Look(_) => return,
    693 ( 0.00%) .          .          .                       HirKind::Capture(ref x) if x.sub.kind.subs().is_empty() => return,
  4,068 ( 0.00%) .          .          .                       HirKind::Repetition(ref x) if x.sub.kind.subs().is_empty() => {
      .          .          .          .                           return
      .          .          .          .                       }
      .          .          .          .                       HirKind::Concat(ref x) if x.is_empty() => return,
      .          .          .          .                       HirKind::Alternation(ref x) if x.is_empty() => return,
      .          .          .          .                       _ => {}
      .          .          .          .                   }
      .          .          .          .           
    104 ( 0.00%) .          .          .                   let mut stack = vec![mem::replace(self, Hir::empty())];
247,662 ( 0.07%) .          .          .                   while let Some(mut expr) = stack.pop() {
192,626 ( 0.06%) .          .          .                       match expr.kind {
      .          .          .          .                           HirKind::Empty
      .          .          .          .                           | HirKind::Literal(_)
      .          .          .          .                           | HirKind::Class(_)
      .          .          .          .                           | HirKind::Look(_) => {}
      .          .          .          .                           HirKind::Capture(ref mut x) => {
    693 ( 0.00%) .          .          .                               stack.push(mem::replace(&mut x.sub, Hir::empty()));
      .          .          .          .                           }
      .          .          .          .                           HirKind::Repetition(ref mut x) => {
  2,029 ( 0.00%) .          .          .                               stack.push(mem::replace(&mut x.sub, Hir::empty()));
      .          .          .          .                           }
      .          .          .          .                           HirKind::Concat(ref mut x) => {
      .          .          .          .                               stack.extend(x.drain(..));
      .          .          .          .                           }
      .          .          .          .                           HirKind::Alternation(ref mut x) => {
      .          .          .          .                               stack.extend(x.drain(..));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
555,360 ( 0.16%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A type that collects various properties of an HIR value.
      .          .          .          .           ///
      .          .          .          .           /// Properties are always scalar values and represent meta data that is
      .          .          .          .           /// computed inductively on an HIR value. Properties are defined for all
      .          .          .          .           /// HIR values.
      .          .          .          .           ///
      .          .          .          .           /// All methods on a `Properties` value take constant time and are meant to
      .          .          .          .           /// be cheap to call.
     81 ( 0.00%) .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           pub struct Properties(Box<PropertiesI>);
      .          .          .          .           
      .          .          .          .           /// The property definition. It is split out so that we can box it, and
      .          .          .          .           /// there by make `Properties` use less stack size. This is kind-of important
      .          .          .          .           /// because every HIR value has a `Properties` attached to it.
      .          .          .          .           ///
      .          .          .          .           /// This does have the unfortunate consequence that creating any HIR value
      .          .          .          .           /// always leads to at least one alloc for properties, but this is generally
      .          .          .          .           /// true anyway (for pretty much all HirKinds except for look-arounds).
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           struct PropertiesI {
      .          .          .          .               minimum_len: Option<usize>,
    116 ( 0.00%) .          .          .               maximum_len: Option<usize>,
    112 ( 0.00%) .          .          .               look_set: LookSet,
     58 ( 0.00%) .          .          .               look_set_prefix: LookSet,
     58 ( 0.00%) .          .          .               look_set_suffix: LookSet,
     58 ( 0.00%) .          .          .               look_set_prefix_any: LookSet,
     58 ( 0.00%) .          .          .               look_set_suffix_any: LookSet,
    348 ( 0.00%) .          .          .               utf8: bool,
    174 ( 0.00%) .          .          .               explicit_captures_len: usize,
     58 ( 0.00%) .          .          .               static_explicit_captures_len: Option<usize>,
    406 ( 0.00%) .          .          .               literal: bool,
    406 ( 0.00%) .          .          .               alternation_literal: bool,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Properties {
      .          .          .          .               /// Returns the length (in bytes) of the smallest string matched by this
      .          .          .          .               /// HIR.
      .          .          .          .               ///
      .          .          .          .               /// A return value of `0` is possible and occurs when the HIR can match an
      .          .          .          .               /// empty string.
      .          .          .          .               ///
      .          .          .          .               /// `None` is returned when there is no minimum length. This occurs in
      .          .          .          .               /// precisely the cases where the HIR matches nothing. i.e., The language
      .          .          .          .               /// the regex matches is empty. An example of such a regex is `\P{any}`.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn minimum_len(&self) -> Option<usize> {
 20,628 ( 0.01%) .          .          .                   self.0.minimum_len
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length (in bytes) of the longest string matched by this
      .          .          .          .               /// HIR.
      .          .          .          .               ///
      .          .          .          .               /// A return value of `0` is possible and occurs when nothing longer than
      .          .          .          .               /// the empty string is in the language described by this HIR.
      .          .          .          .               ///
      .          .          .          .               /// `None` is returned when there is no longest matching string. This
      .          .          .          .               /// occurs when the HIR matches nothing or when there is no upper bound on
      .          .          .          .               /// the length of matching strings. Example of such regexes are `\P{any}`
      .          .          .          .               /// (matches nothing) and `a+` (has no upper bound).
      .          .          .          .               #[inline]
      .          .          .          .               pub fn maximum_len(&self) -> Option<usize> {
 20,358 ( 0.01%) .          .          .                   self.0.maximum_len
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a set of all look-around assertions that appear at least once
      .          .          .          .               /// in this HIR value.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn look_set(&self) -> LookSet {
 24,440 ( 0.01%) .          .          .                   self.0.look_set
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a set of all look-around assertions that appear as a prefix for
      .          .          .          .               /// this HIR value. That is, the set returned corresponds to the set of
      .          .          .          .               /// assertions that must be passed before matching any bytes in a haystack.
      .          .          .          .               ///
      .          .          .          .               /// For example, `hir.look_set_prefix().contains(Look::Start)` returns true
      .          .          .          .               /// if and only if the HIR is fully anchored at the start.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn look_set_prefix(&self) -> LookSet {
  2,699 ( 0.00%) .          .          .                   self.0.look_set_prefix
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a set of all look-around assertions that appear as a _possible_
      .          .          .          .               /// prefix for this HIR value. That is, the set returned corresponds to the
      .          .          .          .               /// set of assertions that _may_ be passed before matching any bytes in a
      .          .          .          .               /// haystack.
      .          .          .          .               ///
      .          .          .          .               /// For example, `hir.look_set_prefix_any().contains(Look::Start)` returns
-- line 2042 ----------------------------------------
-- line 2051 ----------------------------------------
      .          .          .          .               /// this HIR value. That is, the set returned corresponds to the set of
      .          .          .          .               /// assertions that must be passed in order to be considered a match after
      .          .          .          .               /// all other consuming HIR expressions.
      .          .          .          .               ///
      .          .          .          .               /// For example, `hir.look_set_suffix().contains(Look::End)` returns true
      .          .          .          .               /// if and only if the HIR is fully anchored at the end.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn look_set_suffix(&self) -> LookSet {
  2,292 ( 0.00%) .          .          .                   self.0.look_set_suffix
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a set of all look-around assertions that appear as a _possible_
      .          .          .          .               /// suffix for this HIR value. That is, the set returned corresponds to the
      .          .          .          .               /// set of assertions that _may_ be passed before matching any bytes in a
      .          .          .          .               /// haystack.
      .          .          .          .               ///
      .          .          .          .               /// For example, `hir.look_set_suffix_any().contains(Look::End)` returns
-- line 2067 ----------------------------------------
-- line 2133 ----------------------------------------
      .          .          .          .               /// // are not valid UTF-8, when combined together, the
      .          .          .          .               /// // overall expression *does* match valid UTF-8!
      .          .          .          .               /// assert!(parse(r"(?-u)\xE2\x98\x83")?.properties().is_utf8());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_utf8(&self) -> bool {
 24,424 ( 0.01%) .          .          .                   self.0.utf8
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the total number of explicit capturing groups in the
      .          .          .          .               /// corresponding HIR.
      .          .          .          .               ///
      .          .          .          .               /// Note that this does not include the implicit capturing group
      .          .          .          .               /// corresponding to the entire match that is typically included by regex
      .          .          .          .               /// engines.
-- line 2149 ----------------------------------------
-- line 2157 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// assert_eq!(0, parse("a")?.properties().explicit_captures_len());
      .          .          .          .               /// assert_eq!(1, parse("(a)")?.properties().explicit_captures_len());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn explicit_captures_len(&self) -> usize {
    774 ( 0.00%) .          .          .                   self.0.explicit_captures_len
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the total number of explicit capturing groups that appear in
      .          .          .          .               /// every possible match.
      .          .          .          .               ///
      .          .          .          .               /// If the number of capture groups can vary depending on the match, then
      .          .          .          .               /// this returns `None`. That is, a value is only returned when the number
      .          .          .          .               /// of matching groups is invariant or "static."
-- line 2173 ----------------------------------------
-- line 2197 ----------------------------------------
      .          .          .          .               /// assert_eq!(None, len("a|(b)")?);
      .          .          .          .               /// assert_eq!(None, len("(b)*")?);
      .          .          .          .               /// assert_eq!(Some(1), len("(b)+")?);
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn static_explicit_captures_len(&self) -> Option<usize> {
 23,135 ( 0.01%) .          .          .                   self.0.static_explicit_captures_len
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return true if and only if this HIR is a simple literal. This is
      .          .          .          .               /// only true when this HIR expression is either itself a `Literal` or a
      .          .          .          .               /// concatenation of only `Literal`s.
      .          .          .          .               ///
      .          .          .          .               /// For example, `f` and `foo` are literals, but `f+`, `(foo)`, `foo()` and
      .          .          .          .               /// the empty string are not (even though they contain sub-expressions that
      .          .          .          .               /// are literals).
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_literal(&self) -> bool {
 18,314 ( 0.01%) .          .          .                   self.0.literal
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return true if and only if this HIR is either a simple literal or an
      .          .          .          .               /// alternation of simple literals. This is only
      .          .          .          .               /// true when this HIR expression is either itself a `Literal` or a
      .          .          .          .               /// concatenation of only `Literal`s or an alternation of only `Literal`s.
      .          .          .          .               ///
      .          .          .          .               /// For example, `f`, `foo`, `a|b|c`, and `foo|bar|baz` are alternation
      .          .          .          .               /// literals, but `f+`, `(foo)`, `foo()`, and the empty pattern are not
      .          .          .          .               /// (even though that contain sub-expressions that are literals).
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_alternation_literal(&self) -> bool {
  3,560 ( 0.00%) .          .          .                   self.0.alternation_literal
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the total amount of heap memory usage, in bytes, used by this
      .          .          .          .               /// `Properties` value.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn memory_usage(&self) -> usize {
      .          .          .          .                   core::mem::size_of::<PropertiesI>()
      .          .          .          .               }
-- line 2238 ----------------------------------------
-- line 2302 ----------------------------------------
      .          .          .          .               ///		hir2.properties(),
      .          .          .          .               ///		hir3.properties(),
      .          .          .          .               ///	]);
      .          .          .          .               /// assert_eq!(Some(1), unioned.minimum_len());
      .          .          .          .               /// assert_eq!(None, unioned.maximum_len());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
    567 ( 0.00%) .          .          .               pub fn union<I, P>(props: I) -> Properties
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = P>,
      .          .          .          .                   P: core::borrow::Borrow<Properties>,
      .          .          .          .               {
      .          .          .          .                   let mut it = props.into_iter().peekable();
      .          .          .          .                   // While empty alternations aren't possible, we still behave as if they
      .          .          .          .                   // are. When we have an empty alternate, then clearly the look-around
      .          .          .          .                   // prefix and suffix is empty. Otherwise, it is the intersection of all
-- line 2318 ----------------------------------------
-- line 2351 ----------------------------------------
      .          .          .          .                   // Handle properties that need to visit every child hir.
      .          .          .          .                   for prop in it {
      .          .          .          .                       let p = prop.borrow();
      .          .          .          .                       props.look_set.set_union(p.look_set());
      .          .          .          .                       props.look_set_prefix.set_intersect(p.look_set_prefix());
      .          .          .          .                       props.look_set_suffix.set_intersect(p.look_set_suffix());
      .          .          .          .                       props.look_set_prefix_any.set_union(p.look_set_prefix_any());
      .          .          .          .                       props.look_set_suffix_any.set_union(p.look_set_suffix_any());
 38,300 ( 0.01%) .          .          .                       props.utf8 = props.utf8 && p.is_utf8();
      .          .          .          .                       props.explicit_captures_len = props
      .          .          .          .                           .explicit_captures_len
      .          .          .          .                           .saturating_add(p.explicit_captures_len());
 35,410 ( 0.01%) .          .          .                       if props.static_explicit_captures_len
      .          .          .          .                           != p.static_explicit_captures_len()
      .          .          .          .                       {
      .          .          .          .                           props.static_explicit_captures_len = None;
      .          .          .          .                       }
      .          .          .          .                       props.alternation_literal =
 35,410 ( 0.01%) .          .          .                           props.alternation_literal && p.is_literal();
 50,185 ( 0.01%) .          .          .                       if !min_poisoned {
 36,728 ( 0.01%) .          .          .                           if let Some(xmin) = p.minimum_len() {
 53,115 ( 0.02%) .          .          .                               if props.minimum_len.map_or(true, |pmin| xmin < pmin) {
      .          .          .          .                                   props.minimum_len = Some(xmin);
      .          .          .          .                               }
      .          .          .          .                           } else {
      .          .          .          .                               props.minimum_len = None;
      .          .          .          .                               min_poisoned = true;
      .          .          .          .                           }
      .          .          .          .                       }
 35,410 ( 0.01%) .          .          .                       if !max_poisoned {
 36,720 ( 0.01%) .          .          .                           if let Some(xmax) = p.maximum_len() {
 53,100 ( 0.02%) .          .          .                               if props.maximum_len.map_or(true, |pmax| xmax > pmax) {
      .          .          .          .                                   props.maximum_len = Some(xmax);
      .          .          .          .                               }
      .          .          .          .                           } else {
      .          .          .          .                               props.maximum_len = None;
      .          .          .          .                               max_poisoned = true;
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Properties(Box::new(props))
    648 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Properties {
      .          .          .          .               /// Create a new set of HIR properties for an empty regex.
      .          .          .          .               fn empty() -> Properties {
      .          .          .          .                   let inner = PropertiesI {
      .          .          .          .                       minimum_len: Some(0),
      .          .          .          .                       maximum_len: Some(0),
-- line 2400 ----------------------------------------
-- line 2425 ----------------------------------------
      .          .          .          .                       static_explicit_captures_len: Some(0),
      .          .          .          .                       literal: false,
      .          .          .          .                       alternation_literal: false,
      .          .          .          .                   };
      .          .          .          .                   Properties(Box::new(inner))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a literal regex.
  5,736 ( 0.00%) .          .          .               fn literal(lit: &Literal) -> Properties {
      .          .          .          .                   let inner = PropertiesI {
  1,912 ( 0.00%) .          .          .                       minimum_len: Some(lit.0.len()),
      .          .          .          .                       maximum_len: Some(lit.0.len()),
      .          .          .          .                       look_set: LookSet::empty(),
      .          .          .          .                       look_set_prefix: LookSet::empty(),
      .          .          .          .                       look_set_suffix: LookSet::empty(),
      .          .          .          .                       look_set_prefix_any: LookSet::empty(),
      .          .          .          .                       look_set_suffix_any: LookSet::empty(),
123,392 ( 0.04%) .          .          .                       utf8: core::str::from_utf8(&lit.0).is_ok(),
 98,933 ( 0.03%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/converts.rs:core::str::converts::from_utf8 (1,912x)
      .          .          .          .                       explicit_captures_len: 0,
      .          .          .          .                       static_explicit_captures_len: Some(0),
      .          .          .          .                       literal: true,
      .          .          .          .                       alternation_literal: true,
      .          .          .          .                   };
      .          .          .          .                   Properties(Box::new(inner))
  7,648 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a character class.
 13,640 ( 0.00%) .          .          .               fn class(class: &Class) -> Properties {
    440 ( 0.00%) .          .          .                   let inner = PropertiesI {
      .          .          .          .                       minimum_len: class.minimum_len(),
      .          .          .          .                       maximum_len: class.maximum_len(),
      .          .          .          .                       look_set: LookSet::empty(),
      .          .          .          .                       look_set_prefix: LookSet::empty(),
      .          .          .          .                       look_set_suffix: LookSet::empty(),
      .          .          .          .                       look_set_prefix_any: LookSet::empty(),
      .          .          .          .                       look_set_suffix_any: LookSet::empty(),
      .          .          .          .                       utf8: class.is_utf8(),
      .          .          .          .                       explicit_captures_len: 0,
      .          .          .          .                       static_explicit_captures_len: Some(0),
      .          .          .          .                       literal: false,
      .          .          .          .                       alternation_literal: false,
      .          .          .          .                   };
      .          .          .          .                   Properties(Box::new(inner))
 16,368 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a look-around assertion.
      4 ( 0.00%) .          .          .               fn look(look: Look) -> Properties {
      .          .          .          .                   let inner = PropertiesI {
      .          .          .          .                       minimum_len: Some(0),
      .          .          .          .                       maximum_len: Some(0),
      .          .          .          .                       look_set: LookSet::singleton(look),
      .          .          .          .                       look_set_prefix: LookSet::singleton(look),
      .          .          .          .                       look_set_suffix: LookSet::singleton(look),
      .          .          .          .                       look_set_prefix_any: LookSet::singleton(look),
      .          .          .          .                       look_set_suffix_any: LookSet::singleton(look),
-- line 2479 ----------------------------------------
-- line 2492 ----------------------------------------
      .          .          .          .                       // property borderline useless.
      .          .          .          .                       utf8: true,
      .          .          .          .                       explicit_captures_len: 0,
      .          .          .          .                       static_explicit_captures_len: Some(0),
      .          .          .          .                       literal: false,
      .          .          .          .                       alternation_literal: false,
      .          .          .          .                   };
      .          .          .          .                   Properties(Box::new(inner))
      4 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a repetition.
 14,238 ( 0.00%) .          .          .               fn repetition(rep: &Repetition) -> Properties {
  2,034 ( 0.00%) .          .          .                   let p = rep.sub.properties();
      .          .          .          .                   let minimum_len = p.minimum_len().map(|child_min| {
      .          .          .          .                       let rep_min = usize::try_from(rep.min).unwrap_or(usize::MAX);
      .          .          .          .                       child_min.saturating_mul(rep_min)
      .          .          .          .                   });
  3,981 ( 0.00%) .          .          .                   let maximum_len = rep.max.and_then(|rep_max| {
      .          .          .          .                       let rep_max = usize::try_from(rep_max).ok()?;
  1,947 ( 0.00%) .          .          .                       let child_max = p.maximum_len()?;
      .          .          .          .                       child_max.checked_mul(rep_max)
      .          .          .          .                   });
      .          .          .          .           
      .          .          .          .                   let mut inner = PropertiesI {
      .          .          .          .                       minimum_len,
      .          .          .          .                       maximum_len,
      .          .          .          .                       look_set: p.look_set(),
      .          .          .          .                       look_set_prefix: LookSet::empty(),
-- line 2519 ----------------------------------------
-- line 2524 ----------------------------------------
      .          .          .          .                       explicit_captures_len: p.explicit_captures_len(),
      .          .          .          .                       static_explicit_captures_len: p.static_explicit_captures_len(),
      .          .          .          .                       literal: false,
      .          .          .          .                       alternation_literal: false,
      .          .          .          .                   };
      .          .          .          .                   // If the repetition operator can match the empty string, then its
      .          .          .          .                   // lookset prefix and suffixes themselves remain empty since they are
      .          .          .          .                   // no longer required to match.
  4,068 ( 0.00%) .          .          .                   if rep.min > 0 {
      .          .          .          .                       inner.look_set_prefix = p.look_set_prefix();
      .          .          .          .                       inner.look_set_suffix = p.look_set_suffix();
      .          .          .          .                   }
      .          .          .          .                   // If the static captures len of the sub-expression is not known or
      .          .          .          .                   // is greater than zero, then it automatically propagates to the
      .          .          .          .                   // repetition, regardless of the repetition. Otherwise, it might
      .          .          .          .                   // change, but only when the repetition can match 0 times.
  5,322 ( 0.00%) .          .          .                   if rep.min == 0
      .          .          .          .                       && inner.static_explicit_captures_len.map_or(false, |len| len > 0)
      .          .          .          .                   {
      .          .          .          .                       // If we require a match 0 times, then our captures len is
      .          .          .          .                       // guaranteed to be zero. Otherwise, if we *can* match the empty
      .          .          .          .                       // string, then it's impossible to know how many captures will be
      .          .          .          .                       // in the resulting match.
      .          .          .          .                       if rep.max == Some(0) {
      .          .          .          .                           inner.static_explicit_captures_len = Some(0);
      .          .          .          .                       } else {
      .          .          .          .                           inner.static_explicit_captures_len = None;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Properties(Box::new(inner))
 16,272 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a capture.
  4,851 ( 0.00%) .          .          .               fn capture(capture: &Capture) -> Properties {
    693 ( 0.00%) .          .          .                   let p = capture.sub.properties();
      .          .          .          .                   Properties(Box::new(PropertiesI {
      .          .          .          .                       explicit_captures_len: p.explicit_captures_len().saturating_add(1),
      .          .          .          .                       static_explicit_captures_len: p
      .          .          .          .                           .static_explicit_captures_len()
      .          .          .          .                           .map(|len| len.saturating_add(1)),
      .          .          .          .                       literal: false,
      .          .          .          .                       alternation_literal: false,
      .          .          .          .                       ..*p.0.clone()
      .          .          .          .                   }))
  5,544 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a concatenation.
      .          .          .          .               fn concat(concat: &[Hir]) -> Properties {
      .          .          .          .                   // The base case is an empty concatenation, which matches the empty
      .          .          .          .                   // string. Note though that empty concatenations aren't possible,
      .          .          .          .                   // because the Hir::concat smart constructor rewrites those as
      .          .          .          .                   // Hir::empty.
      .          .          .          .                   let mut props = PropertiesI {
-- line 2576 ----------------------------------------
-- line 2586 ----------------------------------------
      .          .          .          .                       static_explicit_captures_len: Some(0),
      .          .          .          .                       literal: true,
      .          .          .          .                       alternation_literal: true,
      .          .          .          .                   };
      .          .          .          .                   // Handle properties that need to visit every child hir.
      .          .          .          .                   for x in concat.iter() {
      .          .          .          .                       let p = x.properties();
      .          .          .          .                       props.look_set.set_union(p.look_set());
 13,438 ( 0.00%) .          .          .                       props.utf8 = props.utf8 && p.is_utf8();
      .          .          .          .                       props.explicit_captures_len = props
      .          .          .          .                           .explicit_captures_len
      .          .          .          .                           .saturating_add(p.explicit_captures_len());
      .          .          .          .                       props.static_explicit_captures_len = p
      .          .          .          .                           .static_explicit_captures_len()
      .          .          .          .                           .and_then(|len1| {
      .          .          .          .                               Some((len1, props.static_explicit_captures_len?))
      .          .          .          .                           })
      .          .          .          .                           .and_then(|(len1, len2)| Some(len1.saturating_add(len2)));
 13,438 ( 0.00%) .          .          .                       props.literal = props.literal && p.is_literal();
      .          .          .          .                       props.alternation_literal =
 13,438 ( 0.00%) .          .          .                           props.alternation_literal && p.is_alternation_literal();
 13,438 ( 0.00%) .          .          .                       if let Some(minimum_len) = props.minimum_len {
 13,438 ( 0.00%) .          .          .                           match p.minimum_len() {
      .          .          .          .                               None => props.minimum_len = None,
      .          .          .          .                               Some(len) => {
      .          .          .          .                                   // We use saturating arithmetic here because the
      .          .          .          .                                   // minimum is just a lower bound. We can't go any
      .          .          .          .                                   // higher than what our number types permit.
      .          .          .          .                                   props.minimum_len =
      .          .          .          .                                       Some(minimum_len.saturating_add(len));
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                       }
 19,677 ( 0.01%) .          .          .                       if let Some(maximum_len) = props.maximum_len {
 12,478 ( 0.00%) .          .          .                           match p.maximum_len() {
      .          .          .          .                               None => props.maximum_len = None,
      .          .          .          .                               Some(len) => {
      .          .          .          .                                   props.maximum_len = maximum_len.checked_add(len)
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // Handle the prefix properties, which only requires visiting
      .          .          .          .                   // child exprs until one matches more than the empty string.
      .          .          .          .                   let mut it = concat.iter();
      .          .          .          .                   while let Some(x) = it.next() {
      .          .          .          .                       props.look_set_prefix.set_union(x.properties().look_set_prefix());
      .          .          .          .                       props
      .          .          .          .                           .look_set_prefix_any
      .          .          .          .                           .set_union(x.properties().look_set_prefix_any());
  8,519 ( 0.00%) .          .          .                       if x.properties().maximum_len().map_or(true, |x| x > 0) {
      .          .          .          .                           break;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // Same thing for the suffix properties, but in reverse.
      .          .          .          .                   let mut it = concat.iter().rev();
 10,365 ( 0.00%) .          .          .                   while let Some(x) = it.next() {
      .          .          .          .                       props.look_set_suffix.set_union(x.properties().look_set_suffix());
      .          .          .          .                       props
      .          .          .          .                           .look_set_suffix_any
      .          .          .          .                           .set_union(x.properties().look_set_suffix_any());
  8,277 ( 0.00%) .          .          .                       if x.properties().maximum_len().map_or(true, |x| x > 0) {
      .          .          .          .                           break;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Properties(Box::new(props))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a concatenation.
      .          .          .          .               fn alternation(alts: &[Hir]) -> Properties {
-- line 2655 ----------------------------------------
-- line 2656 ----------------------------------------
      .          .          .          .                   Properties::union(alts.iter().map(|hir| hir.properties()))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A set of look-around assertions.
      .          .          .          .           ///
      .          .          .          .           /// This is useful for efficiently tracking look-around assertions. For
      .          .          .          .           /// example, an [`Hir`] provides properties that return `LookSet`s.
  3,514 ( 0.00%) .          .          .           #[derive(Clone, Copy, Default, Eq, PartialEq)]
      .          .          .          .           pub struct LookSet {
      .          .          .          .               /// The underlying representation this set is exposed to make it possible
      .          .          .          .               /// to store it somewhere efficiently. The representation is that
      .          .          .          .               /// of a bitset, where each assertion occupies bit `i` where `i =
      .          .          .          .               /// Look::as_repr()`.
      .          .          .          .               ///
      .          .          .          .               /// Note that users of this internal representation must permit the full
      .          .          .          .               /// range of `u16` values to be represented. For example, even if the
-- line 2672 ----------------------------------------
-- line 2705 ----------------------------------------
      .          .          .          .                   // OK because max value always fits in a u8, which in turn always
      .          .          .          .                   // fits in a usize, regardless of target.
      .          .          .          .                   usize::try_from(self.bits.count_ones()).unwrap()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this set is empty.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_empty(self) -> bool {
     16 ( 0.00%) .          .          .                   self.len() == 0
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if the given look-around assertion is in this
      .          .          .          .               /// set.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn contains(self, look: Look) -> bool {
    300 ( 0.00%) .          .          .                   self.bits & look.as_repr() != 0
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this set contains any anchor assertions.
      .          .          .          .               /// This includes both "start/end of haystack" and "start/end of line."
      .          .          .          .               #[inline]
      .          .          .          .               pub fn contains_anchor(&self) -> bool {
      .          .          .          .                   self.contains_anchor_haystack() || self.contains_anchor_line()
      .          .          .          .               }
-- line 2728 ----------------------------------------
-- line 2841 ----------------------------------------
      .          .          .          .               #[inline]
      .          .          .          .               pub fn set_subtract(&mut self, other: LookSet) {
      .          .          .          .                   *self = self.subtract(other);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a new set that is the union of this and the one given.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn union(self, other: LookSet) -> LookSet {
  8,422 ( 0.00%) .          .          .                   LookSet { bits: self.bits | other.bits }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Updates this set in place with the result of unioning it with the one
      .          .          .          .               /// given.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn set_union(&mut self, other: LookSet) {
      .          .          .          .                   *self = self.union(other);
      .          .          .          .               }
-- line 2857 ----------------------------------------
-- line 2935 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Given a sequence of HIR values where each value corresponds to a Unicode
      .          .          .          .           /// class (or an all-ASCII byte class), return a single Unicode class
      .          .          .          .           /// corresponding to the union of the classes found.
      .          .          .          .           fn class_chars(hirs: &[Hir]) -> Option<Class> {
      .          .          .          .               let mut cls = ClassUnicode::new(vec![]);
      .          .          .          .               for hir in hirs.iter() {
  3,816 ( 0.00%) .          .          .                   match *hir.kind() {
      .          .          .          .                       HirKind::Class(Class::Unicode(ref cls2)) => {
      .          .          .          .                           cls.union(cls2);
      .          .          .          .                       }
      .          .          .          .                       HirKind::Class(Class::Bytes(ref cls2)) => {
      .          .          .          .                           cls.union(&cls2.to_unicode_class()?);
      .          .          .          .                       }
      .          .          .          .                       _ => return None,
      .          .          .          .                   };
-- line 2951 ----------------------------------------
-- line 2954 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Given a sequence of HIR values where each value corresponds to a byte class
      .          .          .          .           /// (or an all-ASCII Unicode class), return a single byte class corresponding
      .          .          .          .           /// to the union of the classes found.
      .          .          .          .           fn class_bytes(hirs: &[Hir]) -> Option<Class> {
      .          .          .          .               let mut cls = ClassBytes::new(vec![]);
      .          .          .          .               for hir in hirs.iter() {
  4,003 ( 0.00%) .          .          .                   match *hir.kind() {
      .          .          .          .                       HirKind::Class(Class::Unicode(ref cls2)) => {
      .          .          .          .                           cls.union(&cls2.to_byte_class()?);
      .          .          .          .                       }
      .          .          .          .                       HirKind::Class(Class::Bytes(ref cls2)) => {
      .          .          .          .                           cls.union(cls2);
      .          .          .          .                       }
      .          .          .          .                       _ => return None,
      .          .          .          .                   };
-- line 2970 ----------------------------------------
-- line 2973 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Given a sequence of HIR values where each value corresponds to a literal
      .          .          .          .           /// that is a single `char`, return that sequence of `char`s. Otherwise return
      .          .          .          .           /// None. No deduplication is done.
      .          .          .          .           fn singleton_chars(hirs: &[Hir]) -> Option<Vec<char>> {
      .          .          .          .               let mut singletons = vec![];
      .          .          .          .               for hir in hirs.iter() {
  1,246 ( 0.00%) .          .          .                   let literal = match *hir.kind() {
      .          .          .          .                       HirKind::Literal(Literal(ref bytes)) => bytes,
      .          .          .          .                       _ => return None,
      .          .          .          .                   };
  4,590 ( 0.00%) .          .          .                   let ch = match crate::debug::utf8_decode(literal) {
  7,718 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/debug.rs:regex_syntax::debug::utf8_decode (454x)
      .          .          .          .                       None => return None,
      .          .          .          .                       Some(Err(_)) => return None,
      .          .          .          .                       Some(Ok(ch)) => ch,
      .          .          .          .                   };
    918 ( 0.00%) .          .          .                   if literal.len() != ch.len_utf8() {
      .          .          .          .                       return None;
      .          .          .          .                   }
      .          .          .          .                   singletons.push(ch);
      .          .          .          .               }
      1 ( 0.00%) .          .          .               Some(singletons)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Given a sequence of HIR values where each value corresponds to a literal
      .          .          .          .           /// that is a single byte, return that sequence of bytes. Otherwise return
      .          .          .          .           /// None. No deduplication is done.
      .          .          .          .           fn singleton_bytes(hirs: &[Hir]) -> Option<Vec<u8>> {
      .          .          .          .               let mut singletons = vec![];
      .          .          .          .               for hir in hirs.iter() {
  1,236 ( 0.00%) .          .          .                   let literal = match *hir.kind() {
      .          .          .          .                       HirKind::Literal(Literal(ref bytes)) => bytes,
      .          .          .          .                       _ => return None,
      .          .          .          .                   };
    908 ( 0.00%) .          .          .                   if literal.len() != 1 {
      .          .          .          .                       return None;
      .          .          .          .                   }
     78 ( 0.00%) .          .          .                   singletons.push(literal[0]);
      .          .          .          .               }
      .          .          .          .               Some(singletons)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Looks for a common prefix in the list of alternation branches given. If one
      .          .          .          .           /// is found, then an equivalent but (hopefully) simplified Hir is returned.
      .          .          .          .           /// Otherwise, the original given list of branches is returned unmodified.
      .          .          .          .           ///
-- line 3019 ----------------------------------------
-- line 3020 ----------------------------------------
      .          .          .          .           /// This is not quite as good as it could be. Right now, it requires that
      .          .          .          .           /// all branches are 'Concat' expressions. It also doesn't do well with
      .          .          .          .           /// literals. For example, given 'foofoo|foobar', it will not refactor it to
      .          .          .          .           /// 'foo(?:foo|bar)' because literals are flattened into their own special
      .          .          .          .           /// concatenation. (One wonders if perhaps 'Literal' should be a single atom
      .          .          .          .           /// instead of a string of bytes because of this. Otherwise, handling the
      .          .          .          .           /// current representation in this routine will be pretty gnarly. Sigh.)
      .          .          .          .           fn lift_common_prefix(hirs: Vec<Hir>) -> Result<Hir, Vec<Hir>> {
  1,158 ( 0.00%) .          .          .               if hirs.len() <= 1 {
      .          .          .          .                   return Err(hirs);
      .          .          .          .               }
  1,158 ( 0.00%) .          .          .               let mut prefix = match hirs[0].kind() {
      .          .          .          .                   HirKind::Concat(ref xs) => &**xs,
      .          .          .          .                   _ => return Err(hirs),
      .          .          .          .               };
    206 ( 0.00%) .          .          .               if prefix.is_empty() {
      .          .          .          .                   return Err(hirs);
      .          .          .          .               }
      .          .          .          .               for h in hirs.iter().skip(1) {
    232 ( 0.00%) .          .          .                   let concat = match h.kind() {
      .          .          .          .                       HirKind::Concat(ref xs) => xs,
      .          .          .          .                       _ => return Err(hirs),
      .          .          .          .                   };
      .          .          .          .                   let common_len = prefix
      .          .          .          .                       .iter()
      .          .          .          .                       .zip(concat.iter())
      .          .          .          .                       .take_while(|(x, y)| x == y)
      .          .          .          .                       .count();
      .          .          .          .                   prefix = &prefix[..common_len];
     48 ( 0.00%) .          .          .                   if prefix.is_empty() {
      .          .          .          .                       return Err(hirs);
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .               let len = prefix.len();
      .          .          .          .               assert_ne!(0, len);
      .          .          .          .               let mut prefix_concat = vec![];
      .          .          .          .               let mut suffix_alts = vec![];
     49 ( 0.00%) .          .          .               for h in hirs {
     10 ( 0.00%) .          .          .                   let mut concat = match h.into_kind() {
     20 ( 0.00%) .          .          .                       HirKind::Concat(xs) => xs,
      .          .          .          .                       // We required all sub-expressions to be
      .          .          .          .                       // concats above, so we're only here if we
      .          .          .          .                       // have a concat.
      .          .          .          .                       _ => unreachable!(),
      .          .          .          .                   };
     15 ( 0.00%) .          .          .                   suffix_alts.push(Hir::concat(concat.split_off(len)));
  6,351 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (5x)
     15 ( 0.00%) .          .          .                   if prefix_concat.is_empty() {
      4 ( 0.00%) .          .          .                       prefix_concat = concat;
      .          .          .          .                   }
      .          .          .          .               }
      4 ( 0.00%) .          .          .               let mut concat = prefix_concat;
      7 ( 0.00%) .          .          .               concat.push(Hir::alternation(suffix_alts));
  4,930 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation'2 (1x)
      6 ( 0.00%) .          .          .               Ok(Hir::concat(concat))
  1,102 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (1x)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[cfg(test)]
      .          .          .          .           mod tests {
      .          .          .          .               use super::*;
      .          .          .          .           
      .          .          .          .               fn uclass(ranges: &[(char, char)]) -> ClassUnicode {
      .          .          .          .                   let ranges: Vec<ClassUnicodeRange> = ranges
-- line 3080 ----------------------------------------

585,980 ( 0.17%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 26 ----------------------------------------
      .          .          .          .           impl Default for TranslatorBuilder {
      .          .          .          .               fn default() -> TranslatorBuilder {
      .          .          .          .                   TranslatorBuilder::new()
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl TranslatorBuilder {
      .          .          .          .               /// Create a new translator builder with a default c onfiguration.
     81 ( 0.00%) .          .          .               pub fn new() -> TranslatorBuilder {
      .          .          .          .                   TranslatorBuilder {
      .          .          .          .                       utf8: true,
      .          .          .          .                       line_terminator: b'\n',
      .          .          .          .                       flags: Flags::default(),
      .          .          .          .                   }
     81 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Build a translator using the current configuration.
     81 ( 0.00%) .          .          .               pub fn build(&self) -> Translator {
    486 ( 0.00%) .          .          .                   Translator {
      .          .          .          .                       stack: RefCell::new(vec![]),
    324 ( 0.00%) .          .          .                       flags: Cell::new(self.flags),
     81 ( 0.00%) .          .          .                       utf8: self.utf8,
     81 ( 0.00%) .          .          .                       line_terminator: self.line_terminator,
      .          .          .          .                   }
     81 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// When disabled, translation will permit the construction of a regular
      .          .          .          .               /// expression that may match invalid UTF-8.
      .          .          .          .               ///
      .          .          .          .               /// When enabled (the default), the translator is guaranteed to produce an
      .          .          .          .               /// expression that, for non-empty matches, will only ever produce spans
      .          .          .          .               /// that are entirely valid UTF-8 (otherwise, the translator will return an
      .          .          .          .               /// error).
-- line 58 ----------------------------------------
-- line 59 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// Perhaps surprisingly, when UTF-8 is enabled, an empty regex or even
      .          .          .          .               /// a negated ASCII word boundary (uttered as `(?-u:\B)` in the concrete
      .          .          .          .               /// syntax) will be allowed even though they can produce matches that split
      .          .          .          .               /// a UTF-8 encoded codepoint. This only applies to zero-width or "empty"
      .          .          .          .               /// matches, and it is expected that the regex engine itself must handle
      .          .          .          .               /// these cases if necessary (perhaps by suppressing any zero-width matches
      .          .          .          .               /// that split a codepoint).
     81 ( 0.00%) .          .          .               pub fn utf8(&mut self, yes: bool) -> &mut TranslatorBuilder {
     81 ( 0.00%) .          .          .                   self.utf8 = yes;
      .          .          .          .                   self
     81 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets the line terminator for use with `(?u-s:.)` and `(?-us:.)`.
      .          .          .          .               ///
      .          .          .          .               /// Namely, instead of `.` (by default) matching everything except for `\n`,
      .          .          .          .               /// this will cause `.` to match everything except for the byte given.
      .          .          .          .               ///
      .          .          .          .               /// If `.` is used in a context where Unicode mode is enabled and this byte
      .          .          .          .               /// isn't ASCII, then an error will be returned. When Unicode mode is
-- line 78 ----------------------------------------
-- line 84 ----------------------------------------
      .          .          .          .               /// mode or UTF-8 mode are enabled.
      .          .          .          .               ///
      .          .          .          .               /// Note that if `R` mode is enabled then it always takes precedence and
      .          .          .          .               /// the line terminator will be treated as `\r` and `\n` simultaneously.
      .          .          .          .               ///
      .          .          .          .               /// Note also that this *doesn't* impact the look-around assertions
      .          .          .          .               /// `(?m:^)` and `(?m:$)`. That's usually controlled by additional
      .          .          .          .               /// configuration in the regex engine itself.
     81 ( 0.00%) .          .          .               pub fn line_terminator(&mut self, byte: u8) -> &mut TranslatorBuilder {
     81 ( 0.00%) .          .          .                   self.line_terminator = byte;
      .          .          .          .                   self
     81 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable or disable the case insensitive flag (`i`) by default.
    162 ( 0.00%) .          .          .               pub fn case_insensitive(&mut self, yes: bool) -> &mut TranslatorBuilder {
    162 ( 0.00%) .          .          .                   self.flags.case_insensitive = if yes { Some(true) } else { None };
      .          .          .          .                   self
     81 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable or disable the multi-line matching flag (`m`) by default.
    162 ( 0.00%) .          .          .               pub fn multi_line(&mut self, yes: bool) -> &mut TranslatorBuilder {
    162 ( 0.00%) .          .          .                   self.flags.multi_line = if yes { Some(true) } else { None };
      .          .          .          .                   self
     81 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable or disable the "dot matches any character" flag (`s`) by
      .          .          .          .               /// default.
    162 ( 0.00%) .          .          .               pub fn dot_matches_new_line(
      .          .          .          .                   &mut self,
      .          .          .          .                   yes: bool,
      .          .          .          .               ) -> &mut TranslatorBuilder {
    162 ( 0.00%) .          .          .                   self.flags.dot_matches_new_line = if yes { Some(true) } else { None };
      .          .          .          .                   self
     81 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable or disable the CRLF mode flag (`R`) by default.
    162 ( 0.00%) .          .          .               pub fn crlf(&mut self, yes: bool) -> &mut TranslatorBuilder {
    162 ( 0.00%) .          .          .                   self.flags.crlf = if yes { Some(true) } else { None };
      .          .          .          .                   self
     81 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable or disable the "swap greed" flag (`U`) by default.
    162 ( 0.00%) .          .          .               pub fn swap_greed(&mut self, yes: bool) -> &mut TranslatorBuilder {
    162 ( 0.00%) .          .          .                   self.flags.swap_greed = if yes { Some(true) } else { None };
      .          .          .          .                   self
     81 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable or disable the Unicode flag (`u`) by default.
     81 ( 0.00%) .          .          .               pub fn unicode(&mut self, yes: bool) -> &mut TranslatorBuilder {
    162 ( 0.00%) .          .          .                   self.flags.unicode = if yes { None } else { Some(false) };
      .          .          .          .                   self
     81 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A translator maps abstract syntax to a high level intermediate
      .          .          .          .           /// representation.
      .          .          .          .           ///
      .          .          .          .           /// A translator may be benefit from reuse. That is, a translator can translate
      .          .          .          .           /// many abstract syntax trees.
      .          .          .          .           ///
-- line 143 ----------------------------------------
-- line 165 ----------------------------------------
      .          .          .          .               /// intermediate representation (HIR).
      .          .          .          .               ///
      .          .          .          .               /// If there was a problem doing the translation, then an HIR-specific
      .          .          .          .               /// error is returned.
      .          .          .          .               ///
      .          .          .          .               /// The original pattern string used to produce the `Ast` *must* also be
      .          .          .          .               /// provided. The translator does not use the pattern string during any
      .          .          .          .               /// correct translation, but is used for error reporting.
    243 ( 0.00%) .          .          .               pub fn translate(&mut self, pattern: &str, ast: &Ast) -> Result<Hir> {
    162 ( 0.00%) .          .          .                   ast::visit(ast, TranslatorI::new(self, pattern))
70,504,119 (20.29%) 152,032 (18.77%) 26 ( 8.02%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (81x)
    324 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// An HirFrame is a single stack frame, represented explicitly, which is
      .          .          .          .           /// created for each item in the Ast that we traverse.
      .          .          .          .           ///
      .          .          .          .           /// Note that technically, this type doesn't represent our entire stack
      .          .          .          .           /// frame. In particular, the Ast visitor represents any state associated with
      .          .          .          .           /// traversing the Ast itself.
-- line 183 ----------------------------------------
-- line 245 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// It is popped after each expression in a branch until an 'Alternation'
      .          .          .          .               /// frame is observed when doing a post visit on an alternation.
      .          .          .          .               AlternationBranch,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl HirFrame {
      .          .          .          .               /// Assert that the current stack frame is an Hir expression and return it.
 23,931 ( 0.01%) .          .          .               fn unwrap_expr(self) -> Hir {
 21,272 ( 0.01%) .          .          .                   match self {
 15,954 ( 0.00%) .          .          .                       HirFrame::Expr(expr) => expr,
      .          .          .          .                       HirFrame::Literal(lit) => Hir::literal(lit),
      .          .          .          .                       _ => panic!("tried to unwrap expr from HirFrame, got: {:?}", self),
      .          .          .          .                   }
 26,590 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Assert that the current stack frame is a Unicode class expression and
      .          .          .          .               /// return it.
      .          .          .          .               fn unwrap_class_unicode(self) -> hir::ClassUnicode {
 14,430 ( 0.00%) .          .          .                   match self {
 29,635 ( 0.01%) .          .          .                       HirFrame::ClassUnicode(cls) => cls,
      .          .          .          .                       _ => panic!(
      .          .          .          .                           "tried to unwrap Unicode class \
      .          .          .          .                            from HirFrame, got: {:?}",
      .          .          .          .                           self
      .          .          .          .                       ),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
-- line 273 ----------------------------------------
-- line 282 ----------------------------------------
      .          .          .          .                           self
      .          .          .          .                       ),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Assert that the current stack frame is a repetition sentinel. If it
      .          .          .          .               /// isn't, then panic.
      .          .          .          .               fn unwrap_repetition(self) {
  3,770 ( 0.00%) .          .          .                   match self {
      .          .          .          .                       HirFrame::Repetition => {}
      .          .          .          .                       _ => {
      .          .          .          .                           panic!(
      .          .          .          .                               "tried to unwrap repetition from HirFrame, got: {:?}",
      .          .          .          .                               self
      .          .          .          .                           )
      .          .          .          .                       }
      .          .          .          .                   }
  1,885 ( 0.00%) .          .          .               }
 16,965 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> (1,885x)
      .          .          .          .           
      .          .          .          .               /// Assert that the current stack frame is a group indicator and return
      .          .          .          .               /// its corresponding flags (the flags that were active at the time the
      .          .          .          .               /// group was entered).
      .          .          .          .               fn unwrap_group(self) -> Flags {
  1,386 ( 0.00%) .          .          .                   match self {
  2,079 ( 0.00%) .          .          .                       HirFrame::Group { old_flags } => old_flags,
      .          .          .          .                       _ => {
      .          .          .          .                           panic!("tried to unwrap group from HirFrame, got: {:?}", self)
      .          .          .          .                       }
      .          .          .          .                   }
    693 ( 0.00%) .          .          .               }
  6,237 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> (693x)
      .          .          .          .           
      .          .          .          .               /// Assert that the current stack frame is an alternation pipe sentinel. If
      .          .          .          .               /// it isn't, then panic.
      .          .          .          .               fn unwrap_alternation_pipe(self) {
 32,882 ( 0.01%) .          .          .                   match self {
      .          .          .          .                       HirFrame::AlternationBranch => {}
      .          .          .          .                       _ => {
      .          .          .          .                           panic!(
      .          .          .          .                               "tried to unwrap alt pipe from HirFrame, got: {:?}",
      .          .          .          .                               self
      .          .          .          .                           )
      .          .          .          .                       }
      .          .          .          .                   }
 32,882 ( 0.01%) .          .          .               }
147,969 ( 0.04%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> (16,441x)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'t, 'p> Visitor for TranslatorI<'t, 'p> {
      .          .          .          .               type Output = Hir;
      .          .          .          .               type Err = Error;
      .          .          .          .           
    162 ( 0.00%) .          .          .               fn finish(self) -> Result<Hir> {
      .          .          .          .                   // ... otherwise, we should have exactly one HIR on the stack.
    243 ( 0.00%) .          .          .                   assert_eq!(self.trans().stack.borrow().len(), 1);
    162 ( 0.00%) .          .          .                   Ok(self.pop().unwrap().unwrap_expr())
  2,673 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::HirFrame::unwrap_expr (81x)
    324 ( 0.00%) .          .          .               }
      .          .          .          .           
570,048 ( 0.16%) .          .          .               fn visit_pre(&mut self, ast: &Ast) -> Result<()> {
285,024 ( 0.08%) .          .          .                   match *ast {
      .          .          .          .                       Ast::ClassBracketed(_) => {
  5,506 ( 0.00%) .          .          .                           if self.flags().unicode() {
      .          .          .          .                               let cls = hir::ClassUnicode::empty();
      .          .          .          .                               self.push(HirFrame::ClassUnicode(cls));
      .          .          .          .                           } else {
      .          .          .          .                               let cls = hir::ClassBytes::empty();
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls));
      .          .          .          .                           }
      .          .          .          .                       }
  1,885 ( 0.00%) .          .          .                       Ast::Repetition(_) => self.push(HirFrame::Repetition),
      .          .          .          .                       Ast::Group(ref x) => {
    693 ( 0.00%) .          .          .                           let old_flags = x
      .          .          .          .                               .flags()
      .          .          .          .                               .map(|ast| self.set_flags(ast))
  1,386 ( 0.00%) .          .          .                               .unwrap_or_else(|| self.flags());
      .          .          .          .                           self.push(HirFrame::Group { old_flags });
      .          .          .          .                       }
      .          .          .          .                       Ast::Concat(_) => {
 15,786 ( 0.00%) .          .          .                           self.push(HirFrame::Concat);
      .          .          .          .                       }
      .          .          .          .                       Ast::Alternation(ref x) => {
    512 ( 0.00%) .          .          .                           self.push(HirFrame::Alternation);
  1,024 ( 0.00%) .          .          .                           if !x.asts.is_empty() {
      .          .          .          .                               self.push(HirFrame::AlternationBranch);
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       _ => {}
      .          .          .          .                   }
 71,256 ( 0.02%) .          .          .                   Ok(())
641,304 ( 0.18%) .          .          .               }
      .          .          .          .           
712,560 ( 0.21%) .          .          .               fn visit_post(&mut self, ast: &Ast) -> Result<()> {
356,280 ( 0.10%) .          .          .                   match *ast {
      .          .          .          .                       Ast::Empty(_) => {
      .          .          .          .                           self.push(HirFrame::Expr(Hir::empty()));
      .          .          .          .                       }
      .          .          .          .                       Ast::Flags(ref x) => {
     80 ( 0.00%) .          .          .                           self.set_flags(&x.flags);
      .          .          .          .                           // Flags in the AST are generally considered directives and
      .          .          .          .                           // not actual sub-expressions. However, they can be used in
      .          .          .          .                           // the concrete syntax like `((?i))`, and we need some kind of
      .          .          .          .                           // indication of an expression there, and Empty is the correct
      .          .          .          .                           // choice.
      .          .          .          .                           //
      .          .          .          .                           // There can also be things like `(?i)+`, but we rule those out
      .          .          .          .                           // in the parser. In the future, we might allow them for
      .          .          .          .                           // consistency sake.
      .          .          .          .                           self.push(HirFrame::Expr(Hir::empty()));
      .          .          .          .                       }
148,440 ( 0.04%) .          .          .                       Ast::Literal(ref x) => match self.ast_literal_to_scalar(x)? {
      .          .          .          .                           Either::Right(byte) => self.push_byte(byte),
299,120 ( 0.09%) .          .          .                           Either::Left(ch) => match self.case_fold_char(x.span, ch)? {
193,440 ( 0.06%) .          .          .                               None => self.push_char(ch),
8,265,058 ( 2.38%) 33,587 ( 4.15%) 3 ( 0.93%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::TranslatorI::push_char (48,360x)
 11,200 ( 0.00%) .          .          .                               Some(expr) => self.push(HirFrame::Expr(expr)),
 57,501 ( 0.02%) 160 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::TranslatorI::push (1,120x)
      .          .          .          .                           },
      .          .          .          .                       },
      .          .          .          .                       Ast::Dot(ref span) => {
     35 ( 0.00%) .          .          .                           self.push(HirFrame::Expr(self.hir_dot(**span)?));
      .          .          .          .                       }
      .          .          .          .                       Ast::Assertion(ref x) => {
    366 ( 0.00%) .          .          .                           self.push(HirFrame::Expr(self.hir_assertion(x)?));
      .          .          .          .                       }
      .          .          .          .                       Ast::ClassPerl(ref x) => {
      .          .          .          .                           if self.flags().unicode() {
      .          .          .          .                               let cls = self.hir_perl_unicode_class(x)?;
      .          .          .          .                               let hcls = hir::Class::Unicode(cls);
      .          .          .          .                               self.push(HirFrame::Expr(Hir::class(hcls)));
      .          .          .          .                           } else {
      .          .          .          .                               let cls = self.hir_perl_byte_class(x)?;
-- line 408 ----------------------------------------
-- line 410 ----------------------------------------
      .          .          .          .                               self.push(HirFrame::Expr(Hir::class(hcls)));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       Ast::ClassUnicode(ref x) => {
      .          .          .          .                           let cls = hir::Class::Unicode(self.hir_unicode_class(x)?);
      .          .          .          .                           self.push(HirFrame::Expr(Hir::class(cls)));
      .          .          .          .                       }
      .          .          .          .                       Ast::ClassBracketed(ref ast) => {
  5,506 ( 0.00%) .          .          .                           if self.flags().unicode() {
  2,753 ( 0.00%) .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_unicode();
      .          .          .          .                               self.unicode_fold_and_negate(
  2,753 ( 0.00%) .          .          .                                   &ast.span,
  5,506 ( 0.00%) .          .          .                                   ast.negated,
      .          .          .          .                                   &mut cls,
      .          .          .          .                               )?;
 13,765 ( 0.00%) .          .          .                               let expr = Hir::class(hir::Class::Unicode(cls));
      .          .          .          .                               self.push(HirFrame::Expr(expr));
      .          .          .          .                           } else {
      .          .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_bytes();
      .          .          .          .                               self.bytes_fold_and_negate(
      .          .          .          .                                   &ast.span,
      .          .          .          .                                   ast.negated,
      .          .          .          .                                   &mut cls,
      .          .          .          .                               )?;
      .          .          .          .                               let expr = Hir::class(hir::Class::Bytes(cls));
      .          .          .          .                               self.push(HirFrame::Expr(expr));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       Ast::Repetition(ref x) => {
  3,770 ( 0.00%) .          .          .                           let expr = self.pop().unwrap().unwrap_expr();
 62,205 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::HirFrame::unwrap_expr (1,885x)
      .          .          .          .                           self.pop().unwrap().unwrap_repetition();
  9,425 ( 0.00%) .          .          .                           self.push(HirFrame::Expr(self.hir_repetition(x, expr)));
      .          .          .          .                       }
      .          .          .          .                       Ast::Group(ref x) => {
  1,386 ( 0.00%) .          .          .                           let expr = self.pop().unwrap().unwrap_expr();
 22,869 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::HirFrame::unwrap_expr (693x)
      .          .          .          .                           let old_flags = self.pop().unwrap().unwrap_group();
      .          .          .          .                           self.trans().flags.set(old_flags);
  5,544 ( 0.00%) .          .          .                           self.push(HirFrame::Expr(self.hir_capture(x, expr)));
      .          .          .          .                       }
      .          .          .          .                       Ast::Concat(_) => {
      .          .          .          .                           let mut exprs = vec![];
210,600 ( 0.06%) .          .          .                           while let Some(expr) = self.pop_concat_expr() {
 39,784 ( 0.01%) .          .          .                               if !matches!(*expr.kind(), HirKind::Empty) {
238,464 ( 0.07%) .          .          .                                   exprs.push(expr);
      .          .          .          .                               }
     40 ( 0.00%) .          .          .                           }
  3,020 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (20x)
  1,925 ( 0.00%) .          .          .                           exprs.reverse();
110,502 ( 0.03%) .          .          .                           self.push(HirFrame::Expr(Hir::concat(exprs)));
24,777,622 ( 7.13%) 51,488 ( 6.36%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (15,786x)
      .          .          .          .                       }
      .          .          .          .                       Ast::Alternation(_) => {
      .          .          .          .                           let mut exprs = vec![];
 33,906 ( 0.01%) .          .          .                           while let Some(expr) = self.pop_alt_expr() {
      .          .          .          .                               self.pop().unwrap().unwrap_alternation_pipe();
      .          .          .          .                               exprs.push(expr);
      .          .          .          .                           }
    512 ( 0.00%) .          .          .                           exprs.reverse();
  3,584 ( 0.00%) .          .          .                           self.push(HirFrame::Expr(Hir::alternation(exprs)));
6,432,565 ( 1.85%) 2,381 ( 0.29%) 6 ( 1.85%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (512x)
      .          .          .          .                       }
      .          .          .          .                   }
 71,378 ( 0.02%) .          .          .                   Ok(())
641,304 ( 0.18%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn visit_alternation_in(&mut self) -> Result<()> {
 15,929 ( 0.00%) .          .          .                   self.push(HirFrame::AlternationBranch);
      .          .          .          .                   Ok(())
      .          .          .          .               }
      .          .          .          .           
 19,664 ( 0.01%) .          .          .               fn visit_class_set_item_pre(
      .          .          .          .                   &mut self,
      .          .          .          .                   ast: &ast::ClassSetItem,
      .          .          .          .               ) -> Result<()> {
  9,832 ( 0.00%) .          .          .                   match *ast {
      .          .          .          .                       ast::ClassSetItem::Bracketed(_) => {
    142 ( 0.00%) .          .          .                           if self.flags().unicode() {
      .          .          .          .                               let cls = hir::ClassUnicode::empty();
      .          .          .          .                               self.push(HirFrame::ClassUnicode(cls));
      .          .          .          .                           } else {
      .          .          .          .                               let cls = hir::ClassBytes::empty();
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       // We needn't handle the Union case here since the visitor will
      .          .          .          .                       // do it for us.
      .          .          .          .                       _ => {}
      .          .          .          .                   }
  4,916 ( 0.00%) .          .          .                   Ok(())
 24,580 ( 0.01%) .          .          .               }
      .          .          .          .           
 44,244 ( 0.01%) .          .          .               fn visit_class_set_item_post(
      .          .          .          .                   &mut self,
      .          .          .          .                   ast: &ast::ClassSetItem,
      .          .          .          .               ) -> Result<()> {
 49,160 ( 0.01%) .          .          .                   match *ast {
      .          .          .          .                       ast::ClassSetItem::Empty(_) => {}
      .          .          .          .                       ast::ClassSetItem::Literal(ref x) => {
  7,090 ( 0.00%) .          .          .                           if self.flags().unicode() {
  3,545 ( 0.00%) .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_unicode();
  3,545 ( 0.00%) .          .          .                               cls.push(hir::ClassUnicodeRange::new(x.c, x.c));
      .          .          .          .                               self.push(HirFrame::ClassUnicode(cls));
      .          .          .          .                           } else {
      .          .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_bytes();
      .          .          .          .                               let byte = self.class_literal_byte(x)?;
      .          .          .          .                               cls.push(hir::ClassBytesRange::new(byte, byte));
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls));
      .          .          .          .                           }
      .          .          .          .                       }
-- line 515 ----------------------------------------
-- line 522 ----------------------------------------
      .          .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_bytes();
      .          .          .          .                               let start = self.class_literal_byte(&x.start)?;
      .          .          .          .                               let end = self.class_literal_byte(&x.end)?;
      .          .          .          .                               cls.push(hir::ClassBytesRange::new(start, end));
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       ast::ClassSetItem::Ascii(ref x) => {
  1,540 ( 0.00%) .          .          .                           if self.flags().unicode() {
  2,310 ( 0.00%) .          .          .                               let xcls = self.hir_ascii_unicode_class(x)?;
      .          .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_unicode();
      .          .          .          .                               cls.union(&xcls);
      .          .          .          .                               self.push(HirFrame::ClassUnicode(cls));
      .          .          .          .                           } else {
      .          .          .          .                               let xcls = self.hir_ascii_byte_class(x)?;
      .          .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_bytes();
      .          .          .          .                               cls.union(&xcls);
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls));
-- line 539 ----------------------------------------
-- line 541 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .                       ast::ClassSetItem::Unicode(ref x) => {
      .          .          .          .                           let xcls = self.hir_unicode_class(x)?;
      .          .          .          .                           let mut cls = self.pop().unwrap().unwrap_class_unicode();
      .          .          .          .                           cls.union(&xcls);
      .          .          .          .                           self.push(HirFrame::ClassUnicode(cls));
      .          .          .          .                       }
      .          .          .          .                       ast::ClassSetItem::Perl(ref x) => {
     10 ( 0.00%) .          .          .                           if self.flags().unicode() {
     25 ( 0.00%) .          .          .                               let xcls = self.hir_perl_unicode_class(x)?;
 10,600 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::TranslatorI::hir_perl_unicode_class (5x)
      .          .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_unicode();
      .          .          .          .                               cls.union(&xcls);
      .          .          .          .                               self.push(HirFrame::ClassUnicode(cls));
      .          .          .          .                           } else {
      .          .          .          .                               let xcls = self.hir_perl_byte_class(x)?;
      .          .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_bytes();
      .          .          .          .                               cls.union(&xcls);
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       ast::ClassSetItem::Bracketed(ref ast) => {
    142 ( 0.00%) .          .          .                           if self.flags().unicode() {
     71 ( 0.00%) .          .          .                               let mut cls1 = self.pop().unwrap().unwrap_class_unicode();
      .          .          .          .                               self.unicode_fold_and_negate(
     71 ( 0.00%) .          .          .                                   &ast.span,
    142 ( 0.00%) .          .          .                                   ast.negated,
      .          .          .          .                                   &mut cls1,
      .          .          .          .                               )?;
      .          .          .          .           
      .          .          .          .                               let mut cls2 = self.pop().unwrap().unwrap_class_unicode();
      .          .          .          .                               cls2.union(&cls1);
      .          .          .          .                               self.push(HirFrame::ClassUnicode(cls2));
      .          .          .          .                           } else {
      .          .          .          .                               let mut cls1 = self.pop().unwrap().unwrap_class_bytes();
-- line 574 ----------------------------------------
-- line 581 ----------------------------------------
      .          .          .          .                               let mut cls2 = self.pop().unwrap().unwrap_class_bytes();
      .          .          .          .                               cls2.union(&cls1);
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls2));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       // This is handled automatically by the visitor.
      .          .          .          .                       ast::ClassSetItem::Union(_) => {}
      .          .          .          .                   }
  4,916 ( 0.00%) .          .          .                   Ok(())
 44,244 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn visit_class_set_binary_op_pre(
      .          .          .          .                   &mut self,
      .          .          .          .                   _op: &ast::ClassSetBinaryOp,
      .          .          .          .               ) -> Result<()> {
      .          .          .          .                   if self.flags().unicode() {
      .          .          .          .                       let cls = hir::ClassUnicode::empty();
      .          .          .          .                       self.push(HirFrame::ClassUnicode(cls));
-- line 598 ----------------------------------------
-- line 678 ----------------------------------------
      .          .          .          .           struct TranslatorI<'t, 'p> {
      .          .          .          .               trans: &'t Translator,
      .          .          .          .               pattern: &'p str,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'t, 'p> TranslatorI<'t, 'p> {
      .          .          .          .               /// Build a new internal translator.
      .          .          .          .               fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {
    324 ( 0.00%) .          .          .                   TranslatorI { trans, pattern }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return a reference to the underlying translator.
      .          .          .          .               fn trans(&self) -> &Translator {
      .          .          .          .                   &self.trans
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Push the given frame on to the call stack.
  3,360 ( 0.00%) .          .          .               fn push(&self, frame: HirFrame) {
    255 ( 0.00%) .          .          .                   self.trans().stack.borrow_mut().push(frame);
  4,480 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Push the given literal char on to the call stack.
      .          .          .          .               ///
      .          .          .          .               /// If the top-most element of the stack is a literal, then the char
      .          .          .          .               /// is appended to the end of that literal. Otherwise, a new literal
      .          .          .          .               /// containing just the given char is pushed to the top of the stack.
290,160 ( 0.08%) .          .          .               fn push_char(&self, ch: char) {
 48,360 ( 0.01%) .          .          .                   let mut buf = [0; 4];
      .          .          .          .                   let bytes = ch.encode_utf8(&mut buf).as_bytes();
      .          .          .          .                   let mut stack = self.trans().stack.borrow_mut();
 96,720 ( 0.03%) .          .          .                   if let Some(HirFrame::Literal(ref mut literal)) = stack.last_mut() {
      .          .          .          .                       literal.extend_from_slice(bytes);
      .          .          .          .                   } else {
      .          .          .          .                       stack.push(HirFrame::Literal(bytes.to_vec()));
      .          .          .          .                   }
290,160 ( 0.08%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Push the given literal byte on to the call stack.
      .          .          .          .               ///
      .          .          .          .               /// If the top-most element of the stack is a literal, then the byte
      .          .          .          .               /// is appended to the end of that literal. Otherwise, a new literal
      .          .          .          .               /// containing just the given byte is pushed to the top of the stack.
      .          .          .          .               fn push_byte(&self, byte: u8) {
      .          .          .          .                   let mut stack = self.trans().stack.borrow_mut();
-- line 721 ----------------------------------------
-- line 731 ----------------------------------------
      .          .          .          .                   self.trans().stack.borrow_mut().pop()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Pop an HIR expression from the top of the stack for a concatenation.
      .          .          .          .               ///
      .          .          .          .               /// This returns None if the stack is empty or when a concat frame is seen.
      .          .          .          .               /// Otherwise, it panics if it could not find an HIR expression.
      .          .          .          .               fn pop_concat_expr(&self) -> Option<Hir> {
 35,678 ( 0.01%) .          .          .                   let frame = self.pop()?;
321,102 ( 0.09%) .          .          .                   match frame {
      .          .          .          .                       HirFrame::Concat => None,
 31,962 ( 0.01%) .          .          .                       HirFrame::Expr(expr) => Some(expr),
 45,978 ( 0.01%) .          .          .                       HirFrame::Literal(lit) => Some(Hir::literal(lit)),
      .          .          .          .                       HirFrame::ClassUnicode(_) => {
      .          .          .          .                           unreachable!("expected expr or concat, got Unicode class")
      .          .          .          .                       }
      .          .          .          .                       HirFrame::ClassBytes(_) => {
      .          .          .          .                           unreachable!("expected expr or concat, got byte class")
      .          .          .          .                       }
      .          .          .          .                       HirFrame::Repetition => {
      .          .          .          .                           unreachable!("expected expr or concat, got repetition")
-- line 751 ----------------------------------------
-- line 755 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .                       HirFrame::Alternation => {
      .          .          .          .                           unreachable!("expected expr or concat, got alt marker")
      .          .          .          .                       }
      .          .          .          .                       HirFrame::AlternationBranch => {
      .          .          .          .                           unreachable!("expected expr or concat, got alt branch marker")
      .          .          .          .                       }
      .          .          .          .                   }
102,928 ( 0.03%) .          .          .               }
142,074 ( 0.04%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> (15,786x)
      .          .          .          .           
      .          .          .          .               /// Pop an HIR expression from the top of the stack for an alternation.
      .          .          .          .               ///
      .          .          .          .               /// This returns None if the stack is empty or when an alternation frame is
      .          .          .          .               /// seen. Otherwise, it panics if it could not find an HIR expression.
      .          .          .          .               fn pop_alt_expr(&self) -> Option<Hir> {
 16,953 ( 0.00%) .          .          .                   let frame = self.pop()?;
152,577 ( 0.04%) .          .          .                   match frame {
      .          .          .          .                       HirFrame::Alternation => None,
109,697 ( 0.03%) .          .          .                       HirFrame::Expr(expr) => Some(expr),
  2,310 ( 0.00%) .          .          .                       HirFrame::Literal(lit) => Some(Hir::literal(lit)),
      .          .          .          .                       HirFrame::ClassUnicode(_) => {
      .          .          .          .                           unreachable!("expected expr or alt, got Unicode class")
      .          .          .          .                       }
      .          .          .          .                       HirFrame::ClassBytes(_) => {
      .          .          .          .                           unreachable!("expected expr or alt, got byte class")
      .          .          .          .                       }
      .          .          .          .                       HirFrame::Repetition => {
      .          .          .          .                           unreachable!("expected expr or alt, got repetition")
-- line 782 ----------------------------------------
-- line 786 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .                       HirFrame::Concat => {
      .          .          .          .                           unreachable!("expected expr or alt, got concat marker")
      .          .          .          .                       }
      .          .          .          .                       HirFrame::AlternationBranch => {
      .          .          .          .                           unreachable!("expected expr or alt, got alt branch marker")
      .          .          .          .                       }
      .          .          .          .                   }
 34,930 ( 0.01%) .          .          .               }
  4,608 ( 0.00%) .          .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> (512x)
      .          .          .          .           
      .          .          .          .               /// Create a new error with the given span and error type.
      .          .          .          .               fn error(&self, span: Span, kind: ErrorKind) -> Error {
      .          .          .          .                   Error { kind, pattern: self.pattern.to_string(), span }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return a copy of the active flags.
      .          .          .          .               fn flags(&self) -> Flags {
      .          .          .          .                   self.trans().flags.get()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the flags of this translator from the flags set in the given AST.
      .          .          .          .               /// Then, return the old flags.
      .          .          .          .               fn set_flags(&self, ast_flags: &ast::Flags) -> Flags {
    200 ( 0.00%) .          .          .                   let old_flags = self.flags();
      .          .          .          .                   let mut new_flags = Flags::from_ast(ast_flags);
      .          .          .          .                   new_flags.merge(&old_flags);
      .          .          .          .                   self.trans().flags.set(new_flags);
      .          .          .          .                   old_flags
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Convert an Ast literal to its scalar representation.
      .          .          .          .               ///
-- line 817 ----------------------------------------
-- line 821 ----------------------------------------
      .          .          .          .               /// When Unicode mode is disabled, then a `char` will still be returned
      .          .          .          .               /// whenever possible. A byte is returned only when invalid UTF-8 is
      .          .          .          .               /// allowed and when the byte is not ASCII. Otherwise, a non-ASCII byte
      .          .          .          .               /// will result in an error when invalid UTF-8 is not allowed.
      .          .          .          .               fn ast_literal_to_scalar(
      .          .          .          .                   &self,
      .          .          .          .                   lit: &ast::Literal,
      .          .          .          .               ) -> Result<Either<char, u8>> {
148,440 ( 0.04%) .          .          .                   if self.flags().unicode() {
 49,480 ( 0.01%) .          .          .                       return Ok(Either::Left(lit.c));
      .          .          .          .                   }
      .          .          .          .                   let byte = match lit.byte() {
      .          .          .          .                       None => return Ok(Either::Left(lit.c)),
      .          .          .          .                       Some(byte) => byte,
      .          .          .          .                   };
      .          .          .          .                   if byte <= 0x7F {
      .          .          .          .                       return Ok(Either::Left(char::try_from(byte).unwrap()));
      .          .          .          .                   }
      .          .          .          .                   if self.trans().utf8 {
      .          .          .          .                       return Err(self.error(lit.span, ErrorKind::InvalidUtf8));
      .          .          .          .                   }
      .          .          .          .                   Ok(Either::Right(byte))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn case_fold_char(&self, span: Span, c: char) -> Result<Option<Hir>> {
 49,480 ( 0.01%) .          .          .                   if !self.flags().case_insensitive() {
      .          .          .          .                       return Ok(None);
      .          .          .          .                   }
  2,240 ( 0.00%) .          .          .                   if self.flags().unicode() {
      .          .          .          .                       // If case folding won't do anything, then don't bother trying.
      .          .          .          .                       let map = unicode::SimpleCaseFolder::new()
  3,360 ( 0.00%) .          .          .                           .map(|f| f.overlaps(c, c))
183,220 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::SimpleCaseFolder::overlaps (1,120x)
      .          .          .          .                           .map_err(|_| {
      .          .          .          .                               self.error(span, ErrorKind::UnicodeCaseUnavailable)
      .          .          .          .                           })?;
  2,240 ( 0.00%) .          .          .                       if !map {
      .          .          .          .                           return Ok(None);
      .          .          .          .                       }
      .          .          .          .                       let mut cls =
  2,240 ( 0.00%) .          .          .                           hir::ClassUnicode::new(vec![hir::ClassUnicodeRange::new(
      .          .          .          .                               c, c,
      .          .          .          .                           )]);
  2,240 ( 0.00%) .          .          .                       cls.try_case_fold_simple().map_err(|_| {
1,025,515 ( 0.30%) 2,240 ( 0.28%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple (1,120x)
      .          .          .          .                           self.error(span, ErrorKind::UnicodeCaseUnavailable)
      .          .          .          .                       })?;
 10,080 ( 0.00%) .          .          .                       Ok(Some(Hir::class(hir::Class::Unicode(cls))))
431,593 ( 0.12%) 2,140 ( 0.26%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class (1,120x)
      .          .          .          .                   } else {
      .          .          .          .                       if !c.is_ascii() {
      .          .          .          .                           return Ok(None);
      .          .          .          .                       }
      .          .          .          .                       // If case folding won't do anything, then don't bother trying.
      .          .          .          .                       match c {
      .          .          .          .                           'A'..='Z' | 'a'..='z' => {}
      .          .          .          .                           _ => return Ok(None),
-- line 874 ----------------------------------------
-- line 882 ----------------------------------------
      .          .          .          .                           )]);
      .          .          .          .                       cls.case_fold_simple();
      .          .          .          .                       Ok(Some(Hir::class(hir::Class::Bytes(cls))))
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_dot(&self, span: Span) -> Result<Hir> {
      .          .          .          .                   let (utf8, lineterm, flags) =
     15 ( 0.00%) .          .          .                       (self.trans().utf8, self.trans().line_terminator, self.flags());
      5 ( 0.00%) .          .          .                   if utf8 && (!flags.unicode() || !lineterm.is_ascii()) {
      .          .          .          .                       return Err(self.error(span, ErrorKind::InvalidUtf8));
      .          .          .          .                   }
      5 ( 0.00%) .          .          .                   let dot = if flags.dot_matches_new_line() {
      .          .          .          .                       if flags.unicode() {
      .          .          .          .                           hir::Dot::AnyChar
      .          .          .          .                       } else {
      .          .          .          .                           hir::Dot::AnyByte
      .          .          .          .                       }
      .          .          .          .                   } else {
      5 ( 0.00%) .          .          .                       if flags.unicode() {
      5 ( 0.00%) .          .          .                           if flags.crlf() {
      .          .          .          .                               hir::Dot::AnyCharExceptCRLF
      .          .          .          .                           } else {
      5 ( 0.00%) .          .          .                               if !lineterm.is_ascii() {
      .          .          .          .                                   return Err(
      .          .          .          .                                       self.error(span, ErrorKind::InvalidLineTerminator)
      .          .          .          .                                   );
      .          .          .          .                               }
      .          .          .          .                               hir::Dot::AnyCharExcept(char::from(lineterm))
      .          .          .          .                           }
      .          .          .          .                       } else {
      .          .          .          .                           if flags.crlf() {
      .          .          .          .                               hir::Dot::AnyByteExceptCRLF
      .          .          .          .                           } else {
      .          .          .          .                               hir::Dot::AnyByteExcept(lineterm)
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   };
     20 ( 0.00%) .          .          .                   Ok(Hir::dot(dot))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir> {
      .          .          .          .                   let unicode = self.flags().unicode();
      .          .          .          .                   let multi_line = self.flags().multi_line();
      .          .          .          .                   let crlf = self.flags().crlf();
      .          .          .          .                   Ok(match asst.kind {
    132 ( 0.00%) .          .          .                       ast::AssertionKind::StartLine => Hir::look(if multi_line {
      .          .          .          .                           if crlf {
      .          .          .          .                               hir::Look::StartCRLF
      .          .          .          .                           } else {
      .          .          .          .                               hir::Look::StartLF
      .          .          .          .                           }
      .          .          .          .                       } else {
      .          .          .          .                           hir::Look::Start
      .          .          .          .                       }),
    112 ( 0.00%) .          .          .                       ast::AssertionKind::EndLine => Hir::look(if multi_line {
      .          .          .          .                           if crlf {
      .          .          .          .                               hir::Look::EndCRLF
      .          .          .          .                           } else {
      .          .          .          .                               hir::Look::EndLF
      .          .          .          .                           }
      .          .          .          .                       } else {
      .          .          .          .                           hir::Look::End
      .          .          .          .                       }),
-- line 945 ----------------------------------------
-- line 982 ----------------------------------------
      .          .          .          .                           hir::Look::WordEndHalfUnicode
      .          .          .          .                       } else {
      .          .          .          .                           hir::Look::WordEndHalfAscii
      .          .          .          .                       }),
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_capture(&self, group: &ast::Group, expr: Hir) -> Hir {
  3,251 ( 0.00%) .          .          .                   let (index, name) = match group.kind {
    321 ( 0.00%) .          .          .                       ast::GroupKind::CaptureIndex(index) => (index, None),
      .          .          .          .                       ast::GroupKind::CaptureName { ref name, .. } => {
  2,344 ( 0.00%) .          .          .                           (name.index, Some(name.name.clone().into_boxed_str()))
 65,950 ( 0.02%) 52 ( 0.01%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs:<alloc::string::String as core::clone::Clone>::clone (586x)
      .          .          .          .                       }
      .          .          .          .                       // The HIR doesn't need to use non-capturing groups, since the way
      .          .          .          .                       // in which the data type is defined handles this automatically.
      .          .          .          .                       ast::GroupKind::NonCapturing(_) => return expr,
      .          .          .          .                   };
  3,465 ( 0.00%) .          .          .                   Hir::capture(hir::Capture { index, name, sub: Box::new(expr) })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir {
 19,328 ( 0.01%) .          .          .                   let (min, max) = match rep.op.kind {
      .          .          .          .                       ast::RepetitionKind::ZeroOrOne => (0, Some(1)),
      .          .          .          .                       ast::RepetitionKind::ZeroOrMore => (0, None),
      .          .          .          .                       ast::RepetitionKind::OneOrMore => (1, None),
    420 ( 0.00%) .          .          .                       ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(m)) => {
      .          .          .          .                           (m, Some(m))
      .          .          .          .                       }
      .          .          .          .                       ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(m)) => {
      .          .          .          .                           (m, None)
      .          .          .          .                       }
      .          .          .          .                       ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(
     67 ( 0.00%) .          .          .                           m,
    201 ( 0.00%) .          .          .                           n,
      .          .          .          .                       )) => (m, Some(n)),
      .          .          .          .                   };
      .          .          .          .                   let greedy =
 13,195 ( 0.00%) .          .          .                       if self.flags().swap_greed() { !rep.greedy } else { rep.greedy };
 13,195 ( 0.00%) .          .          .                   Hir::repetition(hir::Repetition {
      .          .          .          .                       min,
      .          .          .          .                       max,
      .          .          .          .                       greedy,
      .          .          .          .                       sub: Box::new(expr),
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_unicode_class(
-- line 1028 ----------------------------------------
-- line 1058 ----------------------------------------
      .          .          .          .                   result
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_ascii_unicode_class(
      .          .          .          .                   &self,
      .          .          .          .                   ast: &ast::ClassAscii,
      .          .          .          .               ) -> Result<hir::ClassUnicode> {
      .          .          .          .                   let mut cls = hir::ClassUnicode::new(
    770 ( 0.00%) .          .          .                       ascii_class_as_chars(&ast.kind)
      .          .          .          .                           .map(|(s, e)| hir::ClassUnicodeRange::new(s, e)),
      .          .          .          .                   );
  1,540 ( 0.00%) .          .          .                   self.unicode_fold_and_negate(&ast.span, ast.negated, &mut cls)?;
  2,310 ( 0.00%) .          .          .                   Ok(cls)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_ascii_byte_class(
      .          .          .          .                   &self,
      .          .          .          .                   ast: &ast::ClassAscii,
      .          .          .          .               ) -> Result<hir::ClassBytes> {
      .          .          .          .                   let mut cls = hir::ClassBytes::new(
      .          .          .          .                       ascii_class(&ast.kind)
      .          .          .          .                           .map(|(s, e)| hir::ClassBytesRange::new(s, e)),
      .          .          .          .                   );
      .          .          .          .                   self.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls)?;
      .          .          .          .                   Ok(cls)
      .          .          .          .               }
      .          .          .          .           
     50 ( 0.00%) .          .          .               fn hir_perl_unicode_class(
      .          .          .          .                   &self,
      .          .          .          .                   ast_class: &ast::ClassPerl,
      .          .          .          .               ) -> Result<hir::ClassUnicode> {
      .          .          .          .                   use crate::ast::ClassPerlKind::*;
      .          .          .          .           
     10 ( 0.00%) .          .          .                   assert!(self.flags().unicode());
     20 ( 0.00%) .          .          .                   let result = match ast_class.kind {
      5 ( 0.00%) .          .          .                       Digit => unicode::perl_digit(),
 10,315 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::perl_digit (5x)
      .          .          .          .                       Space => unicode::perl_space(),
      .          .          .          .                       Word => unicode::perl_word(),
      .          .          .          .                   };
      .          .          .          .                   let mut class =
     45 ( 0.00%) .          .          .                       self.convert_unicode_class_error(&ast_class.span, result)?;
      .          .          .          .                   // We needn't apply case folding here because the Perl Unicode classes
      .          .          .          .                   // are already closed under Unicode simple case folding.
     10 ( 0.00%) .          .          .                   if ast_class.negated {
      .          .          .          .                       class.negate();
      .          .          .          .                   }
     80 ( 0.00%) .          .          .                   Ok(class)
     40 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_perl_byte_class(
      .          .          .          .                   &self,
      .          .          .          .                   ast_class: &ast::ClassPerl,
      .          .          .          .               ) -> Result<hir::ClassBytes> {
      .          .          .          .                   use crate::ast::ClassPerlKind::*;
      .          .          .          .           
      .          .          .          .                   assert!(!self.flags().unicode());
-- line 1113 ----------------------------------------
-- line 1160 ----------------------------------------
      .          .          .          .                   span: &Span,
      .          .          .          .                   negated: bool,
      .          .          .          .                   class: &mut hir::ClassUnicode,
      .          .          .          .               ) -> Result<()> {
      .          .          .          .                   // Note that we must apply case folding before negation!
      .          .          .          .                   // Consider `(?i)[^x]`. If we applied negation first, then
      .          .          .          .                   // the result would be the character class that matched any
      .          .          .          .                   // Unicode scalar value.
  7,188 ( 0.00%) .          .          .                   if self.flags().case_insensitive() {
      .          .          .          .                       class.try_case_fold_simple().map_err(|_| {
      .          .          .          .                           self.error(span.clone(), ErrorKind::UnicodeCaseUnavailable)
      .          .          .          .                       })?;
      .          .          .          .                   }
  3,594 ( 0.00%) .          .          .                   if negated {
      .          .          .          .                       class.negate();
      .          .          .          .                   }
      .          .          .          .                   Ok(())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn bytes_fold_and_negate(
      .          .          .          .                   &self,
      .          .          .          .                   span: &Span,
-- line 1181 ----------------------------------------
-- line 1234 ----------------------------------------
      .          .          .          .               // entirely in the parser.
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Flags {
      .          .          .          .               fn from_ast(ast: &ast::Flags) -> Flags {
      .          .          .          .                   let mut flags = Flags::default();
      .          .          .          .                   let mut enable = true;
      .          .          .          .                   for item in &ast.items {
    190 ( 0.00%) .          .          .                       match item.kind {
      .          .          .          .                           ast::FlagsItemKind::Negation => {
      .          .          .          .                               enable = false;
      .          .          .          .                           }
      .          .          .          .                           ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive) => {
     40 ( 0.00%) .          .          .                               flags.case_insensitive = Some(enable);
      .          .          .          .                           }
      .          .          .          .                           ast::FlagsItemKind::Flag(ast::Flag::MultiLine) => {
      .          .          .          .                               flags.multi_line = Some(enable);
      .          .          .          .                           }
      .          .          .          .                           ast::FlagsItemKind::Flag(ast::Flag::DotMatchesNewLine) => {
      .          .          .          .                               flags.dot_matches_new_line = Some(enable);
      .          .          .          .                           }
      .          .          .          .                           ast::FlagsItemKind::Flag(ast::Flag::SwapGreed) => {
-- line 1255 ----------------------------------------
-- line 1263 ----------------------------------------
      .          .          .          .                           }
      .          .          .          .                           ast::FlagsItemKind::Flag(ast::Flag::IgnoreWhitespace) => {}
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   flags
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn merge(&mut self, previous: &Flags) {
     40 ( 0.00%) .          .          .                   if self.case_insensitive.is_none() {
      .          .          .          .                       self.case_insensitive = previous.case_insensitive;
      .          .          .          .                   }
     60 ( 0.00%) .          .          .                   if self.multi_line.is_none() {
      .          .          .          .                       self.multi_line = previous.multi_line;
      .          .          .          .                   }
     60 ( 0.00%) .          .          .                   if self.dot_matches_new_line.is_none() {
      .          .          .          .                       self.dot_matches_new_line = previous.dot_matches_new_line;
      .          .          .          .                   }
     60 ( 0.00%) .          .          .                   if self.swap_greed.is_none() {
      .          .          .          .                       self.swap_greed = previous.swap_greed;
      .          .          .          .                   }
     60 ( 0.00%) .          .          .                   if self.unicode.is_none() {
      .          .          .          .                       self.unicode = previous.unicode;
      .          .          .          .                   }
     60 ( 0.00%) .          .          .                   if self.crlf.is_none() {
      .          .          .          .                       self.crlf = previous.crlf;
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn case_insensitive(&self) -> bool {
      .          .          .          .                   self.case_insensitive.unwrap_or(false)
      .          .          .          .               }
      .          .          .          .           
-- line 1294 ----------------------------------------
-- line 1318 ----------------------------------------
      .          .          .          .                   .map(|(s, e)| hir::ClassBytesRange::new(s, e))
      .          .          .          .                   .collect();
      .          .          .          .               hir::ClassBytes::new(ranges)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           fn ascii_class(kind: &ast::ClassAsciiKind) -> impl Iterator<Item = (u8, u8)> {
      .          .          .          .               use crate::ast::ClassAsciiKind::*;
      .          .          .          .           
  3,080 ( 0.00%) .          .          .               let slice: &'static [(u8, u8)] = match *kind {
      .          .          .          .                   Alnum => &[(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')],
      .          .          .          .                   Alpha => &[(b'A', b'Z'), (b'a', b'z')],
      .          .          .          .                   Ascii => &[(b'\x00', b'\x7F')],
      .          .          .          .                   Blank => &[(b'\t', b'\t'), (b' ', b' ')],
      .          .          .          .                   Cntrl => &[(b'\x00', b'\x1F'), (b'\x7F', b'\x7F')],
      .          .          .          .                   Digit => &[(b'0', b'9')],
      .          .          .          .                   Graph => &[(b'!', b'~')],
      .          .          .          .                   Lower => &[(b'a', b'z')],
-- line 1334 ----------------------------------------

474,259 ( 0.14%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/translate.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 181 ----------------------------------------
      .          .          .          .           ///
      .          .          .          .           /// let haystack = b"quux";
      .          .          .          .           /// re.captures(&mut cache, haystack, &mut caps);
      .          .          .          .           /// assert!(caps.is_match());
      .          .          .          .           /// assert_eq!(Some(Span::from(3..4)), caps.get_group(1));
      .          .          .          .           ///
      .          .          .          .           /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .           /// ```
    162 ( 0.00%) .          .          .           #[derive(Clone)]
      .          .          .          .           pub struct NFA(
      .          .          .          .               // We make NFAs reference counted primarily for two reasons. First is that
      .          .          .          .               // the NFA type itself is quite large (at least 0.5KB), and so it makes
      .          .          .          .               // sense to put it on the heap by default anyway. Second is that, for Arc
      .          .          .          .               // specifically, this enables cheap clones. This tends to be useful because
      .          .          .          .               // several structures (the backtracker, the Pike VM, the hybrid NFA/DFA)
      .          .          .          .               // all want to hang on to an NFA for use during search time. We could
      .          .          .          .               // provide the NFA at search time via a function argument, but this makes
-- line 197 ----------------------------------------
-- line 403 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn patterns(&self) -> PatternIter<'_> {
      .          .          .          .                   PatternIter {
      .          .          .          .                       it: PatternID::iter(self.pattern_len()),
      .          .          .          .                       _marker: core::marker::PhantomData,
      .          .          .          .                   }
    162 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the total number of regex patterns in this NFA.
      .          .          .          .               ///
      .          .          .          .               /// This may return zero if the NFA was constructed with no patterns. In
      .          .          .          .               /// this case, the NFA can never produce a match for any input.
      .          .          .          .               ///
      .          .          .          .               /// This is guaranteed to be no bigger than [`PatternID::LIMIT`] because
      .          .          .          .               /// NFA construction will fail if too many patterns are added.
-- line 419 ----------------------------------------
-- line 466 ----------------------------------------
      .          .          .          .               ///     }
      .          .          .          .               ///     _ => unreachable!("unexpected state"),
      .          .          .          .               /// }
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn start_anchored(&self) -> StateID {
      8 ( 0.00%) .          .          .                   self.0.start_anchored
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the state identifier of the initial unanchored state of this
      .          .          .          .               /// NFA.
      .          .          .          .               ///
      .          .          .          .               /// This is equivalent to the identifier returned by
      .          .          .          .               /// [`NFA::start_anchored`] when the NFA has no unanchored starting state.
      .          .          .          .               ///
-- line 482 ----------------------------------------
-- line 811 ----------------------------------------
      .          .          .          .               /// // and thus does not match the empty string.
      .          .          .          .               /// let nfa = NFA::new("[a&&b]+")?;
      .          .          .          .               /// assert!(!nfa.has_empty(), "+ on never-match still matches nothing");
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn has_empty(&self) -> bool {
     57 ( 0.00%) .          .          .                   self.0.has_empty
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Whether UTF-8 mode is enabled for this NFA or not.
      .          .          .          .               ///
      .          .          .          .               /// When UTF-8 mode is enabled, all matches reported by a regex engine
      .          .          .          .               /// derived from this NFA are guaranteed to correspond to spans of valid
      .          .          .          .               /// UTF-8. This includes zero-width matches. For example, the regex engine
      .          .          .          .               /// must guarantee that the empty regex will not match at the positions
-- line 827 ----------------------------------------
-- line 901 ----------------------------------------
      .          .          .          .               /// how the state machine is constructed, and thus needs to be altered
      .          .          .          .               /// based on the direction of the search.
      .          .          .          .               ///
      .          .          .          .               /// This is automatically set when using a [`Compiler`] with a configuration
      .          .          .          .               /// where [`Config::reverse`] is enabled. If you're building your own NFA
      .          .          .          .               /// by hand via a [`Builder`]
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_reverse(&self) -> bool {
    259 ( 0.00%) .          .          .                   self.0.reverse
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if all starting states for this NFA correspond
      .          .          .          .               /// to the beginning of an anchored search.
      .          .          .          .               ///
      .          .          .          .               /// Typically, an NFA will have both an anchored and an unanchored starting
      .          .          .          .               /// state. Namely, because it tends to be useful to have both and the cost
      .          .          .          .               /// of having an unanchored starting state is almost zero (for an NFA).
-- line 917 ----------------------------------------
-- line 1052 ----------------------------------------
      .          .          .          .               /// assert!(nfa.look_set_any().contains_word());
      .          .          .          .               /// assert!(!nfa.look_set_any().contains_word_unicode());
      .          .          .          .               /// assert!(nfa.look_set_any().contains_word_ascii());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn look_set_any(&self) -> LookSet {
    677 ( 0.00%) .          .          .                   self.0.look_set_any
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the union of all prefix look-around assertions for every
      .          .          .          .               /// pattern in this NFA. When the returned set is empty, it implies none of
      .          .          .          .               /// the patterns require moving through a conditional epsilon transition
      .          .          .          .               /// before inspecting the first byte in the haystack.
      .          .          .          .               ///
      .          .          .          .               /// This can be useful for determining what kinds of assertions need to be
-- line 1068 ----------------------------------------
-- line 1092 ----------------------------------------
      .          .          .          .               /// let nfa = NFA::new_many(&["a", "b", "^ab$", "c"])?;
      .          .          .          .               /// assert!(nfa.look_set_prefix_any().contains(Look::Start));
      .          .          .          .               /// assert!(!nfa.look_set_prefix_any().contains(Look::End));
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn look_set_prefix_any(&self) -> LookSet {
      2 ( 0.00%) .          .          .                   self.0.look_set_prefix_any
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               // FIXME: The `look_set_prefix_all` computation was not correct, and it
      .          .          .          .               // seemed a little tricky to fix it. Since I wasn't actually using it for
      .          .          .          .               // anything, I just decided to remove it in the run up to the regex 1.9
      .          .          .          .               // release. If you need this, please file an issue.
      .          .          .          .               /*
      .          .          .          .               /// Returns the intersection of all prefix look-around assertions for every
-- line 1108 ----------------------------------------
-- line 1186 ----------------------------------------
      .          .          .          .           /// The "inner" part of the NFA. We split this part out so that we can easily
      .          .          .          .           /// wrap it in an `Arc` above in the definition of `NFA`.
      .          .          .          .           ///
      .          .          .          .           /// See builder.rs for the code that actually builds this type. This module
      .          .          .          .           /// does provide (internal) mutable methods for adding things to this
      .          .          .          .           /// NFA before finalizing it, but the high level construction process is
      .          .          .          .           /// controlled by the builder abstraction. (Which is complicated enough to
      .          .          .          .           /// get its own module.)
  1,400 ( 0.00%) .          .          .           #[derive(Default)]
      .          .          .          .           pub(super) struct Inner {
      .          .          .          .               /// The state sequence. This sequence is guaranteed to be indexable by all
      .          .          .          .               /// starting state IDs, and it is also guaranteed to contain at most one
      .          .          .          .               /// `Match` state for each pattern compiled into this NFA. (A pattern may
      .          .          .          .               /// not have a corresponding `Match` state if a `Match` state is impossible
      .          .          .          .               /// to reach.)
      .          .          .          .               states: Vec<State>,
      .          .          .          .               /// The anchored starting state of this NFA.
-- line 1202 ----------------------------------------
-- line 1264 ----------------------------------------
      .          .          .          .               /// various capturing group representations above). Since each state
      .          .          .          .               /// might use a different amount of heap, we need to keep track of this
      .          .          .          .               /// incrementally.
      .          .          .          .               memory_extra: usize,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Inner {
      .          .          .          .               /// Runs any last finalization bits and turns this into a full NFA.
  1,400 ( 0.00%) .          .          .               pub(super) fn into_nfa(mut self) -> NFA {
    175 ( 0.00%) .          .          .                   self.byte_classes = self.byte_class_set.byte_classes();
      .          .          .          .                   // Do epsilon closure from the start state of every pattern in order
      .          .          .          .                   // to compute various properties such as look-around assertions and
      .          .          .          .                   // whether the empty string can be matched.
      .          .          .          .                   let mut stack = vec![];
      .          .          .          .                   let mut seen = SparseSet::new(self.states.len());
    175 ( 0.00%) .          .          .                   for &start_id in self.start_pattern.iter() {
      .          .          .          .                       stack.push(start_id);
      .          .          .          .                       seen.clear();
      .          .          .          .                       // let mut prefix_all = LookSet::full();
      .          .          .          .                       let mut prefix_any = LookSet::empty();
      .          .          .          .                       while let Some(sid) = stack.pop() {
      .          .          .          .                           if !seen.insert(sid) {
      .          .          .          .                               continue;
      .          .          .          .                           }
  8,452 ( 0.00%) .          .          .                           match self.states[sid] {
      .          .          .          .                               State::ByteRange { .. }
      .          .          .          .                               | State::Dense { .. }
      .          .          .          .                               | State::Fail => continue,
      .          .          .          .                               State::Sparse(_) => {
      .          .          .          .                                   // This snippet below will rewrite this sparse state
      .          .          .          .                                   // as a dense state. By doing it here, we apply this
      .          .          .          .                                   // optimization to all hot "sparse" states since these
      .          .          .          .                                   // are the states that are reachable from the start
-- line 1296 ----------------------------------------
-- line 1309 ----------------------------------------
      .          .          .          .                                   // is a large re-design and will require API breaking
      .          .          .          .                                   // changes.
      .          .          .          .                                   // self.memory_extra -= self.states[sid].memory_usage();
      .          .          .          .                                   // let trans = DenseTransitions::from_sparse(sparse);
      .          .          .          .                                   // self.states[sid] = State::Dense(trans);
      .          .          .          .                                   // self.memory_extra += self.states[sid].memory_usage();
      .          .          .          .                                   continue;
      .          .          .          .                               }
      4 ( 0.00%) .          .          .                               State::Match { .. } => self.has_empty = true,
      .          .          .          .                               State::Look { look, next } => {
      .          .          .          .                                   prefix_any = prefix_any.insert(look);
      .          .          .          .                                   stack.push(next);
      .          .          .          .                               }
      .          .          .          .                               State::Union { ref alternates } => {
      .          .          .          .                                   // Order doesn't matter here, since we're just dealing
      .          .          .          .                                   // with look-around sets. But if we do richer analysis
      .          .          .          .                                   // here that needs to care about preference order, then
      .          .          .          .                                   // this should be done in reverse.
    192 ( 0.00%) .          .          .                                   stack.extend(alternates.iter());
      .          .          .          .                               }
    158 ( 0.00%) .          .          .                               State::BinaryUnion { alt1, alt2 } => {
      .          .          .          .                                   stack.push(alt2);
      .          .          .          .                                   stack.push(alt1);
      .          .          .          .                               }
      .          .          .          .                               State::Capture { next, .. } => {
      .          .          .          .                                   stack.push(next);
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                       }
    175 ( 0.00%) .          .          .                       self.look_set_prefix_any =
      .          .          .          .                           self.look_set_prefix_any.union(prefix_any);
      .          .          .          .                   }
      .          .          .          .                   NFA(Arc::new(self))
  1,575 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the capturing group info for this NFA.
      .          .          .          .               pub(super) fn group_info(&self) -> &GroupInfo {
     86 ( 0.00%) .          .          .                   &self.group_info
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add the given state to this NFA after allocating a fresh identifier for
      .          .          .          .               /// it.
      .          .          .          .               ///
      .          .          .          .               /// This panics if too many states are added such that a fresh identifier
      .          .          .          .               /// could not be created. (Currently, the only caller of this routine is
      .          .          .          .               /// a `Builder`, and it upholds this invariant.)
579,726 ( 0.17%) .          .          .               pub(super) fn add(&mut self, state: State) -> StateID {
322,070 ( 0.09%) .          .          .                   match state {
      .          .          .          .                       State::ByteRange { ref trans } => {
136,332 ( 0.04%) .          .          .                           self.byte_class_set.set_range(trans.start, trans.end);
      .          .          .          .                       }
      .          .          .          .                       State::Sparse(ref sparse) => {
 10,394 ( 0.00%) .          .          .                           for trans in sparse.transitions.iter() {
 77,028 ( 0.02%) .          .          .                               self.byte_class_set.set_range(trans.start, trans.end);
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       State::Dense { .. } => unreachable!(),
    245 ( 0.00%) .          .          .                       State::Look { look, .. } => {
      .          .          .          .                           self.look_matcher
    245 ( 0.00%) .          .          .                               .add_to_byteset(look, &mut self.byte_class_set);
    245 ( 0.00%) .          .          .                           self.look_set_any = self.look_set_any.insert(look);
      .          .          .          .                       }
      .          .          .          .                       State::Capture { .. } => {
  3,096 ( 0.00%) .          .          .                           self.has_capture = true;
      .          .          .          .                       }
      .          .          .          .                       State::Union { .. }
      .          .          .          .                       | State::BinaryUnion { .. }
      .          .          .          .                       | State::Fail
      .          .          .          .                       | State::Match { .. } => {}
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   let id = StateID::new(self.states.len()).unwrap();
128,828 ( 0.04%) .          .          .                   self.memory_extra += state.memory_usage();
      .          .          .          .                   self.states.push(state);
      .          .          .          .                   id
579,726 ( 0.17%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the starting state identifiers for this NFA.
      .          .          .          .               ///
      .          .          .          .               /// `start_anchored` and `start_unanchored` may be equivalent. When they
      .          .          .          .               /// are, then the NFA can only execute anchored searches. This might
      .          .          .          .               /// occur, for example, for patterns that are unconditionally anchored.
      .          .          .          .               /// e.g., `^foo`.
      .          .          .          .               pub(super) fn set_starts(
      .          .          .          .                   &mut self,
      .          .          .          .                   start_anchored: StateID,
      .          .          .          .                   start_unanchored: StateID,
      .          .          .          .                   start_pattern: &[StateID],
      .          .          .          .               ) {
    350 ( 0.00%) .          .          .                   self.start_anchored = start_anchored;
    175 ( 0.00%) .          .          .                   self.start_unanchored = start_unanchored;
    525 ( 0.00%) .          .          .                   self.start_pattern = start_pattern.to_vec();
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets the UTF-8 mode of this NFA.
      .          .          .          .               pub(super) fn set_utf8(&mut self, yes: bool) {
    175 ( 0.00%) .          .          .                   self.utf8 = yes;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets the reverse mode of this NFA.
      .          .          .          .               pub(super) fn set_reverse(&mut self, yes: bool) {
    175 ( 0.00%) .          .          .                   self.reverse = yes;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets the look-around assertion matcher for this NFA.
      .          .          .          .               pub(super) fn set_look_matcher(&mut self, m: LookMatcher) {
    175 ( 0.00%) .          .          .                   self.look_matcher = m;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the capturing groups for this NFA.
      .          .          .          .               ///
      .          .          .          .               /// The given slice should contain the capturing groups for each pattern,
      .          .          .          .               /// The capturing groups in turn should correspond to the total number of
      .          .          .          .               /// capturing groups in the pattern, including the anonymous first capture
      .          .          .          .               /// group for each pattern. If a capturing group does have a name, then it
-- line 1423 ----------------------------------------
-- line 1424 ----------------------------------------
      .          .          .          .               /// should be provided as a Arc<str>.
      .          .          .          .               ///
      .          .          .          .               /// This returns an error if a corresponding `GroupInfo` could not be
      .          .          .          .               /// built.
      .          .          .          .               pub(super) fn set_captures(
      .          .          .          .                   &mut self,
      .          .          .          .                   captures: &[Vec<Option<Arc<str>>>],
      .          .          .          .               ) -> Result<(), GroupInfoError> {
    350 ( 0.00%) .          .          .                   self.group_info = GroupInfo::new(
858,248 ( 0.25%) 2,525 ( 0.31%) 2 ( 0.62%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/captures.rs:regex_automata::util::captures::GroupInfo::new (175x)
      .          .          .          .                       captures.iter().map(|x| x.iter().map(|y| y.as_ref())),
      .          .          .          .                   )?;
      .          .          .          .                   Ok(())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Remap the transitions in every state of this NFA using the given map.
      .          .          .          .               /// The given map should be indexed according to state ID namespace used by
      .          .          .          .               /// the transitions of the states currently in this NFA.
      .          .          .          .               ///
      .          .          .          .               /// This is particularly useful to the NFA builder, since it is convenient
      .          .          .          .               /// to add NFA states in order to produce their final IDs. Then, after all
      .          .          .          .               /// of the intermediate "empty" states (unconditional epsilon transitions)
      .          .          .          .               /// have been removed from the builder's representation, we can re-map all
      .          .          .          .               /// of the transitions in the states already added to their final IDs.
    175 ( 0.00%) .          .          .               pub(super) fn remap(&mut self, old_to_new: &[StateID]) {
      .          .          .          .                   for state in &mut self.states {
      .          .          .          .                       state.remap(old_to_new);
      .          .          .          .                   }
    525 ( 0.00%) .          .          .                   self.start_anchored = old_to_new[self.start_anchored];
    525 ( 0.00%) .          .          .                   self.start_unanchored = old_to_new[self.start_unanchored];
      .          .          .          .                   for id in self.start_pattern.iter_mut() {
    525 ( 0.00%) .          .          .                       *id = old_to_new[*id];
      .          .          .          .                   }
    350 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl fmt::Debug for Inner {
      .          .          .          .               fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      .          .          .          .                   writeln!(f, "thompson::NFA(")?;
      .          .          .          .                   for (sid, state) in self.states.iter().with_state_ids() {
      .          .          .          .                       let status = if sid == self.start_anchored {
      .          .          .          .                           '^'
-- line 1464 ----------------------------------------
-- line 1648 ----------------------------------------
      .          .          .          .               ///     trans: Transition { start: b'a', end: b'z', next: StateID::ZERO },
      .          .          .          .               /// };
      .          .          .          .               /// assert!(!state.is_epsilon());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_epsilon(&self) -> bool {
    705 ( 0.00%) .          .          .                   match *self {
      .          .          .          .                       State::ByteRange { .. }
      .          .          .          .                       | State::Sparse { .. }
      .          .          .          .                       | State::Dense { .. }
      .          .          .          .                       | State::Fail
      .          .          .          .                       | State::Match { .. } => false,
      .          .          .          .                       State::Look { .. }
      .          .          .          .                       | State::Union { .. }
      .          .          .          .                       | State::BinaryUnion { .. }
      .          .          .          .                       | State::Capture { .. } => true,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the heap memory usage of this NFA state in bytes.
      .          .          .          .               fn memory_usage(&self) -> usize {
322,070 ( 0.09%) .          .          .                   match *self {
      .          .          .          .                       State::ByteRange { .. }
      .          .          .          .                       | State::Look { .. }
      .          .          .          .                       | State::BinaryUnion { .. }
      .          .          .          .                       | State::Capture { .. }
      .          .          .          .                       | State::Match { .. }
      .          .          .          .                       | State::Fail => 0,
      .          .          .          .                       State::Sparse(SparseTransitions { ref transitions }) => {
 20,788 ( 0.01%) .          .          .                           transitions.len() * mem::size_of::<Transition>()
      .          .          .          .                       }
      .          .          .          .                       State::Dense { .. } => 256 * mem::size_of::<StateID>(),
      .          .          .          .                       State::Union { ref alternates } => {
  2,920 ( 0.00%) .          .          .                           alternates.len() * mem::size_of::<StateID>()
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Remap the transitions in this state using the given map. Namely, the
      .          .          .          .               /// given map should be indexed according to the transitions currently
      .          .          .          .               /// in this state.
      .          .          .          .               ///
      .          .          .          .               /// This is used during the final phase of the NFA compiler, which turns
      .          .          .          .               /// its intermediate NFA into the final NFA.
      .          .          .          .               fn remap(&mut self, remap: &[StateID]) {
257,656 ( 0.07%) .          .          .                   match *self {
      .          .          .          .                       State::ByteRange { ref mut trans } => {
 45,444 ( 0.01%) .          .          .                           trans.next = remap[trans.next]
      .          .          .          .                       }
      .          .          .          .                       State::Sparse(SparseTransitions { ref mut transitions }) => {
 10,394 ( 0.00%) .          .          .                           for t in transitions.iter_mut() {
115,542 ( 0.03%) .          .          .                               t.next = remap[t.next];
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       State::Dense(DenseTransitions { ref mut transitions }) => {
      .          .          .          .                           for sid in transitions.iter_mut() {
      .          .          .          .                               *sid = remap[*sid];
      .          .          .          .                           }
      .          .          .          .                       }
    245 ( 0.00%) .          .          .                       State::Look { ref mut next, .. } => *next = remap[*next],
      .          .          .          .                       State::Union { ref mut alternates } => {
  1,460 ( 0.00%) .          .          .                           for alt in alternates.iter_mut() {
 31,392 ( 0.01%) .          .          .                               *alt = remap[*alt];
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       State::BinaryUnion { ref mut alt1, ref mut alt2 } => {
 15,444 ( 0.00%) .          .          .                           *alt1 = remap[*alt1];
 20,592 ( 0.01%) .          .          .                           *alt2 = remap[*alt2];
      .          .          .          .                       }
  1,548 ( 0.00%) .          .          .                       State::Capture { ref mut next, .. } => *next = remap[*next],
      .          .          .          .                       State::Fail => {}
      .          .          .          .                       State::Match { .. } => {}
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl fmt::Debug for State {
      .          .          .          .               fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-- line 1727 ----------------------------------------
-- line 1800 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// The matching transition is found by looking for a matching byte
      .          .          .          .               /// range (there is at most one) corresponding to the position `at` in
      .          .          .          .               /// `haystack`.
      .          .          .          .               ///
      .          .          .          .               /// If `at >= haystack.len()`, then this returns `None`.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn matches(&self, haystack: &[u8], at: usize) -> Option<StateID> {
     50 ( 0.00%) .          .          .                   haystack.get(at).and_then(|&b| self.matches_byte(b))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// This follows the matching transition for any member of the alphabet.
      .          .          .          .               ///
      .          .          .          .               /// The matching transition is found by looking for a matching byte
      .          .          .          .               /// range (there is at most one) corresponding to the position `at` in
      .          .          .          .               /// `haystack`. If the given alphabet unit is [`EOI`](alphabet::Unit::eoi),
      .          .          .          .               /// then this always returns `None`.
      .          .          .          .               #[inline]
      .          .          .          .               pub(crate) fn matches_unit(
      .          .          .          .                   &self,
      .          .          .          .                   unit: alphabet::Unit,
      .          .          .          .               ) -> Option<StateID> {
    292 ( 0.00%) .          .          .                   unit.as_u8().map_or(None, |byte| self.matches_byte(byte))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// This follows the matching transition for a particular byte.
      .          .          .          .               ///
      .          .          .          .               /// The matching transition is found by looking for a matching byte range
      .          .          .          .               /// (there is at most one) corresponding to the byte given.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn matches_byte(&self, byte: u8) -> Option<StateID> {
    488 ( 0.00%) .          .          .                   for t in self.transitions.iter() {
  1,064 ( 0.00%) .          .          .                       if t.start > byte {
      .          .          .          .                           break;
  1,391 ( 0.00%) .          .          .                       } else if t.matches_byte(byte) {
     40 ( 0.00%) .          .          .                           return Some(t.next);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   None
      .          .          .          .           
      .          .          .          .                   /*
      .          .          .          .                   // This is an alternative implementation that uses binary search. In
      .          .          .          .                   // some ad hoc experiments, like
      .          .          .          .                   //
-- line 1843 ----------------------------------------
-- line 1960 ----------------------------------------
      .          .          .          .           
      .          .          .          .           /// A single transition to another state.
      .          .          .          .           ///
      .          .          .          .           /// This transition may only be followed if the current byte in the haystack
      .          .          .          .           /// falls in the inclusive range of bytes specified.
      .          .          .          .           #[derive(Clone, Copy, Eq, Hash, PartialEq)]
      .          .          .          .           pub struct Transition {
      .          .          .          .               /// The inclusive start of the byte range.
  1,894 ( 0.00%) .          .          .               pub start: u8,
      .          .          .          .               /// The inclusive end of the byte range.
  4,735 ( 0.00%) .          .          .               pub end: u8,
      .          .          .          .               /// The identifier of the state to transition to.
  1,894 ( 0.00%) .          .          .               pub next: StateID,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Transition {
      .          .          .          .               /// Returns true if the position `at` in `haystack` falls in this
      .          .          .          .               /// transition's range of bytes.
      .          .          .          .               ///
      .          .          .          .               /// If `at >= haystack.len()`, then this returns `false`.
      .          .          .          .               pub fn matches(&self, haystack: &[u8], at: usize) -> bool {
-- line 1980 ----------------------------------------
-- line 1986 ----------------------------------------
      .          .          .          .               /// this returns `false`.
      .          .          .          .               pub fn matches_unit(&self, unit: alphabet::Unit) -> bool {
      .          .          .          .                   unit.as_u8().map_or(false, |byte| self.matches_byte(byte))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if the given byte falls in this transition's range of
      .          .          .          .               /// bytes.
      .          .          .          .               pub fn matches_byte(&self, byte: u8) -> bool {
  1,750 ( 0.00%) .          .          .                   self.start <= byte && byte <= self.end
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl fmt::Debug for Transition {
      .          .          .          .               fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      .          .          .          .                   use crate::util::escape::DebugByte;
      .          .          .          .           
      .          .          .          .                   let Transition { start, end, next } = *self;
-- line 2002 ----------------------------------------

293,067 ( 0.08%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/nfa.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 152 ----------------------------------------
      .          .          .          .               limit_total: usize,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Extractor {
      .          .          .          .               /// Create a new extractor with a default configuration.
      .          .          .          .               ///
      .          .          .          .               /// The extractor can be optionally configured before calling
      .          .          .          .               /// [`Extractor::extract`] to get a literal sequence.
     73 ( 0.00%) .          .          .               pub fn new() -> Extractor {
    365 ( 0.00%) .          .          .                   Extractor {
      .          .          .          .                       kind: ExtractKind::Prefix,
      .          .          .          .                       limit_class: 10,
      .          .          .          .                       limit_repeat: 10,
      .          .          .          .                       limit_literal_len: 100,
      .          .          .          .                       limit_total: 250,
      .          .          .          .                   }
     73 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Execute the extractor and return a sequence of literals.
 35,904 ( 0.01%) .          .          .               pub fn extract(&self, hir: &Hir) -> Seq {
      .          .          .          .                   use crate::hir::HirKind::*;
      .          .          .          .           
 18,382 ( 0.01%) .          .          .                   match *hir.kind() {
      .          .          .          .                       Empty | Look(_) => Seq::singleton(self::Literal::exact(vec![])),
      .          .          .          .                       Literal(hir::Literal(ref bytes)) => {
      .          .          .          .                           let mut seq =
  7,233 ( 0.00%) .          .          .                               Seq::singleton(self::Literal::exact(bytes.to_vec()));
  2,411 ( 0.00%) .          .          .                           self.enforce_literal_len(&mut seq);
  2,411 ( 0.00%) .          .          .                           seq
      .          .          .          .                       }
      .          .          .          .                       Class(hir::Class::Unicode(ref cls)) => {
      .          .          .          .                           self.extract_class_unicode(cls)
      .          .          .          .                       }
      .          .          .          .                       Class(hir::Class::Bytes(ref cls)) => self.extract_class_bytes(cls),
      .          .          .          .                       Repetition(ref rep) => self.extract_repetition(rep),
     39 ( 0.00%) .          .          .                       Capture(hir::Capture { ref sub, .. }) => self.extract(sub),
    422 ( 0.00%) .          .          .                       Concat(ref hirs) => match self.kind {
      .          .          .          .                           ExtractKind::Prefix => self.extract_concat(hirs.iter()),
      .          .          .          .                           ExtractKind::Suffix => self.extract_concat(hirs.iter().rev()),
      .          .          .          .                       },
      .          .          .          .                       Alternation(ref hirs) => {
      .          .          .          .                           // Unlike concat, we always union starting from the beginning,
      .          .          .          .                           // since the beginning corresponds to the highest preference,
      .          .          .          .                           // which doesn't change based on forwards vs reverse.
      .          .          .          .                           self.extract_alternation(hirs.iter())
      .          .          .          .                       }
      .          .          .          .                   }
 26,928 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the kind of literal sequence to extract from an [`Hir`] expression.
      .          .          .          .               ///
      .          .          .          .               /// The default is to extract prefixes, but suffixes can be selected
      .          .          .          .               /// instead. The contract for prefixes is that every match of the
      .          .          .          .               /// corresponding `Hir` must start with one of the literals in the sequence
      .          .          .          .               /// returned. Moreover, the _order_ of the sequence returned corresponds to
      .          .          .          .               /// the preference order.
-- line 207 ----------------------------------------
-- line 212 ----------------------------------------
      .          .          .          .               /// preference order.
      .          .          .          .               ///
      .          .          .          .               /// Remember that a sequence can be infinite. For example, unless the
      .          .          .          .               /// limits are configured to be impractically large, attempting to extract
      .          .          .          .               /// prefixes (or suffixes) for the pattern `[A-Z]` will return an infinite
      .          .          .          .               /// sequence. Generally speaking, if the sequence returned is infinite,
      .          .          .          .               /// then it is presumed to be unwise to do prefix (or suffix) optimizations
      .          .          .          .               /// for the pattern.
     73 ( 0.00%) .          .          .               pub fn kind(&mut self, kind: ExtractKind) -> &mut Extractor {
     73 ( 0.00%) .          .          .                   self.kind = kind;
      .          .          .          .                   self
     73 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Configure a limit on the length of the sequence that is permitted for
      .          .          .          .               /// a character class. If a character class exceeds this limit, then the
      .          .          .          .               /// sequence returned for it is infinite.
      .          .          .          .               ///
      .          .          .          .               /// This prevents classes like `[A-Z]` or `\pL` from getting turned into
      .          .          .          .               /// huge and likely unproductive sequences of literals.
      .          .          .          .               ///
-- line 231 ----------------------------------------
-- line 399 ----------------------------------------
      .          .          .          .                       // product will always be a no-op. Thus, there is nothing else we
      .          .          .          .                       // can add to it and can quit early. Note that this also includes
      .          .          .          .                       // infinite sequences.
      .          .          .          .                       if seq.is_inexact() {
      .          .          .          .                           break;
      .          .          .          .                       }
      .          .          .          .                       // Note that 'cross' also dispatches based on whether we're
      .          .          .          .                       // extracting prefixes or suffixes.
  7,639 ( 0.00%) .          .          .                       seq = self.cross(seq, &mut self.extract(hir));
4,738,503 ( 1.36%) 7,828 ( 0.97%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (111x)
1,895,581 ( 0.55%) 8,643 ( 1.07%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (111x)
      .          .          .          .                   }
  1,055 ( 0.00%) .          .          .                   seq
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Extract a sequence from the given alternation.
      .          .          .          .               ///
      .          .          .          .               /// This short circuits once the union turns into an infinite sequence.
      .          .          .          .               fn extract_alternation<'a, I: Iterator<Item = &'a Hir>>(
      .          .          .          .                   &self,
      .          .          .          .                   it: I,
      .          .          .          .               ) -> Seq {
      .          .          .          .                   let mut seq = Seq::empty();
  2,258 ( 0.00%) .          .          .                   for hir in it {
      .          .          .          .                       // Once our 'seq' is infinite, every subsequent union
      .          .          .          .                       // operation on it will itself always result in an
      .          .          .          .                       // infinite sequence. Thus, it can never change and we can
      .          .          .          .                       // short-circuit.
      .          .          .          .                       if !seq.is_finite() {
      .          .          .          .                           break;
      .          .          .          .                       }
 38,335 ( 0.01%) .          .          .                       seq = self.union(seq, &mut self.extract(hir));
434,725 ( 0.13%) 1,763 ( 0.22%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (855x)
1,049,795 ( 0.30%) 257 ( 0.03%) 1 ( 0.31%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::union (855x)
      .          .          .          .                   }
    240 ( 0.00%) .          .          .                   seq
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Extract a sequence of literals from the given repetition. We do our
      .          .          .          .               /// best, Some examples:
      .          .          .          .               ///
      .          .          .          .               ///   'a*'    => [inexact(a), exact("")]
      .          .          .          .               ///   'a*?'   => [exact(""), inexact(a)]
      .          .          .          .               ///   'a+'    => [inexact(a)]
-- line 438 ----------------------------------------
-- line 441 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// The key here really is making sure we get the 'inexact' vs 'exact'
      .          .          .          .               /// attributes correct on each of the literals we add. For example, the
      .          .          .          .               /// fact that 'a*' gives us an inexact 'a' and an exact empty string means
      .          .          .          .               /// that a regex like 'ab*c' will result in [inexact(ab), exact(ac)]
      .          .          .          .               /// literals being extracted, which might actually be a better prefilter
      .          .          .          .               /// than just 'a'.
      .          .          .          .               fn extract_repetition(&self, rep: &hir::Repetition) -> Seq {
    844 ( 0.00%) .          .          .                   let mut subseq = self.extract(&rep.sub);
  9,819 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (9x)
    900 ( 0.00%) .          .          .                   match *rep {
    384 ( 0.00%) .          .          .                       hir::Repetition { min: 0, max, greedy, .. } => {
      .          .          .          .                           // When 'max=1', we can retain exactness, since 'a?' is
      .          .          .          .                           // equivalent to 'a|'. Similarly below, 'a??' is equivalent to
      .          .          .          .                           // '|a'.
    570 ( 0.00%) .          .          .                           if max != Some(1) {
      6 ( 0.00%) .          .          .                               subseq.make_inexact();
      .          .          .          .                           }
      .          .          .          .                           let mut empty = Seq::singleton(Literal::exact(vec![]));
    192 ( 0.00%) .          .          .                           if !greedy {
      .          .          .          .                               mem::swap(&mut subseq, &mut empty);
      .          .          .          .                           }
  1,920 ( 0.00%) .          .          .                           self.union(subseq, &mut empty)
  1,980 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::union (9x)
      .          .          .          .                       }
      .          .          .          .                       hir::Repetition { min, max: Some(max), .. } if min == max => {
      .          .          .          .                           assert!(min > 0); // handled above
      .          .          .          .                           let limit =
      .          .          .          .                               u32::try_from(self.limit_repeat).unwrap_or(u32::MAX);
      .          .          .          .                           let mut seq = Seq::singleton(Literal::exact(vec![]));
      .          .          .          .                           for _ in 0..cmp::min(min, limit) {
      .          .          .          .                               if seq.is_inexact() {
      .          .          .          .                                   break;
      .          .          .          .                               }
    216 ( 0.00%) .          .          .                               seq = self.cross(seq, &mut subseq.clone());
369,557 ( 0.11%) 1,203 ( 0.15%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (18x)
      .          .          .          .                           }
     16 ( 0.00%) .          .          .                           if usize::try_from(min).is_err() || min > limit {
      .          .          .          .                               seq.make_inexact();
      .          .          .          .                           }
     16 ( 0.00%) .          .          .                           seq
      .          .          .          .                       }
      .          .          .          .                       hir::Repetition { min, .. } => {
      .          .          .          .                           assert!(min > 0); // handled above
      .          .          .          .                           let limit =
      .          .          .          .                               u32::try_from(self.limit_repeat).unwrap_or(u32::MAX);
      .          .          .          .                           let mut seq = Seq::singleton(Literal::exact(vec![]));
      .          .          .          .                           for _ in 0..cmp::min(min, limit) {
      .          .          .          .                               if seq.is_inexact() {
      .          .          .          .                                   break;
      .          .          .          .                               }
    132 ( 0.00%) .          .          .                               seq = self.cross(seq, &mut subseq.clone());
  6,887 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (11x)
      .          .          .          .                           }
      .          .          .          .                           seq.make_inexact();
     33 ( 0.00%) .          .          .                           seq
      .          .          .          .                       }
      .          .          .          .                   }
    249 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Convert the given Unicode class into a sequence of literals if the
      .          .          .          .               /// class is small enough. If the class is too big, return an infinite
      .          .          .          .               /// sequence.
      .          .          .          .               fn extract_class_unicode(&self, cls: &hir::ClassUnicode) -> Seq {
    187 ( 0.00%) .          .          .                   if self.class_over_limit_unicode(cls) {
      .          .          .          .                       return Seq::infinite();
      .          .          .          .                   }
      .          .          .          .                   let mut seq = Seq::empty();
      .          .          .          .                   for r in cls.iter() {
      .          .          .          .                       for ch in r.start()..=r.end() {
      .          .          .          .                           seq.push(Literal::from(ch));
      .          .          .          .                       }
      .          .          .          .                   }
    445 ( 0.00%) .          .          .                   self.enforce_literal_len(&mut seq);
    356 ( 0.00%) .          .          .                   seq
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Convert the given byte class into a sequence of literals if the class
      .          .          .          .               /// is small enough. If the class is too big, return an infinite sequence.
      .          .          .          .               fn extract_class_bytes(&self, cls: &hir::ClassBytes) -> Seq {
      .          .          .          .                   if self.class_over_limit_bytes(cls) {
      .          .          .          .                       return Seq::infinite();
      .          .          .          .                   }
-- line 519 ----------------------------------------
-- line 527 ----------------------------------------
      .          .          .          .                   seq
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if the given Unicode class exceeds the configured limits
      .          .          .          .               /// on this extractor.
      .          .          .          .               fn class_over_limit_unicode(&self, cls: &hir::ClassUnicode) -> bool {
      .          .          .          .                   let mut count = 0;
      .          .          .          .                   for r in cls.iter() {
    902 ( 0.00%) .          .          .                       if count > self.limit_class {
      .          .          .          .                           return true;
      .          .          .          .                       }
    246 ( 0.00%) .          .          .                       count += r.len();
      .          .          .          .                   }
     89 ( 0.00%) .          .          .                   count > self.limit_class
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if the given byte class exceeds the configured limits on
      .          .          .          .               /// this extractor.
      .          .          .          .               fn class_over_limit_bytes(&self, cls: &hir::ClassBytes) -> bool {
      .          .          .          .                   let mut count = 0;
      .          .          .          .                   for r in cls.iter() {
      .          .          .          .                       if count > self.limit_class {
-- line 548 ----------------------------------------
-- line 551 ----------------------------------------
      .          .          .          .                       count += r.len();
      .          .          .          .                   }
      .          .          .          .                   count > self.limit_class
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compute the cross product of the two sequences if the result would be
      .          .          .          .               /// within configured limits. Otherwise, make `seq2` infinite and cross the
      .          .          .          .               /// infinite sequence with `seq1`.
  4,820 ( 0.00%) .          .          .               fn cross(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq {
  1,907 ( 0.00%) .          .          .                   if seq1.max_cross_len(seq2).map_or(false, |len| len > self.limit_total)
      .          .          .          .                   {
      .          .          .          .                       seq2.make_infinite();
      .          .          .          .                   }
  2,832 ( 0.00%) .          .          .                   if let ExtractKind::Suffix = self.kind {
      .          .          .          .                       seq1.cross_reverse(seq2);
      .          .          .          .                   } else {
      .          .          .          .                       seq1.cross_forward(seq2);
      .          .          .          .                   }
      .          .          .          .                   assert!(seq1.len().map_or(true, |x| x <= self.limit_total));
    422 ( 0.00%) .          .          .                   self.enforce_literal_len(&mut seq1);
  2,410 ( 0.00%) .          .          .                   seq1
  3,856 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Union the two sequences if the result would be within configured
      .          .          .          .               /// limits. Otherwise, make `seq2` infinite and union the infinite sequence
      .          .          .          .               /// with `seq1`.
 22,023 ( 0.01%) .          .          .               fn union(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq {
  2,444 ( 0.00%) .          .          .                   if seq1.max_union_len(seq2).map_or(false, |len| len > self.limit_total)
      .          .          .          .                   {
      .          .          .          .                       // We try to trim our literal sequences to see if we can make
      .          .          .          .                       // room for more literals. The idea is that we'd rather trim down
      .          .          .          .                       // literals already in our sequence if it means we can add a few
      .          .          .          .                       // more and retain a finite sequence. Otherwise, we'll union with
      .          .          .          .                       // an infinite sequence and that infects everything and effectively
      .          .          .          .                       // stops literal extraction in its tracks.
      .          .          .          .                       //
      .          .          .          .                       // We do we keep 4 bytes here? Well, it's a bit of an abstraction
      .          .          .          .                       // leakage. Downstream, the literals may wind up getting fed to
      .          .          .          .                       // the Teddy algorithm, which supports searching literals up to
      .          .          .          .                       // length 4. So that's why we pick that number here. Arguably this
      .          .          .          .                       // should be a tuneable parameter, but it seems a little tricky to
      .          .          .          .                       // describe. And I'm still unsure if this is the right way to go
      .          .          .          .                       // about culling literal sequences.
      2 ( 0.00%) .          .          .                       match self.kind {
      .          .          .          .                           ExtractKind::Prefix => {
      .          .          .          .                               seq1.keep_first_bytes(4);
      .          .          .          .                               seq2.keep_first_bytes(4);
      .          .          .          .                           }
      .          .          .          .                           ExtractKind::Suffix => {
      .          .          .          .                               seq1.keep_last_bytes(4);
      2 ( 0.00%) .          .          .                               seq2.keep_last_bytes(4);
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       seq1.dedup();
      .          .          .          .                       seq2.dedup();
      1 ( 0.00%) .          .          .                       if seq1
      .          .          .          .                           .max_union_len(seq2)
      .          .          .          .                           .map_or(false, |len| len > self.limit_total)
      .          .          .          .                       {
      .          .          .          .                           seq2.make_infinite();
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   seq1.union(seq2);
      .          .          .          .                   assert!(seq1.len().map_or(true, |x| x <= self.limit_total));
 12,235 ( 0.00%) .          .          .                   seq1
 19,576 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Applies the literal length limit to the given sequence. If none of the
      .          .          .          .               /// literals in the sequence exceed the limit, then this is a no-op.
      .          .          .          .               fn enforce_literal_len(&self, seq: &mut Seq) {
      .          .          .          .                   let len = self.limit_literal_len;
  5,422 ( 0.00%) .          .          .                   match self.kind {
      .          .          .          .                       ExtractKind::Prefix => seq.keep_first_bytes(len),
      .          .          .          .                       ExtractKind::Suffix => seq.keep_last_bytes(len),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Default for Extractor {
      .          .          .          .               fn default() -> Extractor {
-- line 630 ----------------------------------------
-- line 724 ----------------------------------------
      .          .          .          .           /// // not altered by simplifying the set.
      .          .          .          .           /// let expected = Seq::from_iter([
      .          .          .          .           ///     Literal::inexact("far"),
      .          .          .          .           ///     Literal::inexact("app"),
      .          .          .          .           ///     Literal::exact("gap"),
      .          .          .          .           /// ]);
      .          .          .          .           /// assert_eq!(expected, seq);
      .          .          .          .           /// ```
    116 ( 0.00%) .          .          .           #[derive(Clone, Eq, PartialEq)]
      .          .          .          .           pub struct Seq {
      .          .          .          .               /// The members of this seq.
      .          .          .          .               ///
      .          .          .          .               /// When `None`, the seq represents all possible literals. That is, it
      .          .          .          .               /// prevents one from making assumptions about specific literals in the
      .          .          .          .               /// seq, and forces one to treat it as if any literal might be in the seq.
      .          .          .          .               ///
      .          .          .          .               /// Note that `Some(vec![])` is valid and corresponds to the empty seq of
-- line 740 ----------------------------------------
-- line 746 ----------------------------------------
      .          .          .          .           
      .          .          .          .           impl Seq {
      .          .          .          .               /// Returns an empty sequence.
      .          .          .          .               ///
      .          .          .          .               /// An empty sequence matches zero literals, and thus corresponds to a
      .          .          .          .               /// regex that itself can never match.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn empty() -> Seq {
    354 ( 0.00%) .          .          .                   Seq { literals: Some(vec![]) }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a sequence of literals without a finite size and may contain
      .          .          .          .               /// any literal.
      .          .          .          .               ///
      .          .          .          .               /// A sequence without finite size does not reveal anything about the
      .          .          .          .               /// characteristics of the literals in its set. There are no fixed prefixes
      .          .          .          .               /// or suffixes, nor are lower or upper bounds on the length of the literals
-- line 762 ----------------------------------------
-- line 775 ----------------------------------------
      .          .          .          .               #[inline]
      .          .          .          .               pub fn infinite() -> Seq {
      .          .          .          .                   Seq { literals: None }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a sequence containing a single literal.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn singleton(lit: Literal) -> Seq {
 11,518 ( 0.00%) .          .          .                   Seq { literals: Some(vec![lit]) }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a sequence of exact literals from the given byte strings.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn new<I, B>(it: I) -> Seq
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = B>,
      .          .          .          .                   B: AsRef<[u8]>,
-- line 791 ----------------------------------------
-- line 810 ----------------------------------------
      .          .          .          .               /// Similarly, if the most recently added item of this sequence is
      .          .          .          .               /// equivalent to the literal given, then it is not added. This reflects
      .          .          .          .               /// a `Seq`'s "set like" behavior, and represents a practical trade off.
      .          .          .          .               /// Namely, there is never any need to have two adjacent and equivalent
      .          .          .          .               /// literals in the same sequence, _and_ it is easy to detect in some
      .          .          .          .               /// cases.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn push(&mut self, lit: Literal) {
  1,227 ( 0.00%) .          .          .                   let lits = match self.literals {
      .          .          .          .                       None => return,
      .          .          .          .                       Some(ref mut lits) => lits,
      .          .          .          .                   };
    318 ( 0.00%) .          .          .                   if lits.last().map_or(false, |m| m == &lit) {
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .                   lits.push(lit);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Make all of the literals in this sequence inexact.
      .          .          .          .               ///
      .          .          .          .               /// This is a no-op if this sequence is not finite.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn make_inexact(&mut self) {
    116 ( 0.00%) .          .          .                   let lits = match self.literals {
      .          .          .          .                       None => return,
      .          .          .          .                       Some(ref mut lits) => lits,
      .          .          .          .                   };
      .          .          .          .                   for lit in lits.iter_mut() {
      .          .          .          .                       lit.make_inexact();
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Converts this sequence to an infinite sequence.
      .          .          .          .               ///
      .          .          .          .               /// This is a no-op if the sequence is already infinite.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn make_infinite(&mut self) {
     65 ( 0.00%) .          .          .                   self.literals = None;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Modify this sequence to contain the cross product between it and the
      .          .          .          .               /// sequence given.
      .          .          .          .               ///
      .          .          .          .               /// The cross product only considers literals in this sequence that are
      .          .          .          .               /// exact. That is, inexact literals are not extended.
      .          .          .          .               ///
-- line 855 ----------------------------------------
-- line 952 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// // seq1 remains unchanged.
      .          .          .          .               /// assert!(!seq1.is_finite());
      .          .          .          .               /// // Even though the literals in seq2 weren't used, it was still drained.
      .          .          .          .               /// assert_eq!(Some(0), seq2.len());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn cross_forward(&mut self, other: &mut Seq) {
    798 ( 0.00%) .          .          .                   let (lits1, lits2) = match self.cross_preamble(other) {
      .          .          .          .                       None => return,
      .          .          .          .                       Some((lits1, lits2)) => (lits1, lits2),
      .          .          .          .                   };
      .          .          .          .                   let newcap = lits1.len().saturating_mul(lits2.len());
  2,898 ( 0.00%) .          .          .                   for selflit in mem::replace(lits1, Vec::with_capacity(newcap)) {
      .          .          .          .                       if !selflit.is_exact() {
     96 ( 0.00%) .          .          .                           lits1.push(selflit);
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       for otherlit in lits2.iter() {
      .          .          .          .                           let mut newlit = Literal::exact(Vec::with_capacity(
      .          .          .          .                               selflit.len() + otherlit.len(),
      .          .          .          .                           ));
      .          .          .          .                           newlit.extend(&selflit);
  9,256 ( 0.00%) .          .          .                           newlit.extend(&otherlit);
  4,628 ( 0.00%) .          .          .                           if !otherlit.is_exact() {
      .          .          .          .                               newlit.make_inexact();
      .          .          .          .                           }
      .          .          .          .                           lits1.push(newlit);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   lits2.drain(..);
      .          .          .          .                   self.dedup();
      .          .          .          .               }
-- line 984 ----------------------------------------
-- line 1091 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// // seq1 remains unchanged.
      .          .          .          .               /// assert!(!seq1.is_finite());
      .          .          .          .               /// // Even though the literals in seq2 weren't used, it was still drained.
      .          .          .          .               /// assert_eq!(Some(0), seq2.len());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn cross_reverse(&mut self, other: &mut Seq) {
    166 ( 0.00%) .          .          .                   let (lits1, lits2) = match self.cross_preamble(other) {
      .          .          .          .                       None => return,
      .          .          .          .                       Some((lits1, lits2)) => (lits1, lits2),
      .          .          .          .                   };
      .          .          .          .                   // We basically proceed as we do in 'cross_forward' at this point,
      .          .          .          .                   // except that the outer loop is now 'other' and the inner loop is now
      .          .          .          .                   // 'self'. That's because 'self' corresponds to suffixes and 'other'
      .          .          .          .                   // corresponds to the sequence we want to *prepend* to the suffixes.
      .          .          .          .                   let newcap = lits1.len().saturating_mul(lits2.len());
      .          .          .          .                   let selflits = mem::replace(lits1, Vec::with_capacity(newcap));
      .          .          .          .                   for (i, otherlit) in lits2.drain(..).enumerate() {
      .          .          .          .                       for selflit in selflits.iter() {
  2,343 ( 0.00%) .          .          .                           if !selflit.is_exact() {
      .          .          .          .                               // If the suffix isn't exact, then we can't prepend
      .          .          .          .                               // anything to it. However, we still want to keep it. But
      .          .          .          .                               // we only want to keep one of them, to avoid duplication.
      .          .          .          .                               // (The duplication is okay from a correctness perspective,
      .          .          .          .                               // but wasteful.)
     80 ( 0.00%) .          .          .                               if i == 0 {
      .          .          .          .                                   lits1.push(selflit.clone());
      .          .          .          .                               }
      .          .          .          .                               continue;
      .          .          .          .                           }
      .          .          .          .                           let mut newlit = Literal::exact(Vec::with_capacity(
      .          .          .          .                               otherlit.len() + selflit.len(),
      .          .          .          .                           ));
      .          .          .          .                           newlit.extend(&otherlit);
  4,526 ( 0.00%) .          .          .                           newlit.extend(&selflit);
  2,263 ( 0.00%) .          .          .                           if !otherlit.is_exact() {
      .          .          .          .                               newlit.make_inexact();
      .          .          .          .                           }
      .          .          .          .                           lits1.push(newlit);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   self.dedup();
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// A helper function the corresponds to the subtle preamble for both
      .          .          .          .               /// `cross_forward` and `cross_reverse`. In effect, it handles the cases
      .          .          .          .               /// of infinite sequences for both `self` and `other`, as well as ensuring
      .          .          .          .               /// that literals from `other` are drained even if they aren't used.
  4,338 ( 0.00%) .          .          .               fn cross_preamble<'a>(
      .          .          .          .                   &'a mut self,
      .          .          .          .                   other: &'a mut Seq,
      .          .          .          .               ) -> Option<(&'a mut Vec<Literal>, &'a mut Vec<Literal>)> {
  1,446 ( 0.00%) .          .          .                   let lits2 = match other.literals {
      .          .          .          .                       None => {
      .          .          .          .                           // If our current seq contains the empty string and the seq
      .          .          .          .                           // we're adding matches any literal, then it follows that the
      .          .          .          .                           // current seq must now also match any literal.
      .          .          .          .                           //
      .          .          .          .                           // Otherwise, we just have to make sure everything in this
      .          .          .          .                           // sequence is inexact.
     60 ( 0.00%) .          .          .                           if self.min_literal_len() == Some(0) {
     13 ( 0.00%) .          .          .                               *self = Seq::infinite();
      .          .          .          .                           } else {
      .          .          .          .                               self.make_inexact();
      .          .          .          .                           }
      .          .          .          .                           return None;
      .          .          .          .                       }
      .          .          .          .                       Some(ref mut lits) => lits,
      .          .          .          .                   };
    422 ( 0.00%) .          .          .                   let lits1 = match self.literals {
      .          .          .          .                       None => {
      .          .          .          .                           // If we aren't going to make it to the end of this routine
      .          .          .          .                           // where lits2 is drained, then we need to do it now.
      .          .          .          .                           lits2.drain(..);
      .          .          .          .                           return None;
      .          .          .          .                       }
      .          .          .          .                       Some(ref mut lits) => lits,
      .          .          .          .                   };
      .          .          .          .                   Some((lits1, lits2))
  4,820 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Unions the `other` sequence into this one.
      .          .          .          .               ///
      .          .          .          .               /// The literals are always drained out of the given `other` sequence,
      .          .          .          .               /// even if they are being unioned into an infinite sequence. This permits
      .          .          .          .               /// the caller to reuse the `other` sequence in another context.
      .          .          .          .               ///
      .          .          .          .               /// Some literal deduping may be performed. If any deduping happens,
-- line 1179 ----------------------------------------
-- line 1212 ----------------------------------------
      .          .          .          .               /// seq1.union(&mut seq2);
      .          .          .          .               ///
      .          .          .          .               /// // seq1 is still infinite and seq2 has been drained.
      .          .          .          .               /// assert_eq!(None, seq1.len());
      .          .          .          .               /// assert_eq!(Some(0), seq2.len());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn union(&mut self, other: &mut Seq) {
     93 ( 0.00%) .          .          .                   let lits2 = match other.literals {
      .          .          .          .                       None => {
      .          .          .          .                           // Unioning with an infinite sequence always results in an
      .          .          .          .                           // infinite sequence.
      .          .          .          .                           self.make_infinite();
      .          .          .          .                           return;
      .          .          .          .                       }
      .          .          .          .                       Some(ref mut lits) => lits.drain(..),
      .          .          .          .                   };
     54 ( 0.00%) .          .          .                   let lits1 = match self.literals {
      .          .          .          .                       None => return,
      .          .          .          .                       Some(ref mut lits) => lits,
      .          .          .          .                   };
 14,793 ( 0.00%) .          .          .                   lits1.extend(lits2);
      .          .          .          .                   self.dedup();
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Unions the `other` sequence into this one by splice the `other`
      .          .          .          .               /// sequence at the position of the first zero-length literal.
      .          .          .          .               ///
      .          .          .          .               /// This is useful for preserving preference order semantics when combining
      .          .          .          .               /// two literal sequences. For example, in the regex `(a||f)+foo`, the
-- line 1241 ----------------------------------------
-- line 1334 ----------------------------------------
      .          .          .          .               ///     Literal::inexact("foo"),
      .          .          .          .               /// ]);
      .          .          .          .               /// seq.dedup();
      .          .          .          .               ///
      .          .          .          .               /// assert_eq!(Seq::from_iter([Literal::inexact("foo")]), seq);
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn dedup(&mut self) {
  8,682 ( 0.00%) .          .          .                   if let Some(ref mut lits) = self.literals {
      .          .          .          .                       lits.dedup_by(|lit1, lit2| {
 58,970 ( 0.02%) .          .          .                           if lit1.as_bytes() != lit2.as_bytes() {
      .          .          .          .                               return false;
      .          .          .          .                           }
      .          .          .          .                           if lit1.is_exact() != lit2.is_exact() {
      .          .          .          .                               lit1.make_inexact();
      .          .          .          .                               lit2.make_inexact();
      .          .          .          .                           }
      .          .          .          .                           true
      .          .          .          .                       });
-- line 1352 ----------------------------------------
-- line 1482 ----------------------------------------
      .          .          .          .               ///     Literal::exact("a"),
      .          .          .          .               ///     Literal::inexact("fo"),
      .          .          .          .               ///     Literal::inexact("qu"),
      .          .          .          .               /// ]);
      .          .          .          .               /// assert_eq!(expected, seq);
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn keep_first_bytes(&mut self, len: usize) {
    454 ( 0.00%) .          .          .                   if let Some(ref mut lits) = self.literals {
      .          .          .          .                       for m in lits.iter_mut() {
      .          .          .          .                           m.keep_first_bytes(len);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Trims all literals in this seq such that only the last `len` bytes
      .          .          .          .               /// remain. If a literal has less than or equal to `len` bytes, then it
-- line 1498 ----------------------------------------
-- line 1510 ----------------------------------------
      .          .          .          .               ///     Literal::exact("a"),
      .          .          .          .               ///     Literal::inexact("oo"),
      .          .          .          .               ///     Literal::inexact("ux"),
      .          .          .          .               /// ]);
      .          .          .          .               /// assert_eq!(expected, seq);
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn keep_last_bytes(&mut self, len: usize) {
    119 ( 0.00%) .          .          .                   if let Some(ref mut lits) = self.literals {
      .          .          .          .                       for m in lits.iter_mut() {
      .          .          .          .                           m.keep_last_bytes(len);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if this sequence is finite.
      .          .          .          .               ///
-- line 1526 ----------------------------------------
-- line 1583 ----------------------------------------
      .          .          .          .                   Some(len1.saturating_mul(len2))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length of the shortest literal in this sequence.
      .          .          .          .               ///
      .          .          .          .               /// If the sequence is infinite or empty, then this returns `None`.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn min_literal_len(&self) -> Option<usize> {
     60 ( 0.00%) .          .          .                   self.literals.as_ref()?.iter().map(|x| x.len()).min()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length of the longest literal in this sequence.
      .          .          .          .               ///
      .          .          .          .               /// If the sequence is infinite or empty, then this returns `None`.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn max_literal_len(&self) -> Option<usize> {
      .          .          .          .                   self.literals.as_ref()?.iter().map(|x| x.len()).max()
-- line 1599 ----------------------------------------
-- line 1624 ----------------------------------------
      .          .          .          .               /// assert_eq!(None, seq.longest_common_prefix());
      .          .          .          .               /// let seq = Seq::empty();
      .          .          .          .               /// assert_eq!(None, seq.longest_common_prefix());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn longest_common_prefix(&self) -> Option<&[u8]> {
      .          .          .          .                   // If we match everything or match nothing, then there's no meaningful
      .          .          .          .                   // longest common prefix.
    200 ( 0.00%) .          .          .                   let lits = match self.literals {
      .          .          .          .                       None => return None,
      .          .          .          .                       Some(ref lits) => lits,
      .          .          .          .                   };
      .          .          .          .                   if lits.len() == 0 {
      .          .          .          .                       return None;
      .          .          .          .                   }
      .          .          .          .                   let base = lits[0].as_bytes();
      .          .          .          .                   let mut len = base.len();
      .          .          .          .                   for m in lits.iter().skip(1) {
      .          .          .          .                       len = m
      .          .          .          .                           .as_bytes()
      .          .          .          .                           .iter()
      .          .          .          .                           .zip(base[..len].iter())
      .          .          .          .                           .take_while(|&(a, b)| a == b)
      .          .          .          .                           .count();
  1,310 ( 0.00%) .          .          .                       if len == 0 {
      .          .          .          .                           return Some(&[]);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Some(&base[..len])
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the longest common suffix from this seq.
      .          .          .          .               ///
-- line 1656 ----------------------------------------
-- line 1677 ----------------------------------------
      .          .          .          .               /// assert_eq!(None, seq.longest_common_suffix());
      .          .          .          .               /// let seq = Seq::empty();
      .          .          .          .               /// assert_eq!(None, seq.longest_common_suffix());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn longest_common_suffix(&self) -> Option<&[u8]> {
      .          .          .          .                   // If we match everything or match nothing, then there's no meaningful
      .          .          .          .                   // longest common suffix.
     50 ( 0.00%) .          .          .                   let lits = match self.literals {
      .          .          .          .                       None => return None,
      .          .          .          .                       Some(ref lits) => lits,
      .          .          .          .                   };
      .          .          .          .                   if lits.len() == 0 {
      .          .          .          .                       return None;
      .          .          .          .                   }
      .          .          .          .                   let base = lits[0].as_bytes();
      .          .          .          .                   let mut len = base.len();
      .          .          .          .                   for m in lits.iter().skip(1) {
      .          .          .          .                       len = m
      .          .          .          .                           .as_bytes()
      .          .          .          .                           .iter()
      .          .          .          .                           .rev()
     48 ( 0.00%) .          .          .                           .zip(base[base.len() - len..].iter().rev())
      .          .          .          .                           .take_while(|&(a, b)| a == b)
      .          .          .          .                           .count();
     72 ( 0.00%) .          .          .                       if len == 0 {
      .          .          .          .                           return Some(&[]);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Some(&base[base.len() - len..])
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Optimizes this seq while treating its literals as prefixes and
      .          .          .          .               /// respecting the preference order of its literals.
-- line 1710 ----------------------------------------
-- line 1812 ----------------------------------------
      .          .          .          .               ///     "sam",
      .          .          .          .               ///     "frodo",
      .          .          .          .               /// ]);
      .          .          .          .               /// seq.optimize_for_prefix_by_preference();
      .          .          .          .               /// assert!(seq.is_finite());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn optimize_for_prefix_by_preference(&mut self) {
    136 ( 0.00%) .          .          .                   self.optimize_by_preference(true);
4,918,785 ( 1.42%) 10,016 ( 1.24%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Seq::optimize_by_preference (16x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Optimizes this seq while treating its literals as suffixes and
      .          .          .          .               /// respecting the preference order of its literals.
      .          .          .          .               ///
      .          .          .          .               /// Optimization should only be run once extraction is complete.
      .          .          .          .               ///
      .          .          .          .               /// The [`Seq::optimize_for_prefix_by_preference`] does the same thing, but
      .          .          .          .               /// for prefixes. See its documentation for more explanation.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn optimize_for_suffix_by_preference(&mut self) {
     39 ( 0.00%) .          .          .                   self.optimize_by_preference(false);
  3,916 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Seq::optimize_by_preference (13x)
      .          .          .          .               }
      .          .          .          .           
    584 ( 0.00%) .          .          .               fn optimize_by_preference(&mut self, prefix: bool) {
      .          .          .          .                   let origlen = match self.len() {
      .          .          .          .                       None => return,
      .          .          .          .                       Some(len) => len,
      .          .          .          .                   };
      .          .          .          .                   // Just give up now if our sequence contains an empty string.
     71 ( 0.00%) .          .          .                   if self.min_literal_len().map_or(false, |len| len == 0) {
      .          .          .          .                       // We squash the sequence so that nobody else gets any bright
      .          .          .          .                       // ideas to try and use it. An empty string implies a match at
      .          .          .          .                       // every position. A prefilter cannot help you here.
      .          .          .          .                       self.make_infinite();
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .                   // Make sure we start with the smallest sequence possible. We use a
      .          .          .          .                   // special version of preference minimization that retains exactness.
      .          .          .          .                   // This is legal because optimization is only expected to occur once
      .          .          .          .                   // extraction is complete.
    124 ( 0.00%) .          .          .                   if prefix {
      .          .          .          .                       if let Some(ref mut lits) = self.literals {
    150 ( 0.00%) .          .          .                           PreferenceTrie::minimize(lits, true);
2,755,250 ( 0.79%) 8,164 ( 1.01%) 8 ( 2.47%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::PreferenceTrie::minimize (50x)
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // Look for a common prefix (or suffix). If we found one of those and
      .          .          .          .                   // it's long enough, then it's a good bet that it will be our fastest
      .          .          .          .                   // possible prefilter since single-substring search is so fast.
      .          .          .          .                   let fix = if prefix {
    100 ( 0.00%) .          .          .                       self.longest_common_prefix()
      .          .          .          .                   } else {
      .          .          .          .                       self.longest_common_suffix()
      .          .          .          .                   };
      .          .          .          .                   if let Some(fix) = fix {
      .          .          .          .                       // As a special case, if we have a common prefix and the leading
      .          .          .          .                       // byte of that prefix is one that we think probably occurs rarely,
      .          .          .          .                       // then strip everything down to just that single byte. This should
      .          .          .          .                       // promote the use of memchr.
-- line 1870 ----------------------------------------
-- line 1889 ----------------------------------------
      .          .          .          .                           self.dedup();
      .          .          .          .                           return;
      .          .          .          .                       }
      .          .          .          .                       // We only strip down to the common prefix/suffix if we think
      .          .          .          .                       // the existing set of literals isn't great, or if the common
      .          .          .          .                       // prefix/suffix is expected to be particularly discriminatory.
      .          .          .          .                       let isfast =
      .          .          .          .                           self.is_exact() && self.len().map_or(false, |len| len <= 16);
    186 ( 0.00%) .          .          .                       let usefix = fix.len() > 4 || (fix.len() > 1 && !isfast);
      .          .          .          .                       if usefix {
      .          .          .          .                           // If we keep exactly the number of bytes equal to the length
      .          .          .          .                           // of the prefix (or suffix), then by the definition of a
      .          .          .          .                           // prefix, every literal in the sequence will be equivalent.
      .          .          .          .                           // Thus, 'dedup' will leave us with one literal.
      .          .          .          .                           //
      .          .          .          .                           // We do it this way to avoid an alloc, but also to make sure
      .          .          .          .                           // the exactness of literals is kept (or not).
-- line 1905 ----------------------------------------
-- line 1945 ----------------------------------------
      .          .          .          .                   //
      .          .          .          .                   // So for example, the pair (3, 500) would mean, "if we have more than
      .          .          .          .                   // 500 literals in our sequence, then truncate all of our literals
      .          .          .          .                   // such that they are at most 3 bytes in length and the minimize the
      .          .          .          .                   // sequence."
      .          .          .          .                   const ATTEMPTS: [(usize, usize); 5] =
      .          .          .          .                       [(5, 10), (4, 10), (3, 64), (2, 64), (1, 10)];
      .          .          .          .                   for (keep, limit) in ATTEMPTS {
    184 ( 0.00%) .          .          .                       let len = match self.len() {
      .          .          .          .                           None => break,
      .          .          .          .                           Some(len) => len,
      .          .          .          .                       };
      .          .          .          .                       if len <= limit {
      .          .          .          .                           break;
      .          .          .          .                       }
    262 ( 0.00%) .          .          .                       if prefix {
      .          .          .          .                           self.keep_first_bytes(keep);
      .          .          .          .                       } else {
      .          .          .          .                           self.keep_last_bytes(keep);
      .          .          .          .                       }
    647 ( 0.00%) .          .          .                       if prefix {
      .          .          .          .                           if let Some(ref mut lits) = self.literals {
    381 ( 0.00%) .          .          .                               PreferenceTrie::minimize(lits, true);
7,287,742 ( 2.10%) 19,550 ( 2.41%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::PreferenceTrie::minimize (127x)
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // Check for a poison literal. A poison literal is one that is short
      .          .          .          .                   // and is believed to have a very high match count. These poisons
      .          .          .          .                   // generally lead to a prefilter with a very high false positive rate,
      .          .          .          .                   // and thus overall worse performance.
      .          .          .          .                   //
      .          .          .          .                   // We do this last because we could have gone from a non-poisonous
      .          .          .          .                   // sequence to a poisonous one. Perhaps we should add some code to
      .          .          .          .                   // prevent such transitions in the first place, but then again, we
      .          .          .          .                   // likely only made the transition in the first place if the sequence
      .          .          .          .                   // was itself huge. And huge sequences are themselves poisonous. So...
      9 ( 0.00%) .          .          .                   if let Some(lits) = self.literals() {
      .          .          .          .                       if lits.iter().any(|lit| lit.is_poisonous()) {
      .          .          .          .                           self.make_infinite();
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // OK, if we had an exact sequence before attempting more optimizations
      .          .          .          .                   // above and our post-optimized sequence sucks for some reason or
      .          .          .          .                   // another, then we go back to the exact sequence.
    186 ( 0.00%) .          .          .                   if let Some(exact) = exact {
      .          .          .          .                       // If optimizing resulted in dropping our literals, then certainly
      .          .          .          .                       // backup and use the exact sequence that we had.
      .          .          .          .                       if !self.is_finite() {
      .          .          .          .                           *self = exact;
      .          .          .          .                           return;
      .          .          .          .                       }
      .          .          .          .                       // If our optimized sequence contains a short literal, then it's
      .          .          .          .                       // *probably* not so great. So throw it away and revert to the
-- line 1997 ----------------------------------------
-- line 2002 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .                       // Finally, if our optimized sequence is "big" (i.e., can't use
      .          .          .          .                       // Teddy), then also don't use it and rely on the exact sequence.
      .          .          .          .                       if self.len().map_or(true, |len| len > 64) {
      .          .          .          .                           *self = exact;
      .          .          .          .                           return;
      .          .          .          .                       }
      .          .          .          .                   }
    584 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl core::fmt::Debug for Seq {
      .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      .          .          .          .                   write!(f, "Seq")?;
      .          .          .          .                   if let Some(lits) = self.literals() {
      .          .          .          .                       f.debug_list().entries(lits.iter()).finish()
      .          .          .          .                   } else {
-- line 2018 ----------------------------------------
-- line 2043 ----------------------------------------
      .          .          .          .           /// has not been trimmed, and may continue to be extended. If a literal is
      .          .          .          .           /// "exact" after visiting the entire `Hir` expression, then this implies that
      .          .          .          .           /// the literal leads to a match state. (Although it doesn't necessarily imply
      .          .          .          .           /// all occurrences of the literal correspond to a match of the regex, since
      .          .          .          .           /// literal extraction ignores look-around assertions.)
      .          .          .          .           #[derive(Clone, Eq, PartialEq, PartialOrd, Ord)]
      .          .          .          .           pub struct Literal {
      .          .          .          .               bytes: Vec<u8>,
    636 ( 0.00%) .          .          .               exact: bool,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Literal {
      .          .          .          .               /// Returns a new exact literal containing the bytes given.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn exact<B: Into<Vec<u8>>>(bytes: B) -> Literal {
 27,973 ( 0.01%) .          .          .                   Literal { bytes: bytes.into(), exact: true }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a new inexact literal containing the bytes given.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn inexact<B: Into<Vec<u8>>>(bytes: B) -> Literal {
      .          .          .          .                   Literal { bytes: bytes.into(), exact: false }
      .          .          .          .               }
      .          .          .          .           
-- line 2066 ----------------------------------------
-- line 2088 ----------------------------------------
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_empty(&self) -> bool {
      .          .          .          .                   self.len() == 0
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this literal is exact.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_exact(&self) -> bool {
 11,200 ( 0.00%) .          .          .                   self.exact
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Marks this literal as inexact.
      .          .          .          .               ///
      .          .          .          .               /// Inexact literals can never be extended. For example,
      .          .          .          .               /// [`Seq::cross_forward`] will not extend inexact literals.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn make_inexact(&mut self) {
  8,732 ( 0.00%) .          .          .                   self.exact = false;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Reverse the bytes in this literal.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn reverse(&mut self) {
      .          .          .          .                   self.bytes.reverse();
      .          .          .          .               }
      .          .          .          .           
-- line 2113 ----------------------------------------
-- line 2122 ----------------------------------------
      .          .          .          .                   self.bytes.extend_from_slice(&lit.bytes);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Trims this literal such that only the first `len` bytes remain. If
      .          .          .          .               /// this literal has fewer than `len` bytes, then it remains unchanged.
      .          .          .          .               /// Otherwise, the literal is marked as inexact.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn keep_first_bytes(&mut self, len: usize) {
 44,376 ( 0.01%) .          .          .                   if len >= self.len() {
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .                   self.make_inexact();
      .          .          .          .                   self.bytes.truncate(len);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Trims this literal such that only the last `len` bytes remain. If this
      .          .          .          .               /// literal has fewer than `len` bytes, then it remains unchanged.
      .          .          .          .               /// Otherwise, the literal is marked as inexact.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn keep_last_bytes(&mut self, len: usize) {
  6,996 ( 0.00%) .          .          .                   if len >= self.len() {
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .                   self.make_inexact();
      .          .          .          .                   self.bytes.drain(..self.len() - len);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if it is believe that this literal is likely to match very
      .          .          .          .               /// frequently, and is thus not a good candidate for a prefilter.
      .          .          .          .               fn is_poisonous(&self) -> bool {
  6,306 ( 0.00%) .          .          .                   self.is_empty() || (self.len() == 1 && rank(self.as_bytes()[0]) >= 250)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl From<u8> for Literal {
      .          .          .          .               fn from(byte: u8) -> Literal {
      .          .          .          .                   Literal::exact(vec![byte])
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl From<char> for Literal {
      .          .          .          .               fn from(ch: char) -> Literal {
      .          .          .          .                   use alloc::string::ToString;
    409 ( 0.00%) .          .          .                   Literal::exact(ch.encode_utf8(&mut [0; 4]).to_string())
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl AsRef<[u8]> for Literal {
      .          .          .          .               fn as_ref(&self) -> &[u8] {
      .          .          .          .                   self.as_bytes()
  6,995 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl core::fmt::Debug for Literal {
      .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      .          .          .          .                   let tag = if self.exact { "E" } else { "I" };
      .          .          .          .                   f.debug_tuple(tag)
      .          .          .          .                       .field(&crate::debug::Bytes(self.as_bytes()))
      .          .          .          .                       .finish()
-- line 2180 ----------------------------------------
-- line 2229 ----------------------------------------
      .          .          .          .               /// order semantics.
      .          .          .          .               ///
      .          .          .          .               /// When `keep_exact` is true, the exactness of every literal retained is
      .          .          .          .               /// kept. This is useful when dealing with a fully extracted `Seq` that
      .          .          .          .               /// only contains exact literals. In that case, we can keep all retained
      .          .          .          .               /// literals as exact because we know we'll never need to match anything
      .          .          .          .               /// after them and because any removed literals are guaranteed to never
      .          .          .          .               /// match.
  1,062 ( 0.00%) .          .          .               fn minimize(literals: &mut Vec<Literal>, keep_exact: bool) {
  1,062 ( 0.00%) .          .          .                   let mut trie = PreferenceTrie {
      .          .          .          .                       states: vec![],
      .          .          .          .                       matches: vec![],
      .          .          .          .                       next_literal_index: 1,
      .          .          .          .                   };
      .          .          .          .                   let mut make_inexact = vec![];
 68,751 ( 0.02%) .          .          .                   literals.retain_mut(|lit| match trie.insert(lit.as_bytes()) {
8,949,928 ( 2.58%) 20,198 ( 2.49%) 8 ( 2.47%) .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::retain_mut (177x)
      .          .          .          .                       Ok(_) => true,
      .          .          .          .                       Err(i) => {
  5,274 ( 0.00%) .          .          .                           if !keep_exact {
      .          .          .          .                               make_inexact.push(i.checked_sub(1).unwrap());
      .          .          .          .                           }
      .          .          .          .                           false
      .          .          .          .                       }
      .          .          .          .                   });
    531 ( 0.00%) .          .          .                   for i in make_inexact {
      .          .          .          .                       literals[i].make_inexact();
      .          .          .          .                   }
    885 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns `Ok` if the given byte string is accepted into this trie and
      .          .          .          .               /// `Err` otherwise. The index for the success case corresponds to the
      .          .          .          .               /// index of the literal added. The index for the error case corresponds to
      .          .          .          .               /// the index of the literal already in the trie that prevented the given
      .          .          .          .               /// byte string from being added. (Which implies it is a prefix of the one
      .          .          .          .               /// given.)
      .          .          .          .               ///
      .          .          .          .               /// In short, the byte string given is accepted into the trie if and only
      .          .          .          .               /// if it is possible for it to match when executing a preference order
      .          .          .          .               /// search.
168,780 ( 0.05%) .          .          .               fn insert(&mut self, bytes: &[u8]) -> Result<usize, usize> {
      .          .          .          .                   let mut prev = self.root();
117,969 ( 0.03%) .          .          .                   if let Some(idx) = self.matches[prev] {
      .          .          .          .                       return Err(idx.get());
      .          .          .          .                   }
      .          .          .          .                   for &b in bytes.iter() {
 98,724 ( 0.03%) .          .          .                       match self.states[prev].trans.binary_search_by_key(&b, |t| t.0) {
      .          .          .          .                           Ok(i) => {
 30,371 ( 0.01%) .          .          .                               prev = self.states[prev].trans[i].1;
154,453 ( 0.04%) .          .          .                               if let Some(idx) = self.matches[prev] {
      .          .          .          .                                   return Err(idx.get());
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                           Err(i) => {
      .          .          .          .                               let next = self.create_state();
 37,982 ( 0.01%) .          .          .                               self.states[prev].trans.insert(i, (b, next));
      .          .          .          .                               prev = next;
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
 14,280 ( 0.00%) .          .          .                   let idx = self.next_literal_index;
 28,560 ( 0.01%) .          .          .                   self.next_literal_index += 1;
 71,400 ( 0.02%) .          .          .                   self.matches[prev] = NonZeroUsize::new(idx);
      .          .          .          .                   Ok(idx)
135,024 ( 0.04%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the root state ID, and if it doesn't exist, creates it.
      .          .          .          .               fn root(&mut self) -> usize {
 16,878 ( 0.00%) .          .          .                   if !self.states.is_empty() {
      .          .          .          .                       0
      .          .          .          .                   } else {
      .          .          .          .                       self.create_state()
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates a new empty state and returns its ID.
      .          .          .          .               fn create_state(&mut self) -> usize {
      .          .          .          .                   let id = self.states.len();
      .          .          .          .                   self.states.push(State::default());
    177 ( 0.00%) .          .          .                   self.matches.push(None);
      .          .          .          .                   id
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Returns the "rank" of the given byte.
      .          .          .          .           ///
      .          .          .          .           /// The minimum rank value is `0` and the maximum rank value is `255`.
      .          .          .          .           ///
-- line 2315 ----------------------------------------

 62,515 ( 0.02%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-syntax-0.8.5/src/hir/literal.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/strategy.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 70 ----------------------------------------
      .          .          .          .               fn which_overlapping_matches(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .                   patset: &mut PatternSet,
      .          .          .          .               );
      .          .          .          .           }
      .          .          .          .           
  1,296 ( 0.00%) .          .          .           pub(super) fn new(
      .          .          .          .               info: &RegexInfo,
      .          .          .          .               hirs: &[&Hir],
      .          .          .          .           ) -> Result<Arc<dyn Strategy>, BuildError> {
      .          .          .          .               // At this point, we're committed to a regex engine of some kind. So pull
      .          .          .          .               // out a prefilter if we can, which will feed to each of the constituent
      .          .          .          .               // regex engines.
    162 ( 0.00%) .          .          .               let pre = if info.is_always_anchored_start() {
      .          .          .          .                   // PERF: I'm not sure we necessarily want to do this... We may want to
      .          .          .          .                   // run a prefilter for quickly rejecting in some cases. The problem
      .          .          .          .                   // is that anchored searches overlap quite a bit with the use case
      .          .          .          .                   // of "run a regex on every line to extract data." In that case, the
      .          .          .          .                   // regex always matches, so running a prefilter doesn't really help us
      .          .          .          .                   // there. The main place where a prefilter helps in an anchored search
      .          .          .          .                   // is if the anchored search is not expected to match frequently. That
      .          .          .          .                   // is, the prefilter gives us a way to possibly reject a haystack very
-- line 93 ----------------------------------------
-- line 97 ----------------------------------------
      .          .          .          .                   // Or maybe we should only use a prefilter when we think it's "fast"?
      .          .          .          .                   //
      .          .          .          .                   // Interestingly, I think we currently lack the infrastructure for
      .          .          .          .                   // disabling a prefilter based on haystack length. That would probably
      .          .          .          .                   // need to be a new 'Input' option. (Interestingly, an 'Input' used to
      .          .          .          .                   // carry a 'Prefilter' with it, but I moved away from that.)
      .          .          .          .                   debug!("skipping literal extraction since regex is anchored");
      .          .          .          .                   None
     16 ( 0.00%) .          .          .               } else if let Some(pre) = info.config().get_prefilter() {
      .          .          .          .                   debug!(
      .          .          .          .                       "skipping literal extraction since the caller provided a prefilter"
      .          .          .          .                   );
      .          .          .          .                   Some(pre.clone())
     16 ( 0.00%) .          .          .               } else if info.config().get_auto_prefilter() {
      .          .          .          .                   let kind = info.config().get_match_kind();
     16 ( 0.00%) .          .          .                   let prefixes = crate::util::prefilter::prefixes(kind, hirs);
7,615,076 ( 2.19%) 16,850 ( 2.08%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/prefilter/mod.rs:regex_automata::util::prefilter::prefixes (16x)
      .          .          .          .                   // If we can build a full `Strategy` from just the extracted prefixes,
      .          .          .          .                   // then we can short-circuit and avoid building a regex engine at all.
     32 ( 0.00%) .          .          .                   if let Some(pre) = Pre::from_prefixes(info, &prefixes) {
      .          .          .          .                       debug!(
      .          .          .          .                           "found that the regex can be broken down to a literal \
      .          .          .          .                            search, avoiding the regex engine entirely",
      .          .          .          .                       );
      .          .          .          .                       return Ok(pre);
      .          .          .          .                   }
      .          .          .          .                   // This now attempts another short-circuit of the regex engine: if we
      .          .          .          .                   // have a huge alternation of just plain literals, then we can just use
-- line 123 ----------------------------------------
-- line 145 ----------------------------------------
      .          .          .          .                           strings,
      .          .          .          .                       );
      .          .          .          .                       Prefilter::new(kind, strings)
      .          .          .          .                   })
      .          .          .          .               } else {
      .          .          .          .                   debug!("skipping literal extraction since prefilters were disabled");
      .          .          .          .                   None
      .          .          .          .               };
 34,182 ( 0.01%) .          .          .               let mut core = Core::new(info.clone(), pre.clone(), hirs)?;
      .          .          .          .               // Now that we have our core regex engines built, there are a few cases
      .          .          .          .               // where we can do a little bit better than just a normal "search forward
      .          .          .          .               // and maybe use a prefilter when in a start state." However, these cases
      .          .          .          .               // may not always work or otherwise build on top of the Core searcher.
      .          .          .          .               // For example, the reverse anchored optimization seems like it might
      .          .          .          .               // always work, but only the DFAs support reverse searching and the DFAs
      .          .          .          .               // might give up or quit for reasons. If we had, e.g., a PikeVM that
      .          .          .          .               // supported reverse searching, then we could avoid building a full Core
-- line 161 ----------------------------------------
-- line 169 ----------------------------------------
      .          .          .          .               };
      .          .          .          .               core = match ReverseSuffix::new(core, hirs) {
      .          .          .          .                   Err(core) => core,
      .          .          .          .                   Ok(rs) => {
      .          .          .          .                       debug!("using reverse suffix strategy");
      .          .          .          .                       return Ok(Arc::new(rs));
      .          .          .          .                   }
      .          .          .          .               };
    120 ( 0.00%) .          .          .               core = match ReverseInner::new(core, hirs) {
      .          .          .          .                   Err(core) => core,
      .          .          .          .                   Ok(ri) => {
      .          .          .          .                       debug!("using reverse inner strategy");
      .          .          .          .                       return Ok(Arc::new(ri));
      .          .          .          .                   }
      .          .          .          .               };
      .          .          .          .               debug!("using core strategy");
    136 ( 0.00%) .          .          .               Ok(Arc::new(core))
    729 ( 0.00%) .          .          .           }
      .          .          .          .           
      .          .          .          .           #[derive(Clone, Debug)]
      .          .          .          .           struct Pre<P> {
      .          .          .          .               pre: P,
      .          .          .          .               group_info: GroupInfo,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<P: PrefilterI> Pre<P> {
-- line 194 ----------------------------------------
-- line 312 ----------------------------------------
      .          .          .          .               /// them are alternation of literals, but I haven't had the time to go down
      .          .          .          .               /// that path yet.
      .          .          .          .               fn from_alternation_literals(
      .          .          .          .                   info: &RegexInfo,
      .          .          .          .                   hirs: &[&Hir],
      .          .          .          .               ) -> Option<Arc<dyn Strategy>> {
      .          .          .          .                   use crate::util::prefilter::AhoCorasick;
      .          .          .          .           
     64 ( 0.00%) .          .          .                   let lits = crate::meta::literal::alternation_literals(info, hirs)?;
    458 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/literal.rs:regex_automata::meta::literal::alternation_literals (16x)
      .          .          .          .                   let ac = AhoCorasick::new(MatchKind::LeftmostFirst, &lits)?;
      .          .          .          .                   Some(Pre::new(ac))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           // This implements Strategy for anything that implements PrefilterI.
      .          .          .          .           //
      .          .          .          .           // Note that this must only be used for regexes of length 1. Multi-regexes
-- line 328 ----------------------------------------
-- line 461 ----------------------------------------
      .          .          .          .                   let mut lookm = LookMatcher::new();
      .          .          .          .                   lookm.set_line_terminator(info.config().get_line_terminator());
      .          .          .          .                   let thompson_config = thompson::Config::new()
      .          .          .          .                       .utf8(info.config().get_utf8_empty())
      .          .          .          .                       .nfa_size_limit(info.config().get_nfa_size_limit())
      .          .          .          .                       .shrink(false)
      .          .          .          .                       .which_captures(info.config().get_which_captures())
      .          .          .          .                       .look_matcher(lookm);
    162 ( 0.00%) .          .          .                   let nfa = thompson::Compiler::new()
      .          .          .          .                       .configure(thompson_config.clone())
      .          .          .          .                       .build_many_from_hir(hirs)
     81 ( 0.00%) .          .          .                       .map_err(BuildError::nfa)?;
8,446,963 ( 2.43%) 22,276 ( 2.75%) 1 ( 0.31%) .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> (81x)
      .          .          .          .                   // It's possible for the PikeVM or the BB to fail to build, even though
      .          .          .          .                   // at this point, we already have a full NFA in hand. They can fail
      .          .          .          .                   // when a Unicode word boundary is used but where Unicode word boundary
      .          .          .          .                   // support is disabled at compile time, thus making it impossible to
      .          .          .          .                   // match. (Construction can also fail if the NFA was compiled without
      .          .          .          .                   // captures, but we always enable that above.)
    324 ( 0.00%) .          .          .                   let pikevm = wrappers::PikeVM::new(&info, pre.clone(), &nfa)?;
 47,734 ( 0.01%) 111 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::PikeVM::new (81x)
      .          .          .          .                   let backtrack =
    729 ( 0.00%) .          .          .                       wrappers::BoundedBacktracker::new(&info, pre.clone(), &nfa)?;
 48,088 ( 0.01%) 111 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::BoundedBacktracker::new (81x)
      .          .          .          .                   // The onepass engine can of course fail to build, but we expect it to
      .          .          .          .                   // fail in many cases because it is an optimization that doesn't apply
      .          .          .          .                   // to all regexes. The 'OnePass' wrapper encapsulates this failure (and
      .          .          .          .                   // logs a message if it occurs).
     81 ( 0.00%) .          .          .                   let onepass = wrappers::OnePass::new(&info, &nfa);
2,513,072 ( 0.72%) 2,502 ( 0.31%) 2 ( 0.62%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::OnePass::new (81x)
      .          .          .          .                   // We try to encapsulate whether a particular regex engine should be
      .          .          .          .                   // used within each respective wrapper, but the DFAs need a reverse NFA
      .          .          .          .                   // to build itself, and we really do not want to build a reverse NFA if
      .          .          .          .                   // we know we aren't going to use the lazy DFA. So we do a config check
      .          .          .          .                   // up front, which is in practice the only way we won't try to use the
      .          .          .          .                   // DFA.
      .          .          .          .                   let (nfarev, hybrid, dfa) =
     81 ( 0.00%) .          .          .                       if !info.config().get_hybrid() && !info.config().get_dfa() {
      .          .          .          .                           (None, wrappers::Hybrid::none(), wrappers::DFA::none())
      .          .          .          .                       } else {
      .          .          .          .                           // FIXME: Technically, we don't quite yet KNOW that we need
      .          .          .          .                           // a reverse NFA. It's possible for the DFAs below to both
      .          .          .          .                           // fail to build just based on the forward NFA. In which case,
      .          .          .          .                           // building the reverse NFA was totally wasted work. But...
      .          .          .          .                           // fixing this requires breaking DFA construction apart into
      .          .          .          .                           // two pieces: one for the forward part and another for the
      .          .          .          .                           // reverse part. Quite annoying. Making it worse, when building
      .          .          .          .                           // both DFAs fails, it's quite likely that the NFA is large and
      .          .          .          .                           // that it will take quite some time to build the reverse NFA
      .          .          .          .                           // too. So... it's really probably worth it to do this!
    162 ( 0.00%) .          .          .                           let nfarev = thompson::Compiler::new()
      .          .          .          .                               // Currently, reverse NFAs don't support capturing groups,
      .          .          .          .                               // so we MUST disable them. But even if we didn't have to,
      .          .          .          .                               // we would, because nothing in this crate does anything
      .          .          .          .                               // useful with capturing groups in reverse. And of course,
      .          .          .          .                               // the lazy DFA ignores capturing groups in all cases.
      .          .          .          .                               .configure(
      .          .          .          .                                   thompson_config
      .          .          .          .                                       .clone()
      .          .          .          .                                       .which_captures(WhichCaptures::None)
      .          .          .          .                                       .reverse(true),
      .          .          .          .                               )
      .          .          .          .                               .build_many_from_hir(hirs)
     81 ( 0.00%) .          .          .                               .map_err(BuildError::nfa)?;
3,079,197 ( 0.89%) 15,509 ( 1.91%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> (81x)
      .          .          .          .                           let dfa = if !info.config().get_dfa() {
      .          .          .          .                               wrappers::DFA::none()
      .          .          .          .                           } else {
      .          .          .          .                               wrappers::DFA::new(&info, pre.clone(), &nfa, &nfarev)
      .          .          .          .                           };
     81 ( 0.00%) .          .          .                           let hybrid = if !info.config().get_hybrid() {
      .          .          .          .                               wrappers::Hybrid::none()
      .          .          .          .                           } else if dfa.is_some() {
      .          .          .          .                               debug!("skipping lazy DFA because we have a full DFA");
      .          .          .          .                               wrappers::Hybrid::none()
      .          .          .          .                           } else {
     81 ( 0.00%) .          .          .                               wrappers::Hybrid::new(&info, pre.clone(), &nfa, &nfarev)
1,177,206 ( 0.34%) 606 ( 0.07%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::new (81x)
      .          .          .          .                           };
 23,976 ( 0.01%) .          .          .                           (Some(nfarev), hybrid, dfa)
      .          .          .          .                       };
      .          .          .          .                   Ok(Core {
      .          .          .          .                       info,
      .          .          .          .                       pre,
      .          .          .          .                       nfa,
      .          .          .          .                       nfarev,
      .          .          .          .                       pikevm,
    648 ( 0.00%) .          .          .                       backtrack,
      .          .          .          .                       onepass,
      .          .          .          .                       hybrid,
      .          .          .          .                       dfa,
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn try_search_mayfail(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .               ) -> Option<Result<Option<Match>, RetryFailError>> {
     45 ( 0.00%) .          .          .                   if let Some(e) = self.dfa.get(input) {
      .          .          .          .                       trace!("using full DFA for search at {:?}", input.get_span());
      .          .          .          .                       Some(e.try_search(input))
     45 ( 0.00%) .          .          .                   } else if let Some(e) = self.hybrid.get(input) {
      .          .          .          .                       trace!("using lazy DFA for search at {:?}", input.get_span());
      .          .          .          .                       Some(e.try_search(&mut cache.hybrid, input))
      .          .          .          .                   } else {
      .          .          .          .                       None
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn search_nofail(
-- line 566 ----------------------------------------
-- line 602 ----------------------------------------
      .          .          .          .                   // Only the lazy/full DFA returns half-matches, since the DFA requires
      .          .          .          .                   // a reverse scan to find the start position. These fallback regex
      .          .          .          .                   // engines can find the start and end in a single pass, so we just do
      .          .          .          .                   // that and throw away the start offset to conform to the API.
      .          .          .          .                   let m = self.search_nofail(cache, input)?;
      .          .          .          .                   Some(HalfMatch::new(m.pattern(), m.end()))
      .          .          .          .               }
      .          .          .          .           
     72 ( 0.00%) .          .          .               fn search_slots_nofail(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .                   slots: &mut [Option<NonMaxUsize>],
      .          .          .          .               ) -> Option<PatternID> {
      1 ( 0.00%) .          .          .                   if let Some(ref e) = self.onepass.get(input) {
      .          .          .          .                       trace!(
      .          .          .          .                           "using OnePass for capture search at {:?}",
      .          .          .          .                           input.get_span()
      .          .          .          .                       );
      1 ( 0.00%) .          .          .                       e.search_slots(&mut cache.onepass, input, slots)
      .          .          .          .                   } else if let Some(ref e) = self.backtrack.get(input) {
      .          .          .          .                       trace!(
      .          .          .          .                           "using BoundedBacktracker for capture search at {:?}",
      .          .          .          .                           input.get_span()
      .          .          .          .                       );
      5 ( 0.00%) .          .          .                       e.search_slots(&mut cache.backtrack, input, slots)
      .          .          .          .                   } else {
      .          .          .          .                       trace!(
      .          .          .          .                           "using PikeVM for capture search at {:?}",
      .          .          .          .                           input.get_span()
      .          .          .          .                       );
      .          .          .          .                       let e = self.pikevm.get();
      .          .          .          .                       e.search_slots(&mut cache.pikevm, input, slots)
      .          .          .          .                   }
     60 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn is_match_nofail(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
      .          .          .          .                   if let Some(ref e) = self.onepass.get(input) {
      .          .          .          .                       trace!(
      .          .          .          .                           "using OnePass for is-match search at {:?}",
      .          .          .          .                           input.get_span()
      .          .          .          .                       );
      .          .          .          .                       e.search_slots(&mut cache.onepass, input, &mut []).is_some()
-- line 644 ----------------------------------------
-- line 654 ----------------------------------------
      .          .          .          .                           input.get_span()
      .          .          .          .                       );
      .          .          .          .                       let e = self.pikevm.get();
      .          .          .          .                       e.is_match(&mut cache.pikevm, input)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn is_capture_search_needed(&self, slots_len: usize) -> bool {
     82 ( 0.00%) .          .          .                   slots_len > self.nfa.group_info().implicit_slot_len()
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Strategy for Core {
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn group_info(&self) -> &GroupInfo {
      .          .          .          .                   self.nfa.group_info()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
    294 ( 0.00%) .          .          .               fn create_cache(&self) -> Cache {
     11 ( 0.00%) .          .          .                   Cache {
      .          .          .          .                       capmatches: Captures::all(self.group_info().clone()),
      .          .          .          .                       pikevm: self.pikevm.create_cache(),
      .          .          .          .                       backtrack: self.backtrack.create_cache(),
      .          .          .          .                       onepass: self.onepass.create_cache(),
    212 ( 0.00%) .          .          .                       hybrid: self.hybrid.create_cache(),
573,708 ( 0.17%) 352 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::create_cache (11x)
      .          .          .          .                       revhybrid: wrappers::ReverseHybridCache::none(),
      .          .          .          .                   }
    378 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn reset_cache(&self, cache: &mut Cache) {
      .          .          .          .                   cache.pikevm.reset(&self.pikevm);
      .          .          .          .                   cache.backtrack.reset(&self.backtrack);
      .          .          .          .                   cache.onepass.reset(&self.onepass);
      .          .          .          .                   cache.hybrid.reset(&self.hybrid);
      .          .          .          .               }
-- line 690 ----------------------------------------
-- line 788 ----------------------------------------
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   } else {
      .          .          .          .                       self.is_match_nofail(cache, input)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
    552 ( 0.00%) .          .          .               fn search_slots(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .                   slots: &mut [Option<NonMaxUsize>],
      .          .          .          .               ) -> Option<PatternID> {
      .          .          .          .                   // Even if the regex has explicit capture groups, if the caller didn't
      .          .          .          .                   // provide any explicit slots, then it doesn't make sense to try and do
      .          .          .          .                   // extra work to get offsets for those slots. Ideally the caller should
      .          .          .          .                   // realize this and not call this routine in the first place, but alas,
      .          .          .          .                   // we try to save the caller from themselves if they do.
     46 ( 0.00%) .          .          .                   if !self.is_capture_search_needed(slots.len()) {
      .          .          .          .                       trace!("asked for slots unnecessarily, trying fast path");
      .          .          .          .                       let m = self.search(cache, input)?;
      .          .          .          .                       copy_match_to_slots(m, slots);
      .          .          .          .                       return Some(m.pattern());
      .          .          .          .                   }
      .          .          .          .                   // If the onepass DFA is available for this search (which only happens
      .          .          .          .                   // when it's anchored), then skip running a fallible DFA. The onepass
      .          .          .          .                   // DFA isn't as fast as a full or lazy DFA, but it is typically quite
-- line 815 ----------------------------------------
-- line 818 ----------------------------------------
      .          .          .          .                   //
      .          .          .          .                   // We still theorize that it's better to do a full/lazy DFA scan, even
      .          .          .          .                   // when it's anchored, because it's usually much faster and permits us
      .          .          .          .                   // to say "no match" much more quickly. This does hurt the case of,
      .          .          .          .                   // say, parsing each line in a log file into capture groups, because
      .          .          .          .                   // in that case, the line always matches. So the lazy DFA scan is
      .          .          .          .                   // usually just wasted work. But, the lazy DFA is usually quite fast
      .          .          .          .                   // and doesn't cost too much here.
     46 ( 0.00%) .          .          .                   if self.onepass.get(&input).is_some() {
      .          .          .          .                       return self.search_slots_nofail(cache, &input, slots);
      .          .          .          .                   }
      .          .          .          .                   let m = match self.try_search_mayfail(cache, input) {
      .          .          .          .                       Some(Ok(Some(m))) => m,
      .          .          .          .                       Some(Ok(None)) => return None,
      .          .          .          .                       Some(Err(_err)) => {
      .          .          .          .                           trace!("fast capture search failed: {}", _err);
      .          .          .          .                           return self.search_slots_nofail(cache, input, slots);
-- line 834 ----------------------------------------
-- line 847 ----------------------------------------
      .          .          .          .                       m.start(),
      .          .          .          .                       m.end(),
      .          .          .          .                   );
      .          .          .          .                   let input = input
      .          .          .          .                       .clone()
      .          .          .          .                       .span(m.start()..m.end())
      .          .          .          .                       .anchored(Anchored::Pattern(m.pattern()));
      .          .          .          .                   Some(
     20 ( 0.00%) .          .          .                       self.search_slots_nofail(cache, &input, slots)
 15,250 ( 0.00%) 6 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/strategy.rs:regex_automata::meta::strategy::Core::search_slots_nofail (5x)
      .          .          .          .                           .expect("should find a match"),
      .          .          .          .                   )
    368 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn which_overlapping_matches(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .                   patset: &mut PatternSet,
      .          .          .          .               ) {
-- line 866 ----------------------------------------
-- line 902 ----------------------------------------
      .          .          .          .           
      .          .          .          .           #[derive(Debug)]
      .          .          .          .           struct ReverseAnchored {
      .          .          .          .               core: Core,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ReverseAnchored {
      .          .          .          .               fn new(core: Core) -> Result<ReverseAnchored, Core> {
     81 ( 0.00%) .          .          .                   if !core.info.is_always_anchored_end() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse anchored optimization because \
      .          .          .          .           				 the regex is not always anchored at the end"
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   // Note that the caller can still request an anchored search even when
      .          .          .          .                   // the regex isn't anchored at the start. We detect that case in the
-- line 918 ----------------------------------------
-- line 977 ----------------------------------------
      .          .          .          .           // at the end (or else 'ReverseAnchored' won't be built). We don't check that
      .          .          .          .           // here because the 'Regex' wrapper actually does that for us in all cases.
      .          .          .          .           // Thus, in this impl, we can actually assume that the end position in 'input'
      .          .          .          .           // is equivalent to the length of the haystack.
      .          .          .          .           impl Strategy for ReverseAnchored {
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn group_info(&self) -> &GroupInfo {
      .          .          .          .                   self.core.group_info()
     72 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn create_cache(&self) -> Cache {
      .          .          .          .                   self.core.create_cache()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn reset_cache(&self, cache: &mut Cache) {
-- line 993 ----------------------------------------
-- line 1115 ----------------------------------------
      .          .          .          .           #[derive(Debug)]
      .          .          .          .           struct ReverseSuffix {
      .          .          .          .               core: Core,
      .          .          .          .               pre: Prefilter,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ReverseSuffix {
      .          .          .          .               fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseSuffix, Core> {
     81 ( 0.00%) .          .          .                   if !core.info.config().get_auto_prefilter() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse suffix optimization because \
      .          .          .          .                            automatic prefilters are disabled"
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   // Like the reverse inner optimization, we don't do this for regexes
      .          .          .          .                   // that are always anchored. It could lead to scanning too much, but
-- line 1131 ----------------------------------------
-- line 1137 ----------------------------------------
      .          .          .          .                   // do another forward scan to find the end position.)
      .          .          .          .                   //
      .          .          .          .                   // Note that the caller can still request an anchored search even
      .          .          .          .                   // when the regex isn't anchored. We detect that case in the search
      .          .          .          .                   // routines below and just fallback to the core engine. Currently this
      .          .          .          .                   // optimization assumes all searches are unanchored, so if we do want
      .          .          .          .                   // to enable this optimization for anchored searches, it will need a
      .          .          .          .                   // little work to support it.
    210 ( 0.00%) .          .          .                   if core.info.is_always_anchored_start() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse suffix optimization because \
      .          .          .          .           				 the regex is always anchored at the start",
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   // Only DFAs can do reverse searches (currently), so we need one of
      .          .          .          .                   // them in order to do this optimization. It's possible (although
-- line 1153 ----------------------------------------
-- line 1162 ----------------------------------------
      .          .          .          .                   if core.pre.as_ref().map_or(false, |p| p.is_fast()) {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse suffix optimization because \
      .          .          .          .           				 we already have a prefilter that we think is fast"
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   let kind = core.info.config().get_match_kind();
     13 ( 0.00%) .          .          .                   let suffixes = crate::util::prefilter::suffixes(kind, hirs);
2,469,073 ( 0.71%) 5,221 ( 0.64%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/prefilter/mod.rs:regex_automata::util::prefilter::suffixes (13x)
     25 ( 0.00%) .          .          .                   let lcs = match suffixes.longest_common_suffix() {
      .          .          .          .                       None => {
      .          .          .          .                           debug!(
      .          .          .          .                               "skipping reverse suffix optimization because \
      .          .          .          .                                a longest common suffix could not be found",
      .          .          .          .                           );
      .          .          .          .                           return Err(core);
      .          .          .          .                       }
      .          .          .          .                       Some(lcs) if lcs.is_empty() => {
-- line 1179 ----------------------------------------
-- line 1503 ----------------------------------------
      .          .          .          .               preinner: Prefilter,
      .          .          .          .               nfarev: NFA,
      .          .          .          .               hybrid: wrappers::ReverseHybrid,
      .          .          .          .               dfa: wrappers::ReverseDFA,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ReverseInner {
      .          .          .          .               fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseInner, Core> {
     81 ( 0.00%) .          .          .                   if !core.info.config().get_auto_prefilter() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse inner optimization because \
      .          .          .          .                            automatic prefilters are disabled"
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   // Currently we hard-code the assumption of leftmost-first match
      .          .          .          .                   // semantics. This isn't a huge deal because 'all' semantics tend to
      .          .          .          .                   // only be used for forward overlapping searches with multiple regexes,
      .          .          .          .                   // and this optimization only supports a single pattern at the moment.
     81 ( 0.00%) .          .          .                   if core.info.config().get_match_kind() != MatchKind::LeftmostFirst {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse inner optimization because \
      .          .          .          .           				 match kind is {:?} but this only supports leftmost-first",
      .          .          .          .                           core.info.config().get_match_kind(),
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   // It's likely that a reverse inner scan has too much overhead for it
-- line 1530 ----------------------------------------
-- line 1537 ----------------------------------------
      .          .          .          .                   // or reject, which is a fair bit of work.
      .          .          .          .                   //
      .          .          .          .                   // Note that the caller can still request an anchored search even
      .          .          .          .                   // when the regex isn't anchored. We detect that case in the search
      .          .          .          .                   // routines below and just fallback to the core engine. Currently this
      .          .          .          .                   // optimization assumes all searches are unanchored, so if we do want
      .          .          .          .                   // to enable this optimization for anchored searches, it will need a
      .          .          .          .                   // little work to support it.
    162 ( 0.00%) .          .          .                   if core.info.is_always_anchored_start() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse inner optimization because \
      .          .          .          .           				 the regex is always anchored at the start",
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   // Only DFAs can do reverse searches (currently), so we need one of
      .          .          .          .                   // them in order to do this optimization. It's possible (although
      .          .          .          .                   // pretty unlikely) that we have neither and need to give up.
     16 ( 0.00%) .          .          .                   if !core.hybrid.is_some() && !core.dfa.is_some() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse inner optimization because \
      .          .          .          .           				 we don't have a lazy DFA or a full DFA"
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   if core.pre.as_ref().map_or(false, |p| p.is_fast()) {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse inner optimization because \
      .          .          .          .           				 we already have a prefilter that we think is fast"
      .          .          .          .                       );
      3 ( 0.00%) .          .          .                       return Err(core);
      .          .          .          .                   } else if core.pre.is_some() {
      .          .          .          .                       debug!(
      .          .          .          .                           "core engine has a prefix prefilter, but it is \
      .          .          .          .                            probably not fast, so continuing with attempt to \
      .          .          .          .                            use reverse inner prefilter"
      .          .          .          .                       );
      .          .          .          .                   }
     39 ( 0.00%) .          .          .                   let (concat_prefix, preinner) = match reverse_inner::extract(hirs) {
31,332,161 ( 9.02%) 58,077 ( 7.17%) 21 ( 6.48%) .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::extract (13x)
    130 ( 0.00%) .          .          .                       Some(x) => x,
      .          .          .          .                       // N.B. the 'extract' function emits debug messages explaining
      .          .          .          .                       // why we bailed out here.
      .          .          .          .                       None => return Err(core),
      .          .          .          .                   };
      .          .          .          .                   debug!("building reverse NFA for prefix before inner literal");
      .          .          .          .                   let mut lookm = LookMatcher::new();
      .          .          .          .                   lookm.set_line_terminator(core.info.config().get_line_terminator());
      .          .          .          .                   let thompson_config = thompson::Config::new()
      .          .          .          .                       .reverse(true)
      .          .          .          .                       .utf8(core.info.config().get_utf8_empty())
      .          .          .          .                       .nfa_size_limit(core.info.config().get_nfa_size_limit())
      .          .          .          .                       .shrink(false)
      .          .          .          .                       .which_captures(WhichCaptures::None)
      .          .          .          .                       .look_matcher(lookm);
     52 ( 0.00%) .          .          .                   let result = thompson::Compiler::new()
  4,225 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::new (13x)
    351 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::configure (13x)
      .          .          .          .                       .configure(thompson_config)
     26 ( 0.00%) .          .          .                       .build_from_hir(&concat_prefix);
 43,984 ( 0.01%) 228 ( 0.03%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> (13x)
     26 ( 0.00%) .          .          .                   let nfarev = match result {
     26 ( 0.00%) .          .          .                       Ok(nfarev) => nfarev,
      .          .          .          .                       Err(_err) => {
      .          .          .          .                           debug!(
      .          .          .          .                               "skipping reverse inner optimization because the \
      .          .          .          .           					 reverse NFA failed to build: {}",
      .          .          .          .                               _err,
      .          .          .          .                           );
      .          .          .          .                           return Err(core);
      .          .          .          .                       }
      .          .          .          .                   };
      .          .          .          .                   debug!("building reverse DFA for prefix before inner literal");
      .          .          .          .                   let dfa = if !core.info.config().get_dfa() {
      .          .          .          .                       wrappers::ReverseDFA::none()
      .          .          .          .                   } else {
      .          .          .          .                       wrappers::ReverseDFA::new(&core.info, &nfarev)
      .          .          .          .                   };
     13 ( 0.00%) .          .          .                   let hybrid = if !core.info.config().get_hybrid() {
      .          .          .          .                       wrappers::ReverseHybrid::none()
      .          .          .          .                   } else if dfa.is_some() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping lazy DFA for reverse inner optimization \
      .          .          .          .           				 because we have a full DFA"
      .          .          .          .                       );
      .          .          .          .                       wrappers::ReverseHybrid::none()
      .          .          .          .                   } else {
     13 ( 0.00%) .          .          .                       wrappers::ReverseHybrid::new(&core.info, &nfarev)
 87,088 ( 0.03%) 39 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::new (13x)
      .          .          .          .                   };
    351 ( 0.00%) .          .          .                   Ok(ReverseInner { core, preinner, nfarev, hybrid, dfa })
  2,626 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (26x)
     26 ( 0.00%) .          .          .               }
231,560 ( 0.07%) 1,123 ( 0.14%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (13x)
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn try_search_full(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .               ) -> Result<Option<Match>, RetryError> {
      .          .          .          .                   let mut span = input.get_span();
      .          .          .          .                   let mut min_match_start = 0;
      .          .          .          .                   let mut min_pre_start = 0;
      .          .          .          .                   loop {
     24 ( 0.00%) .          .          .                       let litmatch = match self.preinner.find(input.haystack(), span) {
      .          .          .          .                           None => return Ok(None),
      .          .          .          .                           Some(span) => span,
      .          .          .          .                       };
      .          .          .          .                       if litmatch.start < min_pre_start {
      .          .          .          .                           trace!(
      .          .          .          .                               "found inner prefilter match at {:?}, which starts \
      .          .          .          .           					 before the end of the last forward scan at {}, \
      .          .          .          .           					 quitting to avoid quadratic behavior",
-- line 1643 ----------------------------------------
-- line 1746 ----------------------------------------
      .          .          .          .                   } else {
      .          .          .          .                       unreachable!("ReverseInner always has a DFA")
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Strategy for ReverseInner {
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
     14 ( 0.00%) .          .          .               fn group_info(&self) -> &GroupInfo {
      .          .          .          .                   self.core.group_info()
     14 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
     77 ( 0.00%) .          .          .               fn create_cache(&self) -> Cache {
      .          .          .          .                   let mut cache = self.core.create_cache();
     33 ( 0.00%) .          .          .                   cache.revhybrid = self.hybrid.create_cache();
147,668 ( 0.04%) 139 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::create_cache (11x)
     44 ( 0.00%) .          .          .                   cache
  1,771 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (11x)
     99 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn reset_cache(&self, cache: &mut Cache) {
      .          .          .          .                   self.core.reset_cache(cache);
      .          .          .          .                   cache.revhybrid.reset(&self.hybrid);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn is_accelerated(&self) -> bool {
-- line 1771 ----------------------------------------
-- line 1835 ----------------------------------------
      .          .          .          .                           self.core.is_match_nofail(cache, input)
      .          .          .          .                       }
      .          .          .          .                       Ok(None) => false,
      .          .          .          .                       Ok(Some(_)) => true,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
    144 ( 0.00%) .          .          .               fn search_slots(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .                   slots: &mut [Option<NonMaxUsize>],
      .          .          .          .               ) -> Option<PatternID> {
     12 ( 0.00%) .          .          .                   if input.get_anchored().is_anchored() {
      .          .          .          .                       return self.core.search_slots(cache, input, slots);
      .          .          .          .                   }
     12 ( 0.00%) .          .          .                   if !self.core.is_capture_search_needed(slots.len()) {
      .          .          .          .                       trace!("asked for slots unnecessarily, trying fast path");
      .          .          .          .                       let m = self.search(cache, input)?;
      .          .          .          .                       copy_match_to_slots(m, slots);
      .          .          .          .                       return Some(m.pattern());
      .          .          .          .                   }
      .          .          .          .                   let m = match self.try_search_full(cache, input) {
      .          .          .          .                       Err(RetryError::Quadratic(_err)) => {
      .          .          .          .                           trace!("reverse inner captures optimization failed: {}", _err);
-- line 1860 ----------------------------------------
-- line 1873 ----------------------------------------
      .          .          .          .                       m.start(),
      .          .          .          .                       m.end(),
      .          .          .          .                   );
      .          .          .          .                   let input = input
      .          .          .          .                       .clone()
      .          .          .          .                       .span(m.start()..m.end())
      .          .          .          .                       .anchored(Anchored::Pattern(m.pattern()));
      .          .          .          .                   self.core.search_slots_nofail(cache, &input, slots)
     96 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn which_overlapping_matches(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .                   patset: &mut PatternSet,
      .          .          .          .               ) {
-- line 1889 ----------------------------------------

625,522 ( 0.18%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/meta/strategy.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 84 ----------------------------------------
     .          .          .          .           /// `state` corresponds to the current DFA state on which one wants to compute
     .          .          .          .           /// the transition for the input `unit`.
     .          .          .          .           ///
     .          .          .          .           /// `empty_builder` corresponds to the builder allocation to use to produce a
     .          .          .          .           /// complete `StateBuilderNFA` state. If the state is not needed (or is already
     .          .          .          .           /// cached), then it can be cleared and reused without needing to create a new
     .          .          .          .           /// `State`. The `StateBuilderNFA` state returned is final and ready to be
     .          .          .          .           /// turned into a `State` if necessary.
 2,398 ( 0.00%) .          .          .           pub(crate) fn next(
     .          .          .          .               nfa: &thompson::NFA,
     .          .          .          .               match_kind: MatchKind,
     .          .          .          .               sparses: &mut SparseSets,
     .          .          .          .               stack: &mut Vec<StateID>,
     .          .          .          .               state: &State,
     .          .          .          .               unit: alphabet::Unit,
     .          .          .          .               empty_builder: StateBuilderEmpty,
     .          .          .          .           ) -> StateBuilderNFA {
-- line 100 ----------------------------------------
-- line 123 ----------------------------------------
     .          .          .          .               });
     .          .          .          .           
     .          .          .          .               // Compute look-ahead assertions originating from the current state. Based
     .          .          .          .               // on the input unit we're transitioning over, some additional set of
     .          .          .          .               // assertions may be true. Thus, we re-compute this state's epsilon closure
     .          .          .          .               // (but only if necessary). Notably, when we build a DFA state initially,
     .          .          .          .               // we don't enable any look-ahead assertions because we don't know whether
     .          .          .          .               // they're true or not at that point.
   218 ( 0.00%) .          .          .               if !state.look_need().is_empty() {
     .          .          .          .                   // Add look-ahead assertions that are now true based on the current
     .          .          .          .                   // input unit.
     .          .          .          .                   let mut look_have = state.look_have().clone();
   280 ( 0.00%) .          .          .                   match unit.as_u8() {
     .          .          .          .                       Some(b'\r') => {
     .          .          .          .                           if !rev || !state.is_half_crlf() {
     .          .          .          .                               look_have = look_have.insert(Look::EndCRLF);
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                       Some(b'\n') => {
     .          .          .          .                           if rev || !state.is_half_crlf() {
     .          .          .          .                               look_have = look_have.insert(Look::EndCRLF);
-- line 143 ----------------------------------------
-- line 146 ----------------------------------------
     .          .          .          .                       Some(_) => {}
     .          .          .          .                       None => {
     .          .          .          .                           look_have = look_have
     .          .          .          .                               .insert(Look::End)
     .          .          .          .                               .insert(Look::EndLF)
     .          .          .          .                               .insert(Look::EndCRLF);
     .          .          .          .                       }
     .          .          .          .                   }
    80 ( 0.00%) .          .          .                   if unit.is_byte(lookm.get_line_terminator()) {
     .          .          .          .                       look_have = look_have.insert(Look::EndLF);
     .          .          .          .                   }
    40 ( 0.00%) .          .          .                   if state.is_half_crlf()
     .          .          .          .                       && ((rev && !unit.is_byte(b'\r'))
     .          .          .          .                           || (!rev && !unit.is_byte(b'\n')))
     .          .          .          .                   {
     .          .          .          .                       look_have = look_have.insert(Look::StartCRLF);
     .          .          .          .                   }
   200 ( 0.00%) .          .          .                   if state.is_from_word() == unit.is_word_byte() {
     .          .          .          .                       look_have = look_have
     .          .          .          .                           .insert(Look::WordAsciiNegate)
     .          .          .          .                           .insert(Look::WordUnicodeNegate);
     .          .          .          .                   } else {
     .          .          .          .                       look_have =
     .          .          .          .                           look_have.insert(Look::WordAscii).insert(Look::WordUnicode);
     .          .          .          .                   }
    41 ( 0.00%) .          .          .                   if !unit.is_word_byte() {
     .          .          .          .                       look_have = look_have
     .          .          .          .                           .insert(Look::WordEndHalfAscii)
     .          .          .          .                           .insert(Look::WordEndHalfUnicode);
     .          .          .          .                   }
   119 ( 0.00%) .          .          .                   if state.is_from_word() && !unit.is_word_byte() {
     .          .          .          .                       look_have = look_have
     .          .          .          .                           .insert(Look::WordEndAscii)
     .          .          .          .                           .insert(Look::WordEndUnicode);
    40 ( 0.00%) .          .          .                   } else if !state.is_from_word() && unit.is_word_byte() {
     .          .          .          .                       look_have = look_have
     .          .          .          .                           .insert(Look::WordStartAscii)
     .          .          .          .                           .insert(Look::WordStartUnicode);
     .          .          .          .                   }
     .          .          .          .                   // If we have new assertions satisfied that are among the set of
     .          .          .          .                   // assertions that exist in this state (that is, just because we added
     .          .          .          .                   // an EndLF assertion above doesn't mean there is an EndLF conditional
     .          .          .          .                   // epsilon transition in this state), then we re-compute this state's
     .          .          .          .                   // epsilon closure using the updated set of assertions.
     .          .          .          .                   //
     .          .          .          .                   // Note that since our DFA states omit unconditional epsilon
     .          .          .          .                   // transitions, this check is necessary for correctness. If we re-did
     .          .          .          .                   // the epsilon closure below needlessly, it could change based on the
     .          .          .          .                   // fact that we omitted epsilon states originally.
    40 ( 0.00%) .          .          .                   if !look_have
     .          .          .          .                       .subtract(state.look_have())
     .          .          .          .                       .intersect(state.look_need())
     .          .          .          .                       .is_empty()
     .          .          .          .                   {
     .          .          .          .                       for nfa_id in sparses.set1.iter() {
     .          .          .          .                           epsilon_closure(
     .          .          .          .                               nfa,
     .          .          .          .                               nfa_id,
-- line 203 ----------------------------------------
-- line 212 ----------------------------------------
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               // Convert our empty builder into one that can record assertions and match
     .          .          .          .               // pattern IDs.
     .          .          .          .               let mut builder = empty_builder.into_matches();
     .          .          .          .               // Set whether the StartLF look-behind assertion is true for this
     .          .          .          .               // transition or not. The look-behind assertion for ASCII word boundaries
     .          .          .          .               // is handled below.
   218 ( 0.00%) .          .          .               if nfa.look_set_any().contains_anchor_line()
     .          .          .          .                   && unit.is_byte(lookm.get_line_terminator())
     .          .          .          .               {
     .          .          .          .                   // Why only handle StartLF here and not Start? That's because Start
     .          .          .          .                   // can only impact the starting state, which is special cased in
     .          .          .          .                   // start state handling.
     .          .          .          .                   builder.set_look_have(|have| have.insert(Look::StartLF));
     .          .          .          .               }
     .          .          .          .               // We also need to add StartCRLF to our assertions too, if we can. This
     .          .          .          .               // is unfortunately a bit more complicated, because it depends on the
     .          .          .          .               // direction of the search. In the forward direction, ^ matches after a
     .          .          .          .               // \n, but in the reverse direction, ^ only matches after a \r. (This is
     .          .          .          .               // further complicated by the fact that reverse a regex means changing a ^
     .          .          .          .               // to a $ and vice versa.)
   218 ( 0.00%) .          .          .               if nfa.look_set_any().contains_anchor_crlf()
     .          .          .          .                   && ((rev && unit.is_byte(b'\r')) || (!rev && unit.is_byte(b'\n')))
     .          .          .          .               {
     .          .          .          .                   builder.set_look_have(|have| have.insert(Look::StartCRLF));
     .          .          .          .               }
     .          .          .          .               // And also for the start-half word boundary assertions. As long as the
     .          .          .          .               // look-behind byte is not a word char, then the assertions are satisfied.
     .          .          .          .               if nfa.look_set_any().contains_word() && !unit.is_word_byte() {
     .          .          .          .                   builder.set_look_have(|have| {
     .          .          .          .                       have.insert(Look::WordStartHalfAscii)
     .          .          .          .                           .insert(Look::WordStartHalfUnicode)
     .          .          .          .                   });
     .          .          .          .               }
     .          .          .          .               for nfa_id in sparses.set1.iter() {
   988 ( 0.00%) .          .          .                   match *nfa.state(nfa_id) {
     .          .          .          .                       thompson::State::Union { .. }
     .          .          .          .                       | thompson::State::BinaryUnion { .. }
     .          .          .          .                       | thompson::State::Fail
     .          .          .          .                       | thompson::State::Look { .. }
     .          .          .          .                       | thompson::State::Capture { .. } => {}
     3 ( 0.00%) .          .          .                       thompson::State::Match { pattern_id } => {
     .          .          .          .                           // Notice here that we are calling the NEW state a match
     .          .          .          .                           // state if the OLD state we are transitioning from
     .          .          .          .                           // contains an NFA match state. This is precisely how we
     .          .          .          .                           // delay all matches by one byte and also what therefore
     .          .          .          .                           // guarantees that starting states cannot be match states.
     .          .          .          .                           //
     .          .          .          .                           // If we didn't delay matches by one byte, then whether
     .          .          .          .                           // a DFA is a matching state or not would be determined
-- line 262 ----------------------------------------
-- line 275 ----------------------------------------
     .          .          .          .                           //
     .          .          .          .                           // N.B. We delay matches by 1 byte as a way to hack 1-byte
     .          .          .          .                           // look-around into DFA searches. This lets us support ^, $
     .          .          .          .                           // and ASCII-only \b. The delay is also why we need a special
     .          .          .          .                           // "end-of-input" (EOI) sentinel and why we need to follow the
     .          .          .          .                           // EOI sentinel at the end of every search. This final EOI
     .          .          .          .                           // transition is necessary to report matches found at the end
     .          .          .          .                           // of a haystack.
     6 ( 0.00%) .          .          .                           builder.add_match_pattern_id(pattern_id);
    60 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/state.rs:regex_automata::util::determinize::state::StateBuilderMatches::add_match_pattern_id (3x)
     6 ( 0.00%) .          .          .                           if !match_kind.continue_past_first_match() {
     .          .          .          .                               break;
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                       thompson::State::ByteRange { ref trans } => {
   954 ( 0.00%) .          .          .                           if trans.matches_unit(unit) {
     .          .          .          .                               epsilon_closure(
     .          .          .          .                                   nfa,
     .          .          .          .                                   trans.next,
     .          .          .          .                                   builder.look_have(),
     .          .          .          .                                   stack,
     .          .          .          .                                   &mut sparses.set2,
     .          .          .          .                               );
     .          .          .          .                           }
-- line 297 ----------------------------------------
-- line 332 ----------------------------------------
     .          .          .          .               // a quit byte is seen. Consuming until EOI isn't a correctness problem,
     .          .          .          .               // but a (serious) perf problem. Hitting a quit byte, however, could be a
     .          .          .          .               // correctness problem since it could cause search routines to report an
     .          .          .          .               // error instead of a detected match once the quit state is entered. (The
     .          .          .          .               // search routine could be made to be a bit smarter by reporting a match
     .          .          .          .               // if one was detected once it enters a quit state (and indeed, the search
     .          .          .          .               // routines in this crate do just that), but it seems better to prevent
     .          .          .          .               // these things by construction if possible.)
   218 ( 0.00%) .          .          .               if !sparses.set2.is_empty() {
     .          .          .          .                   if nfa.look_set_any().contains_word() && unit.is_word_byte() {
     .          .          .          .                       builder.set_is_from_word();
     .          .          .          .                   }
   175 ( 0.00%) .          .          .                   if nfa.look_set_any().contains_anchor_crlf()
     .          .          .          .                       && ((rev && unit.is_byte(b'\n')) || (!rev && unit.is_byte(b'\r')))
     .          .          .          .                   {
     .          .          .          .                       builder.set_is_half_crlf();
     .          .          .          .                   }
     .          .          .          .               }
   654 ( 0.00%) .          .          .               let mut builder_nfa = builder.into_nfa();
   218 ( 0.00%) .          .          .               add_nfa_states(nfa, &sparses.set2, &mut builder_nfa);
24,097 ( 0.01%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs:regex_automata::util::determinize::add_nfa_states (218x)
   872 ( 0.00%) .          .          .               builder_nfa
 1,962 ( 0.00%) .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Compute the epsilon closure for the given NFA state. The epsilon closure
     .          .          .          .           /// consists of all NFA state IDs, including `start_nfa_id`, that can be
     .          .          .          .           /// reached from `start_nfa_id` without consuming any input. These state IDs
     .          .          .          .           /// are written to `set` in the order they are visited, but only if they are
     .          .          .          .           /// not already in `set`. `start_nfa_id` must be a valid state ID for the NFA
     .          .          .          .           /// given.
     .          .          .          .           ///
     .          .          .          .           /// `look_have` consists of the satisfied assertions at the current
     .          .          .          .           /// position. For conditional look-around epsilon transitions, these are
     .          .          .          .           /// only followed if they are satisfied by `look_have`.
     .          .          .          .           ///
     .          .          .          .           /// `stack` must have length 0. It is used as scratch space for depth first
     .          .          .          .           /// traversal. After returning, it is guaranteed that `stack` will have length
     .          .          .          .           /// 0.
 1,880 ( 0.00%) .          .          .           pub(crate) fn epsilon_closure(
     .          .          .          .               nfa: &thompson::NFA,
     .          .          .          .               start_nfa_id: StateID,
     .          .          .          .               look_have: LookSet,
     .          .          .          .               stack: &mut Vec<StateID>,
     .          .          .          .               set: &mut SparseSet,
     .          .          .          .           ) {
   235 ( 0.00%) .          .          .               assert!(stack.is_empty());
     .          .          .          .               // If this isn't an epsilon state, then the epsilon closure is always just
     .          .          .          .               // itself, so there's no need to spin up the machinery below to handle it.
   235 ( 0.00%) .          .          .               if !nfa.state(start_nfa_id).is_epsilon() {
     .          .          .          .                   set.insert(start_nfa_id);
     .          .          .          .                   return;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               stack.push(start_nfa_id);
     .          .          .          .               while let Some(mut id) = stack.pop() {
     .          .          .          .                   // In many cases, we can avoid stack operations when an NFA state only
     .          .          .          .                   // adds one new state to visit. In that case, we just set our ID to
-- line 387 ----------------------------------------
-- line 388 ----------------------------------------
     .          .          .          .                   // that state and mush on. We only use the stack when an NFA state
     .          .          .          .                   // introduces multiple new states to visit.
     .          .          .          .                   loop {
     .          .          .          .                       // Insert this NFA state, and if it's already in the set and thus
     .          .          .          .                       // already visited, then we can move on to the next one.
     .          .          .          .                       if !set.insert(id) {
     .          .          .          .                           break;
     .          .          .          .                       }
 1,150 ( 0.00%) .          .          .                       match *nfa.state(id) {
     .          .          .          .                           thompson::State::ByteRange { .. }
     .          .          .          .                           | thompson::State::Sparse { .. }
     .          .          .          .                           | thompson::State::Dense { .. }
     .          .          .          .                           | thompson::State::Fail
     .          .          .          .                           | thompson::State::Match { .. } => break,
     .          .          .          .                           thompson::State::Look { look, next } => {
    41 ( 0.00%) .          .          .                               if !look_have.contains(look) {
     .          .          .          .                                   break;
     .          .          .          .                               }
     .          .          .          .                               id = next;
     .          .          .          .                           }
     .          .          .          .                           thompson::State::Union { ref alternates } => {
    68 ( 0.00%) .          .          .                               id = match alternates.get(0) {
     .          .          .          .                                   None => break,
    34 ( 0.00%) .          .          .                                   Some(&id) => id,
     .          .          .          .                               };
     .          .          .          .                               // We need to process our alternates in order to preserve
     .          .          .          .                               // match preferences, so put the earliest alternates closer
     .          .          .          .                               // to the top of the stack.
     .          .          .          .                               stack.extend(alternates[1..].iter().rev());
     .          .          .          .                           }
   186 ( 0.00%) .          .          .                           thompson::State::BinaryUnion { alt1, alt2 } => {
     .          .          .          .                               id = alt1;
     .          .          .          .                               stack.push(alt2);
     .          .          .          .                           }
     .          .          .          .                           thompson::State::Capture { next, .. } => {
     .          .          .          .                               id = next;
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .               }
 1,880 ( 0.00%) .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Add the NFA state IDs in the given `set` to the given DFA builder state.
     .          .          .          .           /// The order in which states are added corresponds to the order in which they
     .          .          .          .           /// were added to `set`.
     .          .          .          .           ///
     .          .          .          .           /// The DFA builder state given should already have its complete set of match
     .          .          .          .           /// pattern IDs added (if any) and any look-behind assertions (StartLF, Start
     .          .          .          .           /// and whether this state is being generated for a transition over a word byte
-- line 436 ----------------------------------------
-- line 440 ----------------------------------------
     .          .          .          .           /// delayed by one byte. The things that should _not_ be set are look-ahead
     .          .          .          .           /// assertions (EndLF, End and whether the next byte is a word byte or not).
     .          .          .          .           /// The builder state should also not have anything in `look_need` set, as this
     .          .          .          .           /// routine will compute that for you.
     .          .          .          .           ///
     .          .          .          .           /// The given NFA should be able to resolve all identifiers in `set` to a
     .          .          .          .           /// particular NFA state. Additionally, `set` must have capacity equivalent
     .          .          .          .           /// to `nfa.len()`.
 2,072 ( 0.00%) .          .          .           pub(crate) fn add_nfa_states(
     .          .          .          .               nfa: &thompson::NFA,
     .          .          .          .               set: &SparseSet,
     .          .          .          .               builder: &mut StateBuilderNFA,
     .          .          .          .           ) {
     .          .          .          .               for nfa_id in set.iter() {
 2,486 ( 0.00%) .          .          .                   match *nfa.state(nfa_id) {
     .          .          .          .                       thompson::State::ByteRange { .. } => {
     .          .          .          .                           builder.add_nfa_state_id(nfa_id);
     .          .          .          .                       }
     .          .          .          .                       thompson::State::Sparse { .. } => {
     .          .          .          .                           builder.add_nfa_state_id(nfa_id);
     .          .          .          .                       }
     .          .          .          .                       thompson::State::Dense { .. } => {
     .          .          .          .                           builder.add_nfa_state_id(nfa_id);
     .          .          .          .                       }
    41 ( 0.00%) .          .          .                       thompson::State::Look { look, .. } => {
     .          .          .          .                           builder.add_nfa_state_id(nfa_id);
     .          .          .          .                           builder.set_look_need(|need| need.insert(look));
     .          .          .          .                       }
     .          .          .          .                       thompson::State::Union { .. }
     .          .          .          .                       | thompson::State::BinaryUnion { .. } => {
     .          .          .          .                           // Pure epsilon transitions don't need to be tracked as part
     .          .          .          .                           // of the DFA state. Tracking them is actually superfluous;
     .          .          .          .                           // they won't cause any harm other than making determinization
-- line 472 ----------------------------------------
-- line 568 ----------------------------------------
     .          .          .          .                           // match state. See 'next' for how this is handled.
     .          .          .          .                           builder.add_nfa_state_id(nfa_id);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .               // If we know this state contains no look-around assertions, then
     .          .          .          .               // there's no reason to track which look-around assertions were
     .          .          .          .               // satisfied when this state was created.
   518 ( 0.00%) .          .          .               if builder.look_need().is_empty() {
     .          .          .          .                   builder.set_look_have(|_| LookSet::empty());
     .          .          .          .               }
 2,072 ( 0.00%) .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Sets the appropriate look-behind assertions on the given state based on
     .          .          .          .           /// this starting configuration.
    41 ( 0.00%) .          .          .           pub(crate) fn set_lookbehind_from_start(
     .          .          .          .               nfa: &thompson::NFA,
     .          .          .          .               start: &Start,
     .          .          .          .               builder: &mut StateBuilderMatches,
     .          .          .          .           ) {
     .          .          .          .               let rev = nfa.is_reverse();
     .          .          .          .               let lineterm = nfa.look_matcher().get_line_terminator();
     .          .          .          .               let lookset = nfa.look_set_any();
    41 ( 0.00%) .          .          .               match *start {
     .          .          .          .                   Start::NonWordByte => {
     .          .          .          .                       if lookset.contains_word() {
     .          .          .          .                           builder.set_look_have(|have| {
     .          .          .          .                               have.insert(Look::WordStartHalfAscii)
     .          .          .          .                                   .insert(Look::WordStartHalfUnicode)
     .          .          .          .                           });
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   Start::WordByte => {
     .          .          .          .                       if lookset.contains_word() {
     .          .          .          .                           builder.set_is_from_word();
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   Start::Text => {
    41 ( 0.00%) .          .          .                       if lookset.contains_anchor_haystack() {
     .          .          .          .                           builder.set_look_have(|have| have.insert(Look::Start));
     .          .          .          .                       }
    41 ( 0.00%) .          .          .                       if lookset.contains_anchor_line() {
     .          .          .          .                           builder.set_look_have(|have| {
     .          .          .          .                               have.insert(Look::StartLF).insert(Look::StartCRLF)
     .          .          .          .                           });
     .          .          .          .                       }
     .          .          .          .                       if lookset.contains_word() {
     .          .          .          .                           builder.set_look_have(|have| {
     .          .          .          .                               have.insert(Look::WordStartHalfAscii)
     .          .          .          .                                   .insert(Look::WordStartHalfUnicode)
-- line 617 ----------------------------------------
-- line 674 ----------------------------------------
     .          .          .          .                               builder.set_look_have(|have| {
     .          .          .          .                                   have.insert(Look::WordStartHalfAscii)
     .          .          .          .                                       .insert(Look::WordStartHalfUnicode)
     .          .          .          .                               });
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .               }
    82 ( 0.00%) .          .          .           }

17,731 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/util/determinize/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/pattern.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 11 ----------------------------------------
    .          .          .          .           ///
    .          .          .          .           /// This collection of patterns is what is passed around to both execute
    .          .          .          .           /// searches and to construct the searchers themselves. Namely, this permits
    .          .          .          .           /// searches to avoid copying all of the patterns, and allows us to keep only
    .          .          .          .           /// one copy throughout all packed searchers.
    .          .          .          .           ///
    .          .          .          .           /// Note that this collection is not a set. The same pattern can appear more
    .          .          .          .           /// than once.
  528 ( 0.00%) .          .          .           #[derive(Clone, Debug)]
412,097 ( 0.12%) 2,747 ( 0.34%) .          .           => /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::clone::Clone>::clone (48x)
    .          .          .          .           pub(crate) struct Patterns {
    .          .          .          .               /// The match semantics supported by this collection of patterns.
    .          .          .          .               ///
    .          .          .          .               /// The match semantics determines the order of the iterator over patterns.
    .          .          .          .               /// For leftmost-first, patterns are provided in the same order as were
    .          .          .          .               /// provided by the caller. For leftmost-longest, patterns are provided in
    .          .          .          .               /// descending order of length, with ties broken by the order in which they
    .          .          .          .               /// were provided by the caller.
-- line 27 ----------------------------------------
-- line 50 ----------------------------------------
    .          .          .          .               /// Create a new collection of patterns for the given match semantics. The
    .          .          .          .               /// ID of each pattern is the index of the pattern at which it occurs in
    .          .          .          .               /// the `by_id` slice.
    .          .          .          .               ///
    .          .          .          .               /// If any of the patterns in the slice given are empty, then this panics.
    .          .          .          .               /// Similarly, if the number of patterns given is zero, then this also
    .          .          .          .               /// panics.
    .          .          .          .               pub(crate) fn new() -> Patterns {
  576 ( 0.00%) .          .          .                   Patterns {
    .          .          .          .                       kind: MatchKind::default(),
    .          .          .          .                       by_id: vec![],
    .          .          .          .                       order: vec![],
    .          .          .          .                       minimum_len: usize::MAX,
    .          .          .          .                       total_pattern_bytes: 0,
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Add a pattern to this collection.
    .          .          .          .               ///
    .          .          .          .               /// This panics if the pattern given is empty.
6,970 ( 0.00%) .          .          .               pub(crate) fn add(&mut self, bytes: &[u8]) {
1,394 ( 0.00%) .          .          .                   assert!(!bytes.is_empty());
2,788 ( 0.00%) .          .          .                   assert!(self.by_id.len() <= u16::MAX as usize);
    .          .          .          .           
    .          .          .          .                   let id = PatternID::new(self.by_id.len()).unwrap();
  180 ( 0.00%) .          .          .                   self.order.push(id);
    .          .          .          .                   self.by_id.push(bytes.to_vec());
2,788 ( 0.00%) .          .          .                   self.minimum_len = cmp::min(self.minimum_len, bytes.len());
1,394 ( 0.00%) .          .          .                   self.total_pattern_bytes += bytes.len();
8,364 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Set the match kind semantics for this collection of patterns.
    .          .          .          .               ///
    .          .          .          .               /// If the kind is not set, then the default is leftmost-first.
    .          .          .          .               pub(crate) fn set_match_kind(&mut self, kind: MatchKind) {
   48 ( 0.00%) .          .          .                   self.kind = kind;
   48 ( 0.00%) .          .          .                   match self.kind {
    .          .          .          .                       MatchKind::LeftmostFirst => {
    .          .          .          .                           self.order.sort();
    .          .          .          .                       }
    .          .          .          .                       MatchKind::LeftmostLongest => {
    .          .          .          .                           let (order, by_id) = (&mut self.order, &mut self.by_id);
    .          .          .          .                           order.sort_by(|&id1, &id2| {
    .          .          .          .                               by_id[id1].len().cmp(&by_id[id2].len()).reverse()
    .          .          .          .                           });
-- line 94 ----------------------------------------
-- line 96 ----------------------------------------
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Return the number of patterns in this collection.
    .          .          .          .               ///
    .          .          .          .               /// This is guaranteed to be greater than zero.
    .          .          .          .               pub(crate) fn len(&self) -> usize {
    .          .          .          .                   self.by_id.len()
2,788 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns true if and only if this collection of patterns is empty.
    .          .          .          .               pub(crate) fn is_empty(&self) -> bool {
    .          .          .          .                   self.len() == 0
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the approximate total amount of heap used by these patterns, in
    .          .          .          .               /// units of bytes.
-- line 112 ----------------------------------------
-- line 124 ----------------------------------------
    .          .          .          .                   self.order.clear();
    .          .          .          .                   self.minimum_len = usize::MAX;
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the length, in bytes, of the smallest pattern.
    .          .          .          .               ///
    .          .          .          .               /// This is guaranteed to be at least one.
    .          .          .          .               pub(crate) fn minimum_len(&self) -> usize {
1,285 ( 0.00%) .          .          .                   self.minimum_len
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the match semantics used by these patterns.
    .          .          .          .               pub(crate) fn match_kind(&self) -> &MatchKind {
    .          .          .          .                   &self.kind
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Return the pattern with the given identifier. If such a pattern does
-- line 140 ----------------------------------------
-- line 189 ----------------------------------------
    .          .          .          .               patterns: &'p Patterns,
    .          .          .          .               i: usize,
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'p> Iterator for PatternIter<'p> {
    .          .          .          .               type Item = (PatternID, Pattern<'p>);
    .          .          .          .           
    .          .          .          .               fn next(&mut self) -> Option<(PatternID, Pattern<'p>)> {
5,262 ( 0.00%) .          .          .                   if self.i >= self.patterns.len() {
    .          .          .          .                       return None;
    .          .          .          .                   }
7,434 ( 0.00%) .          .          .                   let id = self.patterns.order[self.i];
    .          .          .          .                   let p = self.patterns.get(id);
    .          .          .          .                   self.i += 1;
    .          .          .          .                   Some((id, p))
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// A pattern that is used in packed searching.
    .          .          .          .           #[derive(Clone)]
-- line 208 ----------------------------------------
-- line 227 ----------------------------------------
    .          .          .          .                   &self.0
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the first `len` low nybbles from this pattern. If this pattern
    .          .          .          .               /// is shorter than `len`, then this panics.
    .          .          .          .               pub(crate) fn low_nybbles(&self, len: usize) -> Box<[u8]> {
    .          .          .          .                   let mut nybs = vec![0; len].into_boxed_slice();
    .          .          .          .                   for (i, byte) in self.bytes().iter().take(len).enumerate() {
3,072 ( 0.00%) .          .          .                       nybs[i] = byte & 0xF;
    .          .          .          .                   }
    .          .          .          .                   nybs
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns true if this pattern is a prefix of the given bytes.
    .          .          .          .               #[inline(always)]
    .          .          .          .               pub(crate) fn is_prefix(&self, bytes: &[u8]) -> bool {
    .          .          .          .                   is_prefix(bytes, self.bytes())
-- line 243 ----------------------------------------
-- line 264 ----------------------------------------
    .          .          .          .               #[inline(always)]
    .          .          .          .               pub(crate) unsafe fn is_prefix_raw(
    .          .          .          .                   &self,
    .          .          .          .                   start: *const u8,
    .          .          .          .                   end: *const u8,
    .          .          .          .               ) -> bool {
    .          .          .          .                   let patlen = self.bytes().len();
    .          .          .          .                   let haylen = end.distance(start);
  100 ( 0.00%) .          .          .                   if patlen > haylen {
    .          .          .          .                       return false;
    .          .          .          .                   }
    .          .          .          .                   // SAFETY: We've checked that the haystack has length at least equal
    .          .          .          .                   // to this pattern. All other safety concerns are the responsibility
    .          .          .          .                   // of the caller.
    .          .          .          .                   is_equal_raw(start, self.bytes().as_ptr(), patlen)
    .          .          .          .               }
    .          .          .          .           }
-- line 280 ----------------------------------------
-- line 365 ----------------------------------------
    .          .          .          .           /// * The distance being in bounds must not rely on "wrapping around" the
    .          .          .          .           /// address space.
    .          .          .          .           #[inline(always)]
    .          .          .          .           unsafe fn is_equal_raw(mut x: *const u8, mut y: *const u8, n: usize) -> bool {
    .          .          .          .               // If we don't have enough bytes to do 4-byte at a time loads, then
    .          .          .          .               // handle each possible length specially. Note that I used to have a
    .          .          .          .               // byte-at-a-time loop here and that turned out to be quite a bit slower
    .          .          .          .               // for the memmem/pathological/defeat-simple-vector-alphabet benchmark.
  100 ( 0.00%) .          .          .               if n < 4 {
   50 ( 0.00%) .          .          .                   return match n {
    .          .          .          .                       0 => true,
    .          .          .          .                       1 => x.read() == y.read(),
    .          .          .          .                       2 => {
    .          .          .          .                           x.cast::<u16>().read_unaligned()
    .          .          .          .                               == y.cast::<u16>().read_unaligned()
    .          .          .          .                       }
    .          .          .          .                       // I also tried copy_nonoverlapping here and it looks like the
    .          .          .          .                       // codegen is the same.
-- line 382 ----------------------------------------

6,344 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-1.1.3/src/packed/pattern.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/literal_trie.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 102 ----------------------------------------
      .          .          .          .                   LiteralTrie { states: vec![root], rev: true }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add the given literal to this trie.
      .          .          .          .               ///
      .          .          .          .               /// If the literal could not be added because the `StateID` space was
      .          .          .          .               /// exhausted, then an error is returned. If an error returns, the trie
      .          .          .          .               /// is in an unspecified state.
267,110 ( 0.08%) .          .          .               pub(crate) fn add(&mut self, bytes: &[u8]) -> Result<(), BuildError> {
      .          .          .          .                   let mut prev = StateID::ZERO;
      .          .          .          .                   let mut it = bytes.iter().copied();
221,725 ( 0.06%) .          .          .                   while let Some(b) = if self.rev { it.next_back() } else { it.next() } {
      .          .          .          .                       prev = self.get_or_add_state(prev, b)?;
      .          .          .          .                   }
      .          .          .          .                   self.states[prev].add_match();
      .          .          .          .                   Ok(())
240,399 ( 0.07%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// If the given transition is defined, then return the next state ID.
      .          .          .          .               /// Otherwise, add the transition to `from` and point it to a new state.
      .          .          .          .               ///
      .          .          .          .               /// If a new state ID could not be allocated, then an error is returned.
      .          .          .          .               fn get_or_add_state(
      .          .          .          .                   &mut self,
      .          .          .          .                   from: StateID,
      .          .          .          .                   byte: u8,
      .          .          .          .               ) -> Result<StateID, BuildError> {
      .          .          .          .                   let active = self.states[from].active_chunk();
      .          .          .          .                   match active.binary_search_by_key(&byte, |t| t.byte) {
 30,376 ( 0.01%) .          .          .                       Ok(i) => Ok(active[i].next),
      .          .          .          .                       Err(i) => {
      .          .          .          .                           // Add a new state and get its ID.
      .          .          .          .                           let next = StateID::new(self.states.len()).map_err(|_| {
      .          .          .          .                               BuildError::too_many_states(self.states.len())
      .          .          .          .                           })?;
      .          .          .          .                           self.states.push(State::default());
      .          .          .          .                           // Offset our position to account for all transitions and not
      .          .          .          .                           // just the ones in the active chunk.
 42,597 ( 0.01%) .          .          .                           let i = self.states[from].active_chunk_start() + i;
      .          .          .          .                           let t = Transition { byte, next };
      .          .          .          .                           self.states[from].transitions.insert(i, t);
      .          .          .          .                           Ok(next)
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile this literal trie to the NFA builder given.
      .          .          .          .               ///
      .          .          .          .               /// This forwards any errors that may occur while using the given builder.
  4,950 ( 0.00%) .          .          .               pub(crate) fn compile(
      .          .          .          .                   &self,
      .          .          .          .                   builder: &mut Builder,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   // Compilation proceeds via depth-first traversal of the trie.
      .          .          .          .                   //
      .          .          .          .                   // This is overall pretty brutal. The recursive version of this is
      .          .          .          .                   // deliciously simple. (See 'compile_to_hir' below for what it might
      .          .          .          .                   // look like.) But recursion on a trie means your call stack grows
-- line 159 ----------------------------------------
-- line 164 ----------------------------------------
      .          .          .          .                   // frame. If someone can simplify this without using recursion, that'd
      .          .          .          .                   // be great.
      .          .          .          .           
      .          .          .          .                   // 'end' is our match state for this trie, but represented in the the
      .          .          .          .                   // NFA. Any time we see a match in the trie, we insert a transition
      .          .          .          .                   // from the current state we're in to 'end'.
      .          .          .          .                   let end = builder.add_empty()?;
      .          .          .          .                   let mut stack = vec![];
    495 ( 0.00%) .          .          .                   let mut f = Frame::new(&self.states[StateID::ZERO]);
      .          .          .          .                   loop {
      .          .          .          .                       if let Some(t) = f.transitions.next() {
163,204 ( 0.05%) .          .          .                           if self.states[t.next].is_leaf() {
 49,682 ( 0.01%) .          .          .                               f.sparse.push(thompson::Transition {
      .          .          .          .                                   start: t.byte,
      .          .          .          .                                   end: t.byte,
      .          .          .          .                                   next: end,
      .          .          .          .                               });
      .          .          .          .                           } else {
 15,960 ( 0.00%) .          .          .                               f.sparse.push(thompson::Transition {
      .          .          .          .                                   start: t.byte,
      .          .          .          .                                   end: t.byte,
      .          .          .          .                                   // This is a little funny, but when the frame we create
      .          .          .          .                                   // below completes, it will pop this parent frame off
      .          .          .          .                                   // and modify this transition to point to the correct
      .          .          .          .                                   // state.
      .          .          .          .                                   next: StateID::ZERO,
      .          .          .          .                               });
223,440 ( 0.06%) .          .          .                               stack.push(f);
191,520 ( 0.06%) .          .          .                               f = Frame::new(&self.states[t.next]);
      .          .          .          .                           }
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       // At this point, we have visited all transitions in f.chunk, so
      .          .          .          .                       // add it as a sparse NFA state. Unless the chunk was empty, in
      .          .          .          .                       // which case, we don't do anything.
 71,702 ( 0.02%) .          .          .                       if !f.sparse.is_empty() {
      .          .          .          .                           let chunk_id = if f.sparse.len() == 1 {
      .          .          .          .                               builder.add_range(f.sparse.pop().unwrap())?
      .          .          .          .                           } else {
      .          .          .          .                               let sparse = mem::replace(&mut f.sparse, vec![]);
      .          .          .          .                               builder.add_sparse(sparse)?
      .          .          .          .                           };
      .          .          .          .                           f.union.push(chunk_id);
      .          .          .          .                       }
      .          .          .          .                       // Now we need to look to see if there are other chunks to visit.
 18,325 ( 0.01%) .          .          .                       if let Some(chunk) = f.chunks.next() {
      .          .          .          .                           // If we're here, it means we're on the second (or greater)
      .          .          .          .                           // chunk, which implies there is a match at this point. So
      .          .          .          .                           // connect this state to the final end state.
      .          .          .          .                           f.union.push(end);
      .          .          .          .                           // Advance to the next chunk.
  3,740 ( 0.00%) .          .          .                           f.transitions = chunk.iter();
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       // Now that we are out of chunks, we have completely visited
      .          .          .          .                       // this state. So turn our union of chunks into an NFA union
      .          .          .          .                       // state, and add that union state to the parent state's current
      .          .          .          .                       // sparse state. (If there is no parent, we're done.)
 82,275 ( 0.02%) .          .          .                       let start = builder.add_union(f.union)?;
 31,920 ( 0.01%) .          .          .                       match stack.pop() {
      .          .          .          .                           None => {
  2,475 ( 0.00%) .          .          .                               return Ok(ThompsonRef { start, end });
      .          .          .          .                           }
159,600 ( 0.05%) .          .          .                           Some(mut parent) => {
      .          .          .          .                               // OK because the only way a frame gets pushed on to the
      .          .          .          .                               // stack (aside from the root) is when a transition has
      .          .          .          .                               // been added to 'sparse'.
 15,960 ( 0.00%) .          .          .                               parent.sparse.last_mut().unwrap().next = start;
223,440 ( 0.06%) .          .          .                               f = parent;
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
  4,455 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Converts this trie to an equivalent HIR expression.
      .          .          .          .               ///
      .          .          .          .               /// We don't actually use this, but it's useful for tests. In particular,
      .          .          .          .               /// it provides a (somewhat) human readable representation of the trie
      .          .          .          .               /// itself.
      .          .          .          .               #[cfg(test)]
      .          .          .          .               fn compile_to_hir(&self) -> regex_syntax::hir::Hir {
-- line 244 ----------------------------------------
-- line 323 ----------------------------------------
      .          .          .          .               /// Create a new stack frame for trie traversal. This initializes the
      .          .          .          .               /// 'transitions' iterator to the transitions for the first chunk, with the
      .          .          .          .               /// 'chunks' iterator being every chunk after the first one.
      .          .          .          .               fn new(state: &'a State) -> Frame<'a> {
      .          .          .          .                   let mut chunks = state.chunks();
      .          .          .          .                   // every state has at least 1 chunk
      .          .          .          .                   let chunk = chunks.next().unwrap();
      .          .          .          .                   let transitions = chunk.iter();
 54,315 ( 0.02%) .          .          .                   Frame { chunks, transitions, union: vec![], sparse: vec![] }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A state in a trie.
      .          .          .          .           ///
      .          .          .          .           /// This uses a sparse representation. Since we don't use literal tries
      .          .          .          .           /// for searching, and ultimately (and compilation requires visiting every
      .          .          .          .           /// transition anyway), we use a sparse representation for transitions. This
-- line 339 ----------------------------------------
-- line 371 ----------------------------------------
      .          .          .          .               fn add_match(&mut self) {
      .          .          .          .                   // This is not strictly necessary, but there's no point in recording
      .          .          .          .                   // another match by adding another chunk if the state has no
      .          .          .          .                   // transitions. Note though that we only skip this if we already know
      .          .          .          .                   // this is a match state, which is only true if 'chunks' is not empty.
      .          .          .          .                   // Basically, if we didn't do this, nothing semantically would change,
      .          .          .          .                   // but we'd end up pushing another chunk and potentially triggering an
      .          .          .          .                   // alloc.
130,205 ( 0.04%) .          .          .                   if self.transitions.is_empty() && !self.chunks.is_empty() {
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .                   let chunk_start = self.active_chunk_start();
      .          .          .          .                   let chunk_end = self.transitions.len();
 53,422 ( 0.02%) .          .          .                   self.chunks.push((chunk_start, chunk_end));
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this state is a leaf state. That is, a
      .          .          .          .               /// state that has no outgoing transitions.
      .          .          .          .               fn is_leaf(&self) -> bool {
      .          .          .          .                   self.transitions.is_empty()
      .          .          .          .               }
      .          .          .          .           
-- line 392 ----------------------------------------
-- line 399 ----------------------------------------
      .          .          .          .                       transitions: &*self.transitions,
      .          .          .          .                       chunks: self.chunks.iter(),
      .          .          .          .                       active: Some(self.active_chunk()),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the active chunk as a slice of transitions.
      .          .          .          .               fn active_chunk(&self) -> &[Transition] {
 73,003 ( 0.02%) .          .          .                   let start = self.active_chunk_start();
 71,177 ( 0.02%) .          .          .                   &self.transitions[start..]
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the index into 'transitions' where the active chunk starts.
      .          .          .          .               fn active_chunk_start(&self) -> usize {
      .          .          .          .                   self.chunks.last().map_or(0, |&(_, end)| end)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
-- line 416 ----------------------------------------
-- line 446 ----------------------------------------
      .          .          .          .               chunks: core::slice::Iter<'a, (usize, usize)>,
      .          .          .          .               active: Option<&'a [Transition]>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'a> Iterator for StateChunksIter<'a> {
      .          .          .          .               type Item = &'a [Transition];
      .          .          .          .           
      .          .          .          .               fn next(&mut self) -> Option<&'a [Transition]> {
  3,740 ( 0.00%) .          .          .                   if let Some(&(start, end)) = self.chunks.next() {
      .          .          .          .                       return Some(&self.transitions[start..end]);
      .          .          .          .                   }
 18,325 ( 0.01%) .          .          .                   if let Some(chunk) = self.active.take() {
      .          .          .          .                       return Some(chunk);
      .          .          .          .                   }
      .          .          .          .                   None
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A single transition in a trie to another state.
      .          .          .          .           #[derive(Clone, Copy)]
-- line 465 ----------------------------------------

686,371 ( 0.20%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.9/src/nfa/thompson/literal_trie.rs>

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/../sysdeps/x86_64/dl-machine.h
  ./elf/./elf/dl-lookup.c
  ./elf/./elf/dl-tunables.c
  ./elf/./elf/do-rel.h
  ./malloc/./malloc/arena.c
  ./malloc/./malloc/malloc.c
  ./stdio-common/./stdio-common/vfscanf-internal.c
  ./stdlib/../stdlib/strtol_l.c
  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/strcmp.S
  /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/map.rs
  /cargo/registry/src/index.crates.io-6f17d22bba15001f/hashbrown-0.14.0/src/raw/mod.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/alloc.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/boxed.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/map.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/navigate.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/node.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/btree/search.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/collections/vec_deque/mod.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/raw_vec.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/slice.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/string.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/drain.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/into_iter.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/mod.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/set_len_on_drop.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_extend.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/alloc/src/vec/spec_from_iter.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/alloc/layout.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cell.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/char/methods.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/cmp.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/convert/num.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/fmt/mod.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/hash/mod.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/hash/sip.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/intrinsics.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/adapters/map.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/adapters/take.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/range.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/traits/accum.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/traits/collect.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/iter/traits/iterator.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/mem/manually_drop.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/mod.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/num/uint_macros.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ops/range.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/option.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/const_ptr.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mod.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/mut_ptr.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/ptr/non_null.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/result.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/cmp.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/index.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/iter/macros.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/mod.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/slice/sort.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/converts.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/mod.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/traits.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/core/src/str/validations.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/alloc.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/collections/hash/map.rs
  /rustc/cc66ad468955717ab92600c770da8c1601a4ff33/library/std/src/sys/unix/alloc.rs

--------------------------------------------------------------------------------
Ir                  Ge sysCount sysTime 
--------------------------------------------------------------------------------
63,449,799 (18.26%) .          .          .           events annotated

