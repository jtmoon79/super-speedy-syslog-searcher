Linux host 6.6.87.2-microsoft-standard-WSL2 #1 SMP PREEMPT_DYNAMIC Thu Jun  5 18:30:46 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux
dc8f3631 HEAD -> main, origin/main, origin/HEAD
s4 (Super Speedy Syslog Searcher)
Version: 0.8.80
MSRV: 1.85.0
Allocator: system
Platform: x86_64-unknown-linux-gnu
License: MIT
Repository: https://github.com/jtmoon79/super-speedy-syslog-searcher
Author: James Thomas Moon

valgrind-3.22.0

--------------------------------------------------------------------------------
Profile data file './releases/0.8.80/x86_64-unknown-linux-gnu//callgrind.out' (creator: callgrind-3.22.0)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 74584254
Trigger: Program termination
Profiled target:  ./target/valgrind/s4 -a 20000101T000000 -b 20000101T080000 ./logs/other/tests/gen-1000-3-foobar.log (PID 1634976, part 1)
Events recorded:  Ir Ge sysCount sysTime
Events shown:     Ir Ge sysCount sysTime
Event sort order: Ir Ge sysCount sysTime
Thresholds:       99 0 0 0
Include dirs:     ./src/
                  ./src/bin/
                  ./src/data/
                  ./src/python/
                  ./src/python/s4_event_readers/
                  ./src/python/s4_event_readers/s4_event_readers/
                  ./src/python/tools/
                  ./src/debug/
                  ./src/tests/
                  ./src/bindings/
                  ./src/printer/
                  ./src/libload/
                  ./src/readers/
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                   Ge               sysCount     sysTime        
--------------------------------------------------------------------------------
333,086,186 (100.0%) 809,614 (100.0%) 301 (100.0%) 1,386 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                  Ge               sysCount     sysTime         file:function
--------------------------------------------------------------------------------

42,783,313 (12.84%)  10,377 ( 1.28%)  63 (20.93%)     1 ( 0.07%)  < ./malloc/./malloc/malloc.c:malloc (192,318x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
13,027,361 ( 3.91%)  21,574 ( 2.66%)  68 (22.59%)     .           < ./malloc/./malloc/malloc.c:_int_realloc (24,988x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   199,427 ( 0.06%)     292 ( 0.04%)   .              .           < ./malloc/./malloc/malloc.c:calloc (1,327x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    20,693 ( 0.01%)       .            .              .           < ./malloc/./malloc/malloc.c:_int_memalign (85x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
       623 ( 0.00%)       0            2 ( 0.66%)     .           < ./malloc/./malloc/malloc.c:tcache_init.part.0 (3x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
41,340,759 (12.41%)   7,959 ( 0.98%)   .              .           *  ./malloc/./malloc/malloc.c:_int_malloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
12,641,015 ( 3.80%)  24,280 ( 3.00%)   .              .           >   ./malloc/./malloc/malloc.c:malloc_consolidate (2,428x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 1,531,347 ( 0.46%)       .            .              .           >   ./malloc/./malloc/malloc.c:unlink_chunk.isra.0 (67,503x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   512,584 ( 0.15%)       .            .              .           >   ./malloc/./malloc/malloc.c:alloc_perturb (128,146x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
       148 ( 0.00%)       4 ( 0.00%)   1 ( 0.33%)     .           >   ./malloc/./malloc/malloc.c:sysmalloc_mmap.isra.0 (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
       146 ( 0.00%)       0            3 ( 1.00%)     .           >   ./malloc/./malloc/morecore.c:__glibc_morecore (3x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

31,498,341 ( 9.46%) 260,944 (32.23%)   .              .           < ./malloc/./malloc/malloc.c:free (386,093x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 2,579,654 ( 0.77%)   2,163 ( 0.27%)   .              .           < ./malloc/./malloc/malloc.c:_int_realloc (28,564x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    49,057 ( 0.01%)     696 ( 0.09%)   .              .           < ./malloc/./malloc/malloc.c:__malloc_arena_thread_freeres (369x)
29,323,699 ( 8.80%) 262,183 (32.38%)   .              .           *  ./malloc/./malloc/malloc.c:_int_free [/usr/lib/x86_64-linux-gnu/libc.so.6]
 4,803,353 ( 1.44%)   1,620 ( 0.20%)   .              .           >   ./malloc/./malloc/malloc.c:_int_free_merge_chunk (28,130x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

65,508,548 (19.67%) 393,539 (48.61%)  63 (20.93%)     1 ( 0.07%)  < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/alloc/unix.rs:__rdl_alloc (402,375x)
     3,836 ( 0.00%)      22 ( 0.00%)   7 ( 2.33%)     .           < ./malloc/./malloc/malloc.c:realloc (6x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     2,232 ( 0.00%)       2 ( 0.00%)   3 ( 1.00%)     .           < ???:0x00000000048a03f0 (4x) [???]
20,618,247 ( 6.19%) 383,170 (47.33%)   .              .           *  ./malloc/./malloc/malloc.c:malloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
42,783,313 (12.84%)  10,377 ( 1.28%)  63 (20.93%)     1 ( 0.07%)  >   ./malloc/./malloc/malloc.c:_int_malloc (192,318x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     3,061 ( 0.00%)      16 ( 0.00%)   9 ( 2.99%)     .           >   ./malloc/./malloc/malloc.c:tcache_init.part.0 (3x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

12,641,015 ( 3.80%)  24,280 ( 3.00%)   .              .           < ./malloc/./malloc/malloc.c:_int_malloc (2,428x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 2,155,591 ( 0.65%)   1,620 ( 0.20%)   .              .           < ./malloc/./malloc/malloc.c:_int_free_maybe_consolidate (162x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
11,683,055 ( 3.51%)  25,900 ( 3.20%)   .              .           *  ./malloc/./malloc/malloc.c:malloc_consolidate [/usr/lib/x86_64-linux-gnu/libc.so.6]
 3,113,551 ( 0.93%)       .            .              .           >   ./malloc/./malloc/malloc.c:unlink_chunk.isra.0 (144,723x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

46,535,039 (13.97%) 260,940 (32.23%)   1 ( 0.33%)     .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/alloc/unix.rs:__rdl_dealloc (386,075x)
     1,629 ( 0.00%)       4 ( 0.00%)   .              .           < ???:0x00000000048a03e0 (19x) [???]
       179 ( 0.00%)       2 ( 0.00%)   .              .           < ./malloc/./malloc/malloc.c:__malloc_arena_thread_freeres (1x)
        85 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/pal/unix/fs.rs:std::sys::pal::unix::fs::canonicalize (1x) [./target/valgrind/s4]
10,810,652 ( 3.25%)       .            .              .           *  ./malloc/./malloc/malloc.c:free [/usr/lib/x86_64-linux-gnu/libc.so.6]
31,498,341 ( 9.46%) 260,944 (32.23%)   .              .           >   ./malloc/./malloc/malloc.c:_int_free (386,093x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        36 ( 0.00%)       2 ( 0.00%)   1 ( 0.33%)     .           >   ./malloc/./malloc/malloc.c:munmap_chunk (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 5,679,760 ( 1.71%)       .            .              .           < ???:0x00000000048a06b0 (25,018x) [???]
   773,760 ( 0.23%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (48,360x)
   264,180 ( 0.08%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::hir::Hir::concat (15,408x)
   254,160 ( 0.08%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (8,472x) [./target/valgrind/s4]
   252,326 ( 0.08%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (5,123x)
   223,949 ( 0.07%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::hir::literal::Extractor::cross (13,790x)
   191,190 ( 0.06%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (6,373x)
   189,060 ( 0.06%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (6,302x) [./target/valgrind/s4]
   170,430 ( 0.05%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (2,824x)
   169,440 ( 0.05%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (5,648x) [./target/valgrind/s4]
   155,798 ( 0.05%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::nfa::thompson::builder::Builder::build (12,029x)
   129,570 ( 0.04%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (4,319x)
    84,870 ( 0.03%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (2,829x)
    84,720 ( 0.03%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op (2,824x) [./target/valgrind/s4]
    84,720 ( 0.03%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (2,824x)
    82,740 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (2,758x) [./target/valgrind/s4]
    82,590 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (2,753x)
    82,590 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (2,753x)
    82,590 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (2,753x) [./target/valgrind/s4]
    56,690 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add (4,122x)
    41,720 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::hir::literal::Extractor::extract'2 (2,411x)
    38,848 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::hir::literal::PreferenceTrie::insert (2,611x)
    37,584 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::new (324x) [./target/valgrind/s4]
    35,609 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::meta::reverse_inner::flatten'2 (2,071x)
    29,938 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:<alloc::string::String as core::fmt::Write>::write_str (1,871x)
    27,643 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:<alloc::vec::Vec<T,A> as core::clone::Clone>::clone (1,589x)
    24,523 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:aho_corasick::packed::pattern::Patterns::add (1,394x)
    19,963 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (980x)
    18,395 ( 0.01%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/intrinsics/mod.rs:<alloc::string::String as core::clone::Clone>::clone (1,188x)
    16,604 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,318x)
    15,360 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (512x)
    14,009 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_automata::meta::regex::Builder::build (81x)
    11,375 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build (175x) [./target/valgrind/s4]
    11,347 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x)
    11,252 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::fold (81x)
    11,188 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex::builders::Builder::build_one_bytes (80x)
    10,804 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (846x)
    10,638 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (773x)
    10,620 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:aho_corasick::nfa::noncontiguous::Builder::build (144x)
     9,097 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (586x)
     9,097 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::util::captures::GroupInfo::new (586x)
     8,724 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (144x) [./target/valgrind/s4]
     8,523 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/pool.rs:regex_automata::util::pool::inner::Pool<T,F>::get_slow (53x) [./target/valgrind/s4]
     7,290 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::Hybrid::new (243x)
     6,895 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::Edge>::insert_recursing (525x)
     6,890 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::meta::wrappers::Hybrid::create_cache (106x)
     6,006 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_automata::util::prefilter::teddy::Teddy::new (78x)
     5,353 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::create_cache (53x) [./target/valgrind/s4]
     5,330 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::OnePass::new (82x) [./target/valgrind/s4]
     5,250 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x) [./target/valgrind/s4]
     5,250 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Builder::build_from_nfa (175x) [./target/valgrind/s4]
     5,250 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/alphabet.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x)
     4,980 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:alloc::collections::btree::remove::<impl alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::KV>>::remove_leaf_kv (358x)
     4,860 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::meta::wrappers::Hybrid::new (162x)
     4,860 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::meta::strategy::new (162x)
     3,796 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::util::determinize::state::State::dead (292x)
     3,696 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (48x) [./target/valgrind/s4]
     3,003 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/prefilter/mod.rs:regex_automata::util::prefilter::Choice::new (39x) [./target/valgrind/s4]
     3,003 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_automata::util::prefilter::Prefilter::from_choice (39x)
     2,626 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::new (26x) [./target/valgrind/s4]
     2,626 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/strategy.rs:regex_automata::meta::strategy::new (26x) [./target/valgrind/s4]
     2,465 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:clap_builder::util::flat_map::FlatMap<K,V>::remove_entry (36x)
     2,445 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (57x) [./target/valgrind/s4]
     2,445 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (57x)
     2,445 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (57x)
     2,430 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::PikeVM::new (81x)
     2,430 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_automata::meta::regex::RegexInfo::new (81x)
     2,430 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::BoundedBacktracker::new (81x)
     2,430 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::OnePass::new (81x)
     2,400 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-1.11.3/src/builders.rs:regex::regex::bytes::Regex::new (80x)
     2,232 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (174x)
     2,150 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap_builder-4.5.48/src/builder/command.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (22x)
     2,130 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (71x)
     1,892 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:aho_corasick::util::remapper::Remapper::remap (48x)
     1,772 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:clap_builder::builder::command::Command::arg_internal (20x)
     1,771 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/strategy.rs:<regex_automata::meta::strategy::ReverseInner as regex_automata::meta::strategy::Strategy>::create_cache (11x) [./target/valgrind/s4]
     1,652 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (96x)
     1,560 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:alloc::collections::btree::node::BalancingContext<K,V>::do_merge (120x)
     1,440 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::byte_classes (48x) [./target/valgrind/s4]
     1,365 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:aho_corasick::packed::teddy::builder::x86_64::FatAVX2<3_usize>::new_unchecked (21x)
     1,365 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::builder::x86_64::FatAVX2<3_usize>::new_unchecked (21x)
     1,313 ( 0.00%)       .            .              .           < ???:regex_automata::meta::strategy::new (13x)
     1,292 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::meta::reverse_inner::extract (13x)
     1,278 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:aho_corasick::ahocorasick::AhoCorasickBuilder::build (18x)
     1,122 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:aho_corasick::packed::api::Builder::build (48x)
     1,122 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (48x)
     1,060 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:<clap_builder::builder::styled_str::StyledStr as core::convert::From<&str>>::from (24x)
       951 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:alloc::collections::vec_deque::VecDeque<T,A>::grow (69x)
       943 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap_builder-4.5.48/src/builder/arg.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (11x)
       847 ( 0.00%)       .            .              .           < src/bin/s4.rs:s4::processing_loop (11x) [./target/valgrind/s4]
       810 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:core::slice::sort::stable::drift::sort (10x)
       715 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::create_cache (11x) [./target/valgrind/s4]
       715 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::meta::wrappers::ReverseHybrid::create_cache (11x)
       711 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::hir::Hir::alternation (63x)
       681 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::hir::interval::IntervalSet<I>::negate (61x)
       637 ( 0.00%)       .            .              .           < src/readers/syslinereader.rs:s4lib::readers::syslinereader::SyslineReader::new (3x) [./target/valgrind/s4]
       586 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x)
       583 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:aho_corasick::ahocorasick::AhoCorasickBuilder::build (9x)
       510 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:s4lib::data::datetime::bytes_to_regex_to_datetime (30x)
       447 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/intrinsics/mod.rs:<std::io::stdio::StdoutLock as std::io::Write>::write (33x)
       445 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:crossbeam_channel::select::SelectedOperation::recv (5x)
       445 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:crossbeam_channel::channel::read (5x)
       445 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:crossbeam_channel::flavors::array::Channel<T>::send (5x)
       445 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossbeam-channel-0.5.15/src/flavors/array.rs:crossbeam_channel::channel::read (5x)
       397 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/intrinsics/mod.rs:std::sys::os_str::bytes::Slice::to_owned (28x)
       396 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::meta::reverse_inner::flatten (34x)
       394 ( 0.00%)       .            .              .           < src/readers/linereader.rs:s4lib::readers::linereader::LineReader::new (2x) [./target/valgrind/s4]
       390 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:alloc::collections::btree::node::BalancingContext<K,V>::bulk_steal_right (28x)
       390 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::nfa::thompson::compiler::Compiler::new (13x)
       390 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::ReverseHybrid::new (13x)
       358 ( 0.00%)       .            .              .           < src/bin/s4.rs:s4::exec_fileprocessor_thread (2x) [./target/valgrind/s4]
       332 ( 0.00%)       .            .              .           < src/readers/summary.rs:s4lib::readers::summary::Summary::new (6x) [./target/valgrind/s4]
       269 ( 0.00%)       .            .              .           < src/readers/syslogprocessor.rs:s4lib::readers::syslogprocessor::SyslogProcessor::new (1x) [./target/valgrind/s4]
       150 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:alloc::collections::btree::fix::<impl alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::LeafOrInternal>>::fix_node_and_affected_ancestors (12x)
       149 ( 0.00%)       .            .              .           < src/readers/blockreader.rs:s4lib::readers::blockreader::BlockReader::new (3x) [./target/valgrind/s4]
       119 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:hashbrown::map::HashMap<K,V,S,A>::insert (2x)
       118 ( 0.00%)       .            .              .           < src/readers/syslogprocessor.rs:s4lib::readers::syslogprocessor::SyslogProcessor::summary_complete (2x) [./target/valgrind/s4]
       101 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap_builder-4.5.48/src/builder/command.rs:clap_builder::builder::command::Command::get_matches_from (1x) [./target/valgrind/s4]
       101 ( 0.00%)       .            .              .           < src/bin/s4.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (1x) [./target/valgrind/s4]
        85 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/intrinsics/mod.rs:std::env::args_os (6x)
        78 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:s4lib::printer::printers::PrinterLogMessage::print_sysline_color (6x)
        77 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:s4::processing_loop (1x)
        77 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<4_usize>::new_unchecked (1x)
        77 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<4_usize>::new_unchecked (1x)
        72 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Internal>,alloc::collections::btree::node::marker::KV>::split (6x)
        65 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (1x) [./target/valgrind/s4]
        65 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::dfa::remapper::Remapper::remap (1x)
        60 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/pal/unix/fs.rs:std::sys::pal::unix::fs::stat (2x) [./target/valgrind/s4]
        59 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/intrinsics/mod.rs:std::env::_var_os (4x)
        54 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/intrinsics/mod.rs:<alloc::string::String as core::fmt::Write>::write_str (4x)
        34 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/intrinsics/mod.rs:std::sys::pal::unix::fs::canonicalize (2x)
        34 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/intrinsics/mod.rs:std::sys::pal::unix::fs::stat (2x)
        30 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:chrono::offset::local::inner::Source::new (1x)
        30 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:std::sys::thread_local::native::lazy::Storage<T,D>::initialize'2 (1x)
        30 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ctrlc-3.4.7/src/platform/unix/mod.rs:ctrlc::init_and_set_handler (1x)
        30 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/try_trait.rs:core::array::drain::drain_array_with (1x)
        30 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/nix-0.30.1/src/sys/signal.rs:nix::sys::signal::sigaction (1x) [./target/valgrind/s4]
        30 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/pal/unix/fs.rs:std::sys::pal::unix::fs::lstat (1x) [./target/valgrind/s4]
        30 ( 0.00%)       .            .              .           < /rust/deps/hashbrown-0.15.2/src/map.rs:hashbrown::map::HashMap<K,V,S,A>::remove (1x) [./target/valgrind/s4]
        30 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex::builders::Builder::build_one_string (1x)
        30 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/pal/unix/fs.rs:std::fs::File::metadata (1x)
        30 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:chrono::offset::local::inner::offset (1x)
        30 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/result.rs:std::fs::File::metadata (1x)
        30 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:<F as clap_builder::builder::value_parser::TypedValueParser>::parse_ref (2x)
        30 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-1.11.3/src/builders.rs:regex::regex::string::Regex::new (1x)
        28 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/pal/unix/thread.rs:std::sys::pal::unix::thread::Thread::set_name (2x) [./target/valgrind/s4]
        26 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:s4::process_dt_exit (2x)
        26 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:crossbeam_channel::waker::SyncWaker::notify (2x)
        25 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/intrinsics/mod.rs:std::fs::OpenOptions::_open (2x)
        18 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:clap_builder::builder::command::Command::get_matches_from (1x)
        18 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:s4lib::readers::filepreprocessor::pathbuf_to_filetype_impl (1x)
        13 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/intrinsics/mod.rs:std::sys::pal::unix::os::getenv::{{closure}} (1x)
        13 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/intrinsics/mod.rs:std::io::default_read_to_end::small_probe_read (1x)
        13 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/intrinsics/mod.rs:std::sys::pal::unix::fs::lstat (1x)
        11 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:s4lib::readers::helpers::basename (1x)
 9,679,782 ( 2.91%)       .            .              .           *  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms [/usr/lib/x86_64-linux-gnu/libc.so.6]

 4,724,398 ( 1.42%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::pikevm::ActiveStates::reset (318x)
   557,491 ( 0.17%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (66x)
   325,202 ( 0.10%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (350x)
   284,851 ( 0.09%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::builder::Builder::build (175x)
   272,746 ( 0.08%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (324x)
   242,811 ( 0.07%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::util::sparse_set::SparseSets::new (468x)
    75,964 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (1,066x)
    65,552 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:s4lib::readers::blockreader::BlockReader::read_block_File (1x)
    13,809 ( 0.00%)       .            .              .           < ???:0x00000000048a0740 (227x) [???]
     3,873 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash (347x)
     2,096 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::meta::regex::Regex::create_captures (86x)
     1,728 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::new (48x) [./target/valgrind/s4]
     1,013 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_automata::meta::strategy::Core as regex_automata::meta::strategy::Strategy>::create_cache (43x)
       279 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_automata::meta::strategy::ReverseInner as regex_automata::meta::strategy::Strategy>::create_cache (11x)
       199 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/backtrack.rs:regex_automata::nfa::thompson::backtrack::BoundedBacktracker::search_imp (9x) [./target/valgrind/s4]
       143 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:hashbrown::raw::RawTable<T,A>::with_capacity_in (13x)
        78 ( 0.00%)       .            .              .           < src/bin/s4.rs:s4::processing_loop (1x) [./target/valgrind/s4]
        55 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:s4::processing_loop (5x)
        46 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:<lru::LruCache<K,V,S> as core::ops::drop::Drop>::drop (4x)
        38 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::DFA::try_search_slots_imp (2x) [./target/valgrind/s4]
        34 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:lru::LruCache<K,V>::new (3x)
        26 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::backtrack::BoundedBacktracker::search_imp (1x)
 6,572,432 ( 1.97%)       .            .              .           *  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms [/usr/lib/x86_64-linux-gnu/libc.so.6]

31,997,007 ( 9.61%) 144,997 (17.91%)  68 (22.59%)     .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/alloc/unix.rs:__rdl_realloc (61,219x)
     4,364 ( 0.00%)      22 ( 0.00%)   7 ( 2.33%)     .           < ???:0x00000000048a0410 (7x) [???]
 5,160,211 ( 1.55%) 121,260 (14.98%)   .              .           *  ./malloc/./malloc/malloc.c:realloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
25,441,336 ( 7.64%)  23,737 ( 2.93%)  68 (22.59%)     .           >   ./malloc/./malloc/malloc.c:_int_realloc (60,844x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     3,836 ( 0.00%)      22 ( 0.00%)   7 ( 2.33%)     .           >   ./malloc/./malloc/malloc.c:malloc (6x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 3,113,551 ( 0.93%)       .            .              .           < ./malloc/./malloc/malloc.c:malloc_consolidate (144,723x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 1,531,347 ( 0.46%)       .            .              .           < ./malloc/./malloc/malloc.c:_int_malloc (67,503x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   167,865 ( 0.05%)       .            .              .           < ./malloc/./malloc/malloc.c:_int_free_merge_chunk (7,172x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    86,887 ( 0.03%)       .            .              .           < ./malloc/./malloc/malloc.c:_int_realloc (3,567x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     1,302 ( 0.00%)       .            .              .           < ./malloc/./malloc/malloc.c:_int_memalign (61x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 4,900,952 ( 1.47%)       .            .              .           *  ./malloc/./malloc/malloc.c:unlink_chunk.isra.0 [/usr/lib/x86_64-linux-gnu/libc.so.6]

62,028,739 (18.62%) 147,940 (18.27%)  20 ( 6.64%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (71,256x) [./target/valgrind/s4]
 4,690,606 ( 1.41%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post [./target/valgrind/s4]
24,333,545 ( 7.31%)  51,060 ( 6.31%)   2 ( 0.66%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (15,786x) [./target/valgrind/s4]
 6,555,178 ( 1.97%)   2,505 ( 0.31%)   4 ( 1.33%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (512x) [./target/valgrind/s4]
 2,123,692 ( 0.64%)   9,527 ( 1.18%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class (3,873x) [./target/valgrind/s4]
   931,859 ( 0.28%)   2,240 ( 0.28%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple (1,190x) [./target/valgrind/s4]
   317,853 ( 0.10%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> (35,317x) [./target/valgrind/s4]
   157,920 ( 0.05%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::SimpleCaseFolder::overlaps (1,120x) [./target/valgrind/s4]
    79,918 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::HirFrame::unwrap_expr (2,578x) [./target/valgrind/s4]
    71,074 ( 0.02%)      50 ( 0.01%)   .              .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/string.rs:<alloc::string::String as core::clone::Clone>::clone (586x) [./target/valgrind/s4]
     2,888 ( 0.00%)       1 ( 0.00%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (20x) [./target/valgrind/s4]
     1,950 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::TranslatorI::set_flags (20x) [./target/valgrind/s4]

 4,227,903 ( 1.27%)       .            .              .           *  ./malloc/./malloc/arena.c:free

16,447,947 ( 4.94%)  80,603 ( 9.96%)  12 ( 3.99%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add (48,899x)
 9,090,023 ( 2.73%)  44,208 ( 5.46%)   7 ( 2.33%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile (37,448x)
 5,493,638 ( 1.65%)  29,210 ( 3.61%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (18,495x)
 4,430,832 ( 1.33%)  18,015 ( 2.23%)   4 ( 1.33%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::PreferenceTrie::insert (10,736x)
 3,623,709 ( 1.09%)   6,974 ( 0.86%)  13 ( 4.32%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (18,030x)
 3,331,766 ( 1.00%)   5,007 ( 0.62%)  21 ( 6.98%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::add (1,376x)
 2,546,827 ( 0.76%)   3,677 ( 0.45%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::concat (16,418x)
 1,620,353 ( 0.49%)   8,485 ( 1.05%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::patch (5,355x)
 1,449,558 ( 0.44%)   4,047 ( 0.50%)   5 ( 1.66%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::nfa::Inner::add (1,275x)
 1,023,156 ( 0.31%)     330 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (81x)
   884,302 ( 0.27%)   4,443 ( 0.55%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (1,445x)
   553,226 ( 0.17%)   2,127 ( 0.26%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::build (1,033x)
   521,359 ( 0.16%)   2,240 ( 0.28%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple (1,120x)
   468,888 ( 0.14%)     876 ( 0.11%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (2,914x)
   454,611 ( 0.14%)   2,504 ( 0.31%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::dfa::DFA::set_matches (1,835x)
   437,590 ( 0.13%)   1,219 ( 0.15%)   1 ( 0.33%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state (384x)
   372,221 ( 0.11%)     879 ( 0.11%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from (1,901x)
   324,919 ( 0.10%)   1,256 ( 0.16%)   3 ( 1.00%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre (297x)
   275,118 ( 0.08%)     265 ( 0.03%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (1,978x)
   190,861 ( 0.06%)     798 ( 0.10%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::packed::rabinkarp::RabinKarp::new (733x)
   130,435 ( 0.04%)     651 ( 0.08%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (221x)
   128,214 ( 0.04%)     331 ( 0.04%)   1 ( 0.33%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::visitor::visit (486x)
   119,654 ( 0.04%)     547 ( 0.07%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::util::captures::GroupInfo::new (227x)
   119,430 ( 0.04%)     435 ( 0.05%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::add_capture_start (308x)
   117,684 ( 0.04%)     450 ( 0.06%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (243x)
    93,862 ( 0.03%)     260 ( 0.03%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push (211x)
    87,272 ( 0.03%)     300 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::add_match (144x)
    85,085 ( 0.03%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::range_trie::RangeTrie::add_empty (674x)
    84,324 ( 0.03%)     336 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (167x)
    78,082 ( 0.02%)     309 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie (180x)
    77,839 ( 0.02%)     368 ( 0.05%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::packed::pattern::Patterns::add (180x)
    75,120 ( 0.02%)     314 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:alloc::collections::vec_deque::VecDeque<T,A>::grow (180x) [./target/valgrind/s4]
    68,836 ( 0.02%)     174 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (406x)
    61,071 ( 0.02%)     328 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x)
    57,190 ( 0.02%)     164 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (162x)
    49,737 ( 0.01%)     229 ( 0.03%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next (123x)
    46,722 ( 0.01%)     140 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::meta::regex::Builder::build (162x)
    43,003 ( 0.01%)     167 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (154x)
    42,963 ( 0.01%)     120 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::util::captures::GroupInfoInner::add_first_group (243x)
    40,184 ( 0.01%)      78 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::Extractor::extract'2 (125x)
    37,189 ( 0.01%)     174 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::interval::IntervalSet<I>::negate (81x)
    28,050 ( 0.01%)      74 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (175x)
    17,904 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::Builder::build (144x)
    17,307 ( 0.01%)      68 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (34x)
    14,625 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::hybrid::dfa::Lazy::init_cache (117x)
    12,817 ( 0.00%)      16 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::meta::regex::RegexInfo::new (81x)
    11,748 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_group (91x)
    10,044 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (81x)
     9,753 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::parser::arg_matcher::ArgMatcher::start_custom_arg (36x)
     8,946 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (71x)
     8,375 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::new (67x)
     7,604 ( 0.00%)      18 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::alternation (15x)
     5,863 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::parser::matches::matched_arg::MatchedArg::append_val (22x)
     5,084 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::util::determinize::epsilon_closure (41x)
     4,675 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::parser::arg_matcher::ArgMatcher::add_index_to (18x)
     3,746 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::util::flat_map::Entry<K,V>::or_insert (8x)
     2,520 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_flags (20x)
     1,862 ( 0.00%)       6 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::backtrack::BoundedBacktracker::search_imp (4x)
     1,780 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (7x)
     1,642 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::builder::command::Command::_build_self (5x)
     1,594 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::builder::command::Command::arg_internal (4x)
     1,334 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::util::flat_map::FlatMap<K,V>::extend_unchecked (4x)
     1,084 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::parser::arg_matcher::ArgMatcher::start_custom_group (4x)
       517 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::builder::command::Command::unroll_arg_requires (3x)
       454 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::alternation'2 (2x)
       270 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::parser::validator::gather_direct_conflicts (1x)
       241 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::mkeymap::MKeyMap::_build (1x)
       126 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:crossbeam_channel::waker::SyncWaker::register (1x)
       126 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open (1x)
       125 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::Extractor::extract (1x)
 4,006,502 ( 1.20%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one [./target/valgrind/s4]
47,667,734 (14.31%) 223,224 (27.57%)  67 (22.26%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::finish_grow (177,664x) [./target/valgrind/s4]

25,441,336 ( 7.64%)  23,737 ( 2.93%)  68 (22.59%)     .           < ./malloc/./malloc/malloc.c:realloc (60,844x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 3,968,876 ( 1.19%)       .            .              .           *  ./malloc/./malloc/malloc.c:_int_realloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
13,027,361 ( 3.91%)  21,574 ( 2.66%)  68 (22.59%)     .           >   ./malloc/./malloc/malloc.c:_int_malloc (24,988x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 2,579,654 ( 0.77%)   2,163 ( 0.27%)   .              .           >   ./malloc/./malloc/malloc.c:_int_free (28,564x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    86,887 ( 0.03%)       .            .              .           >   ./malloc/./malloc/malloc.c:unlink_chunk.isra.0 (3,567x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 4,406,916 ( 1.32%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (220,401x) [./target/valgrind/s4]
 3,697,472 ( 1.11%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (184,846x) [./target/valgrind/s4]
   318,580 ( 0.10%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (15,929x) [./target/valgrind/s4]
   254,904 ( 0.08%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (12,720x) [./target/valgrind/s4]
   225,912 ( 0.07%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open (11,298x) [./target/valgrind/s4]
   189,600 ( 0.06%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item (9,360x) [./target/valgrind/s4]
   141,420 ( 0.04%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::maybe_parse_ascii_class (7,071x) [./target/valgrind/s4]
   136,920 ( 0.04%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (6,846x) [./target/valgrind/s4]
    71,580 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range (3,549x) [./target/valgrind/s4]
    71,160 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition (3,558x) [./target/valgrind/s4]
    64,480 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape (3,224x) [./target/valgrind/s4]
    56,480 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x) [./target/valgrind/s4]
    56,432 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (2,824x) [./target/valgrind/s4]
    43,132 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (2,159x) [./target/valgrind/s4]
    32,180 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (1,609x) [./target/valgrind/s4]
    15,100 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (755x) [./target/valgrind/s4]
    14,244 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_group (713x) [./target/valgrind/s4]
    13,860 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x) [./target/valgrind/s4]
     4,200 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_flags (210x) [./target/valgrind/s4]
       400 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_flag (20x) [./target/valgrind/s4]
       300 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_perl_class (15x) [./target/valgrind/s4]
 3,924,992 ( 1.18%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char [./target/valgrind/s4]

47,667,734 (14.31%) 223,224 (27.57%)  67 (22.26%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (177,664x) [./target/valgrind/s4]
16,747,326 ( 5.03%)  42,609 ( 5.26%)  15 ( 4.98%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (22,914x) [./target/valgrind/s4]
 3,747,416 ( 1.13%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::finish_grow [./target/valgrind/s4]
29,044,346 ( 8.72%) 155,370 (19.19%)  14 ( 4.65%)     .           >   ???:__rust_alloc (156,554x) [./target/valgrind/s4]

58,463,297 (17.55%) 143,996 (17.79%)   1 ( 0.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::Parser::parse (81x) [./target/valgrind/s4]
 3,714,739 ( 1.12%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments [./target/valgrind/s4]
 8,923,368 ( 2.68%)   1,216 ( 0.15%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (2,753x) [./target/valgrind/s4]
 7,753,142 ( 2.33%)  26,910 ( 3.32%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (15,929x) [./target/valgrind/s4]
 4,464,110 ( 1.34%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (49,607x) [./target/valgrind/s4]
 4,406,916 ( 1.32%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (220,401x) [./target/valgrind/s4]
 4,259,921 ( 1.28%)     305 ( 0.04%)   1 ( 0.33%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::NestLimiter<P>::check (81x) [./target/valgrind/s4]
 1,588,677 ( 0.48%)     660 ( 0.08%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_group (713x) [./target/valgrind/s4]
 1,289,898 ( 0.39%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (71,661x) [./target/valgrind/s4]
   916,137 ( 0.28%)   2,355 ( 0.29%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x) [./target/valgrind/s4]
   856,796 ( 0.26%)   1,320 ( 0.16%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition (1,713x) [./target/valgrind/s4]
   243,845 ( 0.07%)     132 ( 0.02%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (172x) [./target/valgrind/s4]
    82,590 ( 0.02%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    26,962 ( 0.01%)     136 ( 0.02%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group_end (81x) [./target/valgrind/s4]

 3,349,933 ( 1.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:alloc::vec::Vec<T,A>::extend_with

71,272,262 (21.40%) 151,036 (18.66%)  23 ( 7.64%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::Translator::translate (81x) [./target/valgrind/s4]
 4,259,516 ( 1.28%)     305 ( 0.04%)   1 ( 0.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::NestLimiter<P>::check (81x) [./target/valgrind/s4]
 3,315,482 ( 1.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit [./target/valgrind/s4]
62,028,739 (18.62%) 147,940 (18.27%)  20 ( 6.64%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (71,256x) [./target/valgrind/s4]
 2,619,293 ( 0.79%)   1,256 ( 0.16%)   3 ( 1.00%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre (71,256x) [./target/valgrind/s4]
 1,716,692 ( 0.52%)   1,526 ( 0.19%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (4,916x) [./target/valgrind/s4]
    80,556 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre (4,916x) [./target/valgrind/s4]
     6,399 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::finish (81x) [./target/valgrind/s4]

 3,220,694 ( 0.97%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/alloc/unix.rs:__rdl_alloc
65,508,548 (19.67%) 393,539 (48.61%)  63 (20.93%)     1 ( 0.07%)  >   ./malloc/./malloc/malloc.c:malloc (402,375x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    59,350 ( 0.02%)     168 ( 0.02%)   .              .           >   ./malloc/./malloc/malloc.c:posix_memalign (121x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 3,868,053 ( 1.16%)   3,023 ( 0.37%)   3 ( 1.00%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (46,585x)
 1,381,856 ( 0.41%)     546 ( 0.07%)   8 ( 2.66%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile (16,950x)
 1,343,310 ( 0.40%)     796 ( 0.10%)   8 ( 2.66%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile (17,526x) [./target/valgrind/s4]
   276,110 ( 0.08%)     104 ( 0.01%)   1 ( 0.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (693x)
   191,212 ( 0.06%)      90 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (3,283x) [./target/valgrind/s4]
    78,526 ( 0.02%)      66 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (773x)
    76,039 ( 0.02%)     178 ( 0.02%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter (1,078x)
    51,420 ( 0.02%)      52 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add_capture_start (774x) [./target/valgrind/s4]
    32,877 ( 0.01%)      32 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (526x) [./target/valgrind/s4]
    26,946 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (252x)
    16,163 ( 0.00%)      36 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::new (126x)
    15,444 ( 0.00%)      44 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::compile (65x)
    12,983 ( 0.00%)       4 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c (225x)
    10,318 ( 0.00%)      12 ( 0.00%)   1 ( 0.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (175x)
     9,109 ( 0.00%)      12 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (134x)
     7,431 ( 0.00%)      12 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap (81x)
       480 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least'2 (10x)
        48 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (1x) [./target/valgrind/s4]
 2,644,615 ( 0.79%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add [./target/valgrind/s4]

 4,464,110 ( 1.34%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (49,607x) [./target/valgrind/s4]
 1,433,610 ( 0.43%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (15,929x) [./target/valgrind/s4]
   634,950 ( 0.19%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::maybe_parse_ascii_class (7,055x) [./target/valgrind/s4]
   308,070 ( 0.09%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (3,423x) [./target/valgrind/s4]
   289,790 ( 0.09%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape (3,219x) [./target/valgrind/s4]
   254,244 ( 0.08%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open (2,826x) [./target/valgrind/s4]
   254,080 ( 0.08%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x) [./target/valgrind/s4]
   225,958 ( 0.07%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (2,511x) [./target/valgrind/s4]
   175,770 ( 0.05%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item (1,937x) [./target/valgrind/s4]
   154,158 ( 0.05%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition (1,713x) [./target/valgrind/s4]
    62,138 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x) [./target/valgrind/s4]
    21,600 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (240x) [./target/valgrind/s4]
    21,510 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (239x) [./target/valgrind/s4]
    15,480 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_and_bump_space (172x) [./target/valgrind/s4]
     2,700 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_flags (30x) [./target/valgrind/s4]
       450 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_perl_class (5x) [./target/valgrind/s4]
 2,495,421 ( 0.75%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump [./target/valgrind/s4]
 3,697,472 ( 1.11%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (184,846x) [./target/valgrind/s4]

 2,476,731 ( 0.74%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/alphabet.rs:regex_automata::nfa::thompson::nfa::Inner::add

 2,177,479 ( 0.65%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:aho_corasick::dfa::Builder::finish_build_one_start

 2,129,118 ( 0.64%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

 2,108,844 ( 0.63%)       .            .              .           *  ./malloc/./malloc/arena.c:malloc
     1,151 ( 0.00%)       0            1 ( 0.33%)     .           >   ./malloc/./malloc/arena.c:ptmalloc_init.part.0 (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

72,373,710 (21.73%) 199,581 (24.65%)  75 (24.92%)     1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (1,386x) [./target/valgrind/s4]
69,916,719 (20.99%) 190,902 (23.58%)  77 (25.58%)     1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (2,840x) [./target/valgrind/s4]
15,195,368 ( 4.56%)  27,864 ( 3.44%)  21 ( 6.98%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (12,493x) [./target/valgrind/s4]
14,280,992 ( 4.29%)  14,076 ( 1.74%)  24 ( 7.97%)     1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter (6,614x) [./target/valgrind/s4]
 1,093,997 ( 0.33%)     548 ( 0.07%)   2 ( 0.66%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (142x) [./target/valgrind/s4]
   794,452 ( 0.24%)      54 ( 0.01%)   1 ( 0.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least'2 (10x) [./target/valgrind/s4]
   303,821 ( 0.09%)     864 ( 0.11%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_concat (580x) [./target/valgrind/s4]
   264,671 ( 0.08%)     901 ( 0.11%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (526x) [./target/valgrind/s4]
 2,090,032 ( 0.63%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 [./target/valgrind/s4]
73,121,553 (21.95%) 200,912 (24.82%)  76 (25.25%)     1 ( 0.07%)  >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (1,386x) [./target/valgrind/s4]
24,167,248 ( 7.26%)  80,603 ( 9.96%)  12 ( 3.99%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add (26,711x) [./target/valgrind/s4]
17,181,242 ( 5.16%)  45,823 ( 5.66%)  23 ( 7.64%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile (495x) [./target/valgrind/s4]
15,737,713 ( 4.72%)  15,987 ( 1.97%)  24 ( 7.97%)     1 ( 0.07%)  >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter (538x) [./target/valgrind/s4]
15,195,368 ( 4.56%)  27,864 ( 3.44%)  21 ( 6.98%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (12,493x) [./target/valgrind/s4]
 4,772,349 ( 1.43%)     662 ( 0.08%)  38 (12.62%)     1 ( 0.07%)  >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::new (126x) [./target/valgrind/s4]
 2,576,745 ( 0.77%)   5,694 ( 0.70%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (39,782x) [./target/valgrind/s4]
 1,164,077 ( 0.35%)     764 ( 0.09%)   2 ( 0.66%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (142x) [./target/valgrind/s4]
   926,427 ( 0.28%)   1,443 ( 0.18%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::add (1,179x) [./target/valgrind/s4]
   798,648 ( 0.24%)      54 ( 0.01%)   1 ( 0.33%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least'2 (10x) [./target/valgrind/s4]
   691,299 ( 0.21%)   2,005 ( 0.25%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (134x) [./target/valgrind/s4]
   442,337 ( 0.13%)     229 ( 0.03%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/utf8.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next (3,756x) [./target/valgrind/s4]
   392,673 ( 0.12%)     364 ( 0.04%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/map.rs:regex_automata::nfa::thompson::map::Utf8SuffixMap::clear (127x) [./target/valgrind/s4]
   234,769 ( 0.07%)     606 ( 0.07%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_concat (210x) [./target/valgrind/s4]
   204,016 ( 0.06%)     394 ( 0.05%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::finish (126x) [./target/valgrind/s4]
   191,212 ( 0.06%)      90 ( 0.01%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (3,283x) [./target/valgrind/s4]
   146,101 ( 0.04%)     418 ( 0.05%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/utf8.rs:regex_syntax::utf8::Utf8Sequences::new (1,386x) [./target/valgrind/s4]
    91,463 ( 0.03%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next (16,182x) [./target/valgrind/s4]
    73,177 ( 0.02%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::ClassUnicode::is_ascii (5,629x) [./target/valgrind/s4]
    20,688 ( 0.01%)      18 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::reverse (252x) [./target/valgrind/s4]

 2,046,084 ( 0.61%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler>

11,493,493 ( 3.45%)  37,972 ( 4.69%)   1 ( 0.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/strategy.rs:regex_automata::meta::strategy::new (175x) [./target/valgrind/s4]
    49,791 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::meta::wrappers::Hybrid::new (243x)
    16,597 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::meta::wrappers::BoundedBacktracker::new (81x)
    16,597 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::meta::wrappers::OnePass::new (81x)
    16,597 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::meta::wrappers::PikeVM::new (81x)
     2,657 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::meta::wrappers::ReverseHybrid::new (13x)
 2,038,069 ( 0.61%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> [./target/valgrind/s4]
 5,546,407 ( 1.67%)  33,350 ( 4.12%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (674x) [./target/valgrind/s4]

 2,037,975 ( 0.61%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs:aho_corasick::dfa::Builder::finish_build_one_start

18,604,395 ( 5.59%)  33,833 ( 4.18%)   7 ( 2.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::compile (175x) [./target/valgrind/s4]
 1,979,045 ( 0.59%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build [./target/valgrind/s4]
 6,817,361 ( 2.05%)   4,047 ( 0.50%)   5 ( 1.66%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (64,414x) [./target/valgrind/s4]
 1,694,769 ( 0.51%)   1,802 ( 0.22%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x) [./target/valgrind/s4]
 1,236,667 ( 0.37%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::remap (175x) [./target/valgrind/s4]
    11,375 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 1,961,492 ( 0.59%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs:regex_syntax::ast::parse::ParserI<P>::char

 4,803,353 ( 1.44%)   1,620 ( 0.20%)   .              .           < ./malloc/./malloc/malloc.c:_int_free (28,130x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     5,251 ( 0.00%)       .            .              .           < ./malloc/./malloc/malloc.c:_int_memalign (61x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
 1,800,497 ( 0.54%)       .            .              .           *  ./malloc/./malloc/malloc.c:_int_free_merge_chunk [/usr/lib/x86_64-linux-gnu/libc.so.6]
 2,840,242 ( 0.85%)   1,620 ( 0.20%)   .              .           >   ./malloc/./malloc/malloc.c:_int_free_maybe_consolidate (28,191x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   167,865 ( 0.05%)       .            .              .           >   ./malloc/./malloc/malloc.c:unlink_chunk.isra.0 (7,172x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 2,576,745 ( 0.77%)   5,694 ( 0.70%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (39,782x) [./target/valgrind/s4]
   940,989 ( 0.28%)   1,771 ( 0.22%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (13,228x) [./target/valgrind/s4]
   220,820 ( 0.07%)     802 ( 0.10%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (1,712x) [./target/valgrind/s4]
    94,828 ( 0.03%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (2,671x) [./target/valgrind/s4]
    75,449 ( 0.02%)     218 ( 0.03%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (504x) [./target/valgrind/s4]
    47,816 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (1,386x) [./target/valgrind/s4]
     8,260 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_concat (236x) [./target/valgrind/s4]
     7,555 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::compile (175x) [./target/valgrind/s4]
     6,044 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (175x)
     5,570 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap (162x) [./target/valgrind/s4]
     2,866 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least'2 (20x) [./target/valgrind/s4]
 1,780,929 ( 0.53%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch [./target/valgrind/s4]

 6,817,361 ( 2.05%)   4,047 ( 0.50%)   5 ( 1.66%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build (64,414x) [./target/valgrind/s4]
 1,766,602 ( 0.53%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add [./target/valgrind/s4]
     3,920 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/look.rs:regex_automata::util::look::LookMatcher::add_to_byteset (245x) [./target/valgrind/s4]

 2,619,293 ( 0.79%)   1,256 ( 0.16%)   3 ( 1.00%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (71,256x) [./target/valgrind/s4]
 1,749,998 ( 0.53%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre [./target/valgrind/s4]

17,181,242 ( 5.16%)  45,823 ( 5.66%)  23 ( 7.64%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (495x) [./target/valgrind/s4]
 1,714,300 ( 0.51%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile [./target/valgrind/s4]
 1,343,310 ( 0.40%)     796 ( 0.10%)   8 ( 2.66%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (17,526x) [./target/valgrind/s4]

 1,289,898 ( 0.39%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (71,661x) [./target/valgrind/s4]
   179,406 ( 0.05%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (9,967x) [./target/valgrind/s4]
    63,882 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range (3,549x) [./target/valgrind/s4]
    50,868 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open (2,826x) [./target/valgrind/s4]
    12,834 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (713x) [./target/valgrind/s4]
     4,320 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (240x) [./target/valgrind/s4]
     4,302 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (239x) [./target/valgrind/s4]
     3,096 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_and_bump_space (172x) [./target/valgrind/s4]
 1,608,606 ( 0.48%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space [./target/valgrind/s4]

16,810,488 ( 5.05%)  99,702 (12.31%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop (71,256x) [./target/valgrind/s4]
   347,910 ( 0.10%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (2,578x) [./target/valgrind/s4]
 1,603,470 ( 0.48%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 [./target/valgrind/s4]
12,032,955 ( 3.61%)  94,213 (11.64%)   .              .           >   ???:__rust_dealloc (90,718x) [./target/valgrind/s4]
 1,498,896 ( 0.45%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop'2 (73,834x) [./target/valgrind/s4]
 1,244,800 ( 0.37%)   2,886 ( 0.36%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (2,753x) [./target/valgrind/s4]
   347,910 ( 0.10%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (2,578x) [./target/valgrind/s4]
    55,060 ( 0.02%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSetItem> (2,753x) [./target/valgrind/s4]

 6,555,178 ( 1.97%)   2,505 ( 0.31%)   4 ( 1.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (512x) [./target/valgrind/s4]
   591,079 ( 0.18%)     248 ( 0.03%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten (55x) [./target/valgrind/s4]
   182,605 ( 0.05%)      66 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (12x) [./target/valgrind/s4]
 1,597,060 ( 0.48%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation [./target/valgrind/s4]
 4,624,483 ( 1.39%)   1,059 ( 0.13%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::into_parts (18,288x) [./target/valgrind/s4]
     7,409 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (6x) [./target/valgrind/s4]
     6,810 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/debug.rs:regex_syntax::debug::utf8_decode (454x) [./target/valgrind/s4]
     4,939 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation'2 (1x) [./target/valgrind/s4]
       171 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::new (1x) [./target/valgrind/s4]

 1,576,724 ( 0.47%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::visitor::visit
   128,214 ( 0.04%)     331 ( 0.04%)   1 ( 0.33%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (486x) [./target/valgrind/s4]

24,333,545 ( 7.31%)  51,060 ( 6.31%)   2 ( 0.66%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (15,786x) [./target/valgrind/s4]
   251,527 ( 0.08%)     241 ( 0.03%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::extract (39x) [./target/valgrind/s4]
   161,821 ( 0.05%)     312 ( 0.04%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (83x) [./target/valgrind/s4]
    45,502 ( 0.01%)      76 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten (29x) [./target/valgrind/s4]
     7,409 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (6x) [./target/valgrind/s4]
 1,541,447 ( 0.46%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat [./target/valgrind/s4]
 7,671,072 ( 2.30%)  29,408 ( 3.63%)   2 ( 0.66%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::into_parts (20,550x) [./target/valgrind/s4]
 2,490,300 ( 0.75%)      22 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::literal (15,406x) [./target/valgrind/s4]
        94 ( 0.00%)       .            .              .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/str/converts.rs:core::str::converts::from_utf8 (2x) [./target/valgrind/s4]

 1,498,896 ( 0.45%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (73,834x) [./target/valgrind/s4]
 1,498,896 ( 0.45%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop'2 [./target/valgrind/s4]

 4,946,851 ( 1.49%)  29,429 ( 3.63%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (27,518x)
   776,860 ( 0.23%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::into_parts (38,843x)
     1,360 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::concat (68x)
       260 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::into_kind (13x)
       260 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::meta::reverse_inner::extract (13x)
       100 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::alternation (5x)
 1,479,714 ( 0.44%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> [./target/valgrind/s4]
 3,964,397 ( 1.19%)  28,858 ( 3.56%)   .              .           >   ???:__rust_dealloc (30,116x) [./target/valgrind/s4]
    65,328 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop'2 (2,722x) [./target/valgrind/s4]
    54,440 ( 0.02%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind>'2 (2,722x) [./target/valgrind/s4]

 1,476,672 ( 0.44%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/validations.rs:regex_syntax::ast::parse::ParserI<P>::char

 1,290,404 ( 0.39%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:alloc::vec::Vec<T,A>::dedup_by (58,970x)
    78,893 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (3,659x)
    32,843 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (1,453x)
    30,464 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert (1,394x)
     6,735 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:hashbrown::map::HashMap<K,V,S,A>::insert (354x)
     3,170 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:regex_syntax::hir::literal::Extractor::extract'2 (317x)
     1,400 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:regex_automata::util::captures::Captures::get_group_by_name (65x)
       907 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (46x)
       622 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::parser::arg_matcher::ArgMatcher::check_explicit (31x)
       543 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::parser::validator::Validator::validate (27x)
       474 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::parser::arg_matcher::ArgMatcher::add_index_to (24x)
       474 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::parser::parser::Parser::push_arg_values (24x)
       430 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::util::flat_map::FlatMap<K,V>::remove_entry (22x)
       319 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::parser::parser::Parser::start_custom_arg (16x)
       310 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::parser::validator::gather_direct_conflicts (16x)
       136 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::parser::validator::Conflicts::gather_conflicts (7x)
       132 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::parser::arg_matcher::ArgMatcher::start_custom_arg (6x)
       132 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::util::flat_map::FlatMap<K,V>::remove (6x)
       132 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::parser::parser::Parser::add_defaults (6x)
       110 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:chrono::format::parse::parse_internal (11x)
       104 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::parser::arg_matcher::ArgMatcher::start_custom_group (5x)
        85 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:s4lib::readers::filepreprocessor::pathbuf_to_filetype_impl (4x)
        76 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::builder::command::Command::_build_self (4x)
        76 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::parser::parser::Parser::get_matches_with (4x)
        57 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::builder::command::Command::unroll_arg_requires (3x)
        57 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::parser::parser::Parser::resolve_pending (3x)
        38 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:clap_builder::builder::possible_value::PossibleValue::matches (2x)
        22 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:regex_automata::util::captures::GroupInfo::new (1x)
        20 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:chrono::offset::local::tz_info::parser::Cursor::read_tag (2x)
        10 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:core::str::iter::SplitInternal<P>::next_back (1x)
        10 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:<regex_syntax::hir::Hir as core::cmp::PartialEq>::eq (1x)
        10 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:regex_syntax::hir::literal::Extractor::extract (1x)
 1,449,195 ( 0.44%)       .            .              .           *  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe [/usr/lib/x86_64-linux-gnu/libc.so.6]

 1,448,070 ( 0.43%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:alloc::raw_vec::finish_grow

 1,414,657 ( 0.42%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

 1,395,988 ( 0.42%)       .            .              .           *  ./malloc/./malloc/arena.c:realloc

11,399,105 ( 3.42%)  54,328 ( 6.71%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (233x) [./target/valgrind/s4]
   932,232 ( 0.28%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::into_parts (38,843x)
   866,574 ( 0.26%)   4,083 ( 0.50%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::meta::reverse_inner::extract (13x)
     1,632 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::concat (68x)
       312 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::into_kind (13x)
       120 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::alternation (5x)
       120 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir>'2 (5x) [./target/valgrind/s4]
 1,383,791 ( 0.42%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop [./target/valgrind/s4]

24,167,248 ( 7.26%)  80,603 ( 9.96%)  12 ( 3.99%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (26,711x) [./target/valgrind/s4]
 1,376,673 ( 0.41%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add [./target/valgrind/s4]

 1,315,816 ( 0.40%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/str/validations.rs:core::str::converts::from_utf8

 1,297,462 ( 0.39%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add
16,447,947 ( 4.94%)  80,603 ( 9.96%)  12 ( 3.99%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (48,899x) [./target/valgrind/s4]

 1,136,026 ( 0.34%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post
 3,623,709 ( 1.09%)   6,974 ( 0.86%)  13 ( 4.32%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (18,030x) [./target/valgrind/s4]

 8,443,069 ( 2.53%)     862 ( 0.11%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (39x) [./target/valgrind/s4]
 1,123,186 ( 0.34%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::finish_build_one_start [./target/valgrind/s4]
   255,384 ( 0.08%)     862 ( 0.11%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::DFA::set_matches (953x) [./target/valgrind/s4]

 1,111,472 ( 0.33%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:alloc::raw_vec::RawVec<T,A>::grow_one

 1,078,933 ( 0.32%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs:alloc::raw_vec::RawVec<T,A>::grow_one

 1,057,233 ( 0.32%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop
 4,435,017 ( 1.33%)  33,419 ( 4.13%)   .              .           >   ???:__rust_dealloc (34,540x) [./target/valgrind/s4]

   990,929 ( 0.30%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments
    82,590 ( 0.02%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 7,753,142 ( 2.33%)  26,910 ( 3.32%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (15,929x) [./target/valgrind/s4]
   934,361 ( 0.28%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate [./target/valgrind/s4]
 3,598,399 ( 1.08%)  22,359 ( 2.76%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (15,929x) [./target/valgrind/s4]
 1,433,610 ( 0.43%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (15,929x) [./target/valgrind/s4]
   318,580 ( 0.10%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (15,929x) [./target/valgrind/s4]

   931,965 ( 0.28%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

   912,078 ( 0.27%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   857,066 ( 0.26%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/alloc/unix.rs:__rdl_realloc
31,997,007 ( 9.61%) 144,997 (17.91%)  68 (22.59%)     .           >   ./malloc/./malloc/malloc.c:realloc (61,219x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   847,634 ( 0.25%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::visitor::visit

   813,944 ( 0.24%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:aho_corasick::dfa::Builder::finish_build_one_start

   813,944 ( 0.24%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:aho_corasick::dfa::Builder::finish_build_one_start

48,079,339 (14.43%) 260,940 (32.23%)   1 ( 0.33%)     .           < ???:__rust_dealloc (386,075x) [./target/valgrind/s4]
   772,150 ( 0.23%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/alloc.rs:__rdl_dealloc [./target/valgrind/s4]

   772,150 ( 0.23%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/alloc/unix.rs:__rdl_dealloc
46,535,039 (13.97%) 260,940 (32.23%)   1 ( 0.33%)     .           >   ./malloc/./malloc/malloc.c:free (386,075x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   769,300 ( 0.23%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/alphabet.rs:regex_automata::hybrid::dfa::Builder::build_from_nfa

   767,361 ( 0.23%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/alphabet.rs:regex_automata::hybrid::dfa::Lazy::init_cache

   763,000 ( 0.23%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/alphabet.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa
     5,250 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   692,049 ( 0.21%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (27,518x)
    65,328 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (2,722x) [./target/valgrind/s4]
   757,377 ( 0.23%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop'2 [./target/valgrind/s4]

 4,727,714 ( 1.42%)     924 ( 0.11%)   7 ( 2.33%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::pikevm::ActiveStates::reset (318x)
 4,449,609 ( 1.34%)   1,439 ( 0.18%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop (270x)
 4,186,677 ( 1.26%)  30,522 ( 3.77%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (15,399x)
 1,026,971 ( 0.31%)     842 ( 0.10%)   2 ( 0.66%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (290x)
   793,166 ( 0.24%)   1,802 ( 0.22%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (302x)
   471,526 ( 0.14%)   1,256 ( 0.16%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend (450x)
   424,499 ( 0.13%)   1,048 ( 0.13%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (525x)
   385,224 ( 0.12%)     994 ( 0.12%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::builder::Builder::build (175x)
   365,825 ( 0.11%)     863 ( 0.11%)   6 ( 1.99%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:aho_corasick::nfa::noncontiguous::Compiler::densify (314x)
   325,224 ( 0.10%)     801 ( 0.10%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<alloc::string::String as core::fmt::Write>::write_str (1,865x)
   186,836 ( 0.06%)     456 ( 0.06%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::hybrid::dfa::Lazy::init_cache (468x)
   148,206 ( 0.04%)     311 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (846x)
   142,439 ( 0.04%)     553 ( 0.07%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (428x)
   136,106 ( 0.04%)     500 ( 0.06%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::util::sparse_set::SparseSets::new (468x)
   116,779 ( 0.04%)     188 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (243x)
    48,196 ( 0.01%)      68 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (34x)
    39,420 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::util::determinize::state::State::dead (292x)
    10,968 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex::regex::bytes::Regex::new (80x)
    10,342 ( 0.00%)      26 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_syntax::hir::Hir::alternation (58x)
     6,689 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<clap_builder::builder::styled_str::StyledStr as core::convert::From<&str>>::from (24x)
     5,535 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x)
     3,208 ( 0.00%)      14 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::util::determinize::epsilon_closure (7x)
     2,191 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (8x)
       502 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<T,I>>::from_iter (2x)
       452 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:clap_builder::builder::command::Command::_build_self (2x)
       271 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:clap_builder::mkeymap::MKeyMap::_build (1x)
       251 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<F as clap_builder::builder::value_parser::TypedValueParser>::parse_ref (1x)
       135 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<regex_automata::meta::strategy::Core as regex_automata::meta::strategy::Strategy>::create_cache (1x)
       135 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex::regex::string::Regex::new (1x)
       135 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::backtrack::BoundedBacktracker::search_imp (1x)
   723,062 ( 0.22%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle [./target/valgrind/s4]
16,747,326 ( 5.03%)  42,609 ( 5.26%)  15 ( 4.98%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::finish_grow (22,914x) [./target/valgrind/s4]

   720,542 ( 0.22%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile
 9,090,023 ( 2.73%)  44,208 ( 5.46%)   7 ( 2.33%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (37,448x) [./target/valgrind/s4]

   717,043 ( 0.22%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::visitor::visit
   666,750 ( 0.20%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::NestLimiter<P>::increment_depth (22,225x) [./target/valgrind/s4]

   701,620 ( 0.21%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::PreferenceTrie::insert
 4,430,832 ( 1.33%)  18,015 ( 2.23%)   4 ( 1.33%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (10,736x) [./target/valgrind/s4]

 2,840,242 ( 0.85%)   1,620 ( 0.20%)   .              .           < ./malloc/./malloc/malloc.c:_int_free_merge_chunk (28,191x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     2,052 ( 0.00%)       .            .              .           < ./malloc/./malloc/malloc.c:_int_memalign (85x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   682,428 ( 0.20%)       .            .              .           *  ./malloc/./malloc/malloc.c:_int_free_maybe_consolidate [/usr/lib/x86_64-linux-gnu/libc.so.6]
 2,155,591 ( 0.65%)   1,620 ( 0.20%)   .              .           >   ./malloc/./malloc/malloc.c:malloc_consolidate (162x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 1,236,667 ( 0.37%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build (175x) [./target/valgrind/s4]
   672,734 ( 0.20%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::remap [./target/valgrind/s4]

   638,874 ( 0.19%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

 8,061,486 ( 2.42%)  18,015 ( 2.23%)   4 ( 1.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:alloc::vec::Vec<T,A>::retain_mut (16,878x)
   638,588 ( 0.19%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::PreferenceTrie::insert [./target/valgrind/s4]

   635,807 ( 0.19%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   626,374 ( 0.19%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   621,488 ( 0.19%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::into_parts
   932,232 ( 0.28%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (38,843x) [./target/valgrind/s4]
   776,860 ( 0.23%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (38,843x) [./target/valgrind/s4]

   612,055 ( 0.18%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:alloc::raw_vec::RawVec<T,A>::grow_one

   666,750 ( 0.20%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::visitor::visit (22,225x)
   600,075 ( 0.18%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::NestLimiter<P>::increment_depth [./target/valgrind/s4]

   599,610 ( 0.18%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_syntax::ast::visitor::visit

   594,094 ( 0.18%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_automata::nfa::thompson::builder::Builder::build

   593,634 ( 0.18%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop
 4,946,851 ( 1.49%)  29,429 ( 3.63%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (27,518x) [./target/valgrind/s4]
   692,049 ( 0.21%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop'2 (27,518x) [./target/valgrind/s4]
    67,704 ( 0.02%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/drain.rs:<alloc::vec::drain::Drain<T,A> as core::ops::drop::Drop>::drop (2,604x) [./target/valgrind/s4]

   917,832 ( 0.28%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (16,096x)
   885,942 ( 0.27%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::literal (15,406x) [./target/valgrind/s4]
   104,669 ( 0.03%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::literal (1,912x) [./target/valgrind/s4]
    68,338 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class (1,454x) [./target/valgrind/s4]
     1,130 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/os_str/bytes.rs:std::sys::os_str::bytes::Slice::to_str (12x)
       399 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/string.rs:std::sys::os_str::bytes::Buf::into_string (5x)
       312 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/chrono-0.4.42/src/offset/local/tz_info/parser.rs:chrono::offset::local::tz_info::parser::Cursor::read_int (7x) [./target/valgrind/s4]
       113 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/chrono-0.4.42/src/offset/local/tz_info/parser.rs:chrono::offset::local::tz_info::parser::parse (1x) [./target/valgrind/s4]
        94 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (2x) [./target/valgrind/s4]
        80 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap_lex-0.7.5/src/ext.rs:clap_lex::ParsedArg::to_short (2x)
   593,249 ( 0.18%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/str/converts.rs:core::str::converts::from_utf8 [./target/valgrind/s4]

 2,756,235 ( 0.83%)   1,248 ( 0.15%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
   580,400 ( 0.17%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie [./target/valgrind/s4]
   580,438 ( 0.17%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::add_transition (2,432x) [./target/valgrind/s4]
   205,101 ( 0.06%)     639 ( 0.08%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (2,432x) [./target/valgrind/s4]
   158,700 ( 0.05%)     300 ( 0.04%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::add_match (1,394x) [./target/valgrind/s4]
   125,120 ( 0.04%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::set_range (3,680x) [./target/valgrind/s4]
    33,120 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::iter_trans (3,680x) [./target/valgrind/s4]

   577,089 ( 0.17%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

   573,197 ( 0.17%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments
    82,590 ( 0.02%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   562,443 ( 0.17%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   548,459 ( 0.16%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments
 5,493,638 ( 1.65%)  29,210 ( 3.61%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (18,495x) [./target/valgrind/s4]

   545,024 ( 0.16%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::dfa::Builder::finish_build_one_start

   534,923 ( 0.16%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

   532,992 ( 0.16%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:alloc::raw_vec::RawVec<T,A>::grow_one

24,106,519 ( 7.24%) 101,299 (12.51%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast> (774x) [./target/valgrind/s4]
   521,034 ( 0.16%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop [./target/valgrind/s4]
16,810,488 ( 5.05%)  99,702 (12.31%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (71,256x) [./target/valgrind/s4]

   512,584 ( 0.15%)       .            .              .           < ./malloc/./malloc/malloc.c:_int_malloc (128,146x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   512,584 ( 0.15%)       .            .              .           *  ./malloc/./malloc/malloc.c:alloc_perturb [/usr/lib/x86_64-linux-gnu/libc.so.6]

   503,677 ( 0.15%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_syntax::ast::visitor::visit

   500,169 ( 0.15%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

   498,822 ( 0.15%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

   494,025 ( 0.15%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::add
 3,331,766 ( 1.00%)   5,007 ( 0.62%)  21 ( 6.98%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (1,376x) [./target/valgrind/s4]

   490,624 ( 0.15%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::char

   490,624 ( 0.15%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_syntax::ast::parse::ParserI<P>::char

   490,624 ( 0.15%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_syntax::ast::parse::ParserI<P>::char

   490,122 ( 0.15%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:regex_syntax::ast::parse::ParserI<P>::char

   490,122 ( 0.15%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/traits.rs:regex_syntax::ast::parse::ParserI<P>::char

33,343,825 (10.01%) 144,997 (17.91%)  68 (22.59%)     .           < ???:__rust_realloc (61,219x) [./target/valgrind/s4]
   489,752 ( 0.15%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/alloc.rs:__rdl_realloc [./target/valgrind/s4]

 2,034,446 ( 0.61%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::union (2,445x) [./target/valgrind/s4]
   201,140 ( 0.06%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (422x) [./target/valgrind/s4]
    70,139 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_automata::util::prefilter::prefixes (15x)
     3,015 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_automata::util::prefilter::suffixes (12x)
   488,772 ( 0.15%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::dedup_by [./target/valgrind/s4]

   481,634 ( 0.14%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::builder::Builder::add

 7,671,072 ( 2.30%)  29,408 ( 3.63%)   2 ( 0.66%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (20,550x) [./target/valgrind/s4]
 4,624,483 ( 1.39%)   1,059 ( 0.13%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (18,288x) [./target/valgrind/s4]
     1,195 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation'2 (5x) [./target/valgrind/s4]
   466,116 ( 0.14%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::into_parts [./target/valgrind/s4]

   454,316 ( 0.14%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post
 4,186,677 ( 1.26%)  30,522 ( 3.77%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (15,399x) [./target/valgrind/s4]

   716,865 ( 0.22%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::init_cache (22,413x) [./target/valgrind/s4]
     6,976 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (218x) [./target/valgrind/s4]
   452,620 ( 0.14%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::set_transition [./target/valgrind/s4]

   451,502 ( 0.14%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

 8,923,368 ( 2.68%)   1,216 ( 0.15%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (2,753x) [./target/valgrind/s4]
   444,667 ( 0.13%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class [./target/valgrind/s4]
 2,637,164 ( 0.79%)     330 ( 0.04%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (2,824x) [./target/valgrind/s4]
 1,724,922 ( 0.52%)      10 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x) [./target/valgrind/s4]
 1,428,189 ( 0.43%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range (3,549x) [./target/valgrind/s4]
   952,460 ( 0.29%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::maybe_parse_ascii_class (841x) [./target/valgrind/s4]
   254,904 ( 0.08%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (12,720x) [./target/valgrind/s4]
   189,060 ( 0.06%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (6,302x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   179,406 ( 0.05%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (9,967x) [./target/valgrind/s4]

151,112,926 (45.37%) 351,472 (43.41%) 103 (34.22%)     1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/regex.rs:regex_automata::meta::regex::Builder::build (81x) [./target/valgrind/s4]
   440,067 ( 0.13%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/strategy.rs:regex_automata::meta::strategy::new [./target/valgrind/s4]
32,594,058 ( 9.79%)  58,128 ( 7.18%)  15 ( 4.98%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::extract (13x) [./target/valgrind/s4]
11,493,493 ( 3.45%)  37,972 ( 4.69%)   1 ( 0.33%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> (175x) [./target/valgrind/s4]
 7,207,125 ( 2.16%)  17,054 ( 2.11%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/prefilter/mod.rs:regex_automata::util::prefilter::prefixes (16x) [./target/valgrind/s4]
 2,572,840 ( 0.77%)   2,469 ( 0.30%)   2 ( 0.66%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::OnePass::new (81x) [./target/valgrind/s4]
 2,162,573 ( 0.65%)   5,148 ( 0.64%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/prefilter/mod.rs:regex_automata::util::prefilter::suffixes (13x) [./target/valgrind/s4]
 1,135,526 ( 0.34%)     606 ( 0.07%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::new (81x) [./target/valgrind/s4]
   232,863 ( 0.07%)   1,121 ( 0.14%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (13x) [./target/valgrind/s4]
    83,265 ( 0.02%)      39 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::new (13x) [./target/valgrind/s4]
    45,250 ( 0.01%)     111 ( 0.01%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::BoundedBacktracker::new (81x) [./target/valgrind/s4]
    44,560 ( 0.01%)     111 ( 0.01%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::PikeVM::new (81x) [./target/valgrind/s4]
     3,809 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::new (13x) [./target/valgrind/s4]
     2,626 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (26x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
       458 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/literal.rs:regex_automata::meta::literal::alternation_literals (16x) [./target/valgrind/s4]
       377 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::configure (13x) [./target/valgrind/s4]

   435,592 ( 0.13%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie

   431,567 ( 0.13%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop

   427,273 ( 0.13%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::into_parts
 4,821,884 ( 1.45%)  29,864 ( 3.69%)   2 ( 0.66%)     .           >   ???:__rust_alloc (38,843x) [./target/valgrind/s4]
 3,823,624 ( 1.15%)     603 ( 0.07%)   .              .           >   ???:__rust_dealloc (38,843x) [./target/valgrind/s4]

   427,273 ( 0.13%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::hir::Hir::into_parts

   422,207 ( 0.13%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

   414,870 ( 0.12%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::dfa::Builder::finish_build_one_start

   405,274 ( 0.12%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap

69,192,056 (20.77%) 393,707 (48.63%)  63 (20.93%)     1 ( 0.07%)  < ???:__rust_alloc (402,496x) [./target/valgrind/s4]
   402,859 ( 0.12%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/alloc.rs:__rdl_alloc [./target/valgrind/s4]

29,044,346 ( 8.72%) 155,370 (19.19%)  14 ( 4.65%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::finish_grow (156,554x) [./target/valgrind/s4]
10,788,329 ( 3.24%)  81,752 (10.10%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (52,360x)
 4,821,884 ( 1.45%)  29,864 ( 3.69%)   2 ( 0.66%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::into_parts (38,843x)
 3,121,395 ( 0.94%)  23,291 ( 2.88%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::Concat::into_ast (15,786x)
 2,985,482 ( 0.90%)  10,948 ( 1.35%)   1 ( 0.33%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (36,032x)
 2,690,268 ( 0.81%)  20,326 ( 2.51%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::builder::Builder::build (12,204x)
 2,283,622 ( 0.69%)  16,454 ( 2.03%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::concat (17,551x)
 2,043,937 ( 0.61%)     260 ( 0.03%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::fold (81x)
 1,413,296 ( 0.42%)   9,717 ( 1.20%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::cross (7,320x)
 1,063,219 ( 0.32%)   7,541 ( 0.93%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (5,619x)
   935,612 ( 0.28%)     950 ( 0.12%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::meta::strategy::new (81x)
   878,995 ( 0.26%)     626 ( 0.08%)  38 (12.62%)     1 ( 0.07%)  < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::map::Utf8BoundedMap::clear (67x)
   849,464 ( 0.26%)      22 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::literal (15,406x)
   626,468 ( 0.19%)   4,397 ( 0.54%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::class (2,728x)
   541,031 ( 0.16%)   2,976 ( 0.37%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::extract'2 (5,194x)
   471,519 ( 0.14%)   3,644 ( 0.45%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::literal (1,912x)
   454,807 ( 0.14%)   3,688 ( 0.46%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::repetition (2,034x)
   351,729 ( 0.11%)   1,320 ( 0.16%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition (3,426x)
   350,044 ( 0.11%)   2,935 ( 0.36%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::vec::Vec<T,A> as core::clone::Clone>::clone (1,657x)
   347,584 ( 0.10%)   2,707 ( 0.33%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::meta::reverse_inner::flatten'2 (2,166x)
   280,382 ( 0.08%)   2,221 ( 0.27%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::packed::pattern::Patterns::add (1,394x)
   271,538 ( 0.08%)   2,018 ( 0.25%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::class (1,454x)
   197,716 ( 0.06%)     144 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (81x)
   172,675 ( 0.05%)   1,048 ( 0.13%)   4 ( 1.33%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::alternation (1,162x)
   166,609 ( 0.05%)      62 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (2,930x)
   165,072 ( 0.05%)     192 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::meta::reverse_inner::flatten (118x)
   160,642 ( 0.05%)   1,127 ( 0.14%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::capture (693x)
   153,587 ( 0.05%)     310 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<T as alloc::vec::spec_from_elem::SpecFromElem>::from_elem (153x)
   150,700 ( 0.05%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop (2,740x)
   144,186 ( 0.04%)   1,026 ( 0.13%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::util::captures::GroupInfo::new (761x)
   132,201 ( 0.04%)     845 ( 0.10%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (773x)
   118,560 ( 0.04%)     314 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (1,386x)
   114,223 ( 0.03%)     418 ( 0.05%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::utf8::Utf8Sequences::new (1,386x)
   109,789 ( 0.03%)     324 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (1,279x)
   105,088 ( 0.03%)     820 ( 0.10%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (586x)
    89,856 ( 0.03%)     622 ( 0.08%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::Alternation::into_ast (512x)
    81,834 ( 0.02%)     413 ( 0.05%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter (782x)
    79,675 ( 0.02%)     123 ( 0.02%)   .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:<alloc::string::String as core::clone::Clone>::clone (1,187x)
    64,377 ( 0.02%)     364 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::map::Utf8SuffixMap::clear (68x)
    56,440 ( 0.02%)     200 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::meta::regex::Builder::build (324x)
    56,105 ( 0.02%)      50 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (595x)
    50,746 ( 0.02%)     144 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::util::pool::inner::Pool<T,F>::new (81x)
    49,031 ( 0.01%)      94 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex::builders::Builder::build_one_bytes (80x)
    45,923 ( 0.01%)     220 ( 0.03%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x)
    44,718 ( 0.01%)     183 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::meta::regex::RegexInfo::new (162x)
    43,749 ( 0.01%)     108 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (512x)
    40,950 ( 0.01%)      77 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (586x)
    38,543 ( 0.01%)     164 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash (347x)
    31,300 ( 0.01%)     302 ( 0.04%)   4 ( 1.33%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (114x)
    26,962 ( 0.01%)     164 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (174x)
    18,760 ( 0.01%)     146 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::util::captures::GroupInfoInner::add_first_group (81x)
    18,154 ( 0.01%)      84 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::Ast::repetition (172x)
    16,853 ( 0.01%)      92 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Repetition::with (149x)
    16,840 ( 0.01%)     128 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::union (81x)
    16,112 ( 0.00%)      48 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::alloc::exchange_malloc (172x) [./target/valgrind/s4]
    16,060 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::util::determinize::state::State::dead (292x)
    15,144 ( 0.00%)      18 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::reverse (252x)
    14,897 ( 0.00%)       8 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_automata::meta::strategy::Core as regex_automata::meta::strategy::Strategy>::create_cache (42x)
    12,681 ( 0.00%)       4 ( 0.00%)   .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/raw_vec.rs:alloc::raw_vec::finish_grow (159x) [./target/valgrind/s4]
    11,902 ( 0.00%)      30 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::util::prefilter::Prefilter::from_choice (50x)
     8,687 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::meta::regex::Regex::create_captures (86x)
     8,597 ( 0.00%)      24 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::Ast::empty (107x)
     8,296 ( 0.00%)      54 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::Edge>::insert_recursing (70x)
     8,055 ( 0.00%)      18 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::FatAVX2<3_usize>::new_unchecked (42x)
     7,030 ( 0.00%)      34 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert (73x)
     6,645 ( 0.00%)      12 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::packed::api::Builder::build (96x)
     5,830 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Compiler::c (112x)
     5,720 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::dot (110x)
     5,580 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (29x)
     5,089 ( 0.00%)       4 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::data::line::Line::get_boxptrs (84x)
     4,857 ( 0.00%)      10 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<1_usize>::new_unchecked (36x)
     4,789 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:std::sys::os_str::bytes::Slice::to_owned (26x)
     4,203 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (71x)
     3,596 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<P as clap_builder::builder::value_parser::AnyValueParser>::parse_ref_ (18x)
     3,381 ( 0.00%)       4 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::extract (51x)
     3,119 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::builder::arg::Arg::_build (15x)
     3,086 ( 0.00%)       6 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::meta::reverse_inner::extract (26x)
     2,640 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::util::remapper::Remapper::remap (48x)
     2,640 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle (48x)
     2,255 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x)
     1,833 ( 0.00%)      16 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:lru::LruCache<K,V>::new (9x)
     1,798 ( 0.00%)      10 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:lru::LruCache<K,V,S>::put (15x)
     1,767 ( 0.00%)      16 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:hashbrown::raw::RawTable<T,A>::with_capacity_in (13x)
     1,590 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<3_usize>::new_unchecked (15x)
     1,375 ( 0.00%)      10 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::linereader::LineReader::insert_line (5x)
     1,347 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::push_group (20x)
     1,228 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<T,I>>::from_iter (12x)
     1,189 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:std::env::args_os (7x)
     1,118 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:std::sync::poison::once::Once::call_once_force::{{closure}} (6x)
       970 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::parser::parser::Parser::add_defaults (15x)
       831 ( 0.00%)       6 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::parse_datetime_in_line_cached (5x)
       800 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::parser::parser::Parser::start_custom_arg (4x)
       741 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4::processing_loop (3x)
       741 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<P as clap_builder::builder::value_parser::AnyValueParser>::possible_values (11x)
       718 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::unicode::perl_digit (5x)
       669 ( 0.00%)       6 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::linereader::LineReader::find_line_in_block (3x)
       666 ( 0.00%)       6 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::linereader::LineReader::new (3x)
       605 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_automata::meta::strategy::ReverseInner as regex_automata::meta::strategy::Strategy>::create_cache (11x)
       521 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::insert_sysline (4x)
       495 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::ahocorasick::AhoCorasickBuilder::build (9x)
       440 ( 0.00%)       4 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Internal>,alloc::collections::btree::node::marker::KV>::split (2x)
       385 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<F as clap_builder::builder::value_parser::TypedValueParser>::parse_ref (2x)
       384 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:chrono::offset::local::tz_info::parser::parse (2x)
       367 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::interval::IntervalSet<I>::new (7x)
       275 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:crossbeam_channel::select::Select::new (5x)
       270 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::blockreader::BlockReader::read_block_File (2x)
       269 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::look (2x)
       246 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:alloc::fmt::format::format_inner (2x)
       237 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<4_usize>::new_unchecked (3x)
       220 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:std::thread::Builder::spawn_unchecked (4x)
       207 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::new (1x)
       205 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:std::sync::poison::once::Once::call_once::{{closure}} (1x)
       198 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::printer::printers::PrinterLogMessage::new (1x)
       197 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::required_graph (1x)
       191 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::boxed::iter::<impl core::iter::traits::collect::FromIterator<I> for alloc::boxed::Box<[I]>>::from_iter (1x)
       185 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::get_matches_from (1x)
       156 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::unroll_arg_requires (3x)
       110 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:std::thread::Thread::new (2x)
       110 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4::process_dt_exit (2x)
       110 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::linereader::LineReader::find_line (2x)
       110 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:std::sys::pal::unix::thread::Thread::new (2x)
       110 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4::main (2x)
       104 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::find_sysline_year (2x)
       104 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::find_sysline_in_block_year (2x)
        55 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::helpers::basename (1x)
        55 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex::builders::Builder::build_one_string (1x)
        55 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::filepreprocessor::process_path (1x)
        55 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:crossbeam_channel::context::Context::new (1x)
        55 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::dfa::onepass::InternalBuilder::shuffle_states (1x)
        55 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::alternation'2 (1x)
        55 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:std::sys::pal::unix::os::getenv::{{closure}} (1x)
        55 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::dfa::remapper::Remapper::remap (1x)
        55 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:std::sync::poison::once::Once::call_once_force::{{closure}} (1x)
        55 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:std::sys::pal::unix::fs::canonicalize (1x)
        52 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:ctrlc::init_and_set_handler (1x)
        52 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::filepreprocessor::pathbuf_to_filetype_impl (1x)
   402,496 ( 0.12%)       .            .              .           *  ???:__rust_alloc [./target/valgrind/s4]
69,192,056 (20.77%) 393,707 (48.63%)  63 (20.93%)     1 ( 0.07%)  >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/alloc.rs:__rdl_alloc (402,496x) [./target/valgrind/s4]

   398,511 ( 0.12%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

   397,712 ( 0.12%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap

   389,034 ( 0.12%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::nfa::Inner::add
 1,449,558 ( 0.44%)   4,047 ( 0.50%)   5 ( 1.66%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (1,275x) [./target/valgrind/s4]

12,032,955 ( 3.61%)  94,213 (11.64%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (90,718x) [./target/valgrind/s4]
 6,024,901 ( 1.81%)   2,128 ( 0.26%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::concat (60,755x)
 5,445,967 ( 1.64%)  39,114 ( 4.83%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (43,258x)
 4,435,017 ( 1.33%)  33,419 ( 4.13%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (34,540x)
 3,964,397 ( 1.19%)  28,858 ( 3.56%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (30,116x) [./target/valgrind/s4]
 3,823,624 ( 1.15%)     603 ( 0.07%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::into_parts (38,843x)
 3,719,133 ( 1.12%)  27,118 ( 3.35%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (27,622x)
 1,866,333 ( 0.56%)   2,878 ( 0.36%)   1 ( 0.33%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> (2,155x)
 1,074,794 ( 0.32%)     273 ( 0.03%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile (10,884x)
   984,217 ( 0.30%)   7,537 ( 0.93%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::PreferenceTrie::minimize (7,022x)
   689,353 ( 0.21%)   3,346 ( 0.41%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::cross (5,904x)
   443,340 ( 0.13%)   1,182 ( 0.15%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (1,881x)
   333,796 ( 0.10%)   2,603 ( 0.32%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (2,598x)
   330,690 ( 0.10%)   2,543 ( 0.31%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::vec::Vec<T,A>::retain_mut (2,598x)
   225,634 ( 0.07%)       8 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,299x)
   217,635 ( 0.07%)     394 ( 0.05%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::extract'2 (2,035x)
   193,832 ( 0.06%)   1,508 ( 0.19%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::util::prefilter::teddy::Teddy::new (1,490x)
   172,319 ( 0.05%)     988 ( 0.12%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::sync::Arc<T,A>::drop_slow (1,453x)
   163,199 ( 0.05%)   1,104 ( 0.14%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::meta::reverse_inner::prefilter (1,317x)
   161,525 ( 0.05%)   1,019 ( 0.13%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::meta::regex::Builder::build (1,231x)
   143,156 ( 0.04%)      24 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::class (1,454x)
   128,243 ( 0.04%)     944 ( 0.12%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<aho_corasick::dfa::DFA> (909x)
   117,890 ( 0.04%)     753 ( 0.09%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_automata::util::prefilter::teddy::Teddy> (745x)
   105,352 ( 0.03%)     880 ( 0.11%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (595x)
   103,147 ( 0.03%)     908 ( 0.11%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSetItem> (596x) [./target/valgrind/s4]
    96,984 ( 0.03%)     664 ( 0.08%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::alternation (657x)
    95,230 ( 0.03%)      68 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::extract (935x)
    92,046 ( 0.03%)      76 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::Concat::into_ast (917x)
    92,040 ( 0.03%)      47 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (947x)
    88,196 ( 0.03%)     716 ( 0.09%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::builder::Builder::build (525x)
    85,398 ( 0.03%)     541 ( 0.07%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (563x)
    84,242 ( 0.03%)      49 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (846x) [./target/valgrind/s4]
    80,288 ( 0.02%)     289 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (735x)
    79,027 ( 0.02%)     109 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast> (774x) [./target/valgrind/s4]
    75,488 ( 0.02%)     548 ( 0.07%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::sync::Arc<T,A>::drop_slow'2 (555x)
    74,474 ( 0.02%)     571 ( 0.07%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (586x)
    71,490 ( 0.02%)     361 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (525x)
    69,773 ( 0.02%)      68 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x)
    61,588 ( 0.02%)     397 ( 0.05%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<alloc::collections::btree::map::BTreeMap<alloc::boxed::Box<[u8]>,usize>> (507x)
    46,371 ( 0.01%)     288 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::visitor::visit (324x)
    41,134 ( 0.01%)     329 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<aho_corasick::nfa::noncontiguous::NFA> (240x)
    32,297 ( 0.01%)     246 ( 0.03%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::union (254x)
    30,782 ( 0.01%)     199 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::meta::strategy::new (244x)
    28,568 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::util::determinize::state::State::dead (292x)
    25,601 ( 0.01%)      90 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (233x)
    21,778 ( 0.01%)     142 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex::regex::bytes::Regex::new (160x)
    16,501 ( 0.00%)     158 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop (81x)
    15,948 ( 0.00%)      90 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::packed::api::Builder::build (108x)
    15,616 ( 0.00%)     122 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<aho_corasick::packed::teddy::generic::Teddy<16_usize>> (122x)
    15,209 ( 0.00%)      12 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash (149x)
    11,962 ( 0.00%)       1 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (122x) [./target/valgrind/s4]
     9,842 ( 0.00%)      14 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::parse_datetime_in_line_cached (94x)
     9,468 ( 0.00%)      92 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<aho_corasick::util::prefilter::Builder> (48x)
     9,392 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::util::remapper::Remapper::remap (96x)
     8,344 ( 0.00%)      66 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions (48x)
     8,176 ( 0.00%)       8 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::data::datetime::bytes_to_regex_to_datetime (79x)
     7,753 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::parser::matches::matched_arg::MatchedArg::into_vals_flatten (71x)
     6,152 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::parser::matches::arg_matches::ArgMatches::try_remove_one (46x)
     5,320 ( 0.00%)      46 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::collections::btree::node::BalancingContext<K,V>::do_merge (24x)
     3,528 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Seq::optimize_by_preference (36x)
     3,227 ( 0.00%)      27 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_automata::hybrid::dfa::Cache> (21x)
     2,892 ( 0.00%)       6 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (27x)
     2,884 ( 0.00%)      24 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::util::prefilter::prefixes (15x)
     2,762 ( 0.00%)      17 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<lru::LruCache<K,V,S> as core::ops::drop::Drop>::drop (23x)
     2,523 ( 0.00%)      33 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::collections::btree::map::BTreeMap<K,V,A> as core::ops::drop::Drop>::drop (12x)
     2,364 ( 0.00%)       1 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<1_usize>::new_unchecked (24x)
     2,059 ( 0.00%)       9 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<hashbrown::raw::RawTable<T,A> as core::ops::drop::Drop>::drop (18x)
     2,058 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::FatAVX2<3_usize>::new_unchecked (21x)
     1,647 ( 0.00%)      12 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::meta::reverse_inner::extract (13x)
     1,620 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::parser::parser::Parser::push_arg_values (18x)
     1,440 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<clap_builder::builder::command::Command> (12x)
     1,293 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::util::prefilter::suffixes (12x)
     1,278 ( 0.00%)       7 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<std::sys::thread_local::native::lazy::State<regex::regex::string::Regex,()>> (10x)
     1,266 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::into_kind (13x)
     1,200 ( 0.00%)       9 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<aho_corasick::packed::teddy::generic::Teddy<8_usize>> (10x)
     1,186 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Seq::cross_preamble (13x)
     1,080 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<T,I>>::from_iter (12x)
     1,069 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::_build_self (11x)
       990 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4::processing_loop (11x)
       980 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<3_usize>::new_unchecked (10x)
       918 ( 0.00%)       9 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<s4lib::readers::syslogprocessor::SyslogProcessor> (5x)
       728 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4::main (7x)
       666 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::util::any_value::AnyValue::downcast_into (6x)
       642 ( 0.00%)       6 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<&T,I>>::spec_extend (3x)
       630 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::get_matches_from (7x)
       585 ( 0.00%)       2 ( 0.00%)   .              .           < src/data/datetime.rs:s4lib::data::datetime::bytes_to_regex_to_datetime (5x) [./target/valgrind/s4]
       540 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::builder::command::Command::unroll_arg_requires (6x)
       476 ( 0.00%)       4 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::collections::btree::remove::<impl alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::KV>>::remove_leaf_kv (2x)
       471 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir>'2 (5x) [./target/valgrind/s4]
       471 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir>'2 (5x)
       389 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<s4lib::readers::blockreader::BlockReader> (3x)
       388 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<alloc::boxed::Box<crossbeam_channel::counter::Counter<crossbeam_channel::flavors::array::Channel<s4::ChanDatum>>>> (3x)
       386 ( 0.00%)       4 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::collections::btree::fix::<impl alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::LeafOrInternal>>::fix_node_and_affected_ancestors (2x)
       360 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4::process_dt_exit (4x)
       334 ( 0.00%)       3 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:std::sys::thread_local::native::lazy::destroy (2x)
       299 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex::regex::string::Regex::new (2x)
       287 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<clap_builder::parser::matches::arg_matches::ArgMatches> (2x)
       270 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::parser::validator::Validator::validate (3x)
       240 ( 0.00%)       2 ( 0.00%)   .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:alloc::sync::Arc<T,A>::drop_slow (2x)
       208 ( 0.00%)       1 ( 0.00%)   .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:std::sys::pal::unix::thread::Thread::new::thread_start (2x)
       196 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::collections::btree::map::IntoIter<K,V,A>::dying_next (2x)
       196 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<4_usize>::new_unchecked (2x)
       196 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_automata::util::sparse_set::SparseSet> (2x)
       196 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::dfa::remapper::Remapper::remap (2x)
       196 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::summary (2x)
       180 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<core::option::Option<s4lib::printer::printers::PrinterLogMessage>> (1x)
       180 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::filepreprocessor::process_path (2x)
       180 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:std::sync::poison::once::Once::call_once_force::{{closure}} (2x)
       180 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4::string_wdhms_to_duration (2x)
       180 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4::cli_process_blocksz (2x)
       180 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop (2x)
       180 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<F as clap_builder::builder::value_parser::TypedValueParser>::parse_ref (2x)
       180 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::alternation'2 (2x)
       173 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:chrono::offset::local::tz_info::timezone::TimeZone::from_posix_tz (1x)
       128 ( 0.00%)       1 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<(usize,s4lib::readers::summary::Summary)> (1x)
       126 ( 0.00%)       1 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<s4lib::readers::summary::Summary> (1x)
        98 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::syslinereader::SyslineReader::dt_patterns_analysis (1x)
        98 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::blockreader::BlockReader::new (1x)
        90 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4::exec_fileprocessor_thread (1x)
        90 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<clap_builder::parser::matches::arg_matches::Values<T> as core::iter::traits::iterator::Iterator>::next (1x)
        90 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter (1x)
        90 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:s4lib::readers::filepreprocessor::pathbuf_to_filetype_impl (1x)
        90 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::interval::IntervalSet<I>::new (1x)
        90 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:core::ptr::drop_in_place<std::io::buffered::linewriter::LineWriter<std::io::stdio::StdoutRaw>> (1x)
        90 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:termcolor::ColorChoice::should_attempt_color (1x)
        90 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:clap_builder::parser::parser::Parser::get_matches_with (1x)
        90 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<s4::CLI_Args as clap_builder::derive::Args>::augment_args (1x)
   386,075 ( 0.12%)       .            .              .           *  ???:__rust_dealloc [./target/valgrind/s4]
48,079,339 (14.43%) 260,940 (32.23%)   1 ( 0.33%)     .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/alloc.rs:__rdl_dealloc (386,075x) [./target/valgrind/s4]

 2,490,300 ( 0.75%)      22 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (15,406x) [./target/valgrind/s4]
   385,150 ( 0.12%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::literal [./target/valgrind/s4]
   885,942 ( 0.27%)       .            .              .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/str/converts.rs:core::str::converts::from_utf8 (15,406x) [./target/valgrind/s4]

   379,830 ( 0.11%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   372,274 ( 0.11%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

   369,692 ( 0.11%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs:regex_syntax::ast::parse::ParserI<P>::bump

   369,448 ( 0.11%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/validations.rs:regex_syntax::ast::parse::ParserI<P>::bump

   580,438 ( 0.17%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie (2,432x) [./target/valgrind/s4]
   357,352 ( 0.11%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::add_transition [./target/valgrind/s4]

   355,328 ( 0.11%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:alloc::raw_vec::RawVec<T,A>::grow_one

   358,556 ( 0.11%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop (16,298x)
    67,704 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (2,604x)
        31 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:s4::processing_loop (1x)
   348,072 ( 0.10%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/drain.rs:<alloc::vec::drain::Drain<T,A> as core::ops::drop::Drop>::drop [./target/valgrind/s4]

   347,294 ( 0.10%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:alloc::vec::Vec<T,A>::dedup_by
 1,290,404 ( 0.39%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (58,970x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   347,051 ( 0.10%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop
   358,556 ( 0.11%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/drain.rs:<alloc::vec::drain::Drain<T,A> as core::ops::drop::Drop>::drop (16,298x) [./target/valgrind/s4]

   342,350 ( 0.10%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie

   336,139 ( 0.10%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:alloc::vec::Vec<T,A>::extend_with

   441,242 ( 0.13%)     336 ( 0.04%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (5,231x)
    66,072 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre (2,753x)
    56,520 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple (1,120x)
    31,530 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::Hir::alternation (1,216x)
    27,842 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::new (1,127x) [./target/valgrind/s4]
     9,220 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::unicode::perl_digit (5x)
     2,640 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::Hir::dot (110x)
     1,704 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre (71x)
   326,887 ( 0.10%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize [./target/valgrind/s4]

   318,451 ( 0.10%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::concat
 6,024,901 ( 1.81%)   2,128 ( 0.26%)   .              .           >   ???:__rust_dealloc (60,755x) [./target/valgrind/s4]
 2,283,622 ( 0.69%)  16,454 ( 2.03%)   .              .           >   ???:__rust_alloc (17,551x) [./target/valgrind/s4]

   317,853 ( 0.10%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (35,317x) [./target/valgrind/s4]
   317,853 ( 0.10%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> [./target/valgrind/s4]

   311,407 ( 0.09%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments
10,788,329 ( 3.24%)  81,752 (10.10%)   .              .           >   ???:__rust_alloc (52,360x) [./target/valgrind/s4]

   309,091 ( 0.09%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

   306,073 ( 0.09%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

   302,971 ( 0.09%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2
 3,868,053 ( 1.16%)   3,023 ( 0.37%)   3 ( 1.00%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (46,585x) [./target/valgrind/s4]

   300,881 ( 0.09%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   290,160 ( 0.09%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

   881,407 ( 0.26%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (2,824x) [./target/valgrind/s4]
   288,081 ( 0.09%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open [./target/valgrind/s4]
   254,244 ( 0.08%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (2,826x) [./target/valgrind/s4]
   225,912 ( 0.07%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (11,298x) [./target/valgrind/s4]
    50,868 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (2,826x) [./target/valgrind/s4]

   286,879 ( 0.09%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

   277,269 ( 0.08%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::bump

   277,269 ( 0.08%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::bump

   277,032 ( 0.08%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   274,968 ( 0.08%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle

   272,000 ( 0.08%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::map::Utf8SuffixMap::clear

 1,447,351 ( 0.43%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::remap (48x) [./target/valgrind/s4]
   270,270 ( 0.08%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap [./target/valgrind/s4]

 1,228,822 ( 0.37%)   1,219 ( 0.15%)   1 ( 0.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::init_unanchored_start_state (96x) [./target/valgrind/s4]
   394,848 ( 0.12%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::add_dead_state_loop (48x) [./target/valgrind/s4]
   260,928 ( 0.08%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state [./target/valgrind/s4]

   257,656 ( 0.08%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::nfa::Inner::add

   256,258 ( 0.08%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::build
   553,226 ( 0.17%)   2,127 ( 0.26%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (1,033x) [./target/valgrind/s4]

   250,594 ( 0.08%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

   250,159 ( 0.08%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/primitives.rs:regex_automata::nfa::thompson::nfa::Inner::remap

 1,716,692 ( 0.52%)   1,526 ( 0.19%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (4,916x) [./target/valgrind/s4]
   249,569 ( 0.07%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post [./target/valgrind/s4]
    84,242 ( 0.03%)      49 ( 0.01%)   .              .           >   ???:__rust_dealloc (846x) [./target/valgrind/s4]
    14,348 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::TranslatorI::hir_perl_unicode_class (5x) [./target/valgrind/s4]

   240,204 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_automata::nfa::thompson::builder::Builder::patch

   237,852 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop

   237,227 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::concat
 2,546,827 ( 0.76%)   3,677 ( 0.45%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (16,418x) [./target/valgrind/s4]

   236,986 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::concat
     1,632 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (68x) [./target/valgrind/s4]
     1,360 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (68x) [./target/valgrind/s4]

   442,337 ( 0.13%)     229 ( 0.03%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (3,756x) [./target/valgrind/s4]
   236,451 ( 0.07%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/utf8.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next [./target/valgrind/s4]

   236,187 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

 3,598,399 ( 1.08%)  22,359 ( 2.76%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (15,929x) [./target/valgrind/s4]
   154,073 ( 0.05%)     872 ( 0.11%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x) [./target/valgrind/s4]
    21,535 ( 0.01%)     136 ( 0.02%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group_end (81x) [./target/valgrind/s4]
   233,842 ( 0.07%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast [./target/valgrind/s4]

   232,948 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_syntax::ast::visitor::visit

   231,306 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_syntax::hir::Hir::concat

   231,234 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

   231,027 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

   226,664 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

   224,418 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post
 2,985,482 ( 0.90%)  10,948 ( 1.35%)   1 ( 0.33%)     .           >   ???:__rust_alloc (36,032x) [./target/valgrind/s4]
 2,816,220 ( 0.85%)  29,550 ( 3.65%)   .              .           >   ???:__rust_realloc (14,913x) [./target/valgrind/s4]

   222,864 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state
   437,590 ( 0.13%)   1,219 ( 0.15%)   1 ( 0.33%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (384x) [./target/valgrind/s4]

   222,192 ( 0.07%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

   203,008 ( 0.06%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/sip.rs:core::hash::BuildHasher::hash_one (4,055x)
    57,495 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/mod.rs:core::hash::BuildHasher::hash_one (1,637x) [./target/valgrind/s4]
   220,265 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/sip.rs:<core::hash::sip::Hasher<S> as core::hash::Hasher>::write [./target/valgrind/s4]

   220,120 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::raw_vec::finish_grow
29,955,108 ( 8.99%) 110,463 (13.64%)  68 (22.59%)     .           >   ???:__rust_realloc (44,024x) [./target/valgrind/s4]

 1,428,189 ( 0.43%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (3,549x) [./target/valgrind/s4]
   220,048 ( 0.07%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range [./target/valgrind/s4]
 1,005,248 ( 0.30%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item (3,549x) [./target/valgrind/s4]
    71,580 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (3,549x) [./target/valgrind/s4]
    63,882 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (3,549x) [./target/valgrind/s4]

   219,479 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::builder::Builder::build
   385,224 ( 0.12%)     994 ( 0.12%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (175x) [./target/valgrind/s4]

   219,328 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_syntax::hir::Hir::concat

   217,023 ( 0.07%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

   228,716 ( 0.07%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
   209,616 ( 0.06%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::byte_classes [./target/valgrind/s4]
     1,440 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   208,639 ( 0.06%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

 1,244,800 ( 0.37%)   2,886 ( 0.36%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (2,753x) [./target/valgrind/s4]
    79,072 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSet> (2,824x) [./target/valgrind/s4]
   200,658 ( 0.06%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop [./target/valgrind/s4]
    82,740 ( 0.02%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,758x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   200,130 ( 0.06%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

   198,981 ( 0.06%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

   198,265 ( 0.06%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2
 6,013,983 ( 1.81%)  39,114 ( 4.83%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (495x) [./target/valgrind/s4]

   195,928 ( 0.06%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop
 4,449,609 ( 1.34%)   1,439 ( 0.18%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (270x) [./target/valgrind/s4]

 2,123,006 ( 0.64%)   1,402 ( 0.17%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::meta::wrappers::Hybrid::create_cache (106x)
   138,574 ( 0.04%)     139 ( 0.02%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::meta::wrappers::ReverseHybrid::create_cache (11x)
   195,662 ( 0.06%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::init_cache [./target/valgrind/s4]
   716,865 ( 0.22%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::set_transition (22,413x) [./target/valgrind/s4]
    44,553 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/state.rs:regex_automata::util::determinize::state::State::dead (117x) [./target/valgrind/s4]

   193,456 ( 0.06%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::builder::Builder::patch
 1,620,353 ( 0.49%)   8,485 ( 1.05%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (5,355x) [./target/valgrind/s4]

   192,616 ( 0.06%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   189,432 ( 0.06%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::ast::Concat::into_ast

   189,366 ( 0.06%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap

   185,406 ( 0.06%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/primitives.rs:regex_automata::nfa::thompson::builder::Builder::build

   185,086 ( 0.06%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs:regex_syntax::ast::parse::ParserI<P>::bump

   184,846 ( 0.06%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_syntax::ast::parse::ParserI<P>::bump

 4,670,969 ( 1.40%)   9,521 ( 1.18%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract (975x) [./target/valgrind/s4]
 2,303,295 ( 0.69%)   7,268 ( 0.90%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (1,944x) [./target/valgrind/s4]
   184,046 ( 0.06%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 [./target/valgrind/s4]
 2,303,295 ( 0.69%)   7,268 ( 0.90%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (1,944x) [./target/valgrind/s4]
 1,944,627 ( 0.58%)   1,072 ( 0.13%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::union (1,583x) [./target/valgrind/s4]
 1,409,541 ( 0.42%)   4,564 ( 0.56%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (371x) [./target/valgrind/s4]

   987,185 ( 0.30%)     863 ( 0.11%)   6 ( 1.99%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
   183,639 ( 0.06%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::densify [./target/valgrind/s4]

   183,411 ( 0.06%)       .            .              .           *  ./elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object
        72 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memcmp.c:bcmp (3x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        50 ( 0.00%)       .            .              .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcscat.c:wcschr (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        50 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strnlen.c:strnlen (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        50 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strlen.c:strlen (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        48 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memset.c:memset (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        46 ( 0.00%)       .            .              .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wmemchr.c:wmemchr (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        44 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove.c:memmove (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        44 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memcmpeq.c:memcpy@@GLIBC_2.14 (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        28 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86/cacheinfo.c:__x86_cacheinfo (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        25 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strchrnul.c:strchrnul (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        25 ( 0.00%)       .            .              .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcscmp.c:wcscmp (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        25 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memrchr.c:memrchr (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        25 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strrchr.c:rindex (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        24 ( 0.00%)       .            .              .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wmemcmp.c:wmemcmp (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        24 ( 0.00%)       .            .              .           >   ./debug/../sysdeps/x86_64/multiarch/memset_chk.c:__memset_chk (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        23 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memchr.c:memchr (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        22 ( 0.00%)       .            .              .           >   ./debug/../sysdeps/x86_64/multiarch/memmove_chk.c:__memmove_chk (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        22 ( 0.00%)       .            .              .           >   ./debug/../sysdeps/x86_64/multiarch/memcpy_chk.c:__memcpy_chk (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        22 ( 0.00%)       .            .              .           >   ./debug/../sysdeps/x86_64/multiarch/mempcpy_chk.c:__mempcpy_chk (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        22 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/mempcpy.c:mempcpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        21 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strcasecmp_l.c:strcasecmp_l (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        21 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strncase.c:strncasecmp (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        21 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strcasecmp.c:strcasecmp (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        21 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strncase_l.c:strncasecmp_l (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        21 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strncmp.c:strncmp (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        20 ( 0.00%)       .            .              .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wmemset.c:wmemset (2x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        19 ( 0.00%)       .            .              .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcslen.c:wcslen (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        19 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/stpncpy.c:stpncpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        19 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strchr.c:index (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        19 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strncpy.c:strncpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        19 ( 0.00%)       .            .              .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcsnlen.c:wcsnlen (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        19 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strcmp.c:strcmp (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        18 ( 0.00%)       .            .              .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcpcpy.c:wcpncpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        18 ( 0.00%)       .            .              .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcscat.c:wcscat (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        18 ( 0.00%)       .            .              .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcsncpy.c:wcsncpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        17 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/stpcpy.c:stpcpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        17 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strcpy.c:strcpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        17 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strcat.c:strcat (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
        16 ( 0.00%)       .            .              .           >   ./wcsmbs/../sysdeps/x86_64/multiarch/wcscpy.c:wcscpy (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         7 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strpbrk.c:strpbrk (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         7 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strspn.c:strspn (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         7 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/strcspn.c:strcspn (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
         6 ( 0.00%)       .            .              .           >   ./elf/../sysdeps/x86/dl-get-cpu-features.c:__x86_cpu_features (1x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

   182,675 ( 0.05%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_syntax::ast::visitor::visit

   179,520 ( 0.05%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::NFA::add_transition

   179,490 ( 0.05%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/primitives.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

   178,514 ( 0.05%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/primitives.rs:regex_automata::nfa::thompson::builder::Builder::add

   178,514 ( 0.05%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_automata::nfa::thompson::builder::Builder::add

   174,924 ( 0.05%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::nfa::Inner::remap

 1,724,922 ( 0.52%)      10 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (2,824x) [./target/valgrind/s4]
   173,258 ( 0.05%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class [./target/valgrind/s4]
   254,160 ( 0.08%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (8,472x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
   254,080 ( 0.08%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (2,824x) [./target/valgrind/s4]
   203,328 ( 0.06%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op (2,824x) [./target/valgrind/s4]
   152,496 ( 0.05%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSet> (2,824x) [./target/valgrind/s4]
    56,480 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,824x) [./target/valgrind/s4]

   172,875 ( 0.05%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

   172,032 ( 0.05%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::prefilter::Builder::build

   170,156 ( 0.05%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop

   169,466 ( 0.05%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::hir::Hir::literal

   167,835 ( 0.05%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:alloc::vec::Vec<T,A>::extend_with

   164,910 ( 0.05%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_syntax::hir::literal::PreferenceTrie::insert

 2,123,692 ( 0.64%)   9,527 ( 1.18%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (3,873x) [./target/valgrind/s4]
     1,810 ( 0.00%)      10 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (5x)
       149 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation'2 (1x) [./target/valgrind/s4]
   160,974 ( 0.05%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class [./target/valgrind/s4]
   679,904 ( 0.20%)   4,017 ( 0.50%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::class (2,425x) [./target/valgrind/s4]
   468,801 ( 0.14%)     572 ( 0.07%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::literal (3,879x) [./target/valgrind/s4]
    68,338 ( 0.02%)       .            .              .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/str/converts.rs:core::str::converts::from_utf8 (1,454x) [./target/valgrind/s4]

   158,758 ( 0.05%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::dfa::Builder::finish_build_one_start

   153,962 ( 0.05%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

 2,637,164 ( 0.79%)     330 ( 0.04%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (2,824x) [./target/valgrind/s4]
   152,577 ( 0.05%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open [./target/valgrind/s4]
   881,407 ( 0.26%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open (2,824x) [./target/valgrind/s4]
   169,440 ( 0.05%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (5,648x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    56,432 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,824x) [./target/valgrind/s4]

   150,057 ( 0.05%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   148,821 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

   148,694 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

   147,486 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_syntax::hir::Hir::concat

   856,796 ( 0.26%)   1,320 ( 0.16%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (1,713x) [./target/valgrind/s4]
   146,127 ( 0.04%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition [./target/valgrind/s4]
   154,158 ( 0.05%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,713x) [./target/valgrind/s4]
    71,160 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (3,558x) [./target/valgrind/s4]

   145,409 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate

   143,561 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

   143,180 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre
   324,919 ( 0.10%)   1,256 ( 0.16%)   3 ( 1.00%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (297x) [./target/valgrind/s4]
    82,590 ( 0.02%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,alloc::vec::into_iter::IntoIter<T>>>::from_iter (2,753x) [./target/valgrind/s4]

   142,580 ( 0.04%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post
   917,832 ( 0.28%)       .            .              .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/str/converts.rs:core::str::converts::from_utf8 (16,096x) [./target/valgrind/s4]
   558,213 ( 0.17%)   3,416 ( 0.42%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::repetition (1,885x) [./target/valgrind/s4]
   204,301 ( 0.06%)   1,127 ( 0.14%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::capture (693x) [./target/valgrind/s4]
    48,680 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::new (1,125x) [./target/valgrind/s4]
     3,220 ( 0.00%)      10 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::negate (6x) [./target/valgrind/s4]
     1,810 ( 0.00%)      10 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class (5x) [./target/valgrind/s4]

   142,419 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

15,737,713 ( 4.72%)  15,987 ( 1.97%)  24 ( 7.97%)     1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (538x) [./target/valgrind/s4]
    44,087 ( 0.01%)      38 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (1x) [./target/valgrind/s4]
   140,904 ( 0.04%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter [./target/valgrind/s4]
14,280,992 ( 4.29%)  14,076 ( 1.74%)  24 ( 7.97%)     1 ( 0.07%)  >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (6,614x) [./target/valgrind/s4]
 1,152,637 ( 0.35%)   1,771 ( 0.22%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (13,228x) [./target/valgrind/s4]

   138,870 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

   138,719 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions

   138,500 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::nfa::Inner::remap

   136,710 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_syntax::ast::visitor::visit

   135,944 ( 0.04%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/primitives.rs:regex_automata::nfa::thompson::nfa::Inner::add

 1,800,969 ( 0.54%)   8,499 ( 1.05%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract (111x) [./target/valgrind/s4]
 1,409,541 ( 0.42%)   4,564 ( 0.56%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (371x) [./target/valgrind/s4]
   135,810 ( 0.04%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross [./target/valgrind/s4]
   201,140 ( 0.06%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::dedup_by (422x) [./target/valgrind/s4]
    37,856 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Seq::cross_preamble (482x) [./target/valgrind/s4]

   564,478 ( 0.17%)     380 ( 0.05%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
   134,658 ( 0.04%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions [./target/valgrind/s4]
    30,958 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::copy_matches (673x) [./target/valgrind/s4]

 1,005,248 ( 0.30%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range (3,549x) [./target/valgrind/s4]
   133,926 ( 0.04%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item [./target/valgrind/s4]
   476,657 ( 0.14%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape (1,612x) [./target/valgrind/s4]
   189,600 ( 0.06%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (9,360x) [./target/valgrind/s4]
   175,770 ( 0.05%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,937x) [./target/valgrind/s4]

   132,188 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate
   884,302 ( 0.27%)   4,443 ( 0.55%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (1,445x) [./target/valgrind/s4]

   130,806 ( 0.04%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile
 1,381,856 ( 0.41%)     546 ( 0.07%)   8 ( 2.66%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (16,950x) [./target/valgrind/s4]

   130,655 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_syntax::hir::literal::Extractor::cross

   128,121 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

   125,120 ( 0.04%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie (3,680x) [./target/valgrind/s4]
   125,120 ( 0.04%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::set_range [./target/valgrind/s4]

   124,074 ( 0.04%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

   123,300 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::vec::Vec<T,A>::dedup_by

   355,803 ( 0.11%)   2,900 ( 0.36%)   .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/alloc/unix.rs:__rdl_alloc_zeroed (1,316x)
     2,082 ( 0.00%)      10 ( 0.00%)   .              .           < ???:0x00000000048a0450 (9x) [???]
       700 ( 0.00%)       4 ( 0.00%)   .              .           < ./elf/../include/rtld-malloc.h:_dl_allocate_tls (2x)
   123,296 ( 0.04%)   2,622 ( 0.32%)   .              .           *  ./malloc/./malloc/malloc.c:calloc [/usr/lib/x86_64-linux-gnu/libc.so.6]
   199,427 ( 0.06%)     292 ( 0.04%)   .              .           >   ./malloc/./malloc/malloc.c:_int_malloc (1,327x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   121,666 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::nfa::Inner::add

   120,912 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs:regex_syntax::hir::Hir::concat

   119,931 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop

   119,443 ( 0.04%)       .            .              .           *  ./elf/./elf/do-rel.h:_dl_relocate_object

 1,152,637 ( 0.35%)   1,771 ( 0.22%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter (13,228x) [./target/valgrind/s4]
   119,052 ( 0.04%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch [./target/valgrind/s4]
   940,989 ( 0.28%)   1,771 ( 0.22%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (13,228x) [./target/valgrind/s4]

   117,977 ( 0.04%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:core::hash::BuildHasher::hash_one

   116,480 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:regex_syntax::unicode::SimpleCaseFolder::overlaps

   115,850 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::builder::Builder::build

   114,654 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   114,562 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class
   191,190 ( 0.06%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (6,373x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   114,450 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::builder::Builder::build

   113,972 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie

   113,315 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

   113,247 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop
 5,445,967 ( 1.64%)  39,114 ( 4.83%)   .              .           >   ???:__rust_dealloc (43,258x) [./target/valgrind/s4]

   169,108 ( 0.05%)     908 ( 0.11%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (2,758x)
    55,060 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (2,753x) [./target/valgrind/s4]
   113,030 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSetItem> [./target/valgrind/s4]
   103,147 ( 0.03%)     908 ( 0.11%)   .              .           >   ???:__rust_dealloc (596x) [./target/valgrind/s4]
     1,775 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop'2 (71x) [./target/valgrind/s4]
     1,420 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSetItem>'2 (71x) [./target/valgrind/s4]

   112,816 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post
   773,760 ( 0.23%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48,360x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   112,366 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_syntax::hir::Hir::concat

   112,252 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::alternation
     1,973 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (4x) [./target/valgrind/s4]
       120 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop (5x) [./target/valgrind/s4]
       113 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop (1x) [./target/valgrind/s4]
       100 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (5x) [./target/valgrind/s4]

   112,251 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

 1,686,475 ( 0.51%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle (48x) [./target/valgrind/s4]
   111,808 ( 0.03%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::remap [./target/valgrind/s4]
 1,447,351 ( 0.43%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap (48x) [./target/valgrind/s4]

   111,450 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_automata::hybrid::dfa::Lazy::init_cache

   111,115 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_syntax::hir::Hir::alternation

   110,880 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

 1,944,627 ( 0.58%)   1,072 ( 0.13%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (1,583x) [./target/valgrind/s4]
   873,190 ( 0.26%)     274 ( 0.03%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract (864x) [./target/valgrind/s4]
   110,607 ( 0.03%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::union [./target/valgrind/s4]
 2,034,446 ( 0.61%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::dedup_by (2,445x) [./target/valgrind/s4]

   109,262 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   108,369 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

   107,544 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::alternation
    34,740 ( 0.01%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,alloc::vec::into_iter::IntoIter<T>>>::from_iter (1,158x) [./target/valgrind/s4]
     7,604 ( 0.00%)      18 ( 0.00%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (15x) [./target/valgrind/s4]
     1,471 ( 0.00%)       4 ( 0.00%)   .              .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (9x) [./target/valgrind/s4]

 8,600,407 ( 2.58%)  20,558 ( 2.54%)   4 ( 1.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::PreferenceTrie::minimize (177x) [./target/valgrind/s4]
   105,790 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::retain_mut [./target/valgrind/s4]

   105,040 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:regex_syntax::unicode::SimpleCaseFolder::mapping

   104,720 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

   104,368 ( 0.03%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class

 8,985,446 ( 2.70%)   1,084 ( 0.13%)   4 ( 1.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:regex_automata::util::prefilter::teddy::Teddy::new (39x)
 2,382,488 ( 0.72%)   1,782 ( 0.22%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/ahocorasick.rs:aho_corasick::ahocorasick::AhoCorasickBuilder::build (9x) [./target/valgrind/s4]
   103,740 ( 0.03%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::build_from_noncontiguous [./target/valgrind/s4]
 8,443,069 ( 2.53%)     862 ( 0.11%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::finish_build_one_start (39x) [./target/valgrind/s4]
   307,492 ( 0.09%)   1,642 ( 0.20%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::DFA::set_matches (882x) [./target/valgrind/s4]
     3,696 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    99,214 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

    99,201 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap

    98,904 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop

    98,514 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/sip.rs:core::hash::BuildHasher::hash_one
   203,008 ( 0.06%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/sip.rs:<core::hash::sip::Hasher<S> as core::hash::Hasher>::write (4,055x) [./target/valgrind/s4]

   916,137 ( 0.28%)   2,355 ( 0.29%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (693x) [./target/valgrind/s4]
    98,427 ( 0.03%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group [./target/valgrind/s4]
   154,073 ( 0.05%)     872 ( 0.11%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (693x) [./target/valgrind/s4]
   107,264 ( 0.03%)     622 ( 0.08%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Alternation::into_ast (512x) [./target/valgrind/s4]
    62,138 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (693x) [./target/valgrind/s4]
    13,860 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (693x) [./target/valgrind/s4]

    97,888 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add

    97,566 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_syntax::hir::literal::PreferenceTrie::insert

    97,412 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop
 3,719,133 ( 1.12%)  27,118 ( 3.35%)   .              .           >   ???:__rust_dealloc (27,622x) [./target/valgrind/s4]
   166,609 ( 0.05%)      62 ( 0.01%)   .              .           >   ???:__rust_alloc (2,930x) [./target/valgrind/s4]

   158,544 ( 0.05%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
    96,768 ( 0.03%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::add_unanchored_start_state_loop [./target/valgrind/s4]

    92,504 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_syntax::ast::parse::ParserI<P>::bump

    92,423 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::ast::parse::ParserI<P>::bump

    92,423 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_syntax::ast::parse::ParserI<P>::bump

    92,423 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/traits.rs:regex_syntax::ast::parse::ParserI<P>::bump

    92,342 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:regex_syntax::ast::parse::ParserI<P>::bump

    92,297 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::Extractor::cross

    91,656 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle

    90,524 ( 0.03%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/alphabet.rs:regex_automata::hybrid::dfa::Lazy::set_transition

   952,460 ( 0.29%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (841x) [./target/valgrind/s4]
    90,264 ( 0.03%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::maybe_parse_ascii_class [./target/valgrind/s4]
   634,950 ( 0.19%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (7,055x) [./target/valgrind/s4]
   141,420 ( 0.04%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (7,071x) [./target/valgrind/s4]
    31,216 ( 0.01%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:regex_syntax::ast::ClassAsciiKind::from_name (770x) [./target/valgrind/s4]

    89,410 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::hir::Hir::concat
   264,180 ( 0.08%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (15,408x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    89,257 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::builder::Builder::add

   476,657 ( 0.14%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item (1,612x) [./target/valgrind/s4]
    89,103 ( 0.03%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape [./target/valgrind/s4]
   289,790 ( 0.09%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (3,219x) [./target/valgrind/s4]
    64,480 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (3,224x) [./target/valgrind/s4]
     1,095 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_perl_class (5x) [./target/valgrind/s4]
        24 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/lib.rs:regex_syntax::is_escapeable_character (1x) [./target/valgrind/s4]

    88,759 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_syntax::hir::Hir::alternation

    87,422 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::nfa::Inner::add

   250,272 ( 0.08%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
    87,216 ( 0.03%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state [./target/valgrind/s4]
     2,208 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::copy_matches (48x) [./target/valgrind/s4]

    86,783 ( 0.03%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::dfa::Builder::finish_build_one_start

    86,734 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    86,537 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post
   275,118 ( 0.08%)     265 ( 0.03%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (1,978x) [./target/valgrind/s4]
   130,415 ( 0.04%)     401 ( 0.05%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter (770x) [./target/valgrind/s4]

    86,231 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre

    85,480 ( 0.03%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap

    85,165 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/set_len_on_drop.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

    84,765 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate

    82,590 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre (2,753x)
    34,740 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::alternation (1,158x)
     2,130 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre (71x)
       150 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::unicode::perl_digit (5x)
    83,727 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,alloc::vec::into_iter::IntoIter<T>>>::from_iter [./target/valgrind/s4]

    83,650 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

    83,364 ( 0.03%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa

    79,918 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (2,578x) [./target/valgrind/s4]
     2,511 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::finish (81x) [./target/valgrind/s4]
    82,429 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::HirFrame::unwrap_expr [./target/valgrind/s4]

    81,681 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::Concat::into_ast
 3,121,395 ( 0.94%)  23,291 ( 2.88%)   .              .           >   ???:__rust_alloc (15,786x) [./target/valgrind/s4]
    92,046 ( 0.03%)      76 ( 0.01%)   .              .           >   ???:__rust_dealloc (917x) [./target/valgrind/s4]

    81,530 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_automata::hybrid::dfa::Builder::build_from_nfa

   861,284 ( 0.26%)     308 ( 0.04%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (586x) [./target/valgrind/s4]
    81,374 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name [./target/valgrind/s4]
   308,070 ( 0.09%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (3,423x) [./target/valgrind/s4]
   136,920 ( 0.04%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (6,846x) [./target/valgrind/s4]

    81,044 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    79,530 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post

    79,247 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::hir::Hir::concat

    79,165 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_syntax::hir::Hir::concat

    77,664 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:regex_syntax::ast::visitor::visit

    77,030 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::literal
   849,464 ( 0.26%)      22 ( 0.00%)   .              .           >   ???:__rust_alloc (15,406x) [./target/valgrind/s4]

    76,000 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::builder::Builder::patch

   810,871 ( 0.24%)   1,443 ( 0.18%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::add (1,179x) [./target/valgrind/s4]
   150,577 ( 0.05%)     296 ( 0.04%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::finish (126x) [./target/valgrind/s4]
    75,638 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from [./target/valgrind/s4]
   442,320 ( 0.13%)     860 ( 0.11%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (1,588x) [./target/valgrind/s4]

    75,612 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<alloc::vec::drain::Drain<T,A> as core::ops::drop::Drop>::drop

    75,449 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter

   298,368 ( 0.09%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
    74,496 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/prefilter.rs:aho_corasick::util::prefilter::Builder::build [./target/valgrind/s4]
     1,200 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/api.rs:aho_corasick::packed::api::Builder::build (48x) [./target/valgrind/s4]

    74,448 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

    74,256 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state

    73,872 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

    73,728 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

    73,728 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

    73,440 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state

   203,328 ( 0.06%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x) [./target/valgrind/s4]
    73,424 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op [./target/valgrind/s4]
    84,720 ( 0.03%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    72,786 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:alloc::vec::Vec<T,A>::retain_mut
 8,061,486 ( 2.42%)  18,015 ( 2.23%)   4 ( 1.33%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::PreferenceTrie::insert (16,878x) [./target/valgrind/s4]

    70,880 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (2,758x)
     1,775 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSetItem> (71x) [./target/valgrind/s4]
    72,655 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop'2 [./target/valgrind/s4]

    72,423 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::nfa::thompson::builder::Builder::build
   155,798 ( 0.05%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (12,029x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    72,234 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/map.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    71,256 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

    71,087 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:regex_syntax::hir::Hir::alternation
    10,907 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::cmp::PartialEq>::eq (65x) [./target/valgrind/s4]

 2,521,122 ( 0.76%)   2,388 ( 0.29%)   2 ( 0.66%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::OnePass::new (81x) [./target/valgrind/s4]
    70,729 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::Builder::build_from_nfa [./target/valgrind/s4]
 1,047,135 ( 0.31%)     764 ( 0.09%)   2 ( 0.66%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (1,223x) [./target/valgrind/s4]
   260,445 ( 0.08%)     245 ( 0.03%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::compile_transition (390x) [./target/valgrind/s4]
   230,797 ( 0.07%)     260 ( 0.03%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push (2,672x) [./target/valgrind/s4]
   106,698 ( 0.03%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::shuffle_states (1x) [./target/valgrind/s4]
       486 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::nfa::NFA::patterns (81x) [./target/valgrind/s4]
       213 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::util::sparse_set::SparseSet> (1x) [./target/valgrind/s4]
        65 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    69,844 ( 0.02%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/num/uint_macros.rs:core::str::converts::from_utf8

 1,596,896 ( 0.48%)   7,217 ( 0.89%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten (1,589x) [./target/valgrind/s4]
   418,872 ( 0.13%)   2,134 ( 0.26%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (653x) [./target/valgrind/s4]
    69,653 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 [./target/valgrind/s4]
   418,872 ( 0.13%)   2,134 ( 0.26%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (653x) [./target/valgrind/s4]
   182,605 ( 0.05%)      66 ( 0.01%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (12x) [./target/valgrind/s4]
   161,821 ( 0.05%)     312 ( 0.04%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (83x) [./target/valgrind/s4]
    11,236 ( 0.00%)      54 ( 0.01%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Repetition::with (74x) [./target/valgrind/s4]

    80,556 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (4,916x) [./target/valgrind/s4]
    68,895 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre [./target/valgrind/s4]

    68,742 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle

    68,032 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    67,893 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/id.rs:regex_automata::hybrid::dfa::Lazy::set_transition

    67,798 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop
   793,166 ( 0.24%)   1,802 ( 0.22%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (302x) [./target/valgrind/s4]

    67,431 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range

   558,213 ( 0.17%)   3,416 ( 0.42%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (1,885x)
    23,123 ( 0.01%)     136 ( 0.02%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::meta::reverse_inner::flatten (75x)
    22,252 ( 0.01%)     136 ( 0.02%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::meta::reverse_inner::flatten'2 (74x)
    66,602 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::repetition [./target/valgrind/s4]

    66,296 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_syntax::hir::literal::PreferenceTrie::minimize

    96,695 ( 0.03%)       .            .              .           < ./elf/./elf/dl-lookup.c:_dl_lookup_symbol_x (230x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    66,167 ( 0.02%)       .            .              .           *  ./elf/./elf/dl-lookup.c:do_lookup_x [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    28,548 ( 0.01%)       .            .              .           >   ./elf/./elf/dl-lookup.c:check_match (231x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

    66,140 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_automata::nfa::thompson::compiler::Compiler::patch

    65,881 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    64,414 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::nfa::Inner::add

    64,414 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_automata::nfa::thompson::nfa::Inner::add

    63,772 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/manually_drop.rs:regex_syntax::hir::Hir::concat

    63,716 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate

    63,649 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle

    63,642 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_syntax::hir::literal::PreferenceTrie::insert

   152,496 ( 0.05%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x) [./target/valgrind/s4]
    62,128 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSet> [./target/valgrind/s4]
    79,072 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop (2,824x) [./target/valgrind/s4]

    61,624 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::literal

    61,457 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_automata::nfa::thompson::compiler::Compiler::c

29,955,108 ( 8.99%) 110,463 (13.64%)  68 (22.59%)     .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::raw_vec::finish_grow (44,024x)
 2,816,220 ( 0.85%)  29,550 ( 3.65%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (14,913x)
   276,234 ( 0.08%)   2,906 ( 0.36%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::class (1,454x)
   167,431 ( 0.05%)     600 ( 0.07%)   .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/alloc.rs:alloc::raw_vec::finish_grow (200x)
   132,913 ( 0.04%)   1,138 ( 0.14%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::raw_vec::RawVecInner<A>::shrink_to_fit (456x)
    57,138 ( 0.02%)     340 ( 0.04%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (172x)
    61,219 ( 0.02%)       .            .              .           *  ???:__rust_realloc [./target/valgrind/s4]
33,343,825 (10.01%) 144,997 (17.91%)  68 (22.59%)     .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/alloc.rs:__rdl_realloc (61,219x) [./target/valgrind/s4]

 1,047,135 ( 0.31%)     764 ( 0.09%)   2 ( 0.66%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (1,223x) [./target/valgrind/s4]
   218,899 ( 0.07%)     245 ( 0.03%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::compile_transition (390x) [./target/valgrind/s4]
    60,771 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state [./target/valgrind/s4]

    60,761 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next

    60,562 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

    60,051 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/primitives.rs:regex_automata::nfa::thompson::builder::Builder::patch

    59,205 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::hir::literal::Extractor::cross
   223,949 ( 0.07%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (13,790x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    58,970 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:alloc::vec::Vec<T,A>::dedup_by

 1,467,032 ( 0.44%)     656 ( 0.08%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_group (713x) [./target/valgrind/s4]
    58,226 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group [./target/valgrind/s4]
   861,284 ( 0.26%)     308 ( 0.04%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (586x) [./target/valgrind/s4]
   225,958 ( 0.07%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (2,511x) [./target/valgrind/s4]
    43,132 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,159x) [./target/valgrind/s4]
    14,690 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_flags (20x) [./target/valgrind/s4]
    12,834 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (713x) [./target/valgrind/s4]
    10,630 ( 0.00%)      24 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Ast::empty (107x) [./target/valgrind/s4]

    57,858 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::literal::PreferenceTrie::minimize

    56,132 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::util::remapper::Remapper::remap

    55,036 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop

   679,904 ( 0.20%)   4,017 ( 0.50%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class (2,425x) [./target/valgrind/s4]
    47,621 ( 0.01%)     296 ( 0.04%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::meta::reverse_inner::flatten'2 (159x)
    17,004 ( 0.01%)      38 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::dot (110x) [./target/valgrind/s4]
     8,681 ( 0.00%)      46 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::meta::reverse_inner::flatten (34x)
    54,670 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::class [./target/valgrind/s4]

    54,440 ( 0.02%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind> (2,722x) [./target/valgrind/s4]
    54,440 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind>'2 [./target/valgrind/s4]

    54,418 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_syntax::hir::Hir::alternation

    54,050 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

   926,427 ( 0.28%)   1,443 ( 0.18%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (1,179x) [./target/valgrind/s4]
    53,379 ( 0.02%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::add [./target/valgrind/s4]
   810,871 ( 0.24%)   1,443 ( 0.18%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from (1,179x) [./target/valgrind/s4]

    52,603 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments

    52,036 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre

    51,994 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions
    80,096 ( 0.02%)     314 ( 0.04%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:alloc::collections::vec_deque::VecDeque<T,A>::grow (180x) [./target/valgrind/s4]

    83,305 ( 0.03%)       .            .              .           < ./stdio-common/./stdio-common/isoc23_sscanf.c:__isoc23_sscanf (47x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    51,206 ( 0.02%)       .            .              .           *  ./stdio-common/./stdio-common/vfscanf-internal.c:__vfscanf_internal [/usr/lib/x86_64-linux-gnu/libc.so.6]
    25,284 ( 0.01%)       .            .              .           >   ./stdlib/../stdlib/strtol.c:__strtoul_internal (94x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     4,136 ( 0.00%)       .            .              .           >   ./libio/./libio/genops.c:_IO_sputbackc (188x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
       611 ( 0.00%)       .            .              .           >   ./nptl/./nptl/libc-cleanup.c:__libc_cleanup_push_defer (47x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
       423 ( 0.00%)       .            .              .           >   ./nptl/./nptl/libc-cleanup.c:__libc_cleanup_pop_restore (47x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    51,027 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize

    50,622 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post

    50,561 ( 0.02%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::builder::Builder::build
   284,851 ( 0.09%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (175x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   473,738 ( 0.14%)     801 ( 0.10%)   .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/mod.rs:<str as core::fmt::Display>::fmt (1,863x) [./target/valgrind/s4]
    50,301 ( 0.02%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/mod.rs:core::fmt::Formatter::pad [./target/valgrind/s4]
   419,711 ( 0.13%)     801 ( 0.10%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:<alloc::string::String as core::fmt::Write>::write_str (1,863x) [./target/valgrind/s4]

 5,728,638 ( 1.72%)       .            .              .           < ./malloc/../string/bits/string_fortified.h:_int_realloc (24,960x)
     1,056 ( 0.00%)       .            .              .           < ./libio/../string/bits/string_fortified.h:getdelim (51x)
        60 ( 0.00%)       .            .              .           < ./stdio-common/../string/bits/string_fortified.h:__printf_buffer_write (4x)
        42 ( 0.00%)       .            .              .           < ./nptl/../string/bits/string_fortified.h:pthread_attr_setaffinity_np@@GLIBC_2.32 (3x)
    50,036 ( 0.02%)       .            .              .           *  ???:0x00000000048a06b0 [???]
 5,679,760 ( 1.71%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (25,018x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    49,920 ( 0.01%)       .            .              .           *  ./malloc/../string/bits/string_fortified.h:_int_realloc
 5,728,638 ( 1.72%)       .            .              .           >   ???:0x00000000048a06b0 (24,960x) [???]

    49,564 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::util::remapper::Remapper::remap

    49,392 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state

    48,870 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

73,121,553 (21.95%) 200,912 (24.82%)  76 (25.25%)     1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (1,386x) [./target/valgrind/s4]
    47,924 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 [./target/valgrind/s4]
72,373,710 (21.73%) 199,581 (24.65%)  75 (24.92%)     1 ( 0.07%)  >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (1,386x) [./target/valgrind/s4]
   187,407 ( 0.06%)     407 ( 0.05%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add_capture_start (693x) [./target/valgrind/s4]
    47,816 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (1,386x) [./target/valgrind/s4]

    47,787 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate

    47,404 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop
   169,108 ( 0.05%)     908 ( 0.11%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSetItem> (2,758x) [./target/valgrind/s4]
    84,870 ( 0.03%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,829x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    70,880 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop'2 (2,758x) [./target/valgrind/s4]

70,196,367 (21.07%) 190,944 (23.58%)  77 (25.58%)     1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap (175x) [./target/valgrind/s4]
    29,920 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (110x) [./target/valgrind/s4]
    47,035 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c [./target/valgrind/s4]
69,916,719 (20.99%) 190,902 (23.58%)  77 (25.58%)     1 ( 0.07%)  >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (2,840x) [./target/valgrind/s4]
    94,828 ( 0.03%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (2,671x) [./target/valgrind/s4]
    44,087 ( 0.01%)      38 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter (1x) [./target/valgrind/s4]
     1,210 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassBytesIter as core::iter::traits::iterator::Iterator>::next (220x) [./target/valgrind/s4]
        58 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next (10x) [./target/valgrind/s4]
        48 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (1x) [./target/valgrind/s4]
        26 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::ClassUnicode::is_ascii (2x) [./target/valgrind/s4]

    46,984 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    45,999 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre

    45,828 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle

    45,384 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::literal::Extractor::cross

    45,272 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class
   468,888 ( 0.14%)     876 ( 0.11%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (2,914x) [./target/valgrind/s4]

    45,262 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_automata::hybrid::dfa::Lazy::set_transition

    45,184 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open
    84,720 ( 0.03%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

   468,801 ( 0.14%)     572 ( 0.07%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::class (3,879x) [./target/valgrind/s4]
     2,342 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Class::literal (193x) [./target/valgrind/s4]
    45,038 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::literal [./target/valgrind/s4]

   205,101 ( 0.06%)     639 ( 0.08%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie (2,432x) [./target/valgrind/s4]
    14,136 ( 0.00%)      12 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (192x) [./target/valgrind/s4]
    44,608 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state [./target/valgrind/s4]

    44,450 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_syntax::ast::parse::NestLimiter<P>::increment_depth

    44,084 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_syntax::hir::Hir::alternation

    44,037 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    43,460 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::cross
 1,413,296 ( 0.42%)   9,717 ( 1.20%)   .              .           >   ???:__rust_alloc (7,320x) [./target/valgrind/s4]
   689,353 ( 0.21%)   3,346 ( 0.41%)   .              .           >   ???:__rust_dealloc (5,904x) [./target/valgrind/s4]

    43,098 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions

   230,797 ( 0.07%)     260 ( 0.03%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (2,672x) [./target/valgrind/s4]
    42,963 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push [./target/valgrind/s4]

    91,463 ( 0.03%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (16,182x) [./target/valgrind/s4]
        58 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (10x) [./target/valgrind/s4]
    42,945 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next [./target/valgrind/s4]

    42,630 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class
   252,326 ( 0.08%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (5,123x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    42,263 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::remapper::onepass::<impl regex_automata::dfa::remapper::Remappable for regex_automata::dfa::onepass::DFA>::remap

    41,319 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_syntax::hir::literal::Extractor::cross

 1,588,677 ( 0.48%)     660 ( 0.08%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (713x) [./target/valgrind/s4]
    40,563 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_group [./target/valgrind/s4]
 1,467,032 ( 0.44%)     656 ( 0.08%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (713x) [./target/valgrind/s4]
    14,244 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (713x) [./target/valgrind/s4]

 5,145,284 ( 1.54%)  17,798 ( 2.20%)   4 ( 1.33%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_automata::meta::reverse_inner::prefilter (44x)
 4,732,656 ( 1.42%)  10,297 ( 1.27%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_automata::util::prefilter::prefixes (16x)
     4,004 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_automata::util::prefilter::suffixes (13x)
    40,414 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Seq::optimize_by_preference [./target/valgrind/s4]
 9,743,238 ( 2.93%)  28,095 ( 3.47%)   4 ( 1.33%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::PreferenceTrie::minimize (177x) [./target/valgrind/s4]

    40,084 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind>

    39,544 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open

   575,612 ( 0.17%)   1,100 ( 0.14%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::Extractor::union (2,443x)
   113,551 ( 0.03%)     144 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::util::prefilter::prefixes (15x)
     5,312 ( 0.00%)      12 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::util::prefilter::suffixes (12x)
    39,520 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_extend.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend [./target/valgrind/s4]

    39,440 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

   271,606 ( 0.08%)     176 ( 0.02%)   .              .           < /rust/deps/hashbrown-0.15.2/src/raw/mod.rs:hashbrown::map::HashMap<K,V,S,A>::insert (347x)
    39,402 ( 0.01%)       .            .              .           *  /rust/deps/hashbrown-0.15.2/src/raw/mod.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash [./target/valgrind/s4]

    38,997 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

    38,835 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

    38,712 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::builder::Builder::build
 2,690,268 ( 0.81%)  20,326 ( 2.51%)   .              .           >   ???:__rust_alloc (12,204x) [./target/valgrind/s4]
    88,196 ( 0.03%)     716 ( 0.09%)   .              .           >   ???:__rust_dealloc (525x) [./target/valgrind/s4]
    74,684 ( 0.02%)     356 ( 0.04%)   .              .           >   ???:__rust_alloc_zeroed (175x) [./target/valgrind/s4]

    38,606 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie

    36,912 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Compiler::add_unanchored_start_state_loop

    36,864 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state

   307,492 ( 0.09%)   1,642 ( 0.20%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (882x) [./target/valgrind/s4]
   255,384 ( 0.08%)     862 ( 0.11%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::finish_build_one_start (953x) [./target/valgrind/s4]
    36,700 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::DFA::set_matches [./target/valgrind/s4]

   158,700 ( 0.05%)     300 ( 0.04%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie (1,394x) [./target/valgrind/s4]
    36,388 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::add_match [./target/valgrind/s4]

    35,973 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition

    35,936 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/map.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile

    35,440 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_syntax::hir::Hir::alternation

   830,539 ( 0.25%)   2,240 ( 0.28%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple (1,120x)
     5,740 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (70x)
    35,370 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple [./target/valgrind/s4]
   163,360 ( 0.05%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::SimpleCaseFolder::mapping (1,120x) [./target/valgrind/s4]

    35,238 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next
    49,737 ( 0.01%)     229 ( 0.03%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (123x) [./target/valgrind/s4]

    35,224 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:regex_automata::nfa::thompson::map::Utf8SuffixMap::clear

    35,132 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_syntax::hir::Hir::alternation
    10,342 ( 0.00%)      26 ( 0.00%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (58x) [./target/valgrind/s4]

   312,709 ( 0.09%)     130 ( 0.02%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:regex_automata::util::captures::GroupInfo::new (586x)
   170,671 ( 0.05%)     383 ( 0.05%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:regex_automata::hybrid::dfa::Lazy::init_cache (468x)
   135,175 ( 0.04%)      14 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (174x)
    13,487 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x)
     2,421 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:s4::processing_loop (15x)
       576 ( 0.00%)       .            .              .           < /rust/deps/hashbrown-0.15.2/src/set.rs:s4::processing_loop (4x)
    35,080 ( 0.01%)       .            .              .           *  /rust/deps/hashbrown-0.15.2/src/map.rs:hashbrown::map::HashMap<K,V,S,A>::insert [./target/valgrind/s4]
   245,756 ( 0.07%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/mod.rs:core::hash::BuildHasher::hash_one (1,269x) [./target/valgrind/s4]

   245,756 ( 0.07%)       .            .              .           < /rust/deps/hashbrown-0.15.2/src/map.rs:hashbrown::map::HashMap<K,V,S,A>::insert (1,269x) [./target/valgrind/s4]
   137,878 ( 0.04%)       .            .              .           < /rust/deps/hashbrown-0.15.2/src/map.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash (748x)
    80,442 ( 0.02%)       .            .              .           < /rust/deps/hashbrown-0.15.2/src/map.rs:regex_automata::util::captures::GroupInfo::new (505x)
    47,138 ( 0.01%)       .            .              .           < /rust/deps/hashbrown-0.15.2/src/map.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (218x)
    10,185 ( 0.00%)       .            .              .           < /rust/deps/hashbrown-0.15.2/src/map.rs:regex_automata::util::captures::Captures::get_group_by_name (65x)
    10,134 ( 0.00%)       .            .              .           < /rust/deps/hashbrown-0.15.2/src/map.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x)
       890 ( 0.00%)       .            .              .           < /rust/deps/hashbrown-0.15.2/src/map.rs:s4::processing_loop (10x)
    34,699 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/mod.rs:core::hash::BuildHasher::hash_one [./target/valgrind/s4]
    57,495 ( 0.02%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/sip.rs:<core::hash::sip::Hasher<S> as core::hash::Hasher>::write (1,637x) [./target/valgrind/s4]

    34,320 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/sparse_set.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push

    33,659 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions

    33,406 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::Concat::into_ast

   187,407 ( 0.06%)     407 ( 0.05%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (693x) [./target/valgrind/s4]
    41,168 ( 0.01%)      80 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap (81x) [./target/valgrind/s4]
    33,363 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add_capture_start [./target/valgrind/s4]
    51,420 ( 0.02%)      52 ( 0.01%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (774x) [./target/valgrind/s4]

    33,323 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/accum.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    33,071 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/search.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new

    32,778 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next

    32,455 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    32,454 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

    32,389 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_automata::dfa::onepass::Builder::build_from_nfa

    32,264 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

    32,192 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post

    31,858 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate

    31,858 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::visitor::visit

    31,858 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate

    31,335 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    31,318 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from
   372,221 ( 0.11%)     879 ( 0.11%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (1,901x) [./target/valgrind/s4]

   163,360 ( 0.05%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple (1,120x) [./target/valgrind/s4]
    31,280 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::SimpleCaseFolder::mapping [./target/valgrind/s4]

    31,086 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop

    31,012 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_syntax::hir::literal::Extractor::cross

    30,812 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::Hir::literal

    30,510 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::hir::Properties::repetition

    30,157 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_syntax::hir::literal::Seq::optimize_by_preference

    30,008 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::hir::Properties::class

    29,566 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize

    29,515 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

    29,512 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::meta::reverse_inner::flatten'2
   637,372 ( 0.19%)   3,644 ( 0.45%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::literal (1,912x) [./target/valgrind/s4]
    47,621 ( 0.01%)     296 ( 0.04%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::class (159x) [./target/valgrind/s4]
    22,252 ( 0.01%)     136 ( 0.02%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::repetition (74x) [./target/valgrind/s4]
     4,069 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Class::literal (159x) [./target/valgrind/s4]
       317 ( 0.00%)       2 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::look (2x) [./target/valgrind/s4]

   634,469 ( 0.19%)   3,133 ( 0.39%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/api.rs:regex_automata::util::prefilter::teddy::Teddy::new (1,394x)
    29,454 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/pattern.rs:aho_corasick::packed::pattern::Patterns::add [./target/valgrind/s4]

    29,357 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_syntax::hir::literal::Extractor::union

    29,272 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new
    78,893 ( 0.02%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (3,659x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    29,060 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop

    28,921 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    28,890 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::Extractor::extract'2
   541,031 ( 0.16%)   2,976 ( 0.37%)   .              .           >   ???:__rust_alloc (5,194x) [./target/valgrind/s4]
   217,635 ( 0.07%)     394 ( 0.05%)   .              .           >   ???:__rust_dealloc (2,035x) [./target/valgrind/s4]

    28,647 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

    28,623 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    28,560 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple

    28,155 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_syntax::hir::ClassUnicode::is_ascii

   234,769 ( 0.07%)     606 ( 0.07%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (210x) [./target/valgrind/s4]
   113,796 ( 0.03%)     258 ( 0.03%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (134x) [./target/valgrind/s4]
    28,010 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_concat [./target/valgrind/s4]
   303,821 ( 0.09%)     864 ( 0.11%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (580x) [./target/valgrind/s4]
     8,260 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (236x) [./target/valgrind/s4]

    28,000 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_syntax::unicode::SimpleCaseFolder::overlaps

    27,945 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_syntax::hir::literal::Seq::optimize_by_preference

    27,598 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/set_len_on_drop.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop

    29,825 ( 0.01%)       .            .              .           < ./elf/../sysdeps/unix/sysv/linux/dl-sysdep.c:_dl_sysdep_start (1x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    27,565 ( 0.01%)       .            .              .           *  ./elf/./elf/dl-tunables.c:__GI___tunables_init [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

    27,549 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_syntax::hir::literal::Extractor::extract'2

    27,530 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre
    66,072 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (2,753x) [./target/valgrind/s4]

    27,370 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple

    27,235 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:<core::hash::sip::Hasher<S> as core::hash::Hasher>::write

    26,753 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next

   442,320 ( 0.13%)     860 ( 0.11%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from (1,588x) [./target/valgrind/s4]
    48,021 ( 0.01%)      98 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::finish (126x) [./target/valgrind/s4]
    26,584 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile [./target/valgrind/s4]

    26,456 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::patch

   419,711 ( 0.13%)     801 ( 0.10%)   .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/mod.rs:core::fmt::Formatter::pad (1,863x) [./target/valgrind/s4]
       794 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/mod.rs:core::fmt::Formatter::pad_integral (6x) [./target/valgrind/s4]
        82 ( 0.00%)       .            .              .           < /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/mod.rs:core::fmt::write (2x) [./target/valgrind/s4]
    26,194 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:<alloc::string::String as core::fmt::Write>::write_str [./target/valgrind/s4]

    26,136 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/search.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert

    25,690 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::dfa::DFA::set_matches

    25,388 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class

    25,388 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie

   917,383 ( 0.28%)   3,114 ( 0.38%)   2 ( 0.66%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::builder::Builder::build (175x)
    25,262 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/captures.rs:regex_automata::util::captures::GroupInfo::new [./target/valgrind/s4]
    70,180 ( 0.02%)     268 ( 0.03%)   2 ( 0.66%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/captures.rs:regex_automata::util::captures::GroupInfoInner::add_first_group (81x) [./target/valgrind/s4]

   923,249 ( 0.28%)     339 ( 0.04%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::new (162x) [./target/valgrind/s4]
    71,209 ( 0.02%)      26 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::new (13x) [./target/valgrind/s4]
    25,174 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Builder::build_from_nfa [./target/valgrind/s4]
    66,651 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/state.rs:regex_automata::util::determinize::state::State::dead (175x) [./target/valgrind/s4]
     5,250 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    72,094 ( 0.02%)      67 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (586x)
    71,074 ( 0.02%)      50 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (586x) [./target/valgrind/s4]
       542 ( 0.00%)       4 ( 0.00%)   .              .           < src/readers/syslogprocessor.rs:s4lib::readers::syslogprocessor::SyslogProcessor::summary_complete (2x) [./target/valgrind/s4]
       525 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/borrow.rs:std::sync::poison::once::Once::call_once_force::{{closure}} (3x)
       382 ( 0.00%)       2 ( 0.00%)   .              .           < src/readers/blockreader.rs:s4lib::readers::blockreader::BlockReader::new (2x) [./target/valgrind/s4]
       320 ( 0.00%)       .            .              .           < src/bin/s4.rs:s4::processing_loop (3x) [./target/valgrind/s4]
       216 ( 0.00%)       .            .              .           < src/bin/s4.rs:s4::process_dt_exit (2x) [./target/valgrind/s4]
       107 ( 0.00%)       .            .              .           < src/readers/filepreprocessor.rs:s4lib::readers::filepreprocessor::process_path (1x) [./target/valgrind/s4]
       107 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/borrow.rs:s4::processing_loop (1x)
       107 ( 0.00%)       .            .              .           < src/bin/s4.rs:s4::main (1x) [./target/valgrind/s4]
       107 ( 0.00%)       .            .              .           < src/bin/s4.rs:s4::exec_fileprocessor_thread (1x) [./target/valgrind/s4]
    24,948 ( 0.01%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/string.rs:<alloc::string::String as core::clone::Clone>::clone [./target/valgrind/s4]

   637,372 ( 0.19%)   3,644 ( 0.45%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_automata::meta::reverse_inner::flatten'2 (1,912x)
    24,856 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::literal [./target/valgrind/s4]
   104,669 ( 0.03%)       .            .              .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/str/converts.rs:core::str::converts::from_utf8 (1,912x) [./target/valgrind/s4]

    24,814 ( 0.01%)       .            .              .           < ./stdlib/../stdlib/strtol.c:__strtoul_internal (94x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    24,814 ( 0.01%)       .            .              .           *  ./stdlib/../stdlib/strtol_l.c:____strtoul_l_internal [/usr/lib/x86_64-linux-gnu/libc.so.6]

    24,732 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add
    56,690 ( 0.02%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (4,122x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    24,720 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::Compiler::add_unanchored_start_state_loop

   260,445 ( 0.08%)     245 ( 0.03%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (390x) [./target/valgrind/s4]
    24,597 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::compile_transition [./target/valgrind/s4]
   218,899 ( 0.07%)     245 ( 0.03%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (390x) [./target/valgrind/s4]

    24,596 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post
   148,206 ( 0.04%)     311 ( 0.04%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (846x) [./target/valgrind/s4]

    24,576 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::util::prefilter::Builder::build

 3,077,754 ( 0.92%)   6,643 ( 0.82%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::prefilter (44x) [./target/valgrind/s4]
 2,286,479 ( 0.69%)   6,589 ( 0.81%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/prefilter/mod.rs:regex_automata::util::prefilter::prefixes (16x) [./target/valgrind/s4]
 2,147,803 ( 0.64%)   5,134 ( 0.63%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/prefilter/mod.rs:regex_automata::util::prefilter::suffixes (13x) [./target/valgrind/s4]
    24,071 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract [./target/valgrind/s4]
 4,670,969 ( 1.40%)   9,521 ( 1.18%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (975x) [./target/valgrind/s4]
 1,800,969 ( 0.54%)   8,499 ( 1.05%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (111x) [./target/valgrind/s4]
   873,190 ( 0.26%)     274 ( 0.03%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::union (864x) [./target/valgrind/s4]

    24,039 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/lib.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    24,007 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::hybrid::dfa::Lazy::init_cache

    23,980 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_automata::dfa::remapper::onepass::<impl regex_automata::dfa::remapper::Remappable for regex_automata::dfa::onepass::DFA>::remap

    23,941 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2
   333,796 ( 0.10%)   2,603 ( 0.32%)   .              .           >   ???:__rust_dealloc (2,598x) [./target/valgrind/s4]

    23,468 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind>

    23,303 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_syntax::hir::Hir::concat

    23,136 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:aho_corasick::util::remapper::Remapper::swap

    23,100 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::builder::x86_64::FatAVX2<3_usize>::new_unchecked
   700,540 ( 0.21%)   2,448 ( 0.30%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (21x) [./target/valgrind/s4]
     1,365 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (21x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    22,938 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post

    22,906 ( 0.01%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/alloc/layout.rs:alloc::sync::arcinner_layout_for_value_layout

    22,755 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_syntax::hir::literal::Extractor::cross

    22,631 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::hybrid::dfa::Lazy::set_transition

    22,631 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::hybrid::dfa::Lazy::set_transition

    22,631 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new

    22,602 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open

    22,564 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class
     8,946 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (71x) [./target/valgrind/s4]

    22,538 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post
   441,242 ( 0.13%)     336 ( 0.04%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (5,231x) [./target/valgrind/s4]
     5,740 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple (70x) [./target/valgrind/s4]

    22,524 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:regex_syntax::hir::ClassUnicode::is_ascii

   462,580 ( 0.14%)       0            5 ( 1.66%)     .           < ./elf/./elf/rtld.c:dl_main (6x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    22,439 ( 0.01%)       .            .              .           *  ./elf/./elf/dl-reloc.c:_dl_relocate_object [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
   135,440 ( 0.04%)       .            .              .           >   ./elf/./elf/dl-lookup.c:_dl_lookup_symbol_x (225x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
        30 ( 0.00%)       0            5 ( 1.66%)     .           >   ./misc/../sysdeps/unix/syscall-template.S:mprotect (5x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

    22,404 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<alloc::string::String as core::fmt::Write>::write_str
   325,224 ( 0.10%)     801 ( 0.10%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (1,865x) [./target/valgrind/s4]

    31,216 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::maybe_parse_ascii_class (770x) [./target/valgrind/s4]
    22,348 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:regex_syntax::ast::ClassAsciiKind::from_name [./target/valgrind/s4]

    22,340 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize

    22,280 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/num.rs:regex_automata::hybrid::dfa::Lazy::set_transition

    22,276 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_group

    22,269 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition

   135,440 ( 0.04%)       .            .              .           < ./elf/./elf/dl-reloc.c:_dl_relocate_object (225x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
     2,368 ( 0.00%)       .            .              .           < ./elf/./elf/dl-minimal.c:lookup_malloc_symbol (4x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
       683 ( 0.00%)       .            .              .           < ./elf/./elf/dl-sym.c:_dl_sym (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    22,236 ( 0.01%)       .            .              .           *  ./elf/./elf/dl-lookup.c:_dl_lookup_symbol_x [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    96,695 ( 0.03%)       .            .              .           >   ./elf/./elf/dl-lookup.c:do_lookup_x (230x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

    22,225 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::ast::parse::NestLimiter<P>::increment_depth

   146,101 ( 0.04%)     418 ( 0.05%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (1,386x) [./target/valgrind/s4]
    22,176 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/utf8.rs:regex_syntax::utf8::Utf8Sequences::new [./target/valgrind/s4]

    22,141 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre

    21,823 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next

    21,817 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/sparse_set.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa

    21,768 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile
 1,074,794 ( 0.32%)     273 ( 0.03%)   .              .           >   ???:__rust_dealloc (10,884x) [./target/valgrind/s4]

    30,958 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions (673x) [./target/valgrind/s4]
     2,208 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state (48x) [./target/valgrind/s4]
    21,630 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::copy_matches [./target/valgrind/s4]

    21,504 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

   243,845 ( 0.07%)     132 ( 0.02%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (172x) [./target/valgrind/s4]
    21,455 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition [./target/valgrind/s4]
    99,879 ( 0.03%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (239x) [./target/valgrind/s4]
    23,142 ( 0.01%)      84 ( 0.01%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Ast::repetition (172x) [./target/valgrind/s4]
    21,510 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (239x) [./target/valgrind/s4]
    20,812 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_and_bump_space (172x) [./target/valgrind/s4]
    15,100 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (755x) [./target/valgrind/s4]
     8,604 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::specialize_err (239x) [./target/valgrind/s4]
     4,302 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (239x) [./target/valgrind/s4]

   700,540 ( 0.21%)   2,448 ( 0.30%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::builder::x86_64::FatAVX2<3_usize>::new_unchecked (21x)
   124,070 ( 0.04%)     506 ( 0.06%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<3_usize>::new_unchecked (10x)
    83,553 ( 0.03%)     311 ( 0.04%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<1_usize>::new_unchecked (24x)
     8,831 ( 0.00%)      35 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::builder::x86_64::SlimAVX2<4_usize>::new_unchecked (2x)
    21,319 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new [./target/valgrind/s4]
   121,963 ( 0.04%)       8 ( 0.00%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert (406x) [./target/valgrind/s4]
    77,240 ( 0.02%)     397 ( 0.05%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::collections::btree::map::BTreeMap<alloc::boxed::Box<[u8]>,usize>> (57x) [./target/valgrind/s4]
     2,445 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (57x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    21,236 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push
    93,862 ( 0.03%)     260 ( 0.03%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (211x) [./target/valgrind/s4]

    21,105 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2
 1,063,219 ( 0.32%)   7,541 ( 0.93%)   .              .           >   ???:__rust_alloc (5,619x) [./target/valgrind/s4]
   443,340 ( 0.13%)   1,182 ( 0.15%)   .              .           >   ???:__rust_dealloc (1,881x) [./target/valgrind/s4]

    41,933 ( 0.01%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/stable/mod.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,318x)
    21,089 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/smallsort.rs:core::slice::sort::shared::smallsort::insertion_sort_shift_left [./target/valgrind/s4]

    21,032 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::hir::Properties::literal

    20,966 ( 0.01%)       .            .              .           *  ./malloc/./malloc/arena.c:calloc

    47,288 ( 0.01%)      58 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map/entry.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert (542x)
    20,849 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf>,alloc::collections::btree::node::marker::Edge>::insert_recursing [./target/valgrind/s4]
       782 ( 0.00%)       4 ( 0.00%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Internal>,alloc::collections::btree::node::marker::KV>::split (2x) [./target/valgrind/s4]

    20,712 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::literal::PreferenceTrie::minimize
   984,217 ( 0.30%)   7,537 ( 0.93%)   .              .           >   ???:__rust_dealloc (7,022x) [./target/valgrind/s4]

    20,619 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs:regex_syntax::hir::Hir::alternation

   496,637 ( 0.15%)     490 ( 0.06%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::search::find_fwd (218x)
    20,602 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state [./target/valgrind/s4]
   148,471 ( 0.04%)       2 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::next (218x) [./target/valgrind/s4]
     6,976 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::set_transition (218x) [./target/valgrind/s4]

    20,574 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa
    61,071 ( 0.02%)     328 ( 0.04%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (175x) [./target/valgrind/s4]

    20,185 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::dfa::DFA::set_matches
   454,611 ( 0.14%)   2,504 ( 0.31%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (1,835x) [./target/valgrind/s4]

    14,031 ( 0.00%)       .            .              .           < ./elf/./elf/dl-lookup.c:check_match (381x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
     4,142 ( 0.00%)       .            .              .           < ./elf/./elf/dl-misc.c:_dl_name_match_p (102x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
     1,123 ( 0.00%)       .            .              .           < ./elf/./elf/dl-version.c:_dl_check_map_versions (31x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
       407 ( 0.00%)       .            .              .           < ./elf/./elf/dl-lookup-direct.c:_dl_lookup_direct (6x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
       195 ( 0.00%)       .            .              .           < ./elf/./elf/dl-load.c:_dl_map_object (6x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
        50 ( 0.00%)       .            .              .           < ./elf/./elf/dl-load.c:_dl_map_object_from_fd (2x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
        50 ( 0.00%)       .            .              .           < ./elf/../sysdeps/x86/dl-procinfo.h:_dl_load_cache_lookup (2x)
        25 ( 0.00%)       .            .              .           < ./elf/./elf/rtld.c:dl_main (1x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    20,023 ( 0.01%)       .            .              .           *  ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S:strcmp [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

    19,963 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::dfa::onepass::Builder::build_from_nfa
    10,044 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (81x) [./target/valgrind/s4]

    19,844 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/convert.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next

    19,826 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::literal::Extractor::union
   575,612 ( 0.17%)   1,100 ( 0.14%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_extend.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend (2,443x) [./target/valgrind/s4]

    19,768 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op

    19,560 ( 0.01%)       .            .              .           *  ./elf/../sysdeps/generic/dl-new-hash.h:_dl_lookup_symbol_x

    44,372 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/state.rs:regex_automata::util::determinize::next (218x)
    19,468 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/state.rs:regex_automata::util::determinize::state::Repr::iter_nfa_state_ids [./target/valgrind/s4]

    19,406 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:aho_corasick::packed::rabinkarp::RabinKarp::new

    19,020 ( 0.01%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/slice/iter/macros.rs:core::str::count::char_count_general_case

    19,010 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::packed::rabinkarp::RabinKarp::new
   190,861 ( 0.06%)     798 ( 0.10%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (733x) [./target/valgrind/s4]
   156,688 ( 0.05%)     274 ( 0.03%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_elem.rs:<T as alloc::vec::spec_from_elem::SpecFromElem>::from_elem (48x) [./target/valgrind/s4]

    46,656 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::Hybrid::new (486x)
    31,265 ( 0.01%)       2 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::meta::strategy::new (324x)
    15,552 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::OnePass::new (162x)
    15,552 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::BoundedBacktracker::new (162x)
    15,552 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::PikeVM::new (162x)
     2,496 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::meta::wrappers::ReverseHybrid::new (26x)
     2,496 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::nfa::thompson::compiler::Compiler::new (26x)
    18,872 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::nfa::thompson::range_trie::RangeTrie::add_empty [./target/valgrind/s4]

    18,851 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition

   691,299 ( 0.21%)   2,005 ( 0.25%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (134x) [./target/valgrind/s4]
    18,748 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded [./target/valgrind/s4]
   264,671 ( 0.08%)     901 ( 0.11%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (526x) [./target/valgrind/s4]
   220,820 ( 0.07%)     802 ( 0.10%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (1,712x) [./target/valgrind/s4]
   113,796 ( 0.03%)     258 ( 0.03%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_concat (134x) [./target/valgrind/s4]
    32,877 ( 0.01%)      32 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (526x) [./target/valgrind/s4]

    18,427 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs:regex_syntax::hir::literal::Extractor::cross

    18,326 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter

    48,680 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (1,125x)
     1,036 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation'2 (1x) [./target/valgrind/s4]
       171 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (1x) [./target/valgrind/s4]
    18,072 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::new [./target/valgrind/s4]
    27,842 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,127x) [./target/valgrind/s4]

    17,954 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state
   130,435 ( 0.04%)     651 ( 0.08%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (221x) [./target/valgrind/s4]

    17,884 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name

    17,781 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_class

    17,672 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from

    17,646 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/hash/random.rs:core::hash::BuildHasher::hash_one

    17,620 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::Concat::into_ast

    17,597 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_syntax::ast::parse::ParserI<P>::pop_class

    17,538 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert

    60,952 ( 0.02%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle (1,490x) [./target/valgrind/s4]
    17,528 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::swap [./target/valgrind/s4]

   148,471 ( 0.04%)       2 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (218x) [./target/valgrind/s4]
    17,446 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::next [./target/valgrind/s4]
    28,735 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::epsilon_closure (194x) [./target/valgrind/s4]
    25,186 ( 0.01%)       2 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::add_nfa_states (218x) [./target/valgrind/s4]
        69 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/state.rs:regex_automata::util::determinize::state::StateBuilderMatches::add_match_pattern_id (3x) [./target/valgrind/s4]

    17,439 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_syntax::hir::Properties::repetition

    17,276 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class

    17,261 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/alphabet.rs:regex_automata::dfa::onepass::Builder::build_from_nfa

    17,258 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::literal::Extractor::extract'2
     3,510 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (351x) [./target/valgrind/s4]

    17,225 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_syntax::hir::literal::Extractor::extract

    17,136 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_automata::nfa::thompson::map::Utf8SuffixMap::clear

    17,130 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition
   351,729 ( 0.11%)   1,320 ( 0.16%)   .              .           >   ???:__rust_alloc (3,426x) [./target/valgrind/s4]

    17,108 ( 0.01%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/alloc/unix.rs:__rdl_alloc_zeroed
   355,803 ( 0.11%)   2,900 ( 0.36%)   .              .           >   ./malloc/./malloc/malloc.c:calloc (1,316x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    17,079 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile

    16,944 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::pop_class

    16,893 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::is_ascii

    16,880 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple
   521,359 ( 0.16%)   2,240 ( 0.28%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (1,120x) [./target/valgrind/s4]

    16,731 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa

    16,728 ( 0.01%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::packed::rabinkarp::RabinKarp::new

    16,684 ( 0.01%)       .            .              .           *  /rust/deps/hashbrown-0.15.2/src/raw/mod.rs:hashbrown::map::HashMap<K,V,S,A>::insert
   271,606 ( 0.08%)     176 ( 0.02%)   .              .           >   /rust/deps/hashbrown-0.15.2/src/raw/mod.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash (347x) [./target/valgrind/s4]

   931,859 ( 0.28%)   2,240 ( 0.28%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (1,190x) [./target/valgrind/s4]
    16,660 ( 0.01%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple [./target/valgrind/s4]

    16,632 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::ast::parse::ParserI<P>::pop_group

    16,624 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie
    78,082 ( 0.02%)     309 ( 0.04%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (180x) [./target/valgrind/s4]

 1,694,769 ( 0.51%)   1,802 ( 0.22%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build (175x) [./target/valgrind/s4]
    16,533 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa [./target/valgrind/s4]
     5,250 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    16,494 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

    16,379 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

    16,368 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::class
   626,468 ( 0.19%)   4,397 ( 0.54%)   .              .           >   ???:__rust_alloc (2,728x) [./target/valgrind/s4]

    16,317 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:aho_corasick::util::alphabet::ByteClassSet::byte_classes

    16,298 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2

    16,234 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::packed::pattern::Patterns::add
   172,581 ( 0.05%)     544 ( 0.07%)   .              .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (180x) [./target/valgrind/s4]
    77,839 ( 0.02%)     368 ( 0.05%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (180x) [./target/valgrind/s4]

    37,856 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (482x) [./target/valgrind/s4]
    16,139 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Seq::cross_preamble [./target/valgrind/s4]

    16,126 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::meta::reverse_inner::flatten'2

   121,963 ( 0.04%)       8 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (406x) [./target/valgrind/s4]
    53,496 ( 0.02%)      58 ( 0.01%)   .              .           < src/readers/syslinereader.rs:s4lib::readers::syslinereader::SyslineReader::new (175x) [./target/valgrind/s4]
     1,660 ( 0.00%)      14 ( 0.00%)   .              .           < src/bin/s4.rs:s4::processing_loop (5x) [./target/valgrind/s4]
     1,366 ( 0.00%)       4 ( 0.00%)   .              .           < src/readers/linereader.rs:s4lib::readers::linereader::LineReader::insert_line (10x) [./target/valgrind/s4]
     1,296 ( 0.00%)       4 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rangemap-1.6.0/src/map.rs:rangemap::map::RangeMap<K,V>::insert (9x) [./target/valgrind/s4]
       395 ( 0.00%)       .            .              .           < src/readers/syslinereader.rs:s4lib::readers::syslinereader::SyslineReader::insert_sysline (4x) [./target/valgrind/s4]
       251 ( 0.00%)       2 ( 0.00%)   .              .           < src/readers/blockreader.rs:s4lib::readers::blockreader::BlockReader::read_block_File (1x) [./target/valgrind/s4]
       250 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/set.rs:s4lib::readers::blockreader::BlockReader::read_block_File (1x)
       172 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:s4lib::readers::syslinereader::SyslineReader::summary (2x)
       172 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::fold (2x)
    16,111 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert [./target/valgrind/s4]

    16,002 ( 0.00%)       .            .              .           *  /rust/deps/hashbrown-0.15.2/src/control/tag.rs:hashbrown::map::HashMap<K,V,S,A>::insert

    15,994 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::hir::Hir::class

    15,994 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:regex_syntax::hir::ClassUnicode::literal
   383,371 ( 0.12%)     572 ( 0.07%)   .              .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/mod.rs:<str as core::fmt::Display>::fmt (1,454x) [./target/valgrind/s4]

    15,960 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile

    15,949 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::builder::Builder::patch

   204,301 ( 0.06%)   1,127 ( 0.14%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (693x)
    15,939 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::capture [./target/valgrind/s4]

    15,929 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::ast::visitor::visit

 6,013,983 ( 1.81%)  39,114 ( 4.83%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (495x)
 5,546,407 ( 1.67%)  33,350 ( 4.12%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> (674x) [./target/valgrind/s4]
    18,358 ( 0.01%)      69 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:alloc::sync::Arc<T,A>::drop_slow'2 (3x)
     9,842 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<clap_builder::builder::command::Command> (2x) [./target/valgrind/s4]
     3,510 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::literal::Extractor::extract'2 (351x)
     2,950 ( 0.00%)       8 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<clap_builder::parser::matches::arg_matches::ArgMatches> (1x) [./target/valgrind/s4]
     2,592 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::meta::regex::Builder::build (162x)
       710 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::hir::literal::Extractor::extract (71x)
       172 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<std::sys::thread_local::native::lazy::State<regex::regex::string::Regex,()>> (1x) [./target/valgrind/s4]
        19 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:clap_builder::builder::command::Command::_do_parse (1x)
        19 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:clap_builder::builder::command::Command::_build_self (1x)
        14 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:s4::processing_loop (1x)
    15,849 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop [./target/valgrind/s4]

    15,838 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:aho_corasick::nfa::noncontiguous::Compiler::densify
   365,825 ( 0.11%)     863 ( 0.11%)   6 ( 1.99%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (314x) [./target/valgrind/s4]

    15,752 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/utf8.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

    15,747 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::compiler::Compiler::c_alt_iter

    15,496 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item

    15,417 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition

    15,408 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs:regex_syntax::hir::Hir::concat

    15,406 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_syntax::hir::Hir::literal

    15,406 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_syntax::hir::Hir::literal

    15,370 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_group
   117,684 ( 0.04%)     450 ( 0.06%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (243x) [./target/valgrind/s4]
    15,360 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (512x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    15,312 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class
   129,570 ( 0.04%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (4,319x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    15,289 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

    15,276 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_group

    15,086 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize
    84,324 ( 0.03%)     336 ( 0.04%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (167x) [./target/valgrind/s4]

    15,079 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state
 1,026,971 ( 0.31%)     842 ( 0.10%)   2 ( 0.66%)     .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (290x) [./target/valgrind/s4]

    14,925 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2

    14,918 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2

   383,371 ( 0.12%)     572 ( 0.07%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:regex_syntax::hir::ClassUnicode::literal (1,454x)
   104,831 ( 0.03%)     229 ( 0.03%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:regex_syntax::hir::literal::Extractor::extract'2 (407x)
       440 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:regex_syntax::hir::literal::Extractor::extract (2x)
    14,904 ( 0.00%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/mod.rs:<str as core::fmt::Display>::fmt [./target/valgrind/s4]
   473,738 ( 0.14%)     801 ( 0.10%)   .              .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/mod.rs:core::fmt::Formatter::pad (1,863x) [./target/valgrind/s4]

 1,806,737 ( 0.54%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (48x) [./target/valgrind/s4]
    14,840 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle [./target/valgrind/s4]
 1,686,475 ( 0.51%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::remap (48x) [./target/valgrind/s4]
    60,952 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::swap (1,490x) [./target/valgrind/s4]

    14,828 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::nfa::thompson::range_trie::RangeTrie::add_empty
    85,085 ( 0.03%)       2 ( 0.00%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (674x) [./target/valgrind/s4]

    54,873 ( 0.02%)     168 ( 0.02%)   .              .           < ./malloc/./malloc/malloc.c:posix_memalign (121x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
    14,780 ( 0.00%)     168 ( 0.02%)   .              .           *  ./malloc/./malloc/malloc.c:_mid_memalign.isra.0 [/usr/lib/x86_64-linux-gnu/libc.so.6]
    39,175 ( 0.01%)       .            .              .           >   ./malloc/./malloc/malloc.c:_int_memalign (85x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    14,599 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions

    14,564 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::add_transition

    14,540 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Hir::class
   276,234 ( 0.08%)   2,906 ( 0.36%)   .              .           >   ???:__rust_realloc (1,454x) [./target/valgrind/s4]
   271,538 ( 0.08%)   2,018 ( 0.25%)   .              .           >   ???:__rust_alloc (1,454x) [./target/valgrind/s4]

    28,548 ( 0.01%)       .            .              .           < ./elf/./elf/dl-lookup.c:do_lookup_x (231x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    14,517 ( 0.00%)       .            .              .           *  ./elf/./elf/dl-lookup.c:check_match [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]
    14,031 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S:strcmp (381x) [/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2]

    14,488 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape

    14,460 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:aho_corasick::util::remapper::Remapper::swap

    14,459 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle

    14,378 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie

    14,350 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_automata::hybrid::dfa::Builder::configure

    99,879 ( 0.03%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (239x) [./target/valgrind/s4]
    14,332 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal [./target/valgrind/s4]
    32,180 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (1,609x) [./target/valgrind/s4]
    21,600 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (240x) [./target/valgrind/s4]
     4,320 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (240x) [./target/valgrind/s4]

    14,282 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open
 1,023,156 ( 0.31%)     330 ( 0.04%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (81x) [./target/valgrind/s4]

    14,260 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_syntax::ast::parse::ParserI<P>::push_group

    14,221 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop

    14,201 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::hir::literal::Extractor::extract'2
    41,720 ( 0.01%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,411x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    14,175 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name

    14,175 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:aho_corasick::dfa::Builder::build_from_noncontiguous

    14,168 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::NFA::add_transition

   130,415 ( 0.04%)     401 ( 0.05%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (770x)
    18,841 ( 0.01%)       6 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:itertools::Itertools::sorted_by (3x)
    18,739 ( 0.01%)       6 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:s4lib::readers::syslinereader::SyslineReader::parse_datetime_in_line_cached (5x)
       752 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::builder::command::Command::get_matches_from (1x)
       734 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:s4lib::readers::syslinereader::SyslineReader::summary (2x)
       163 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:s4lib::readers::syslinereader::SyslineReader::dt_patterns_analysis (1x)
    14,096 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter [./target/valgrind/s4]

    13,943 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop
   150,700 ( 0.05%)       .            .              .           >   ???:__rust_alloc (2,740x) [./target/valgrind/s4]
    16,501 ( 0.00%)     158 ( 0.02%)   .              .           >   ???:__rust_dealloc (81x) [./target/valgrind/s4]

    13,932 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/captures.rs:regex_automata::nfa::thompson::builder::Builder::build

24,105,935 ( 7.24%) 101,379 (12.52%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::meta::regex::Builder::build (81x)
    94,317 ( 0.03%)      29 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x)
    13,932 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast> [./target/valgrind/s4]
24,106,519 ( 7.24%) 101,299 (12.51%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop (774x) [./target/valgrind/s4]
    79,027 ( 0.02%)     109 ( 0.01%)   .              .           >   ???:__rust_dealloc (774x) [./target/valgrind/s4]

    13,904 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs:regex_syntax::hir::Properties::class

    13,704 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_uncounted_repetition

    13,556 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_automata::dfa::onepass::Builder::build_from_nfa

    13,546 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/sparse_set.rs:regex_automata::util::determinize::epsilon_closure

    13,520 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:regex_syntax::unicode::SimpleCaseFolder::mapping

    13,520 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_syntax::unicode::SimpleCaseFolder::mapping

    13,476 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:aho_corasick::dfa::Builder::finish_build_one_start

    13,362 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:core::ptr::drop_in_place<regex_syntax::hir::HirKind>
    74,474 ( 0.02%)     571 ( 0.07%)   .              .           >   ???:__rust_dealloc (586x) [./target/valgrind/s4]

    13,292 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name
    72,094 ( 0.02%)      67 ( 0.01%)   .              .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/string.rs:<alloc::string::String as core::clone::Clone>::clone (586x) [./target/valgrind/s4]

    13,286 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile

    13,256 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:<regex_syntax::hir::Hir as core::ops::drop::Drop>::drop

    13,143 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:regex_syntax::hir::literal::Seq::optimize_by_preference

    13,118 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_syntax::hir::literal::Extractor::extract'2

    13,098 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/mod.rs:core::slice::sort::stable::drift::sort

    13,055 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::hir::literal::PreferenceTrie::insert
    38,848 ( 0.01%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,611x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    13,038 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<T as alloc::vec::spec_from_elem::SpecFromElem>::from_elem

    13,030 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state

    12,978 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/api.rs:regex_automata::util::prefilter::teddy::Teddy::new
   634,469 ( 0.19%)   3,133 ( 0.39%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/pattern.rs:aho_corasick::packed::pattern::Patterns::add (1,394x) [./target/valgrind/s4]

    12,904 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_automata::nfa::thompson::builder::Builder::build

    12,814 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_group

    25,596 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::new (162x) [./target/valgrind/s4]
     2,054 ( 0.00%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::new (13x) [./target/valgrind/s4]
    12,775 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Builder::configure [./target/valgrind/s4]

    12,584 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    12,572 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name
    32,843 ( 0.01%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (1,453x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    12,552 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop

    12,514 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile
   132,201 ( 0.04%)     845 ( 0.10%)   .              .           >   ???:__rust_alloc (773x) [./target/valgrind/s4]
    92,040 ( 0.03%)      47 ( 0.01%)   .              .           >   ???:__rust_dealloc (947x) [./target/valgrind/s4]

    12,460 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple
   830,539 ( 0.25%)   2,240 ( 0.28%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple (1,120x) [./target/valgrind/s4]
    56,520 ( 0.02%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,120x) [./target/valgrind/s4]

    12,396 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded

    12,375 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:regex_syntax::ast::parse::ParserI<P>::parse_group

    12,354 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/state.rs:regex_automata::util::determinize::add_nfa_states

   157,920 ( 0.05%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_post (1,120x) [./target/valgrind/s4]
    12,320 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::SimpleCaseFolder::overlaps [./target/valgrind/s4]

    12,312 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::meta::wrappers::Hybrid::new
     4,860 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (162x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    12,288 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs:aho_corasick::util::prefilter::Builder::build

    12,281 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa
     1,652 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (96x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    12,275 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::Hir::alternation
    31,530 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,216x) [./target/valgrind/s4]

    12,261 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T,A> as core::clone::Clone>::clone

    12,204 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::hir::Properties::repetition
   454,807 ( 0.14%)   3,688 ( 0.46%)   .              .           >   ???:__rust_alloc (2,034x) [./target/valgrind/s4]

    12,185 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::hybrid::dfa::Builder::build_from_nfa

    12,066 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:regex_automata::dfa::remapper::onepass::<impl regex_automata::dfa::remapper::Remappable for regex_automata::dfa::onepass::DFA>::remap

    12,030 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_syntax::hir::Properties::repetition

   102,562 ( 0.03%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/remapper.rs:regex_automata::dfa::remapper::Remapper::remap (1x) [./target/valgrind/s4]
    12,009 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/remapper.rs:regex_automata::dfa::remapper::onepass::<impl regex_automata::dfa::remapper::Remappable for regex_automata::dfa::onepass::DFA>::remap [./target/valgrind/s4]

    11,962 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::pop_group
    94,317 ( 0.03%)      29 ( 0.00%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast> (693x) [./target/valgrind/s4]

    11,961 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,alloc::vec::into_iter::IntoIter<T>>>::from_iter

    11,961 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,alloc::vec::into_iter::IntoIter<T>>>::from_iter

    11,961 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,alloc::vec::into_iter::IntoIter<T>>>::from_iter

    74,469 ( 0.02%)     557 ( 0.07%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::util::captures::GroupInfo::new (243x)
    73,865 ( 0.02%)     577 ( 0.07%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:aho_corasick::nfa::noncontiguous::Builder::build (211x)
       607 ( 0.00%)       4 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::dfa::onepass::Builder::build_from_nfa (2x)
    11,924 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::shrink_to_fit [./target/valgrind/s4]

    11,900 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/unicode.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple

    11,842 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize

    11,632 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:regex_syntax::hir::ClassUnicode::literal

    11,373 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state
    43,003 ( 0.01%)     167 ( 0.02%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (154x) [./target/valgrind/s4]

    11,337 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile

    11,334 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new
    68,836 ( 0.02%)     174 ( 0.02%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (406x) [./target/valgrind/s4]
    10,194 ( 0.00%)       .            .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_elem.rs:<T as alloc::vec::spec_from_elem::SpecFromElem>::from_elem (57x) [./target/valgrind/s4]

    11,331 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:alloc::vec::Vec<T,A>::retain_mut

    11,296 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open
   170,430 ( 0.05%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    11,296 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open

    11,249 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/lib.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape

    11,235 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state

    11,152 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert
    30,464 ( 0.01%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (1,394x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    11,088 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2

    33,120 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie (3,680x) [./target/valgrind/s4]
    11,040 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::iter_trans [./target/valgrind/s4]

    11,040 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:aho_corasick::nfa::noncontiguous::NFA::iter_trans

    11,012 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre

    11,006 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:hashbrown::raw::RawTable<T,A>::reserve_rehash
     3,873 ( 0.00%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (347x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

    37,576 ( 0.01%)      52 ( 0.01%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x) [./target/valgrind/s4]
    25,186 ( 0.01%)       2 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::next (218x) [./target/valgrind/s4]
    11,000 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::add_nfa_states [./target/valgrind/s4]

    10,825 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:regex_syntax::hir::literal::Extractor::cross

    10,662 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new

    10,660 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2

    10,636 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:<regex_syntax::ast::Ast as core::ops::drop::Drop>::drop

 2,474,378 ( 0.74%)   7,953 ( 0.98%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::extract (193x) [./target/valgrind/s4]
    10,623 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten [./target/valgrind/s4]
 1,596,896 ( 0.48%)   7,217 ( 0.89%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (1,589x) [./target/valgrind/s4]
   591,079 ( 0.18%)     248 ( 0.03%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (55x) [./target/valgrind/s4]
    45,502 ( 0.01%)      76 ( 0.01%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (29x) [./target/valgrind/s4]
    10,981 ( 0.00%)      38 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Repetition::with (75x) [./target/valgrind/s4]

    10,601 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:regex_syntax::hir::literal::Extractor::cross

    10,545 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_syntax::hir::literal::Extractor::extract

    10,530 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle

    10,496 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state

    10,496 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state

89,137,842 (26.76%) 225,040 (27.80%)  85 (28.24%)     1 ( 0.07%)  < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::meta::strategy::new (175x)
    10,495 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::compile [./target/valgrind/s4]
70,331,959 (21.12%) 191,122 (23.61%)  78 (25.91%)     1 ( 0.07%)  >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (350x) [./target/valgrind/s4]
18,604,395 ( 5.59%)  33,833 ( 4.18%)   7 ( 2.33%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build (175x) [./target/valgrind/s4]
    84,121 ( 0.03%)       2 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (110x) [./target/valgrind/s4]
    34,274 ( 0.01%)      38 ( 0.00%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::dot (110x) [./target/valgrind/s4]
    27,590 ( 0.01%)       1 ( 0.00%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (110x) [./target/valgrind/s4]
     7,555 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (175x) [./target/valgrind/s4]
     5,600 ( 0.00%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::clear (175x) [./target/valgrind/s4]

    10,484 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop

    10,450 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:regex_automata::meta::reverse_inner::flatten'2
    35,609 ( 0.01%)       .            .              .           >   ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,071x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

 1,164,077 ( 0.35%)     764 ( 0.09%)   2 ( 0.66%)     .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (142x) [./target/valgrind/s4]
    84,121 ( 0.03%)       2 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::compile (110x) [./target/valgrind/s4]
    10,438 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least [./target/valgrind/s4]
 1,093,997 ( 0.33%)     548 ( 0.07%)   2 ( 0.66%)     .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (142x) [./target/valgrind/s4]
    75,449 ( 0.02%)     218 ( 0.03%)   .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (504x) [./target/valgrind/s4]
    29,920 ( 0.01%)       .            .              .           >   /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (110x) [./target/valgrind/s4]

    10,426 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_syntax::hir::literal::Extractor::extract'2

    10,403 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post

    10,395 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:regex_syntax::hir::Properties::capture

    10,392 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::vec::Vec<T,A>::retain_mut

    10,388 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<regex_syntax::ast::ClassSet as core::ops::drop::Drop>::drop
   424,499 ( 0.13%)   1,048 ( 0.13%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (525x) [./target/valgrind/s4]

    10,311 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:aho_corasick::nfa::noncontiguous::Compiler::densify

    10,272 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push

    10,245 ( 0.00%)       .            .              .           *  /rust/deps/hashbrown-0.15.2/src/control/bitmask.rs:hashbrown::map::HashMap<K,V,S,A>::insert

    10,165 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile

    10,096 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/take.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new

    10,080 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/convert.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple

    36,676 ( 0.01%)      14 ( 0.00%)   .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x) [./target/valgrind/s4]
    28,735 ( 0.01%)       .            .              .           < /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::next (194x) [./target/valgrind/s4]
    10,067 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::epsilon_closure [./target/valgrind/s4]

    10,064 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/sparse_set.rs:regex_automata::util::determinize::state::Repr::iter_nfa_state_ids

     9,962 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name

     9,954 ( 0.00%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/str/validations.rs:core::str::count::char_count_general_case

     9,916 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions

     9,888 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs:regex_syntax::hir::ClassUnicode::literal

     9,880 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

     9,880 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend

    39,175 ( 0.01%)       .            .              .           < ./malloc/./malloc/malloc.c:_mid_memalign.isra.0 (85x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     9,877 ( 0.00%)       .            .              .           *  ./malloc/./malloc/malloc.c:_int_memalign [/usr/lib/x86_64-linux-gnu/libc.so.6]
    20,693 ( 0.01%)       .            .              .           >   ./malloc/./malloc/malloc.c:_int_malloc (85x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     5,251 ( 0.00%)       .            .              .           >   ./malloc/./malloc/malloc.c:_int_free_merge_chunk (61x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     2,052 ( 0.00%)       .            .              .           >   ./malloc/./malloc/malloc.c:_int_free_maybe_consolidate (85x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
     1,302 ( 0.00%)       .            .              .           >   ./malloc/./malloc/malloc.c:unlink_chunk.isra.0 (61x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

     9,856 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push

     9,834 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:hashbrown::map::HashMap<K,V,S,A>::insert

     9,804 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::nfa::noncontiguous::NFA::add_match
    87,272 ( 0.03%)     300 ( 0.04%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (144x) [./target/valgrind/s4]

     9,770 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post

     9,768 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter

     9,758 ( 0.00%)       .            .              .           *  /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs:aho_corasick::nfa::noncontiguous::NFA::add_match

     9,758 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:aho_corasick::packed::pattern::Patterns::add

     9,702 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:regex_syntax::ast::parse::ParserI<P>::pop_group
   118,560 ( 0.04%)     314 ( 0.04%)   .              .           >   ???:__rust_alloc (1,386x) [./target/valgrind/s4]
    69,773 ( 0.02%)      68 ( 0.01%)   .              .           >   ???:__rust_dealloc (693x) [./target/valgrind/s4]

     9,682 ( 0.00%)       .            .              .           *  ./malloc/./malloc/malloc.c:__malloc_arena_thread_freeres
    49,057 ( 0.01%)     696 ( 0.09%)   .              .           >   ./malloc/./malloc/malloc.c:_int_free (369x) [/usr/lib/x86_64-linux-gnu/libc.so.6]
       179 ( 0.00%)       2 ( 0.00%)   .              .           >   ./malloc/./malloc/malloc.c:free (1x) [/usr/lib/x86_64-linux-gnu/libc.so.6]

     9,660 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend
   471,526 ( 0.14%)   1,256 ( 0.16%)   .              .           >   /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (450x) [./target/valgrind/s4]

   172,581 ( 0.05%)     544 ( 0.07%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:aho_corasick::packed::pattern::Patterns::add (180x)
    16,274 ( 0.00%)      54 ( 0.01%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_automata::util::determinize::add_nfa_states (62x)
     9,750 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (78x)
     6,122 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::parser::matches::matched_arg::MatchedArg::append_val (22x)
     1,471 ( 0.00%)       4 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::Hir::alternation (9x)
       832 ( 0.00%)       2 ( 0.00%)   .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::string::String as core::fmt::Write>::write_char (2x)
       547 ( 0.00%)       .            .              .           < /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:clap_builder::parser::parser::Parser::get_matches_with (3x)
     9,652 ( 0.00%)       .            .              .           *  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one [./target/valgrind/s4]
   191,091 ( 0.06%)     604 ( 0.07%)   .              .           >   /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/raw_vec.rs:alloc::raw_vec::finish_grow (356x) [./target/valgrind/s4]

     9,637 ( 0.00%)       .            .              .           *  /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 36 ----------------------------------------
      .          .          .          .                       utf8: true,
      .          .          .          .                       line_terminator: b'\n',
      .          .          .          .                       flags: Flags::default(),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Build a translator using the current configuration.
      .          .          .          .               pub fn build(&self) -> Translator {
    648 ( 0.00%) .          .          .                   Translator {
      .          .          .          .                       stack: RefCell::new(vec![]),
    324 ( 0.00%) .          .          .                       flags: Cell::new(self.flags),
      .          .          .          .                       utf8: self.utf8,
      .          .          .          .                       line_terminator: self.line_terminator,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// When disabled, translation will permit the construction of a regular
      .          .          .          .               /// expression that may match invalid UTF-8.
      .          .          .          .               ///
-- line 54 ----------------------------------------
-- line 60 ----------------------------------------
      .          .          .          .               /// Perhaps surprisingly, when UTF-8 is enabled, an empty regex or even
      .          .          .          .               /// a negated ASCII word boundary (uttered as `(?-u:\B)` in the concrete
      .          .          .          .               /// syntax) will be allowed even though they can produce matches that split
      .          .          .          .               /// a UTF-8 encoded codepoint. This only applies to zero-width or "empty"
      .          .          .          .               /// matches, and it is expected that the regex engine itself must handle
      .          .          .          .               /// these cases if necessary (perhaps by suppressing any zero-width matches
      .          .          .          .               /// that split a codepoint).
      .          .          .          .               pub fn utf8(&mut self, yes: bool) -> &mut TranslatorBuilder {
     81 ( 0.00%) .          .          .                   self.utf8 = yes;
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets the line terminator for use with `(?u-s:.)` and `(?-us:.)`.
      .          .          .          .               ///
      .          .          .          .               /// Namely, instead of `.` (by default) matching everything except for `\n`,
      .          .          .          .               /// this will cause `.` to match everything except for the byte given.
      .          .          .          .               ///
-- line 76 ----------------------------------------
-- line 85 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// Note that if `R` mode is enabled then it always takes precedence and
      .          .          .          .               /// the line terminator will be treated as `\r` and `\n` simultaneously.
      .          .          .          .               ///
      .          .          .          .               /// Note also that this *doesn't* impact the look-around assertions
      .          .          .          .               /// `(?m:^)` and `(?m:$)`. That's usually controlled by additional
      .          .          .          .               /// configuration in the regex engine itself.
      .          .          .          .               pub fn line_terminator(&mut self, byte: u8) -> &mut TranslatorBuilder {
     81 ( 0.00%) .          .          .                   self.line_terminator = byte;
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable or disable the case insensitive flag (`i`) by default.
      .          .          .          .               pub fn case_insensitive(&mut self, yes: bool) -> &mut TranslatorBuilder {
    243 ( 0.00%) .          .          .                   self.flags.case_insensitive = if yes { Some(true) } else { None };
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable or disable the multi-line matching flag (`m`) by default.
      .          .          .          .               pub fn multi_line(&mut self, yes: bool) -> &mut TranslatorBuilder {
    243 ( 0.00%) .          .          .                   self.flags.multi_line = if yes { Some(true) } else { None };
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable or disable the "dot matches any character" flag (`s`) by
      .          .          .          .               /// default.
      .          .          .          .               pub fn dot_matches_new_line(
      .          .          .          .                   &mut self,
      .          .          .          .                   yes: bool,
      .          .          .          .               ) -> &mut TranslatorBuilder {
    243 ( 0.00%) .          .          .                   self.flags.dot_matches_new_line = if yes { Some(true) } else { None };
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable or disable the CRLF mode flag (`R`) by default.
      .          .          .          .               pub fn crlf(&mut self, yes: bool) -> &mut TranslatorBuilder {
    243 ( 0.00%) .          .          .                   self.flags.crlf = if yes { Some(true) } else { None };
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable or disable the "swap greed" flag (`U`) by default.
      .          .          .          .               pub fn swap_greed(&mut self, yes: bool) -> &mut TranslatorBuilder {
    162 ( 0.00%) .          .          .                   self.flags.swap_greed = if yes { Some(true) } else { None };
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable or disable the Unicode flag (`u`) by default.
      .          .          .          .               pub fn unicode(&mut self, yes: bool) -> &mut TranslatorBuilder {
    243 ( 0.00%) .          .          .                   self.flags.unicode = if yes { None } else { Some(false) };
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A translator maps abstract syntax to a high level intermediate
      .          .          .          .           /// representation.
      .          .          .          .           ///
      .          .          .          .           /// A translator may be benefit from reuse. That is, a translator can translate
-- line 141 ----------------------------------------
-- line 165 ----------------------------------------
      .          .          .          .               /// intermediate representation (HIR).
      .          .          .          .               ///
      .          .          .          .               /// If there was a problem doing the translation, then an HIR-specific
      .          .          .          .               /// error is returned.
      .          .          .          .               ///
      .          .          .          .               /// The original pattern string used to produce the `Ast` *must* also be
      .          .          .          .               /// provided. The translator does not use the pattern string during any
      .          .          .          .               /// correct translation, but is used for error reporting.
    243 ( 0.00%) .          .          .               pub fn translate(&mut self, pattern: &str, ast: &Ast) -> Result<Hir> {
    162 ( 0.00%) .          .          .                   ast::visit(ast, TranslatorI::new(self, pattern))
71,272,262 (21.40%) 151,036 (18.66%) 23 ( 7.64%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (81x)
    324 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// An HirFrame is a single stack frame, represented explicitly, which is
      .          .          .          .           /// created for each item in the Ast that we traverse.
      .          .          .          .           ///
      .          .          .          .           /// Note that technically, this type doesn't represent our entire stack
      .          .          .          .           /// frame. In particular, the Ast visitor represents any state associated with
      .          .          .          .           /// traversing the Ast itself.
-- line 183 ----------------------------------------
-- line 245 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// It is popped after each expression in a branch until an 'Alternation'
      .          .          .          .               /// frame is observed when doing a post visit on an alternation.
      .          .          .          .               AlternationBranch,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl HirFrame {
      .          .          .          .               /// Assert that the current stack frame is an Hir expression and return it.
 21,272 ( 0.01%) .          .          .               fn unwrap_expr(self) -> Hir {
 18,613 ( 0.01%) .          .          .                   match self {
 15,954 ( 0.00%) .          .          .                       HirFrame::Expr(expr) => expr,
      .          .          .          .                       HirFrame::Literal(lit) => Hir::literal(lit),
      .          .          .          .                       _ => panic!("tried to unwrap expr from HirFrame, got: {:?}", self),
      .          .          .          .                   }
 23,931 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Assert that the current stack frame is a Unicode class expression and
      .          .          .          .               /// return it.
      .          .          .          .               fn unwrap_class_unicode(self) -> hir::ClassUnicode {
 14,430 ( 0.00%) .          .          .                   match self {
 28,860 ( 0.01%) .          .          .                       HirFrame::ClassUnicode(cls) => cls,
      .          .          .          .                       _ => panic!(
      .          .          .          .                           "tried to unwrap Unicode class \
      .          .          .          .                            from HirFrame, got: {:?}",
      .          .          .          .                           self
      .          .          .          .                       ),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
-- line 273 ----------------------------------------
-- line 282 ----------------------------------------
      .          .          .          .                           self
      .          .          .          .                       ),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Assert that the current stack frame is a repetition sentinel. If it
      .          .          .          .               /// isn't, then panic.
      .          .          .          .               fn unwrap_repetition(self) {
  3,770 ( 0.00%) .          .          .                   match self {
      .          .          .          .                       HirFrame::Repetition => {}
      .          .          .          .                       _ => {
      .          .          .          .                           panic!(
      .          .          .          .                               "tried to unwrap repetition from HirFrame, got: {:?}",
      .          .          .          .                               self
      .          .          .          .                           )
      .          .          .          .                       }
      .          .          .          .                   }
  1,885 ( 0.00%) .          .          .               }
 16,965 ( 0.01%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> (1,885x)
      .          .          .          .           
      .          .          .          .               /// Assert that the current stack frame is a group indicator and return
      .          .          .          .               /// its corresponding flags (the flags that were active at the time the
      .          .          .          .               /// group was entered).
      .          .          .          .               fn unwrap_group(self) -> Flags {
  1,386 ( 0.00%) .          .          .                   match self {
  2,079 ( 0.00%) .          .          .                       HirFrame::Group { old_flags } => old_flags,
      .          .          .          .                       _ => {
      .          .          .          .                           panic!("tried to unwrap group from HirFrame, got: {:?}", self)
      .          .          .          .                       }
      .          .          .          .                   }
    693 ( 0.00%) .          .          .               }
  6,237 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> (693x)
      .          .          .          .           
      .          .          .          .               /// Assert that the current stack frame is an alternation pipe sentinel. If
      .          .          .          .               /// it isn't, then panic.
      .          .          .          .               fn unwrap_alternation_pipe(self) {
 32,882 ( 0.01%) .          .          .                   match self {
      .          .          .          .                       HirFrame::AlternationBranch => {}
      .          .          .          .                       _ => {
      .          .          .          .                           panic!(
      .          .          .          .                               "tried to unwrap alt pipe from HirFrame, got: {:?}",
      .          .          .          .                               self
      .          .          .          .                           )
      .          .          .          .                       }
      .          .          .          .                   }
 32,882 ( 0.01%) .          .          .               }
147,969 ( 0.04%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> (16,441x)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'t, 'p> Visitor for TranslatorI<'t, 'p> {
      .          .          .          .               type Output = Hir;
      .          .          .          .               type Err = Error;
      .          .          .          .           
    324 ( 0.00%) .          .          .               fn finish(self) -> Result<Hir> {
      .          .          .          .                   // ... otherwise, we should have exactly one HIR on the stack.
    162 ( 0.00%) .          .          .                   assert_eq!(self.trans().stack.borrow().len(), 1);
    405 ( 0.00%) .          .          .                   Ok(self.pop().unwrap().unwrap_expr())
  2,511 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::HirFrame::unwrap_expr (81x)
    405 ( 0.00%) .          .          .               }
      .          .          .          .           
641,304 ( 0.19%) .          .          .               fn visit_pre(&mut self, ast: &Ast) -> Result<()> {
349,911 ( 0.11%) .          .          .                   match *ast {
      .          .          .          .                       Ast::ClassBracketed(_) => {
      .          .          .          .                           if self.flags().unicode() {
      .          .          .          .                               let cls = hir::ClassUnicode::empty();
      .          .          .          .                               self.push(HirFrame::ClassUnicode(cls));
      .          .          .          .                           } else {
      .          .          .          .                               let cls = hir::ClassBytes::empty();
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls));
      .          .          .          .                           }
      .          .          .          .                       }
  1,885 ( 0.00%) .          .          .                       Ast::Repetition(_) => self.push(HirFrame::Repetition),
      .          .          .          .                       Ast::Group(ref x) => {
    693 ( 0.00%) .          .          .                           let old_flags = x
      .          .          .          .                               .flags()
      .          .          .          .                               .map(|ast| self.set_flags(ast))
      .          .          .          .                               .unwrap_or_else(|| self.flags());
      .          .          .          .                           self.push(HirFrame::Group { old_flags });
      .          .          .          .                       }
      .          .          .          .                       Ast::Concat(_) => {
 15,786 ( 0.00%) .          .          .                           self.push(HirFrame::Concat);
      .          .          .          .                       }
      .          .          .          .                       Ast::Alternation(ref x) => {
    512 ( 0.00%) .          .          .                           self.push(HirFrame::Alternation);
  2,048 ( 0.00%) .          .          .                           if !x.asts.is_empty() {
      .          .          .          .                               self.push(HirFrame::AlternationBranch);
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       _ => {}
      .          .          .          .                   }
 71,256 ( 0.02%) .          .          .                   Ok(())
641,304 ( 0.19%) .          .          .               }
      .          .          .          .           
641,304 ( 0.19%) .          .          .               fn visit_post(&mut self, ast: &Ast) -> Result<()> {
356,280 ( 0.11%) .          .          .                   match *ast {
      .          .          .          .                       Ast::Empty(_) => {
      .          .          .          .                           self.push(HirFrame::Expr(Hir::empty()));
      .          .          .          .                       }
      .          .          .          .                       Ast::Flags(ref x) => {
    120 ( 0.00%) .          .          .                           self.set_flags(&x.flags);
  1,950 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::TranslatorI::set_flags (20x)
      .          .          .          .                           // Flags in the AST are generally considered directives and
      .          .          .          .                           // not actual sub-expressions. However, they can be used in
      .          .          .          .                           // the concrete syntax like `((?i))`, and we need some kind of
      .          .          .          .                           // indication of an expression there, and Empty is the correct
      .          .          .          .                           // choice.
      .          .          .          .                           //
      .          .          .          .                           // There can also be things like `(?i)+`, but we rule those out
      .          .          .          .                           // in the parser. In the future, we might allow them for
      .          .          .          .                           // consistency sake.
      .          .          .          .                           self.push(HirFrame::Expr(Hir::empty()));
      .          .          .          .                       }
148,440 ( 0.04%) .          .          .                       Ast::Literal(ref x) => match self.ast_literal_to_scalar(x)? {
      .          .          .          .                           Either::Right(byte) => self.push_byte(byte),
395,840 ( 0.12%) .          .          .                           Either::Left(ch) => match self.case_fold_char(x.span, ch)? {
      .          .          .          .                               None => self.push_char(ch),
      .          .          .          .                               Some(expr) => self.push(HirFrame::Expr(expr)),
      .          .          .          .                           },
      .          .          .          .                       },
      .          .          .          .                       Ast::Dot(ref span) => {
     35 ( 0.00%) .          .          .                           self.push(HirFrame::Expr(self.hir_dot(**span)?));
      .          .          .          .                       }
      .          .          .          .                       Ast::Assertion(ref x) => {
    366 ( 0.00%) .          .          .                           self.push(HirFrame::Expr(self.hir_assertion(x)?));
      .          .          .          .                       }
      .          .          .          .                       Ast::ClassPerl(ref x) => {
      .          .          .          .                           if self.flags().unicode() {
      .          .          .          .                               let cls = self.hir_perl_unicode_class(x)?;
      .          .          .          .                               let hcls = hir::Class::Unicode(cls);
      .          .          .          .                               self.push(HirFrame::Expr(Hir::class(hcls)));
      .          .          .          .                           } else {
      .          .          .          .                               let cls = self.hir_perl_byte_class(x)?;
-- line 408 ----------------------------------------
-- line 411 ----------------------------------------
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       Ast::ClassUnicode(ref x) => {
      .          .          .          .                           let cls = hir::Class::Unicode(self.hir_unicode_class(x)?);
      .          .          .          .                           self.push(HirFrame::Expr(Hir::class(cls)));
      .          .          .          .                       }
      .          .          .          .                       Ast::ClassBracketed(ref ast) => {
      .          .          .          .                           if self.flags().unicode() {
  2,753 ( 0.00%) .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_unicode();
      .          .          .          .                               self.unicode_fold_and_negate(
  2,753 ( 0.00%) .          .          .                                   &ast.span,
  2,753 ( 0.00%) .          .          .                                   ast.negated,
      .          .          .          .                                   &mut cls,
      .          .          .          .                               )?;
 19,271 ( 0.01%) .          .          .                               let expr = Hir::class(hir::Class::Unicode(cls));
      .          .          .          .                               self.push(HirFrame::Expr(expr));
      .          .          .          .                           } else {
      .          .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_bytes();
      .          .          .          .                               self.bytes_fold_and_negate(
      .          .          .          .                                   &ast.span,
      .          .          .          .                                   ast.negated,
      .          .          .          .                                   &mut cls,
      .          .          .          .                               )?;
      .          .          .          .                               let expr = Hir::class(hir::Class::Bytes(cls));
      .          .          .          .                               self.push(HirFrame::Expr(expr));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       Ast::Repetition(ref x) => {
  3,770 ( 0.00%) .          .          .                           let expr = self.pop().unwrap().unwrap_expr();
 58,435 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::HirFrame::unwrap_expr (1,885x)
      .          .          .          .                           self.pop().unwrap().unwrap_repetition();
  1,885 ( 0.00%) .          .          .                           self.push(HirFrame::Expr(self.hir_repetition(x, expr)));
      .          .          .          .                       }
      .          .          .          .                       Ast::Group(ref x) => {
  1,386 ( 0.00%) .          .          .                           let expr = self.pop().unwrap().unwrap_expr();
 21,483 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::HirFrame::unwrap_expr (693x)
      .          .          .          .                           let old_flags = self.pop().unwrap().unwrap_group();
      .          .          .          .                           self.trans().flags.set(old_flags);
    693 ( 0.00%) .          .          .                           self.push(HirFrame::Expr(self.hir_capture(x, expr)));
      .          .          .          .                       }
      .          .          .          .                       Ast::Concat(_) => {
      .          .          .          .                           let mut exprs = vec![];
210,600 ( 0.06%) .          .          .                           while let Some(expr) = self.pop_concat_expr() {
 39,784 ( 0.01%) .          .          .                               if !matches!(*expr.kind(), HirKind::Empty) {
238,464 ( 0.07%) .          .          .                                   exprs.push(expr);
      .          .          .          .                               }
     40 ( 0.00%) .          .          .                           }
  2,888 ( 0.00%) 1 ( 0.00%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (20x)
  1,925 ( 0.00%) .          .          .                           exprs.reverse();
110,502 ( 0.03%) .          .          .                           self.push(HirFrame::Expr(Hir::concat(exprs)));
24,333,545 ( 7.31%) 51,060 ( 6.31%) 2 ( 0.66%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (15,786x)
      .          .          .          .                       }
      .          .          .          .                       Ast::Alternation(_) => {
      .          .          .          .                           let mut exprs = vec![];
 33,906 ( 0.01%) .          .          .                           while let Some(expr) = self.pop_alt_expr() {
      .          .          .          .                               self.pop().unwrap().unwrap_alternation_pipe();
      .          .          .          .                               exprs.push(expr);
      .          .          .          .                           }
    512 ( 0.00%) .          .          .                           exprs.reverse();
  3,584 ( 0.00%) .          .          .                           self.push(HirFrame::Expr(Hir::alternation(exprs)));
6,555,178 ( 1.97%) 2,505 ( 0.31%) 4 ( 1.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (512x)
      .          .          .          .                       }
      .          .          .          .                   }
 73,834 ( 0.02%) .          .          .                   Ok(())
662,387 ( 0.20%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn visit_alternation_in(&mut self) -> Result<()> {
 15,929 ( 0.00%) .          .          .                   self.push(HirFrame::AlternationBranch);
      .          .          .          .                   Ok(())
      .          .          .          .               }
      .          .          .          .           
 24,580 ( 0.01%) .          .          .               fn visit_class_set_item_pre(
      .          .          .          .                   &mut self,
      .          .          .          .                   ast: &ast::ClassSetItem,
      .          .          .          .               ) -> Result<()> {
  9,832 ( 0.00%) .          .          .                   match *ast {
      .          .          .          .                       ast::ClassSetItem::Bracketed(_) => {
      .          .          .          .                           if self.flags().unicode() {
      .          .          .          .                               let cls = hir::ClassUnicode::empty();
      .          .          .          .                               self.push(HirFrame::ClassUnicode(cls));
      .          .          .          .                           } else {
      .          .          .          .                               let cls = hir::ClassBytes::empty();
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       // We needn't handle the Union case here since the visitor will
      .          .          .          .                       // do it for us.
      .          .          .          .                       _ => {}
      .          .          .          .                   }
  4,916 ( 0.00%) .          .          .                   Ok(())
 29,496 ( 0.01%) .          .          .               }
      .          .          .          .           
 39,328 ( 0.01%) .          .          .               fn visit_class_set_item_post(
      .          .          .          .                   &mut self,
      .          .          .          .                   ast: &ast::ClassSetItem,
      .          .          .          .               ) -> Result<()> {
 49,160 ( 0.01%) .          .          .                   match *ast {
      .          .          .          .                       ast::ClassSetItem::Empty(_) => {}
      .          .          .          .                       ast::ClassSetItem::Literal(ref x) => {
      .          .          .          .                           if self.flags().unicode() {
  3,545 ( 0.00%) .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_unicode();
  3,545 ( 0.00%) .          .          .                               cls.push(hir::ClassUnicodeRange::new(x.c, x.c));
 42,540 ( 0.01%) .          .          .                               self.push(HirFrame::ClassUnicode(cls));
      .          .          .          .                           } else {
      .          .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_bytes();
      .          .          .          .                               let byte = self.class_literal_byte(x)?;
      .          .          .          .                               cls.push(hir::ClassBytesRange::new(byte, byte));
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       ast::ClassSetItem::Range(ref x) => {
-- line 516 ----------------------------------------
-- line 524 ----------------------------------------
      .          .          .          .                               let end = self.class_literal_byte(&x.end)?;
      .          .          .          .                               cls.push(hir::ClassBytesRange::new(start, end));
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       ast::ClassSetItem::Ascii(ref x) => {
      .          .          .          .                           if self.flags().unicode() {
      .          .          .          .                               let xcls = self.hir_ascii_unicode_class(x)?;
    770 ( 0.00%) .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_unicode();
      .          .          .          .                               cls.union(&xcls);
      .          .          .          .                               self.push(HirFrame::ClassUnicode(cls));
      .          .          .          .                           } else {
      .          .          .          .                               let xcls = self.hir_ascii_byte_class(x)?;
      .          .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_bytes();
      .          .          .          .                               cls.union(&xcls);
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls));
      .          .          .          .                           }
-- line 540 ----------------------------------------
-- line 542 ----------------------------------------
      .          .          .          .                       ast::ClassSetItem::Unicode(ref x) => {
      .          .          .          .                           let xcls = self.hir_unicode_class(x)?;
      .          .          .          .                           let mut cls = self.pop().unwrap().unwrap_class_unicode();
      .          .          .          .                           cls.union(&xcls);
      .          .          .          .                           self.push(HirFrame::ClassUnicode(cls));
      .          .          .          .                       }
      .          .          .          .                       ast::ClassSetItem::Perl(ref x) => {
      .          .          .          .                           if self.flags().unicode() {
      5 ( 0.00%) .          .          .                               let xcls = self.hir_perl_unicode_class(x)?;
 14,348 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::TranslatorI::hir_perl_unicode_class (5x)
      5 ( 0.00%) .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_unicode();
      .          .          .          .                               cls.union(&xcls);
     60 ( 0.00%) .          .          .                               self.push(HirFrame::ClassUnicode(cls));
      .          .          .          .                           } else {
      .          .          .          .                               let xcls = self.hir_perl_byte_class(x)?;
      .          .          .          .                               let mut cls = self.pop().unwrap().unwrap_class_bytes();
      .          .          .          .                               cls.union(&xcls);
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       ast::ClassSetItem::Bracketed(ref ast) => {
      .          .          .          .                           if self.flags().unicode() {
     71 ( 0.00%) .          .          .                               let mut cls1 = self.pop().unwrap().unwrap_class_unicode();
      .          .          .          .                               self.unicode_fold_and_negate(
     71 ( 0.00%) .          .          .                                   &ast.span,
     71 ( 0.00%) .          .          .                                   ast.negated,
      .          .          .          .                                   &mut cls1,
      .          .          .          .                               )?;
      .          .          .          .           
      .          .          .          .                               let mut cls2 = self.pop().unwrap().unwrap_class_unicode();
      .          .          .          .                               cls2.union(&cls1);
    852 ( 0.00%) .          .          .                               self.push(HirFrame::ClassUnicode(cls2));
      .          .          .          .                           } else {
      .          .          .          .                               let mut cls1 = self.pop().unwrap().unwrap_class_bytes();
      .          .          .          .                               self.bytes_fold_and_negate(
      .          .          .          .                                   &ast.span,
      .          .          .          .                                   ast.negated,
      .          .          .          .                                   &mut cls1,
      .          .          .          .                               )?;
      .          .          .          .           
-- line 580 ----------------------------------------
-- line 581 ----------------------------------------
      .          .          .          .                               let mut cls2 = self.pop().unwrap().unwrap_class_bytes();
      .          .          .          .                               cls2.union(&cls1);
      .          .          .          .                               self.push(HirFrame::ClassBytes(cls2));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       // This is handled automatically by the visitor.
      .          .          .          .                       ast::ClassSetItem::Union(_) => {}
      .          .          .          .                   }
  8,461 ( 0.00%) .          .          .                   Ok(())
 44,244 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn visit_class_set_binary_op_pre(
      .          .          .          .                   &mut self,
      .          .          .          .                   _op: &ast::ClassSetBinaryOp,
      .          .          .          .               ) -> Result<()> {
      .          .          .          .                   if self.flags().unicode() {
      .          .          .          .                       let cls = hir::ClassUnicode::empty();
      .          .          .          .                       self.push(HirFrame::ClassUnicode(cls));
-- line 598 ----------------------------------------
-- line 678 ----------------------------------------
      .          .          .          .           struct TranslatorI<'t, 'p> {
      .          .          .          .               trans: &'t Translator,
      .          .          .          .               pattern: &'p str,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'t, 'p> TranslatorI<'t, 'p> {
      .          .          .          .               /// Build a new internal translator.
      .          .          .          .               fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {
    324 ( 0.00%) .          .          .                   TranslatorI { trans, pattern }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return a reference to the underlying translator.
      .          .          .          .               fn trans(&self) -> &Translator {
 59,539 ( 0.02%) .          .          .                   &self.trans
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Push the given frame on to the call stack.
      .          .          .          .               fn push(&self, frame: HirFrame) {
    255 ( 0.00%) .          .          .                   self.trans().stack.borrow_mut().push(frame);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Push the given literal char on to the call stack.
      .          .          .          .               ///
      .          .          .          .               /// If the top-most element of the stack is a literal, then the char
      .          .          .          .               /// is appended to the end of that literal. Otherwise, a new literal
      .          .          .          .               /// containing just the given char is pushed to the top of the stack.
      .          .          .          .               fn push_char(&self, ch: char) {
 48,360 ( 0.01%) .          .          .                   let mut buf = [0; 4];
      .          .          .          .                   let bytes = ch.encode_utf8(&mut buf).as_bytes();
      .          .          .          .                   let mut stack = self.trans().stack.borrow_mut();
 96,720 ( 0.03%) .          .          .                   if let Some(HirFrame::Literal(ref mut literal)) = stack.last_mut() {
      .          .          .          .                       literal.extend_from_slice(bytes);
      .          .          .          .                   } else {
      .          .          .          .                       stack.push(HirFrame::Literal(bytes.to_vec()));
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Push the given literal byte on to the call stack.
      .          .          .          .               ///
-- line 716 ----------------------------------------
-- line 731 ----------------------------------------
      .          .          .          .                   self.trans().stack.borrow_mut().pop()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Pop an HIR expression from the top of the stack for a concatenation.
      .          .          .          .               ///
      .          .          .          .               /// This returns None if the stack is empty or when a concat frame is seen.
      .          .          .          .               /// Otherwise, it panics if it could not find an HIR expression.
      .          .          .          .               fn pop_concat_expr(&self) -> Option<Hir> {
 35,678 ( 0.01%) .          .          .                   let frame = self.pop()?;
321,102 ( 0.10%) .          .          .                   match frame {
      .          .          .          .                       HirFrame::Concat => None,
 31,962 ( 0.01%) .          .          .                       HirFrame::Expr(expr) => Some(expr),
 45,978 ( 0.01%) .          .          .                       HirFrame::Literal(lit) => Some(Hir::literal(lit)),
      .          .          .          .                       HirFrame::ClassUnicode(_) => {
      .          .          .          .                           unreachable!("expected expr or concat, got Unicode class")
      .          .          .          .                       }
      .          .          .          .                       HirFrame::ClassBytes(_) => {
      .          .          .          .                           unreachable!("expected expr or concat, got byte class")
      .          .          .          .                       }
      .          .          .          .                       HirFrame::Repetition => {
      .          .          .          .                           unreachable!("expected expr or concat, got repetition")
-- line 751 ----------------------------------------
-- line 755 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .                       HirFrame::Alternation => {
      .          .          .          .                           unreachable!("expected expr or concat, got alt marker")
      .          .          .          .                       }
      .          .          .          .                       HirFrame::AlternationBranch => {
      .          .          .          .                           unreachable!("expected expr or concat, got alt branch marker")
      .          .          .          .                       }
      .          .          .          .                   }
107,494 ( 0.03%) .          .          .               }
142,074 ( 0.04%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> (15,786x)
      .          .          .          .           
      .          .          .          .               /// Pop an HIR expression from the top of the stack for an alternation.
      .          .          .          .               ///
      .          .          .          .               /// This returns None if the stack is empty or when an alternation frame is
      .          .          .          .               /// seen. Otherwise, it panics if it could not find an HIR expression.
      .          .          .          .               fn pop_alt_expr(&self) -> Option<Hir> {
 16,953 ( 0.01%) .          .          .                   let frame = self.pop()?;
152,577 ( 0.05%) .          .          .                   match frame {
      .          .          .          .                       HirFrame::Alternation => None,
109,697 ( 0.03%) .          .          .                       HirFrame::Expr(expr) => Some(expr),
  2,310 ( 0.00%) .          .          .                       HirFrame::Literal(lit) => Some(Hir::literal(lit)),
      .          .          .          .                       HirFrame::ClassUnicode(_) => {
      .          .          .          .                           unreachable!("expected expr or alt, got Unicode class")
      .          .          .          .                       }
      .          .          .          .                       HirFrame::ClassBytes(_) => {
      .          .          .          .                           unreachable!("expected expr or alt, got byte class")
      .          .          .          .                       }
      .          .          .          .                       HirFrame::Repetition => {
      .          .          .          .                           unreachable!("expected expr or alt, got repetition")
-- line 782 ----------------------------------------
-- line 786 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .                       HirFrame::Concat => {
      .          .          .          .                           unreachable!("expected expr or alt, got concat marker")
      .          .          .          .                       }
      .          .          .          .                       HirFrame::AlternationBranch => {
      .          .          .          .                           unreachable!("expected expr or alt, got alt branch marker")
      .          .          .          .                       }
      .          .          .          .                   }
 34,930 ( 0.01%) .          .          .               }
  4,608 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::translate::HirFrame> (512x)
      .          .          .          .           
      .          .          .          .               /// Create a new error with the given span and error type.
      .          .          .          .               fn error(&self, span: Span, kind: ErrorKind) -> Error {
      .          .          .          .                   Error { kind, pattern: self.pattern.to_string(), span }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return a copy of the active flags.
      .          .          .          .               fn flags(&self) -> Flags {
      .          .          .          .                   self.trans().flags.get()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the flags of this translator from the flags set in the given AST.
      .          .          .          .               /// Then, return the old flags.
    120 ( 0.00%) .          .          .               fn set_flags(&self, ast_flags: &ast::Flags) -> Flags {
      .          .          .          .                   let old_flags = self.flags();
      .          .          .          .                   let mut new_flags = Flags::from_ast(ast_flags);
      .          .          .          .                   new_flags.merge(&old_flags);
      .          .          .          .                   self.trans().flags.set(new_flags);
      .          .          .          .                   old_flags
    340 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Convert an Ast literal to its scalar representation.
      .          .          .          .               ///
      .          .          .          .               /// When Unicode mode is enabled, then this always succeeds and returns a
      .          .          .          .               /// `char` (Unicode scalar value).
      .          .          .          .               ///
      .          .          .          .               /// When Unicode mode is disabled, then a `char` will still be returned
      .          .          .          .               /// whenever possible. A byte is returned only when invalid UTF-8 is
      .          .          .          .               /// allowed and when the byte is not ASCII. Otherwise, a non-ASCII byte
      .          .          .          .               /// will result in an error when invalid UTF-8 is not allowed.
      .          .          .          .               fn ast_literal_to_scalar(
      .          .          .          .                   &self,
      .          .          .          .                   lit: &ast::Literal,
      .          .          .          .               ) -> Result<Either<char, u8>> {
      .          .          .          .                   if self.flags().unicode() {
 49,480 ( 0.01%) .          .          .                       return Ok(Either::Left(lit.c));
      .          .          .          .                   }
      .          .          .          .                   let byte = match lit.byte() {
      .          .          .          .                       None => return Ok(Either::Left(lit.c)),
      .          .          .          .                       Some(byte) => byte,
      .          .          .          .                   };
      .          .          .          .                   if byte <= 0x7F {
      .          .          .          .                       return Ok(Either::Left(char::try_from(byte).unwrap()));
      .          .          .          .                   }
      .          .          .          .                   if self.trans().utf8 {
      .          .          .          .                       return Err(self.error(lit.span, ErrorKind::InvalidUtf8));
      .          .          .          .                   }
      .          .          .          .                   Ok(Either::Right(byte))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn case_fold_char(&self, span: Span, c: char) -> Result<Option<Hir>> {
  2,340 ( 0.00%) .          .          .                   if !self.flags().case_insensitive() {
      .          .          .          .                       return Ok(None);
      .          .          .          .                   }
  1,120 ( 0.00%) .          .          .                   if self.flags().unicode() {
      .          .          .          .                       // If case folding won't do anything, then don't bother trying.
      .          .          .          .                       let map = unicode::SimpleCaseFolder::new()
  3,360 ( 0.00%) .          .          .                           .map(|f| f.overlaps(c, c))
157,920 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::SimpleCaseFolder::overlaps (1,120x)
      .          .          .          .                           .map_err(|_| {
      .          .          .          .                               self.error(span, ErrorKind::UnicodeCaseUnavailable)
      .          .          .          .                           })?;
  2,240 ( 0.00%) .          .          .                       if !map {
      .          .          .          .                           return Ok(None);
      .          .          .          .                       }
      .          .          .          .                       let mut cls =
  2,240 ( 0.00%) .          .          .                           hir::ClassUnicode::new(vec![hir::ClassUnicodeRange::new(
      .          .          .          .                               c, c,
      .          .          .          .                           )]);
  2,240 ( 0.00%) .          .          .                       cls.try_case_fold_simple().map_err(|_| {
930,739 ( 0.28%) 2,240 ( 0.28%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple (1,120x)
      .          .          .          .                           self.error(span, ErrorKind::UnicodeCaseUnavailable)
      .          .          .          .                       })?;
  5,600 ( 0.00%) .          .          .                       Ok(Some(Hir::class(hir::Class::Unicode(cls))))
      .          .          .          .                   } else {
      .          .          .          .                       if !c.is_ascii() {
      .          .          .          .                           return Ok(None);
      .          .          .          .                       }
      .          .          .          .                       // If case folding won't do anything, then don't bother trying.
      .          .          .          .                       match c {
      .          .          .          .                           'A'..='Z' | 'a'..='z' => {}
      .          .          .          .                           _ => return Ok(None),
-- line 874 ----------------------------------------
-- line 882 ----------------------------------------
      .          .          .          .                           )]);
      .          .          .          .                       cls.case_fold_simple();
      .          .          .          .                       Ok(Some(Hir::class(hir::Class::Bytes(cls))))
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_dot(&self, span: Span) -> Result<Hir> {
      .          .          .          .                   let (utf8, lineterm, flags) =
      5 ( 0.00%) .          .          .                       (self.trans().utf8, self.trans().line_terminator, self.flags());
     10 ( 0.00%) .          .          .                   if utf8 && (!flags.unicode() || !lineterm.is_ascii()) {
      .          .          .          .                       return Err(self.error(span, ErrorKind::InvalidUtf8));
      .          .          .          .                   }
      .          .          .          .                   let dot = if flags.dot_matches_new_line() {
      .          .          .          .                       if flags.unicode() {
      .          .          .          .                           hir::Dot::AnyChar
      .          .          .          .                       } else {
      .          .          .          .                           hir::Dot::AnyByte
      .          .          .          .                       }
      .          .          .          .                   } else {
      .          .          .          .                       if flags.unicode() {
      .          .          .          .                           if flags.crlf() {
      .          .          .          .                               hir::Dot::AnyCharExceptCRLF
      .          .          .          .                           } else {
      5 ( 0.00%) .          .          .                               if !lineterm.is_ascii() {
      .          .          .          .                                   return Err(
      .          .          .          .                                       self.error(span, ErrorKind::InvalidLineTerminator)
      .          .          .          .                                   );
      .          .          .          .                               }
      .          .          .          .                               hir::Dot::AnyCharExcept(char::from(lineterm))
      .          .          .          .                           }
      .          .          .          .                       } else {
      .          .          .          .                           if flags.crlf() {
      .          .          .          .                               hir::Dot::AnyByteExceptCRLF
      .          .          .          .                           } else {
      .          .          .          .                               hir::Dot::AnyByteExcept(lineterm)
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   };
     20 ( 0.00%) .          .          .                   Ok(Hir::dot(dot))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir> {
      .          .          .          .                   let unicode = self.flags().unicode();
      .          .          .          .                   let multi_line = self.flags().multi_line();
      .          .          .          .                   let crlf = self.flags().crlf();
    610 ( 0.00%) .          .          .                   Ok(match asst.kind {
      .          .          .          .                       ast::AssertionKind::StartLine => Hir::look(if multi_line {
      .          .          .          .                           if crlf {
      .          .          .          .                               hir::Look::StartCRLF
      .          .          .          .                           } else {
      .          .          .          .                               hir::Look::StartLF
      .          .          .          .                           }
      .          .          .          .                       } else {
      .          .          .          .                           hir::Look::Start
-- line 935 ----------------------------------------
-- line 982 ----------------------------------------
      .          .          .          .                           hir::Look::WordEndHalfUnicode
      .          .          .          .                       } else {
      .          .          .          .                           hir::Look::WordEndHalfAscii
      .          .          .          .                       }),
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_capture(&self, group: &ast::Group, expr: Hir) -> Hir {
  6,023 ( 0.00%) .          .          .                   let (index, name) = match group.kind {
    321 ( 0.00%) .          .          .                       ast::GroupKind::CaptureIndex(index) => (index, None),
      .          .          .          .                       ast::GroupKind::CaptureName { ref name, .. } => {
  1,758 ( 0.00%) .          .          .                           (name.index, Some(name.name.clone().into_boxed_str()))
 71,074 ( 0.02%) 50 ( 0.01%) .          .           => /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/string.rs:<alloc::string::String as core::clone::Clone>::clone (586x)
      .          .          .          .                       }
      .          .          .          .                       // The HIR doesn't need to use non-capturing groups, since the way
      .          .          .          .                       // in which the data type is defined handles this automatically.
      .          .          .          .                       ast::GroupKind::NonCapturing(_) => return expr,
      .          .          .          .                   };
  3,465 ( 0.00%) .          .          .                   Hir::capture(hir::Capture { index, name, sub: Box::new(expr) })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir {
 17,519 ( 0.01%) .          .          .                   let (min, max) = match rep.op.kind {
      .          .          .          .                       ast::RepetitionKind::ZeroOrOne => (0, Some(1)),
      .          .          .          .                       ast::RepetitionKind::ZeroOrMore => (0, None),
      .          .          .          .                       ast::RepetitionKind::OneOrMore => (1, None),
      .          .          .          .                       ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(m)) => {
      .          .          .          .                           (m, Some(m))
      .          .          .          .                       }
      .          .          .          .                       ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(m)) => {
      .          .          .          .                           (m, None)
      .          .          .          .                       }
      .          .          .          .                       ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(
      .          .          .          .                           m,
     67 ( 0.00%) .          .          .                           n,
      .          .          .          .                       )) => (m, Some(n)),
      .          .          .          .                   };
      .          .          .          .                   let greedy =
  1,885 ( 0.00%) .          .          .                       if self.flags().swap_greed() { !rep.greedy } else { rep.greedy };
  9,425 ( 0.00%) .          .          .                   Hir::repetition(hir::Repetition {
      .          .          .          .                       min,
      .          .          .          .                       max,
      .          .          .          .                       greedy,
      .          .          .          .                       sub: Box::new(expr),
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_unicode_class(
-- line 1028 ----------------------------------------
-- line 1058 ----------------------------------------
      .          .          .          .                   result
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_ascii_unicode_class(
      .          .          .          .                   &self,
      .          .          .          .                   ast: &ast::ClassAscii,
      .          .          .          .               ) -> Result<hir::ClassUnicode> {
      .          .          .          .                   let mut cls = hir::ClassUnicode::new(
    770 ( 0.00%) .          .          .                       ascii_class_as_chars(&ast.kind)
      .          .          .          .                           .map(|(s, e)| hir::ClassUnicodeRange::new(s, e)),
      .          .          .          .                   );
    770 ( 0.00%) .          .          .                   self.unicode_fold_and_negate(&ast.span, ast.negated, &mut cls)?;
      .          .          .          .                   Ok(cls)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_ascii_byte_class(
      .          .          .          .                   &self,
      .          .          .          .                   ast: &ast::ClassAscii,
      .          .          .          .               ) -> Result<hir::ClassBytes> {
      .          .          .          .                   let mut cls = hir::ClassBytes::new(
      .          .          .          .                       ascii_class(&ast.kind)
      .          .          .          .                           .map(|(s, e)| hir::ClassBytesRange::new(s, e)),
      .          .          .          .                   );
      .          .          .          .                   self.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls)?;
      .          .          .          .                   Ok(cls)
      .          .          .          .               }
      .          .          .          .           
     35 ( 0.00%) .          .          .               fn hir_perl_unicode_class(
      .          .          .          .                   &self,
      .          .          .          .                   ast_class: &ast::ClassPerl,
      .          .          .          .               ) -> Result<hir::ClassUnicode> {
      .          .          .          .                   use crate::ast::ClassPerlKind::*;
      .          .          .          .           
      .          .          .          .                   assert!(self.flags().unicode());
     20 ( 0.00%) .          .          .                   let result = match ast_class.kind {
     10 ( 0.00%) .          .          .                       Digit => unicode::perl_digit(),
 13,973 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::perl_digit (5x)
      .          .          .          .                       Space => unicode::perl_space(),
      .          .          .          .                       Word => unicode::perl_word(),
      .          .          .          .                   };
      .          .          .          .                   let mut class =
     50 ( 0.00%) .          .          .                       self.convert_unicode_class_error(&ast_class.span, result)?;
    130 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:regex_syntax::hir::translate::TranslatorI::convert_unicode_class_error (5x)
      .          .          .          .                   // We needn't apply case folding here because the Perl Unicode classes
      .          .          .          .                   // are already closed under Unicode simple case folding.
     10 ( 0.00%) .          .          .                   if ast_class.negated {
      .          .          .          .                       class.negate();
      .          .          .          .                   }
     25 ( 0.00%) .          .          .                   Ok(class)
     30 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn hir_perl_byte_class(
      .          .          .          .                   &self,
      .          .          .          .                   ast_class: &ast::ClassPerl,
      .          .          .          .               ) -> Result<hir::ClassBytes> {
      .          .          .          .                   use crate::ast::ClassPerlKind::*;
      .          .          .          .           
      .          .          .          .                   assert!(!self.flags().unicode());
-- line 1113 ----------------------------------------
-- line 1129 ----------------------------------------
      .          .          .          .                   }
      .          .          .          .                   Ok(class)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Converts the given Unicode specific error to an HIR translation error.
      .          .          .          .               ///
      .          .          .          .               /// The span given should approximate the position at which an error would
      .          .          .          .               /// occur.
     45 ( 0.00%) .          .          .               fn convert_unicode_class_error(
      .          .          .          .                   &self,
      .          .          .          .                   span: &Span,
      .          .          .          .                   result: core::result::Result<hir::ClassUnicode, unicode::Error>,
      .          .          .          .               ) -> Result<hir::ClassUnicode> {
      .          .          .          .                   result.map_err(|err| {
      .          .          .          .                       let sp = span.clone();
      .          .          .          .                       match err {
      .          .          .          .                           unicode::Error::PropertyNotFound => {
-- line 1145 ----------------------------------------
-- line 1148 ----------------------------------------
      .          .          .          .                           unicode::Error::PropertyValueNotFound => {
      .          .          .          .                               self.error(sp, ErrorKind::UnicodePropertyValueNotFound)
      .          .          .          .                           }
      .          .          .          .                           unicode::Error::PerlClassNotFound => {
      .          .          .          .                               self.error(sp, ErrorKind::UnicodePerlClassNotFound)
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   })
     40 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn unicode_fold_and_negate(
      .          .          .          .                   &self,
      .          .          .          .                   span: &Span,
      .          .          .          .                   negated: bool,
      .          .          .          .                   class: &mut hir::ClassUnicode,
      .          .          .          .               ) -> Result<()> {
      .          .          .          .                   // Note that we must apply case folding before negation!
      .          .          .          .                   // Consider `(?i)[^x]`. If we applied negation first, then
      .          .          .          .                   // the result would be the character class that matched any
      .          .          .          .                   // Unicode scalar value.
    420 ( 0.00%) .          .          .                   if self.flags().case_insensitive() {
     70 ( 0.00%) .          .          .                       class.try_case_fold_simple().map_err(|_| {
  1,120 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::try_case_fold_simple (70x)
      .          .          .          .                           self.error(span.clone(), ErrorKind::UnicodeCaseUnavailable)
      .          .          .          .                       })?;
      .          .          .          .                   }
  7,188 ( 0.00%) .          .          .                   if negated {
      .          .          .          .                       class.negate();
      .          .          .          .                   }
      .          .          .          .                   Ok(())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn bytes_fold_and_negate(
      .          .          .          .                   &self,
      .          .          .          .                   span: &Span,
-- line 1181 ----------------------------------------
-- line 1234 ----------------------------------------
      .          .          .          .               // entirely in the parser.
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Flags {
      .          .          .          .               fn from_ast(ast: &ast::Flags) -> Flags {
      .          .          .          .                   let mut flags = Flags::default();
      .          .          .          .                   let mut enable = true;
      .          .          .          .                   for item in &ast.items {
    180 ( 0.00%) .          .          .                       match item.kind {
      .          .          .          .                           ast::FlagsItemKind::Negation => {
      .          .          .          .                               enable = false;
      .          .          .          .                           }
      .          .          .          .                           ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive) => {
     40 ( 0.00%) .          .          .                               flags.case_insensitive = Some(enable);
      .          .          .          .                           }
      .          .          .          .                           ast::FlagsItemKind::Flag(ast::Flag::MultiLine) => {
      .          .          .          .                               flags.multi_line = Some(enable);
      .          .          .          .                           }
      .          .          .          .                           ast::FlagsItemKind::Flag(ast::Flag::DotMatchesNewLine) => {
      .          .          .          .                               flags.dot_matches_new_line = Some(enable);
      .          .          .          .                           }
      .          .          .          .                           ast::FlagsItemKind::Flag(ast::Flag::SwapGreed) => {
-- line 1255 ----------------------------------------
-- line 1263 ----------------------------------------
      .          .          .          .                           }
      .          .          .          .                           ast::FlagsItemKind::Flag(ast::Flag::IgnoreWhitespace) => {}
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   flags
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn merge(&mut self, previous: &Flags) {
     40 ( 0.00%) .          .          .                   if self.case_insensitive.is_none() {
      .          .          .          .                       self.case_insensitive = previous.case_insensitive;
      .          .          .          .                   }
     40 ( 0.00%) .          .          .                   if self.multi_line.is_none() {
      .          .          .          .                       self.multi_line = previous.multi_line;
      .          .          .          .                   }
     60 ( 0.00%) .          .          .                   if self.dot_matches_new_line.is_none() {
      .          .          .          .                       self.dot_matches_new_line = previous.dot_matches_new_line;
      .          .          .          .                   }
     60 ( 0.00%) .          .          .                   if self.swap_greed.is_none() {
      .          .          .          .                       self.swap_greed = previous.swap_greed;
      .          .          .          .                   }
     40 ( 0.00%) .          .          .                   if self.unicode.is_none() {
      .          .          .          .                       self.unicode = previous.unicode;
      .          .          .          .                   }
     40 ( 0.00%) .          .          .                   if self.crlf.is_none() {
      .          .          .          .                       self.crlf = previous.crlf;
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn case_insensitive(&self) -> bool {
      .          .          .          .                   self.case_insensitive.unwrap_or(false)
      .          .          .          .               }
      .          .          .          .           
-- line 1294 ----------------------------------------
-- line 1318 ----------------------------------------
      .          .          .          .                   .map(|(s, e)| hir::ClassBytesRange::new(s, e))
      .          .          .          .                   .collect();
      .          .          .          .               hir::ClassBytes::new(ranges)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           fn ascii_class(kind: &ast::ClassAsciiKind) -> impl Iterator<Item = (u8, u8)> {
      .          .          .          .               use crate::ast::ClassAsciiKind::*;
      .          .          .          .           
  3,850 ( 0.00%) .          .          .               let slice: &'static [(u8, u8)] = match *kind {
      .          .          .          .                   Alnum => &[(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')],
      .          .          .          .                   Alpha => &[(b'A', b'Z'), (b'a', b'z')],
      .          .          .          .                   Ascii => &[(b'\x00', b'\x7F')],
      .          .          .          .                   Blank => &[(b'\t', b'\t'), (b' ', b' ')],
      .          .          .          .                   Cntrl => &[(b'\x00', b'\x1F'), (b'\x7F', b'\x7F')],
      .          .          .          .                   Digit => &[(b'0', b'9')],
      .          .          .          .                   Graph => &[(b'!', b'~')],
      .          .          .          .                   Lower => &[(b'a', b'z')],
-- line 1334 ----------------------------------------

517,432 ( 0.16%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 196 ----------------------------------------
      .          .          .          .           /// expression pattern string, and uses constant stack space and heap space
      .          .          .          .           /// proportional to the size of the `Hir`. The regex it prints is guaranteed to
      .          .          .          .           /// be _semantically_ equivalent to the original concrete syntax, but it may
      .          .          .          .           /// look very different. (And potentially not practically readable by a human.)
      .          .          .          .           ///
      .          .          .          .           /// An `Hir`'s `fmt::Debug` implementation currently does not use constant
      .          .          .          .           /// stack space. The implementation will also suppress some details (such as
      .          .          .          .           /// the `Properties` inlined into every `Hir` value to make it less noisy).
    897 ( 0.00%) .          .          .           #[derive(Clone, Eq, PartialEq)]
      .          .          .          .           pub struct Hir {
      .          .          .          .               /// The underlying HIR kind.
    194 ( 0.00%) .          .          .               kind: HirKind,
      .          .          .          .               /// Analysis info about this HIR, computed during construction.
      .          .          .          .               props: Properties,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Methods for accessing the underlying `HirKind` and `Properties`.
      .          .          .          .           impl Hir {
      .          .          .          .               /// Returns a reference to the underlying HIR kind.
      .          .          .          .               pub fn kind(&self) -> &HirKind {
      .          .          .          .                   &self.kind
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Consumes ownership of this HIR expression and returns its underlying
      .          .          .          .               /// `HirKind`.
     65 ( 0.00%) .          .          .               pub fn into_kind(mut self) -> HirKind {
      .          .          .          .                   core::mem::replace(&mut self.kind, HirKind::Empty)
     65 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the properties computed for this `Hir`.
      .          .          .          .               pub fn properties(&self) -> &Properties {
      .          .          .          .                   &self.props
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Splits this HIR into its constituent parts.
      .          .          .          .               ///
      .          .          .          .               /// This is useful because `let Hir { kind, props } = hir;` does not work
      .          .          .          .               /// because of `Hir`'s custom `Drop` implementation.
194,215 ( 0.06%) .          .          .               fn into_parts(mut self) -> (HirKind, Properties) {
272,037 ( 0.08%) .          .          .                   (
      .          .          .          .                       core::mem::replace(&mut self.kind, HirKind::Empty),
      .          .          .          .                       core::mem::replace(&mut self.props, Properties::empty()),
      .          .          .          .                   )
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Smart constructors for HIR values.
      .          .          .          .           ///
-- line 243 ----------------------------------------
-- line 334 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// let ch = '';
      .          .          .          .               /// let got = Hir::literal(ch.encode_utf8(&mut [0; 4]).as_bytes());
      .          .          .          .               ///
      .          .          .          .               /// let expected = HirKind::Literal(Literal(Box::from("".as_bytes())));
      .          .          .          .               /// assert_eq!(&expected, got.kind());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
107,842 ( 0.03%) .          .          .               pub fn literal<B: Into<Box<[u8]>>>(lit: B) -> Hir {
      .          .          .          .                   let bytes = lit.into();
 31,997 ( 0.01%) .          .          .                   if bytes.is_empty() {
      .          .          .          .                       return Hir::empty();
      .          .          .          .                   }
      .          .          .          .           
  5,736 ( 0.00%) .          .          .                   let lit = Literal(bytes);
  1,912 ( 0.00%) .          .          .                   let props = Properties::literal(&lit);
637,372 ( 0.19%) 3,644 ( 0.45%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::literal (1,912x)
 73,176 ( 0.02%) .          .          .                   Hir { kind: HirKind::Literal(lit), props }
 92,436 ( 0.03%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates a class HIR expression. The class may either be defined over
      .          .          .          .               /// ranges of Unicode codepoints or ranges of raw byte values.
      .          .          .          .               ///
      .          .          .          .               /// Note that an empty class is permitted. An empty class is equivalent to
      .          .          .          .               /// `Hir::fail()`.
      .          .          .          .               #[inline]
 34,911 ( 0.01%) .          .          .               pub fn class(class: Class) -> Hir {
  8,061 ( 0.00%) .          .          .                   if class.is_empty() {
      .          .          .          .                       return Hir::fail();
 20,130 ( 0.01%) .          .          .                   } else if let Some(bytes) = class.literal() {
  1,980 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Class::literal (110x)
      .          .          .          .                       return Hir::literal(bytes);
      .          .          .          .                   }
  5,153 ( 0.00%) .          .          .                   let props = Properties::class(&class);
 17,004 ( 0.01%) 38 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::class (110x)
 19,096 ( 0.01%) .          .          .                   Hir { kind: HirKind::Class(class), props }
 33,566 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates a look-around assertion HIR expression.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn look(look: Look) -> Hir {
      4 ( 0.00%) .          .          .                   let props = Properties::look(look);
    317 ( 0.00%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::look (2x)
      6 ( 0.00%) .          .          .                   Hir { kind: HirKind::Look(look), props }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates a repetition HIR expression.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn repetition(mut rep: Repetition) -> Hir {
      .          .          .          .                   // If the sub-expression of a repetition can only match the empty
      .          .          .          .                   // string, then we force its maximum to be at most 1.
  8,281 ( 0.00%) .          .          .                   if rep.sub.properties().maximum_len() == Some(0) {
      .          .          .          .                       rep.min = cmp::min(rep.min, 1);
      .          .          .          .                       rep.max = rep.max.map(|n| cmp::min(n, 1)).or(Some(1));
      .          .          .          .                   }
      .          .          .          .                   // The regex 'a{0}' is always equivalent to the empty regex. This is
      .          .          .          .                   // true even when 'a' is an expression that never matches anything
      .          .          .          .                   // (like '\P{any}').
      .          .          .          .                   //
      .          .          .          .                   // Additionally, the regex 'a{1}' is always equivalent to 'a'.
 14,914 ( 0.00%) .          .          .                   if rep.min == 0 && rep.max == Some(0) {
      .          .          .          .                       return Hir::empty();
    422 ( 0.00%) .          .          .                   } else if rep.min == 1 && rep.max == Some(1) {
      .          .          .          .                       return *rep.sub;
      .          .          .          .                   }
  3,919 ( 0.00%) .          .          .                   let props = Properties::repetition(&rep);
558,213 ( 0.17%) 3,416 ( 0.42%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::repetition (1,885x)
 10,319 ( 0.00%) .          .          .                   Hir { kind: HirKind::Repetition(rep), props }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates a capture HIR expression.
      .          .          .          .               ///
      .          .          .          .               /// Note that there is no explicit HIR value for a non-capturing group.
      .          .          .          .               /// Since a non-capturing group only exists to override precedence in the
      .          .          .          .               /// concrete syntax and since an HIR already does its own grouping based on
      .          .          .          .               /// what is parsed, there is no need to explicitly represent non-capturing
      .          .          .          .               /// groups in the HIR.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn capture(capture: Capture) -> Hir {
  1,386 ( 0.00%) .          .          .                   let props = Properties::capture(&capture);
204,301 ( 0.06%) 1,127 ( 0.14%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Properties::capture (693x)
  3,465 ( 0.00%) .          .          .                   Hir { kind: HirKind::Capture(capture), props }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the concatenation of the given expressions.
      .          .          .          .               ///
      .          .          .          .               /// This attempts to flatten and simplify the concatenation as appropriate.
      .          .          .          .               ///
      .          .          .          .               /// # Example
      .          .          .          .               ///
-- line 417 ----------------------------------------
-- line 431 ----------------------------------------
      .          .          .          .               ///         Hir::literal([b'x']),
      .          .          .          .               ///         Hir::literal([b'y']),
      .          .          .          .               ///         Hir::literal([b'z']),
      .          .          .          .               ///     ]),
      .          .          .          .               /// ]);
      .          .          .          .               /// let expected = Hir::literal("abcxyz".as_bytes());
      .          .          .          .               /// assert_eq!(expected, hir);
      .          .          .          .               /// ```
143,487 ( 0.04%) .          .          .               pub fn concat(subs: Vec<Hir>) -> Hir {
      .          .          .          .                   // We rebuild the concatenation by simplifying it. Would be nice to do
      .          .          .          .                   // it in place, but that seems a little tricky?
      .          .          .          .                   let mut new = vec![];
      .          .          .          .                   // This gobbles up any adjacent literals in a concatenation and smushes
      .          .          .          .                   // them together. Basically, when we see a literal, we add its bytes
      .          .          .          .                   // to 'prior_lit', and whenever we see anything else, we first take
      .          .          .          .                   // any bytes in 'prior_lit' and add it to the 'new' concatenation.
 15,943 ( 0.00%) .          .          .                   let mut prior_lit: Option<Vec<u8>> = None;
205,500 ( 0.06%) .          .          .                   for sub in subs {
226,050 ( 0.07%) .          .          .                       let (kind, props) = sub.into_parts();
7,671,072 ( 2.30%) 29,408 ( 3.63%) 2 ( 0.66%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::into_parts (20,550x)
112,922 ( 0.03%) .          .          .                       match kind {
 30,812 ( 0.01%) .          .          .                           HirKind::Literal(Literal(bytes)) => {
 61,624 ( 0.02%) .          .          .                               if let Some(ref mut prior_bytes) = prior_lit {
      .          .          .          .                                   prior_bytes.extend_from_slice(&bytes);
      .          .          .          .                               } else {
 61,624 ( 0.02%) .          .          .                                   prior_lit = Some(bytes.to_vec());
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                           // We also flatten concats that are direct children of another
      .          .          .          .                           // concat. We only need to do this one level deep since
      .          .          .          .                           // Hir::concat is the only way to build concatenations, and so
      .          .          .          .                           // flattening happens inductively.
    116 ( 0.00%) .          .          .                           HirKind::Concat(subs2) => {
    738 ( 0.00%) .          .          .                               for sub2 in subs2 {
      .          .          .          .                                   let (kind2, props2) = sub2.into_parts();
    136 ( 0.00%) .          .          .                                   match kind2 {
      .          .          .          .                                       HirKind::Literal(Literal(bytes)) => {
      8 ( 0.00%) .          .          .                                           if let Some(ref mut prior_bytes) = prior_lit {
      .          .          .          .                                               prior_bytes.extend_from_slice(&bytes);
      .          .          .          .                                           } else {
      8 ( 0.00%) .          .          .                                               prior_lit = Some(bytes.to_vec());
      .          .          .          .                                           }
      .          .          .          .                                       }
      .          .          .          .                                       kind2 => {
    136 ( 0.00%) .          .          .                                           if let Some(prior_bytes) = prior_lit.take() {
      .          .          .          .                                               new.push(Hir::literal(prior_bytes));
      .          .          .          .                                           }
      .          .          .          .                                           new.push(Hir { kind: kind2, props: props2 });
      .          .          .          .                                       }
      .          .          .          .                                   }
      2 ( 0.00%) .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                           // We can just skip empty HIRs.
      .          .          .          .                           HirKind::Empty => {}
      .          .          .          .                           kind => {
 17,880 ( 0.01%) .          .          .                               if let Some(prior_bytes) = prior_lit.take() {
  4,590 ( 0.00%) .          .          .                                   new.push(Hir::literal(prior_bytes));
245,861 ( 0.07%) 12 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::literal (1,530x)
      .          .          .          .                               }
      .          .          .          .                               new.push(Hir { kind, props });
      .          .          .          .                           }
      .          .          .          .                       }
 46,392 ( 0.01%) .          .          .                   }
117,209 ( 0.04%) .          .          .                   if let Some(prior_bytes) = prior_lit.take() {
 13,876 ( 0.00%) .          .          .                       new.push(Hir::literal(prior_bytes));
2,244,439 ( 0.67%) 10 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::literal (13,876x)
      .          .          .          .                   }
 36,032 ( 0.01%) .          .          .                   if new.is_empty() {
      .          .          .          .                       return Hir::empty();
      .          .          .          .                   } else if new.len() == 1 {
      .          .          .          .                       return new.pop().unwrap();
      .          .          .          .                   }
      .          .          .          .                   let props = Properties::concat(&new);
 14,511 ( 0.00%) .          .          .                   Hir { kind: HirKind::Concat(new), props }
127,544 ( 0.04%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the alternation of the given expressions.
      .          .          .          .               ///
      .          .          .          .               /// This flattens and simplifies the alternation as appropriate. This may
      .          .          .          .               /// include factoring out common prefixes or even rewriting the alternation
      .          .          .          .               /// as a character class.
      .          .          .          .               ///
      .          .          .          .               /// Note that an empty alternation is equivalent to `Hir::fail()`. (It
-- line 510 ----------------------------------------
-- line 564 ----------------------------------------
      .          .          .          .               ///             ClassUnicodeRange::new('a', 'z'),
      .          .          .          .               ///         ]))),
      .          .          .          .               ///     ]),
      .          .          .          .               /// ]);
      .          .          .          .               /// assert_eq!(expected, hir);
      .          .          .          .               /// ```
      .          .          .          .               ///
      .          .          .          .               /// Note that these sorts of simplifications are not guaranteed.
  5,220 ( 0.00%) .          .          .               pub fn alternation(subs: Vec<Hir>) -> Hir {
      .          .          .          .                   // We rebuild the alternation by simplifying it. We proceed similarly
      .          .          .          .                   // as the concatenation case. But in this case, there's no literal
      .          .          .          .                   // simplification happening. We're just flattening alternations.
      .          .          .          .                   let mut new = Vec::with_capacity(subs.len());
202,963 ( 0.06%) .          .          .                   for sub in subs {
146,344 ( 0.04%) .          .          .                       let (kind, props) = sub.into_parts();
4,624,483 ( 1.39%) 1,059 ( 0.13%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::into_parts (18,288x)
 36,586 ( 0.01%) .          .          .                       match kind {
      .          .          .          .                           HirKind::Alternation(subs2) => {
      .          .          .          .                               new.extend(subs2);
      .          .          .          .                           }
      .          .          .          .                           kind => {
      .          .          .          .                               new.push(Hir { kind, props });
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
  2,320 ( 0.00%) .          .          .                   if new.is_empty() {
      .          .          .          .                       return Hir::fail();
      .          .          .          .                   } else if new.len() == 1 {
      .          .          .          .                       return new.pop().unwrap();
      .          .          .          .                   }
      .          .          .          .                   // Now that it's completely flattened, look for the special case of
      .          .          .          .                   // 'char1|char2|...|charN' and collapse that into a class. Note that
      .          .          .          .                   // we look for 'char' first and then bytes. The issue here is that if
      .          .          .          .                   // we find both non-ASCII codepoints and non-ASCII singleton bytes,
      .          .          .          .                   // then it isn't actually possible to smush them into a single class.
      .          .          .          .                   // (Because classes are either "all codepoints" or "all bytes." You
      .          .          .          .                   // can have a class that both matches non-ASCII but valid UTF-8 and
      .          .          .          .                   // invalid UTF-8.) So we look for all chars and then all bytes, and
      .          .          .          .                   // don't handle anything else.
      3 ( 0.00%) .          .          .                   if let Some(singletons) = singleton_chars(&new) {
      .          .          .          .                       let it = singletons
      .          .          .          .                           .into_iter()
      .          .          .          .                           .map(|ch| ClassUnicodeRange { start: ch, end: ch });
      4 ( 0.00%) .          .          .                       return Hir::class(Class::Unicode(ClassUnicode::new(it)));
      .          .          .          .                   }
      .          .          .          .                   if let Some(singletons) = singleton_bytes(&new) {
      .          .          .          .                       let it = singletons
      .          .          .          .                           .into_iter()
      .          .          .          .                           .map(|b| ClassBytesRange { start: b, end: b });
      .          .          .          .                       return Hir::class(Class::Bytes(ClassBytes::new(it)));
      .          .          .          .                   }
      .          .          .          .                   // Similar to singleton chars, we can also look for alternations of
-- line 614 ----------------------------------------
-- line 618 ----------------------------------------
      .          .          .          .                   }
      .          .          .          .                   if let Some(cls) = class_bytes(&new) {
      .          .          .          .                       return Hir::class(cls);
      .          .          .          .                   }
      .          .          .          .                   // Factor out a common prefix if we can, which might potentially
      .          .          .          .                   // simplify the expression and unlock other optimizations downstream.
      .          .          .          .                   // It also might generally make NFA matching and DFA construction
      .          .          .          .                   // faster by reducing the scope of branching in the regex.
  3,473 ( 0.00%) .          .          .                   new = match lift_common_prefix(new) {
      7 ( 0.00%) .          .          .                       Ok(hir) => return hir,
      .          .          .          .                       Err(unchanged) => unchanged,
      .          .          .          .                   };
      .          .          .          .                   let props = Properties::alternation(&new);
  4,624 ( 0.00%) .          .          .                   Hir { kind: HirKind::Alternation(new), props }
  4,640 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns an HIR expression for `.`.
      .          .          .          .               ///
      .          .          .          .               /// * [`Dot::AnyChar`] maps to `(?su-R:.)`.
      .          .          .          .               /// * [`Dot::AnyByte`] maps to `(?s-Ru:.)`.
      .          .          .          .               /// * [`Dot::AnyCharExceptLF`] maps to `(?u-Rs:.)`.
      .          .          .          .               /// * [`Dot::AnyCharExceptCRLF`] maps to `(?Ru-s:.)`.
      .          .          .          .               /// * [`Dot::AnyByteExceptLF`] maps to `(?-Rsu:.)`.
-- line 640 ----------------------------------------
-- line 651 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// let hir = Hir::dot(Dot::AnyByte);
      .          .          .          .               /// let expected = Hir::class(Class::Bytes(ClassBytes::new([
      .          .          .          .               ///     ClassBytesRange::new(0x00, 0xFF),
      .          .          .          .               /// ])));
      .          .          .          .               /// assert_eq!(expected, hir);
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
    660 ( 0.00%) .          .          .               pub fn dot(dot: Dot) -> Hir {
      .          .          .          .                   match dot {
      .          .          .          .                       Dot::AnyChar => Hir::class(Class::Unicode(ClassUnicode::new([
      .          .          .          .                           ClassUnicodeRange::new('\0', '\u{10FFFF}'),
      .          .          .          .                       ]))),
    220 ( 0.00%) .          .          .                       Dot::AnyByte => Hir::class(Class::Bytes(ClassBytes::new([
    550 ( 0.00%) .          .          .                           ClassBytesRange::new(b'\0', b'\xFF'),
    660 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassBytesRange::new (110x)
      .          .          .          .                       ]))),
      .          .          .          .                       Dot::AnyCharExcept(ch) => {
      .          .          .          .                           let mut cls =
      .          .          .          .                               ClassUnicode::new([ClassUnicodeRange::new(ch, ch)]);
      .          .          .          .                           cls.negate();
     20 ( 0.00%) .          .          .                           Hir::class(Class::Unicode(cls))
      .          .          .          .                       }
      .          .          .          .                       Dot::AnyCharExceptLF => {
      .          .          .          .                           Hir::class(Class::Unicode(ClassUnicode::new([
      .          .          .          .                               ClassUnicodeRange::new('\0', '\x09'),
      .          .          .          .                               ClassUnicodeRange::new('\x0B', '\u{10FFFF}'),
      .          .          .          .                           ])))
      .          .          .          .                       }
      .          .          .          .                       Dot::AnyCharExceptCRLF => {
-- line 679 ----------------------------------------
-- line 698 ----------------------------------------
      .          .          .          .                       Dot::AnyByteExceptCRLF => {
      .          .          .          .                           Hir::class(Class::Bytes(ClassBytes::new([
      .          .          .          .                               ClassBytesRange::new(b'\0', b'\x09'),
      .          .          .          .                               ClassBytesRange::new(b'\x0B', b'\x0C'),
      .          .          .          .                               ClassBytesRange::new(b'\x0E', b'\xFF'),
      .          .          .          .                           ])))
      .          .          .          .                       }
      .          .          .          .                   }
    660 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// The underlying kind of an arbitrary [`Hir`] expression.
      .          .          .          .           ///
      .          .          .          .           /// An `HirKind` is principally useful for doing case analysis on the type
      .          .          .          .           /// of a regular expression. If you're looking to build new `Hir` values,
      .          .          .          .           /// then you _must_ use the smart constructors defined on `Hir`, like
      .          .          .          .           /// [`Hir::repetition`], to build new `Hir` values. The API intentionally does
      .          .          .          .           /// not expose any way of building an `Hir` directly from an `HirKind`.
    966 ( 0.00%) .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           pub enum HirKind {
      .          .          .          .               /// The empty regular expression, which matches everything, including the
      .          .          .          .               /// empty string.
      .          .          .          .               Empty,
      .          .          .          .               /// A literalstring that matches exactly these bytes.
      .          .          .          .               Literal(Literal),
      .          .          .          .               /// A single character class that matches any of the characters in the
      .          .          .          .               /// class. A class can either consist of Unicode scalar values as
-- line 724 ----------------------------------------
-- line 751 ----------------------------------------
      .          .          .          .               Alternation(Vec<Hir>),
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl HirKind {
      .          .          .          .               /// Returns a slice of this kind's sub-expressions, if any.
      .          .          .          .               pub fn subs(&self) -> &[Hir] {
      .          .          .          .                   use core::slice::from_ref;
      .          .          .          .           
 19,089 ( 0.01%) .          .          .                   match *self {
      .          .          .          .                       HirKind::Empty
      .          .          .          .                       | HirKind::Literal(_)
      .          .          .          .                       | HirKind::Class(_)
      .          .          .          .                       | HirKind::Look(_) => &[],
      .          .          .          .                       HirKind::Repetition(Repetition { ref sub, .. }) => from_ref(sub),
      .          .          .          .                       HirKind::Capture(Capture { ref sub, .. }) => from_ref(sub),
      .          .          .          .                       HirKind::Concat(ref subs) => subs,
      .          .          .          .                       HirKind::Alternation(ref subs) => subs,
-- line 767 ----------------------------------------
-- line 821 ----------------------------------------
      .          .          .          .           /// regex `(?-u:a|\xc2\xa0)` will compile down to HIR for the Unicode class
      .          .          .          .           /// `[a\u00A0]` due to optimizations.
      .          .          .          .           ///
      .          .          .          .           /// Note that `Bytes` variant may be produced even when it exclusively matches
      .          .          .          .           /// valid UTF-8. This is because a `Bytes` variant represents an intention by
      .          .          .          .           /// the author of the regular expression to disable Unicode mode, which in turn
      .          .          .          .           /// impacts the semantics of case insensitive matching. For example, `(?i)k`
      .          .          .          .           /// and `(?i-u)k` will not match the same set of strings.
  1,607 ( 0.00%) .          .          .           #[derive(Clone, Eq, PartialEq)]
      .          .          .          .           pub enum Class {
      .          .          .          .               /// A set of characters represented by Unicode scalar values.
      .          .          .          .               Unicode(ClassUnicode),
      .          .          .          .               /// A set of characters represented by arbitrary bytes (one byte per
      .          .          .          .               /// character).
      .          .          .          .               Bytes(ClassBytes),
      .          .          .          .           }
      .          .          .          .           
-- line 837 ----------------------------------------
-- line 943 ----------------------------------------
      .          .          .          .               /// assert_eq!(Some(1), hir.properties().minimum_len());
      .          .          .          .               /// // But sometimes Unicode classes might be bigger!
      .          .          .          .               /// let hir = parse(r"\p{Cyrillic}")?;
      .          .          .          .               /// assert_eq!(Some(2), hir.properties().minimum_len());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn minimum_len(&self) -> Option<usize> {
  5,456 ( 0.00%) .          .          .                   match *self {
  2,618 ( 0.00%) .          .          .                       Class::Unicode(ref x) => x.minimum_len(),
      .          .          .          .                       Class::Bytes(ref x) => x.minimum_len(),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length, in bytes, of the longest string matched by this
      .          .          .          .               /// character class.
      .          .          .          .               ///
      .          .          .          .               /// For non-empty byte oriented classes, this always returns `1`. For
-- line 960 ----------------------------------------
-- line 1012 ----------------------------------------
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// If this class consists of exactly one element (whether a codepoint or a
      .          .          .          .               /// byte), then return it as a literal byte string.
      .          .          .          .               ///
      .          .          .          .               /// If this class is empty or contains more than one element, then `None`
      .          .          .          .               /// is returned.
    909 ( 0.00%) .          .          .               pub fn literal(&self) -> Option<Vec<u8>> {
 12,243 ( 0.00%) .          .          .                   match *self {
  8,144 ( 0.00%) .          .          .                       Class::Unicode(ref x) => x.literal(),
  2,342 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::ClassUnicode::literal (193x)
      .          .          .          .                       Class::Bytes(ref x) => x.literal(),
      .          .          .          .                   }
  1,515 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl core::fmt::Debug for Class {
      .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      .          .          .          .                   use crate::debug::Byte;
      .          .          .          .           
      .          .          .          .                   let mut fmter = f.debug_set();
      .          .          .          .                   match *self {
-- line 1033 ----------------------------------------
-- line 1042 ----------------------------------------
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   fmter.finish()
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A set of characters represented by Unicode scalar values.
     64 ( 0.00%) .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
  1,790 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<regex_syntax::hir::interval::IntervalSet<I> as core::cmp::PartialEq>::eq (60x)
      .          .          .          .           pub struct ClassUnicode {
      .          .          .          .               set: IntervalSet<ClassUnicodeRange>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ClassUnicode {
      .          .          .          .               /// Create a new class from a sequence of ranges.
      .          .          .          .               ///
      .          .          .          .               /// The given ranges do not need to be in any specific order, and ranges
      .          .          .          .               /// may overlap. Ranges will automatically be sorted into a canonical
      .          .          .          .               /// non-overlapping order.
      .          .          .          .               pub fn new<I>(ranges: I) -> ClassUnicode
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = ClassUnicodeRange>,
      .          .          .          .               {
  2,271 ( 0.00%) .          .          .                   ClassUnicode { set: IntervalSet::new(ranges) }
  1,036 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::new (1x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new class with no ranges.
      .          .          .          .               ///
      .          .          .          .               /// An empty class matches nothing. That is, it is equivalent to
      .          .          .          .               /// [`Hir::fail`].
      .          .          .          .               pub fn empty() -> ClassUnicode {
      .          .          .          .                   ClassUnicode::new(vec![])
-- line 1073 ----------------------------------------
-- line 1114 ----------------------------------------
      .          .          .          .               /// this class consists of the range `a-z`, then applying case folding will
      .          .          .          .               /// result in the class containing both the ranges `a-z` and `A-Z`.
      .          .          .          .               ///
      .          .          .          .               /// # Error
      .          .          .          .               ///
      .          .          .          .               /// This routine returns an error when the case mapping data necessary
      .          .          .          .               /// for this routine to complete is unavailable. This occurs when the
      .          .          .          .               /// `unicode-case` feature is not enabled.
  7,140 ( 0.00%) .          .          .               pub fn try_case_fold_simple(
      .          .          .          .                   &mut self,
      .          .          .          .               ) -> core::result::Result<(), CaseFoldError> {
      .          .          .          .                   self.set.case_fold_simple()
  9,520 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Negate this character class.
      .          .          .          .               ///
      .          .          .          .               /// For all `c` where `c` is a Unicode scalar value, if `c` was in this
      .          .          .          .               /// set, then it will not be in this set after negation.
      .          .          .          .               pub fn negate(&mut self) {
     66 ( 0.00%) .          .          .                   self.set.negate();
 41,116 ( 0.01%) 164 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::negate (55x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Union this character class with the given character class, in place.
      .          .          .          .               pub fn union(&mut self, other: &ClassUnicode) {
      .          .          .          .                   self.set.union(&other.set);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Intersect this character class with the given character class, in
-- line 1141 ----------------------------------------
-- line 1160 ----------------------------------------
      .          .          .          .               pub fn symmetric_difference(&mut self, other: &ClassUnicode) {
      .          .          .          .                   self.set.symmetric_difference(&other.set);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this character class will either match
      .          .          .          .               /// nothing or only ASCII bytes. Stated differently, this returns false
      .          .          .          .               /// if and only if this class contains a non-ASCII codepoint.
      .          .          .          .               pub fn is_ascii(&self) -> bool {
 11,319 ( 0.00%) .          .          .                   self.set.intervals().last().map_or(true, |r| r.end <= '\x7F')
  5,631 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length, in bytes, of the smallest string matched by this
      .          .          .          .               /// character class.
      .          .          .          .               ///
      .          .          .          .               /// Returns `None` when the class is empty.
      .          .          .          .               pub fn minimum_len(&self) -> Option<usize> {
      .          .          .          .                   let first = self.ranges().get(0)?;
      .          .          .          .                   // Correct because c1 < c2 implies c1.len_utf8() < c2.len_utf8().
  2,618 ( 0.00%) .          .          .                   Some(first.start.len_utf8())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length, in bytes, of the longest string matched by this
      .          .          .          .               /// character class.
      .          .          .          .               ///
      .          .          .          .               /// Returns `None` when the class is empty.
      .          .          .          .               pub fn maximum_len(&self) -> Option<usize> {
      .          .          .          .                   let last = self.ranges().last()?;
      .          .          .          .                   // Correct because c1 < c2 implies c1.len_utf8() < c2.len_utf8().
  2,618 ( 0.00%) .          .          .                   Some(last.end.len_utf8())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// If this class consists of exactly one codepoint, then return it as
      .          .          .          .               /// a literal byte string.
      .          .          .          .               ///
      .          .          .          .               /// If this class is empty or contains more than one codepoint, then `None`
      .          .          .          .               /// is returned.
  8,144 ( 0.00%) .          .          .               pub fn literal(&self) -> Option<Vec<u8>> {
      .          .          .          .                   let rs = self.ranges();
 15,080 ( 0.00%) .          .          .                   if rs.len() == 1 && rs[0].start == rs[0].end {
  1,454 ( 0.00%) .          .          .                       Some(rs[0].start.encode_utf8(&mut [0; 4]).to_string().into_bytes())
      .          .          .          .                   } else {
  2,618 ( 0.00%) .          .          .                       None
      .          .          .          .                   }
 16,288 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// If this class consists of only ASCII ranges, then return its
      .          .          .          .               /// corresponding and equivalent byte class.
      .          .          .          .               pub fn to_byte_class(&self) -> Option<ClassBytes> {
     57 ( 0.00%) .          .          .                   if !self.is_ascii() {
      .          .          .          .                       return None;
      .          .          .          .                   }
      .          .          .          .                   Some(ClassBytes::new(self.ranges().iter().map(|r| {
      .          .          .          .                       // Since we are guaranteed that our codepoint range is ASCII, the
      .          .          .          .                       // 'u8::try_from' calls below are guaranteed to be correct.
      .          .          .          .                       ClassBytesRange {
      .          .          .          .                           start: u8::try_from(r.start).unwrap(),
      .          .          .          .                           end: u8::try_from(r.end).unwrap(),
-- line 1216 ----------------------------------------
-- line 1225 ----------------------------------------
      .          .          .          .           #[derive(Debug)]
      .          .          .          .           pub struct ClassUnicodeIter<'a>(IntervalSetIter<'a, ClassUnicodeRange>);
      .          .          .          .           
      .          .          .          .           impl<'a> Iterator for ClassUnicodeIter<'a> {
      .          .          .          .               type Item = &'a ClassUnicodeRange;
      .          .          .          .           
      .          .          .          .               fn next(&mut self) -> Option<&'a ClassUnicodeRange> {
      .          .          .          .                   self.0.next()
 16,192 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A single range of characters represented by Unicode scalar values.
      .          .          .          .           ///
      .          .          .          .           /// The range is closed. That is, the start and end of the range are included
      .          .          .          .           /// in the range.
      .          .          .          .           #[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]
      .          .          .          .           pub struct ClassUnicodeRange {
 28,061 ( 0.01%) .          .          .               start: char,
      .          .          .          .               end: char,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl core::fmt::Debug for ClassUnicodeRange {
      .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      .          .          .          .                   let start = if !self.start.is_whitespace() && !self.start.is_control()
      .          .          .          .                   {
      .          .          .          .                       self.start.to_string()
-- line 1250 ----------------------------------------
-- line 1282 ----------------------------------------
      .          .          .          .               fn set_upper(&mut self, bound: char) {
      .          .          .          .                   self.end = bound;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Apply simple case folding to this Unicode scalar value range.
      .          .          .          .               ///
      .          .          .          .               /// Additional ranges are appended to the given vector. Canonical ordering
      .          .          .          .               /// is *not* maintained in the given vector.
  8,330 ( 0.00%) .          .          .               fn case_fold_simple(
      .          .          .          .                   &self,
      .          .          .          .                   ranges: &mut Vec<ClassUnicodeRange>,
      .          .          .          .               ) -> Result<(), unicode::CaseFoldError> {
  5,950 ( 0.00%) .          .          .                   let mut folder = unicode::SimpleCaseFolder::new()?;
  4,760 ( 0.00%) .          .          .                   if !folder.overlaps(self.start, self.end) {
      .          .          .          .                       return Ok(());
      .          .          .          .                   }
      .          .          .          .                   let (start, end) = (u32::from(self.start), u32::from(self.end));
  1,120 ( 0.00%) .          .          .                   for cp in (start..=end).filter_map(char::from_u32) {
  3,380 ( 0.00%) .          .          .                       for &cp_folded in folder.mapping(cp) {
163,360 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/unicode.rs:regex_syntax::unicode::SimpleCaseFolder::mapping (1,120x)
      .          .          .          .                           ranges.push(ClassUnicodeRange::new(cp_folded, cp_folded));
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Ok(())
 10,710 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ClassUnicodeRange {
      .          .          .          .               /// Create a new Unicode scalar value range for a character class.
      .          .          .          .               ///
      .          .          .          .               /// The returned range is always in a canonical form. That is, the range
      .          .          .          .               /// returned always satisfies the invariant that `start <= end`.
      .          .          .          .               pub fn new(start: char, end: char) -> ClassUnicodeRange {
-- line 1313 ----------------------------------------
-- line 1314 ----------------------------------------
      .          .          .          .                   ClassUnicodeRange::create(start, end)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the start of this range.
      .          .          .          .               ///
      .          .          .          .               /// The start of a range is always less than or equal to the end of the
      .          .          .          .               /// range.
      .          .          .          .               pub fn start(&self) -> char {
 20,196 ( 0.01%) .          .          .                   self.start
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the end of this range.
      .          .          .          .               ///
      .          .          .          .               /// The end of a range is always greater than or equal to the start of the
      .          .          .          .               /// range.
      .          .          .          .               pub fn end(&self) -> char {
 19,966 ( 0.01%) .          .          .                   self.end
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the number of codepoints in this range.
      .          .          .          .               pub fn len(&self) -> usize {
    738 ( 0.00%) .          .          .                   let diff = 1 + u32::from(self.end) - u32::from(self.start);
      .          .          .          .                   // This is likely to panic in 16-bit targets since a usize can only fit
      .          .          .          .                   // 2^16. It's not clear what to do here, other than to return an error
      .          .          .          .                   // when building a Unicode class that contains a range whose length
      .          .          .          .                   // overflows usize. (Which, to be honest, is probably quite common on
      .          .          .          .                   // 16-bit targets. For example, this would imply that '.' and '\p{any}'
      .          .          .          .                   // would be impossible to build.)
      .          .          .          .                   usize::try_from(diff).expect("char class len fits in usize")
      .          .          .          .               }
-- line 1343 ----------------------------------------
-- line 1356 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// The given ranges do not need to be in any specific order, and ranges
      .          .          .          .               /// may overlap. Ranges will automatically be sorted into a canonical
      .          .          .          .               /// non-overlapping order.
      .          .          .          .               pub fn new<I>(ranges: I) -> ClassBytes
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = ClassBytesRange>,
      .          .          .          .               {
      2 ( 0.00%) .          .          .                   ClassBytes { set: IntervalSet::new(ranges) }
    171 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::new (1x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new class with no ranges.
      .          .          .          .               ///
      .          .          .          .               /// An empty class matches nothing. That is, it is equivalent to
      .          .          .          .               /// [`Hir::fail`].
      .          .          .          .               pub fn empty() -> ClassBytes {
      .          .          .          .                   ClassBytes::new(vec![])
-- line 1372 ----------------------------------------
-- line 1441 ----------------------------------------
      .          .          .          .                   self.set.intervals().last().map_or(true, |r| r.end <= 0x7F)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length, in bytes, of the smallest string matched by this
      .          .          .          .               /// character class.
      .          .          .          .               ///
      .          .          .          .               /// Returns `None` when the class is empty.
      .          .          .          .               pub fn minimum_len(&self) -> Option<usize> {
    220 ( 0.00%) .          .          .                   if self.ranges().is_empty() {
      .          .          .          .                       None
      .          .          .          .                   } else {
      .          .          .          .                       Some(1)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length, in bytes, of the longest string matched by this
      .          .          .          .               /// character class.
-- line 1457 ----------------------------------------
-- line 1467 ----------------------------------------
      .          .          .          .           
      .          .          .          .               /// If this class consists of exactly one byte, then return it as
      .          .          .          .               /// a literal byte string.
      .          .          .          .               ///
      .          .          .          .               /// If this class is empty or contains more than one byte, then `None`
      .          .          .          .               /// is returned.
      .          .          .          .               pub fn literal(&self) -> Option<Vec<u8>> {
      .          .          .          .                   let rs = self.ranges();
    550 ( 0.00%) .          .          .                   if rs.len() == 1 && rs[0].start == rs[0].end {
      .          .          .          .                       Some(vec![rs[0].start])
      .          .          .          .                   } else {
    110 ( 0.00%) .          .          .                       None
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// If this class consists of only ASCII ranges, then return its
      .          .          .          .               /// corresponding and equivalent Unicode class.
      .          .          .          .               pub fn to_unicode_class(&self) -> Option<ClassUnicode> {
      .          .          .          .                   if !self.is_ascii() {
      .          .          .          .                       return None;
-- line 1486 ----------------------------------------
-- line 1503 ----------------------------------------
      .          .          .          .           #[derive(Debug)]
      .          .          .          .           pub struct ClassBytesIter<'a>(IntervalSetIter<'a, ClassBytesRange>);
      .          .          .          .           
      .          .          .          .           impl<'a> Iterator for ClassBytesIter<'a> {
      .          .          .          .               type Item = &'a ClassBytesRange;
      .          .          .          .           
      .          .          .          .               fn next(&mut self) -> Option<&'a ClassBytesRange> {
      .          .          .          .                   self.0.next()
    220 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A single range of characters represented by arbitrary bytes.
      .          .          .          .           ///
      .          .          .          .           /// The range is closed. That is, the start and end of the range are included
      .          .          .          .           /// in the range.
      .          .          .          .           #[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]
      .          .          .          .           pub struct ClassBytesRange {
     10 ( 0.00%) .          .          .               start: u8,
      .          .          .          .               end: u8,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Interval for ClassBytesRange {
      .          .          .          .               type Bound = u8;
      .          .          .          .           
      .          .          .          .               #[inline]
      .          .          .          .               fn lower(&self) -> u8 {
-- line 1528 ----------------------------------------
-- line 1564 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ClassBytesRange {
      .          .          .          .               /// Create a new byte range for a character class.
      .          .          .          .               ///
      .          .          .          .               /// The returned range is always in a canonical form. That is, the range
      .          .          .          .               /// returned always satisfies the invariant that `start <= end`.
    110 ( 0.00%) .          .          .               pub fn new(start: u8, end: u8) -> ClassBytesRange {
      .          .          .          .                   ClassBytesRange::create(start, end)
    110 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the start of this range.
      .          .          .          .               ///
      .          .          .          .               /// The start of a range is always less than or equal to the end of the
      .          .          .          .               /// range.
      .          .          .          .               pub fn start(&self) -> u8 {
    110 ( 0.00%) .          .          .                   self.start
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the end of this range.
      .          .          .          .               ///
      .          .          .          .               /// The end of a range is always greater than or equal to the start of the
      .          .          .          .               /// range.
      .          .          .          .               pub fn end(&self) -> u8 {
      .          .          .          .                   self.end
-- line 1589 ----------------------------------------
-- line 1604 ----------------------------------------
      .          .          .          .                       .field("end", &crate::debug::Byte(self.end))
      .          .          .          .                       .finish()
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// The high-level intermediate representation for a look-around assertion.
      .          .          .          .           ///
      .          .          .          .           /// An assertion match is always zero-length. Also called an "empty match."
      2 ( 0.00%) .          .          .           #[derive(Clone, Copy, Debug, Eq, PartialEq)]
      .          .          .          .           pub enum Look {
      .          .          .          .               /// Match the beginning of text. Specifically, this matches at the starting
      .          .          .          .               /// position of the input.
      .          .          .          .               Start = 1 << 0,
      .          .          .          .               /// Match the end of text. Specifically, this matches at the ending
      .          .          .          .               /// position of the input.
      .          .          .          .               End = 1 << 1,
      .          .          .          .               /// Match the beginning of a line or the beginning of text. Specifically,
-- line 1620 ----------------------------------------
-- line 1813 ----------------------------------------
      .          .          .          .           pub struct Repetition {
      .          .          .          .               /// The minimum range of the repetition.
      .          .          .          .               ///
      .          .          .          .               /// Note that special cases like `?`, `+` and `*` all get translated into
      .          .          .          .               /// the ranges `{0,1}`, `{1,}` and `{0,}`, respectively.
      .          .          .          .               ///
      .          .          .          .               /// When `min` is zero, this expression can match the empty string
      .          .          .          .               /// regardless of what its sub-expression is.
     12 ( 0.00%) .          .          .               pub min: u32,
      .          .          .          .               /// The maximum range of the repetition.
      .          .          .          .               ///
      .          .          .          .               /// Note that when `max` is `None`, `min` acts as a lower bound but where
      .          .          .          .               /// there is no upper bound. For something like `x{5}` where the min and
      .          .          .          .               /// max are equivalent, `min` will be set to `5` and `max` will be set to
      .          .          .          .               /// `Some(5)`.
      8 ( 0.00%) .          .          .               pub max: Option<u32>,
      .          .          .          .               /// Whether this repetition operator is greedy or not. A greedy operator
      .          .          .          .               /// will match as much as it can. A non-greedy operator will match as
      .          .          .          .               /// little as it can.
      .          .          .          .               ///
      .          .          .          .               /// Typically, operators are greedy by default and are only non-greedy when
      .          .          .          .               /// a `?` suffix is used, e.g., `(expr)*` is greedy while `(expr)*?` is
      .          .          .          .               /// not. However, this can be inverted via the `U` "ungreedy" flag.
     12 ( 0.00%) .          .          .               pub greedy: bool,
      .          .          .          .               /// The expression being repeated.
      .          .          .          .               pub sub: Box<Hir>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Repetition {
      .          .          .          .               /// Returns a new repetition with the same `min`, `max` and `greedy`
      .          .          .          .               /// values, but with its sub-expression replaced with the one given.
  1,043 ( 0.00%) .          .          .               pub fn with(&self, sub: Hir) -> Repetition {
    745 ( 0.00%) .          .          .                   Repetition {
    149 ( 0.00%) .          .          .                       min: self.min,
    298 ( 0.00%) .          .          .                       max: self.max,
    149 ( 0.00%) .          .          .                       greedy: self.greedy,
      .          .          .          .                       sub: Box::new(sub),
      .          .          .          .                   }
  1,043 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A type describing the different flavors of `.`.
      .          .          .          .           ///
      .          .          .          .           /// This type is meant to be used with [`Hir::dot`], which is a convenience
      .          .          .          .           /// routine for building HIR values derived from the `.` regex.
      .          .          .          .           #[non_exhaustive]
      .          .          .          .           #[derive(Clone, Copy, Debug, Eq, PartialEq)]
-- line 1859 ----------------------------------------
-- line 1906 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// This is equivalent to `(?R-su:.)` and also `(?-u:[[\x00-\xFF]--\r\n])`.
      .          .          .          .               AnyByteExceptCRLF,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A custom `Drop` impl is used for `HirKind` such that it uses constant stack
      .          .          .          .           /// space but heap space proportional to the depth of the total `Hir`.
      .          .          .          .           impl Drop for Hir {
485,940 ( 0.15%) .          .          .               fn drop(&mut self) {
      .          .          .          .                   use core::mem;
      .          .          .          .           
624,780 ( 0.19%) .          .          .                   match *self.kind() {
      .          .          .          .                       HirKind::Empty
      .          .          .          .                       | HirKind::Literal(_)
      .          .          .          .                       | HirKind::Class(_)
      .          .          .          .                       | HirKind::Look(_) => return,
    693 ( 0.00%) .          .          .                       HirKind::Capture(ref x) if x.sub.kind.subs().is_empty() => return,
  4,068 ( 0.00%) .          .          .                       HirKind::Repetition(ref x) if x.sub.kind.subs().is_empty() => {
      .          .          .          .                           return
      .          .          .          .                       }
      .          .          .          .                       HirKind::Concat(ref x) if x.is_empty() => return,
      .          .          .          .                       HirKind::Alternation(ref x) if x.is_empty() => return,
      .          .          .          .                       _ => {}
      .          .          .          .                   }
      .          .          .          .           
    104 ( 0.00%) .          .          .                   let mut stack = vec![mem::replace(self, Hir::empty())];
247,662 ( 0.07%) .          .          .                   while let Some(mut expr) = stack.pop() {
192,626 ( 0.06%) .          .          .                       match expr.kind {
      .          .          .          .                           HirKind::Empty
      .          .          .          .                           | HirKind::Literal(_)
      .          .          .          .                           | HirKind::Class(_)
      .          .          .          .                           | HirKind::Look(_) => {}
      .          .          .          .                           HirKind::Capture(ref mut x) => {
    693 ( 0.00%) .          .          .                               stack.push(mem::replace(&mut x.sub, Hir::empty()));
      .          .          .          .                           }
      .          .          .          .                           HirKind::Repetition(ref mut x) => {
  2,029 ( 0.00%) .          .          .                               stack.push(mem::replace(&mut x.sub, Hir::empty()));
      .          .          .          .                           }
      .          .          .          .                           HirKind::Concat(ref mut x) => {
      .          .          .          .                               stack.extend(x.drain(..));
      .          .          .          .                           }
      .          .          .          .                           HirKind::Alternation(ref mut x) => {
      .          .          .          .                               stack.extend(x.drain(..));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
555,360 ( 0.17%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A type that collects various properties of an HIR value.
      .          .          .          .           ///
      .          .          .          .           /// Properties are always scalar values and represent meta data that is
      .          .          .          .           /// computed inductively on an HIR value. Properties are defined for all
      .          .          .          .           /// HIR values.
      .          .          .          .           ///
      .          .          .          .           /// All methods on a `Properties` value take constant time and are meant to
      .          .          .          .           /// be cheap to call.
     81 ( 0.00%) .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           pub struct Properties(Box<PropertiesI>);
      .          .          .          .           
      .          .          .          .           /// The property definition. It is split out so that we can box it, and
      .          .          .          .           /// there by make `Properties` use less stack size. This is kind-of important
      .          .          .          .           /// because every HIR value has a `Properties` attached to it.
      .          .          .          .           ///
      .          .          .          .           /// This does have the unfortunate consequence that creating any HIR value
      .          .          .          .           /// always leads to at least one alloc for properties, but this is generally
      .          .          .          .           /// true anyway (for pretty much all HirKinds except for look-arounds).
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           struct PropertiesI {
    116 ( 0.00%) .          .          .               minimum_len: Option<usize>,
     62 ( 0.00%) .          .          .               maximum_len: Option<usize>,
     58 ( 0.00%) .          .          .               look_set: LookSet,
     58 ( 0.00%) .          .          .               look_set_prefix: LookSet,
     58 ( 0.00%) .          .          .               look_set_suffix: LookSet,
     58 ( 0.00%) .          .          .               look_set_prefix_any: LookSet,
     58 ( 0.00%) .          .          .               look_set_suffix_any: LookSet,
    948 ( 0.00%) .          .          .               utf8: bool,
    255 ( 0.00%) .          .          .               explicit_captures_len: usize,
    116 ( 0.00%) .          .          .               static_explicit_captures_len: Option<usize>,
    174 ( 0.00%) .          .          .               literal: bool,
    313 ( 0.00%) .          .          .               alternation_literal: bool,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Properties {
      .          .          .          .               /// Returns the length (in bytes) of the smallest string matched by this
      .          .          .          .               /// HIR.
      .          .          .          .               ///
      .          .          .          .               /// A return value of `0` is possible and occurs when the HIR can match an
      .          .          .          .               /// empty string.
      .          .          .          .               ///
      .          .          .          .               /// `None` is returned when there is no minimum length. This occurs in
      .          .          .          .               /// precisely the cases where the HIR matches nothing. i.e., The language
      .          .          .          .               /// the regex matches is empty. An example of such a regex is `\P{any}`.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn minimum_len(&self) -> Option<usize> {
 21,201 ( 0.01%) .          .          .                   self.0.minimum_len
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the length (in bytes) of the longest string matched by this
      .          .          .          .               /// HIR.
      .          .          .          .               ///
      .          .          .          .               /// A return value of `0` is possible and occurs when nothing longer than
      .          .          .          .               /// the empty string is in the language described by this HIR.
      .          .          .          .               ///
      .          .          .          .               /// `None` is returned when there is no longest matching string. This
      .          .          .          .               /// occurs when the HIR matches nothing or when there is no upper bound on
      .          .          .          .               /// the length of matching strings. Example of such regexes are `\P{any}`
      .          .          .          .               /// (matches nothing) and `a+` (has no upper bound).
      .          .          .          .               #[inline]
      .          .          .          .               pub fn maximum_len(&self) -> Option<usize> {
 21,017 ( 0.01%) .          .          .                   self.0.maximum_len
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a set of all look-around assertions that appear at least once
      .          .          .          .               /// in this HIR value.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn look_set(&self) -> LookSet {
 24,440 ( 0.01%) .          .          .                   self.0.look_set
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a set of all look-around assertions that appear as a prefix for
      .          .          .          .               /// this HIR value. That is, the set returned corresponds to the set of
      .          .          .          .               /// assertions that must be passed before matching any bytes in a haystack.
      .          .          .          .               ///
      .          .          .          .               /// For example, `hir.look_set_prefix().contains(Look::Start)` returns true
      .          .          .          .               /// if and only if the HIR is fully anchored at the start.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn look_set_prefix(&self) -> LookSet {
  2,560 ( 0.00%) .          .          .                   self.0.look_set_prefix
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a set of all look-around assertions that appear as a _possible_
      .          .          .          .               /// prefix for this HIR value. That is, the set returned corresponds to the
      .          .          .          .               /// set of assertions that _may_ be passed before matching any bytes in a
      .          .          .          .               /// haystack.
      .          .          .          .               ///
      .          .          .          .               /// For example, `hir.look_set_prefix_any().contains(Look::Start)` returns
-- line 2042 ----------------------------------------
-- line 2051 ----------------------------------------
      .          .          .          .               /// this HIR value. That is, the set returned corresponds to the set of
      .          .          .          .               /// assertions that must be passed in order to be considered a match after
      .          .          .          .               /// all other consuming HIR expressions.
      .          .          .          .               ///
      .          .          .          .               /// For example, `hir.look_set_suffix().contains(Look::End)` returns true
      .          .          .          .               /// if and only if the HIR is fully anchored at the end.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn look_set_suffix(&self) -> LookSet {
  2,154 ( 0.00%) .          .          .                   self.0.look_set_suffix
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a set of all look-around assertions that appear as a _possible_
      .          .          .          .               /// suffix for this HIR value. That is, the set returned corresponds to the
      .          .          .          .               /// set of assertions that _may_ be passed before matching any bytes in a
      .          .          .          .               /// haystack.
      .          .          .          .               ///
      .          .          .          .               /// For example, `hir.look_set_suffix_any().contains(Look::End)` returns
-- line 2067 ----------------------------------------
-- line 2133 ----------------------------------------
      .          .          .          .               /// // are not valid UTF-8, when combined together, the
      .          .          .          .               /// // overall expression *does* match valid UTF-8!
      .          .          .          .               /// assert!(parse(r"(?-u)\xE2\x98\x83")?.properties().is_utf8());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_utf8(&self) -> bool {
 31,143 ( 0.01%) .          .          .                   self.0.utf8
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the total number of explicit capturing groups in the
      .          .          .          .               /// corresponding HIR.
      .          .          .          .               ///
      .          .          .          .               /// Note that this does not include the implicit capturing group
      .          .          .          .               /// corresponding to the entire match that is typically included by regex
      .          .          .          .               /// engines.
-- line 2149 ----------------------------------------
-- line 2157 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// assert_eq!(0, parse("a")?.properties().explicit_captures_len());
      .          .          .          .               /// assert_eq!(1, parse("(a)")?.properties().explicit_captures_len());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn explicit_captures_len(&self) -> usize {
    774 ( 0.00%) .          .          .                   self.0.explicit_captures_len
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the total number of explicit capturing groups that appear in
      .          .          .          .               /// every possible match.
      .          .          .          .               ///
      .          .          .          .               /// If the number of capture groups can vary depending on the match, then
      .          .          .          .               /// this returns `None`. That is, a value is only returned when the number
      .          .          .          .               /// of matching groups is invariant or "static."
-- line 2173 ----------------------------------------
-- line 2197 ----------------------------------------
      .          .          .          .               /// assert_eq!(None, len("a|(b)")?);
      .          .          .          .               /// assert_eq!(None, len("(b)*")?);
      .          .          .          .               /// assert_eq!(Some(1), len("(b)+")?);
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn static_explicit_captures_len(&self) -> Option<usize> {
 23,135 ( 0.01%) .          .          .                   self.0.static_explicit_captures_len
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return true if and only if this HIR is a simple literal. This is
      .          .          .          .               /// only true when this HIR expression is either itself a `Literal` or a
      .          .          .          .               /// concatenation of only `Literal`s.
      .          .          .          .               ///
      .          .          .          .               /// For example, `f` and `foo` are literals, but `f+`, `(foo)`, `foo()` and
      .          .          .          .               /// the empty string are not (even though they contain sub-expressions that
      .          .          .          .               /// are literals).
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_literal(&self) -> bool {
 18,314 ( 0.01%) .          .          .                   self.0.literal
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return true if and only if this HIR is either a simple literal or an
      .          .          .          .               /// alternation of simple literals. This is only
      .          .          .          .               /// true when this HIR expression is either itself a `Literal` or a
      .          .          .          .               /// concatenation of only `Literal`s or an alternation of only `Literal`s.
      .          .          .          .               ///
      .          .          .          .               /// For example, `f`, `foo`, `a|b|c`, and `foo|bar|baz` are alternation
      .          .          .          .               /// literals, but `f+`, `(foo)`, `foo()`, and the empty pattern are not
      .          .          .          .               /// (even though that contain sub-expressions that are literals).
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_alternation_literal(&self) -> bool {
  3,560 ( 0.00%) .          .          .                   self.0.alternation_literal
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the total amount of heap memory usage, in bytes, used by this
      .          .          .          .               /// `Properties` value.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn memory_usage(&self) -> usize {
      .          .          .          .                   core::mem::size_of::<PropertiesI>()
      .          .          .          .               }
-- line 2238 ----------------------------------------
-- line 2302 ----------------------------------------
      .          .          .          .               ///		hir2.properties(),
      .          .          .          .               ///		hir3.properties(),
      .          .          .          .               ///	]);
      .          .          .          .               /// assert_eq!(Some(1), unioned.minimum_len());
      .          .          .          .               /// assert_eq!(None, unioned.maximum_len());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
    567 ( 0.00%) .          .          .               pub fn union<I, P>(props: I) -> Properties
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = P>,
      .          .          .          .                   P: core::borrow::Borrow<Properties>,
      .          .          .          .               {
      .          .          .          .                   let mut it = props.into_iter().peekable();
      .          .          .          .                   // While empty alternations aren't possible, we still behave as if they
      .          .          .          .                   // are. When we have an empty alternate, then clearly the look-around
      .          .          .          .                   // prefix and suffix is empty. Otherwise, it is the intersection of all
-- line 2318 ----------------------------------------
-- line 2344 ----------------------------------------
      .          .          .          .                       utf8: true,
      .          .          .          .                       explicit_captures_len: 0,
      .          .          .          .                       static_explicit_captures_len,
      .          .          .          .                       literal: false,
      .          .          .          .                       alternation_literal: true,
      .          .          .          .                   };
      .          .          .          .                   let (mut min_poisoned, mut max_poisoned) = (false, false);
      .          .          .          .                   // Handle properties that need to visit every child hir.
    578 ( 0.00%) .          .          .                   for prop in it {
      .          .          .          .                       let p = prop.borrow();
      .          .          .          .                       props.look_set.set_union(p.look_set());
      .          .          .          .                       props.look_set_prefix.set_intersect(p.look_set_prefix());
      .          .          .          .                       props.look_set_suffix.set_intersect(p.look_set_suffix());
      .          .          .          .                       props.look_set_prefix_any.set_union(p.look_set_prefix_any());
      .          .          .          .                       props.look_set_suffix_any.set_union(p.look_set_suffix_any());
 35,988 ( 0.01%) .          .          .                       props.utf8 = props.utf8 && p.is_utf8();
      .          .          .          .                       props.explicit_captures_len = props
      .          .          .          .                           .explicit_captures_len
      .          .          .          .                           .saturating_add(p.explicit_captures_len());
 35,410 ( 0.01%) .          .          .                       if props.static_explicit_captures_len
      .          .          .          .                           != p.static_explicit_captures_len()
      .          .          .          .                       {
      .          .          .          .                           props.static_explicit_captures_len = None;
      .          .          .          .                       }
      .          .          .          .                       props.alternation_literal =
 35,410 ( 0.01%) .          .          .                           props.alternation_literal && p.is_literal();
 35,410 ( 0.01%) .          .          .                       if !min_poisoned {
 36,728 ( 0.01%) .          .          .                           if let Some(xmin) = p.minimum_len() {
123,935 ( 0.04%) .          .          .                               if props.minimum_len.map_or(true, |pmin| xmin < pmin) {
      .          .          .          .                                   props.minimum_len = Some(xmin);
      .          .          .          .                               }
      .          .          .          .                           } else {
      .          .          .          .                               props.minimum_len = None;
      .          .          .          .                               min_poisoned = true;
      .          .          .          .                           }
      .          .          .          .                       }
 53,111 ( 0.02%) .          .          .                       if !max_poisoned {
 36,754 ( 0.01%) .          .          .                           if let Some(xmax) = p.maximum_len() {
 88,500 ( 0.03%) .          .          .                               if props.maximum_len.map_or(true, |pmax| xmax > pmax) {
      .          .          .          .                                   props.maximum_len = Some(xmax);
      .          .          .          .                               }
      .          .          .          .                           } else {
      .          .          .          .                               props.maximum_len = None;
      .          .          .          .                               max_poisoned = true;
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Properties(Box::new(props))
    648 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Properties {
      .          .          .          .               /// Create a new set of HIR properties for an empty regex.
      .          .          .          .               fn empty() -> Properties {
      .          .          .          .                   let inner = PropertiesI {
      .          .          .          .                       minimum_len: Some(0),
      .          .          .          .                       maximum_len: Some(0),
-- line 2400 ----------------------------------------
-- line 2425 ----------------------------------------
      .          .          .          .                       static_explicit_captures_len: Some(0),
      .          .          .          .                       literal: false,
      .          .          .          .                       alternation_literal: false,
      .          .          .          .                   };
      .          .          .          .                   Properties(Box::new(inner))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a literal regex.
  5,736 ( 0.00%) .          .          .               fn literal(lit: &Literal) -> Properties {
 34,870 ( 0.01%) .          .          .                   let inner = PropertiesI {
  1,912 ( 0.00%) .          .          .                       minimum_len: Some(lit.0.len()),
      .          .          .          .                       maximum_len: Some(lit.0.len()),
      .          .          .          .                       look_set: LookSet::empty(),
      .          .          .          .                       look_set_prefix: LookSet::empty(),
      .          .          .          .                       look_set_suffix: LookSet::empty(),
      .          .          .          .                       look_set_prefix_any: LookSet::empty(),
      .          .          .          .                       look_set_suffix_any: LookSet::empty(),
123,390 ( 0.04%) .          .          .                       utf8: core::str::from_utf8(&lit.0).is_ok(),
     94 ( 0.00%) .          .          .           => /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/str/converts.rs:core::str::converts::from_utf8 (2x)
      .          .          .          .                       explicit_captures_len: 0,
      .          .          .          .                       static_explicit_captures_len: Some(0),
      .          .          .          .                       literal: true,
      .          .          .          .                       alternation_literal: true,
      .          .          .          .                   };
      .          .          .          .                   Properties(Box::new(inner))
  7,648 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a character class.
 13,640 ( 0.00%) .          .          .               fn class(class: &Class) -> Properties {
    330 ( 0.00%) .          .          .                   let inner = PropertiesI {
      .          .          .          .                       minimum_len: class.minimum_len(),
      .          .          .          .                       maximum_len: class.maximum_len(),
      .          .          .          .                       look_set: LookSet::empty(),
      .          .          .          .                       look_set_prefix: LookSet::empty(),
      .          .          .          .                       look_set_suffix: LookSet::empty(),
      .          .          .          .                       look_set_prefix_any: LookSet::empty(),
      .          .          .          .                       look_set_suffix_any: LookSet::empty(),
      .          .          .          .                       utf8: class.is_utf8(),
      .          .          .          .                       explicit_captures_len: 0,
      .          .          .          .                       static_explicit_captures_len: Some(0),
      .          .          .          .                       literal: false,
      .          .          .          .                       alternation_literal: false,
      .          .          .          .                   };
      .          .          .          .                   Properties(Box::new(inner))
 16,368 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a look-around assertion.
      4 ( 0.00%) .          .          .               fn look(look: Look) -> Properties {
      .          .          .          .                   let inner = PropertiesI {
      .          .          .          .                       minimum_len: Some(0),
      .          .          .          .                       maximum_len: Some(0),
      .          .          .          .                       look_set: LookSet::singleton(look),
      .          .          .          .                       look_set_prefix: LookSet::singleton(look),
      .          .          .          .                       look_set_suffix: LookSet::singleton(look),
      .          .          .          .                       look_set_prefix_any: LookSet::singleton(look),
      .          .          .          .                       look_set_suffix_any: LookSet::singleton(look),
-- line 2479 ----------------------------------------
-- line 2492 ----------------------------------------
      .          .          .          .                       // property borderline useless.
      .          .          .          .                       utf8: true,
      .          .          .          .                       explicit_captures_len: 0,
      .          .          .          .                       static_explicit_captures_len: Some(0),
      .          .          .          .                       literal: false,
      .          .          .          .                       alternation_literal: false,
      .          .          .          .                   };
      .          .          .          .                   Properties(Box::new(inner))
      4 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a repetition.
 14,238 ( 0.00%) .          .          .               fn repetition(rep: &Repetition) -> Properties {
  2,034 ( 0.00%) .          .          .                   let p = rep.sub.properties();
      .          .          .          .                   let minimum_len = p.minimum_len().map(|child_min| {
  2,034 ( 0.00%) .          .          .                       let rep_min = usize::try_from(rep.min).unwrap_or(usize::MAX);
      .          .          .          .                       child_min.saturating_mul(rep_min)
      .          .          .          .                   });
  3,981 ( 0.00%) .          .          .                   let maximum_len = rep.max.and_then(|rep_max| {
      .          .          .          .                       let rep_max = usize::try_from(rep_max).ok()?;
      .          .          .          .                       let child_max = p.maximum_len()?;
      .          .          .          .                       child_max.checked_mul(rep_max)
      .          .          .          .                   });
      .          .          .          .           
      .          .          .          .                   let mut inner = PropertiesI {
      .          .          .          .                       minimum_len,
      .          .          .          .                       maximum_len,
-- line 2517 ----------------------------------------
-- line 2524 ----------------------------------------
      .          .          .          .                       explicit_captures_len: p.explicit_captures_len(),
      .          .          .          .                       static_explicit_captures_len: p.static_explicit_captures_len(),
      .          .          .          .                       literal: false,
      .          .          .          .                       alternation_literal: false,
      .          .          .          .                   };
      .          .          .          .                   // If the repetition operator can match the empty string, then its
      .          .          .          .                   // lookset prefix and suffixes themselves remain empty since they are
      .          .          .          .                   // no longer required to match.
  4,068 ( 0.00%) .          .          .                   if rep.min > 0 {
      .          .          .          .                       inner.look_set_prefix = p.look_set_prefix();
      .          .          .          .                       inner.look_set_suffix = p.look_set_suffix();
      .          .          .          .                   }
      .          .          .          .                   // If the static captures len of the sub-expression is not known or
      .          .          .          .                   // is greater than zero, then it automatically propagates to the
      .          .          .          .                   // repetition, regardless of the repetition. Otherwise, it might
      .          .          .          .                   // change, but only when the repetition can match 0 times.
      .          .          .          .                   if rep.min == 0
  3,548 ( 0.00%) .          .          .                       && inner.static_explicit_captures_len.map_or(false, |len| len > 0)
      .          .          .          .                   {
      .          .          .          .                       // If we require a match 0 times, then our captures len is
      .          .          .          .                       // guaranteed to be zero. Otherwise, if we *can* match the empty
      .          .          .          .                       // string, then it's impossible to know how many captures will be
      .          .          .          .                       // in the resulting match.
      .          .          .          .                       if rep.max == Some(0) {
      .          .          .          .                           inner.static_explicit_captures_len = Some(0);
      .          .          .          .                       } else {
      .          .          .          .                           inner.static_explicit_captures_len = None;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Properties(Box::new(inner))
 16,272 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a capture.
  4,851 ( 0.00%) .          .          .               fn capture(capture: &Capture) -> Properties {
    693 ( 0.00%) .          .          .                   let p = capture.sub.properties();
      .          .          .          .                   Properties(Box::new(PropertiesI {
      .          .          .          .                       explicit_captures_len: p.explicit_captures_len().saturating_add(1),
      .          .          .          .                       static_explicit_captures_len: p
      .          .          .          .                           .static_explicit_captures_len()
      .          .          .          .                           .map(|len| len.saturating_add(1)),
      .          .          .          .                       literal: false,
      .          .          .          .                       alternation_literal: false,
      .          .          .          .                       ..*p.0.clone()
      .          .          .          .                   }))
  5,544 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a concatenation.
      .          .          .          .               fn concat(concat: &[Hir]) -> Properties {
      .          .          .          .                   // The base case is an empty concatenation, which matches the empty
      .          .          .          .                   // string. Note though that empty concatenations aren't possible,
      .          .          .          .                   // because the Hir::concat smart constructor rewrites those as
      .          .          .          .                   // Hir::empty.
      .          .          .          .                   let mut props = PropertiesI {
-- line 2576 ----------------------------------------
-- line 2586 ----------------------------------------
      .          .          .          .                       static_explicit_captures_len: Some(0),
      .          .          .          .                       literal: true,
      .          .          .          .                       alternation_literal: true,
      .          .          .          .                   };
      .          .          .          .                   // Handle properties that need to visit every child hir.
      .          .          .          .                   for x in concat.iter() {
      .          .          .          .                       let p = x.properties();
      .          .          .          .                       props.look_set.set_union(p.look_set());
 13,438 ( 0.00%) .          .          .                       props.utf8 = props.utf8 && p.is_utf8();
      .          .          .          .                       props.explicit_captures_len = props
      .          .          .          .                           .explicit_captures_len
      .          .          .          .                           .saturating_add(p.explicit_captures_len());
      .          .          .          .                       props.static_explicit_captures_len = p
      .          .          .          .                           .static_explicit_captures_len()
      .          .          .          .                           .and_then(|len1| {
      .          .          .          .                               Some((len1, props.static_explicit_captures_len?))
      .          .          .          .                           })
      .          .          .          .                           .and_then(|(len1, len2)| Some(len1.saturating_add(len2)));
 13,438 ( 0.00%) .          .          .                       props.literal = props.literal && p.is_literal();
      .          .          .          .                       props.alternation_literal =
 13,438 ( 0.00%) .          .          .                           props.alternation_literal && p.is_alternation_literal();
 16,597 ( 0.00%) .          .          .                       if let Some(minimum_len) = props.minimum_len {
 13,438 ( 0.00%) .          .          .                           match p.minimum_len() {
      .          .          .          .                               None => props.minimum_len = None,
      .          .          .          .                               Some(len) => {
      .          .          .          .                                   // We use saturating arithmetic here because the
      .          .          .          .                                   // minimum is just a lower bound. We can't go any
      .          .          .          .                                   // higher than what our number types permit.
      .          .          .          .                                   props.minimum_len =
      .          .          .          .                                       Some(minimum_len.saturating_add(len));
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                       }
 19,677 ( 0.01%) .          .          .                       if let Some(maximum_len) = props.maximum_len {
 12,478 ( 0.00%) .          .          .                           match p.maximum_len() {
      .          .          .          .                               None => props.maximum_len = None,
      .          .          .          .                               Some(len) => {
      .          .          .          .                                   props.maximum_len = maximum_len.checked_add(len)
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // Handle the prefix properties, which only requires visiting
      .          .          .          .                   // child exprs until one matches more than the empty string.
      .          .          .          .                   let mut it = concat.iter();
      .          .          .          .                   while let Some(x) = it.next() {
      .          .          .          .                       props.look_set_prefix.set_union(x.properties().look_set_prefix());
      .          .          .          .                       props
      .          .          .          .                           .look_set_prefix_any
      .          .          .          .                           .set_union(x.properties().look_set_prefix_any());
 10,657 ( 0.00%) .          .          .                       if x.properties().maximum_len().map_or(true, |x| x > 0) {
      .          .          .          .                           break;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // Same thing for the suffix properties, but in reverse.
      .          .          .          .                   let mut it = concat.iter().rev();
 10,365 ( 0.00%) .          .          .                   while let Some(x) = it.next() {
      .          .          .          .                       props.look_set_suffix.set_union(x.properties().look_set_suffix());
      .          .          .          .                       props
      .          .          .          .                           .look_set_suffix_any
      .          .          .          .                           .set_union(x.properties().look_set_suffix_any());
 10,350 ( 0.00%) .          .          .                       if x.properties().maximum_len().map_or(true, |x| x > 0) {
      .          .          .          .                           break;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Properties(Box::new(props))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new set of HIR properties for a concatenation.
      .          .          .          .               fn alternation(alts: &[Hir]) -> Properties {
  1,156 ( 0.00%) .          .          .                   Properties::union(alts.iter().map(|hir| hir.properties()))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A set of look-around assertions.
      .          .          .          .           ///
      .          .          .          .           /// This is useful for efficiently tracking look-around assertions. For
      .          .          .          .           /// example, an [`Hir`] provides properties that return `LookSet`s.
  2,128 ( 0.00%) .          .          .           #[derive(Clone, Copy, Default, Eq, PartialEq)]
      .          .          .          .           pub struct LookSet {
      .          .          .          .               /// The underlying representation this set is exposed to make it possible
      .          .          .          .               /// to store it somewhere efficiently. The representation is that
      .          .          .          .               /// of a bitset, where each assertion occupies bit `i` where `i =
      .          .          .          .               /// Look::as_repr()`.
      .          .          .          .               ///
      .          .          .          .               /// Note that users of this internal representation must permit the full
      .          .          .          .               /// range of `u16` values to be represented. For example, even if the
-- line 2672 ----------------------------------------
-- line 2712 ----------------------------------------
      .          .          .          .               pub fn is_empty(self) -> bool {
      .          .          .          .                   self.len() == 0
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if the given look-around assertion is in this
      .          .          .          .               /// set.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn contains(self, look: Look) -> bool {
     58 ( 0.00%) .          .          .                   self.bits & look.as_repr() != 0
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this set contains any anchor assertions.
      .          .          .          .               /// This includes both "start/end of haystack" and "start/end of line."
      .          .          .          .               #[inline]
      .          .          .          .               pub fn contains_anchor(&self) -> bool {
      .          .          .          .                   self.contains_anchor_haystack() || self.contains_anchor_line()
      .          .          .          .               }
-- line 2728 ----------------------------------------
-- line 2841 ----------------------------------------
      .          .          .          .               #[inline]
      .          .          .          .               pub fn set_subtract(&mut self, other: LookSet) {
      .          .          .          .                   *self = self.subtract(other);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a new set that is the union of this and the one given.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn union(self, other: LookSet) -> LookSet {
  8,422 ( 0.00%) .          .          .                   LookSet { bits: self.bits | other.bits }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Updates this set in place with the result of unioning it with the one
      .          .          .          .               /// given.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn set_union(&mut self, other: LookSet) {
      .          .          .          .                   *self = self.union(other);
      .          .          .          .               }
-- line 2857 ----------------------------------------
-- line 2935 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Given a sequence of HIR values where each value corresponds to a Unicode
      .          .          .          .           /// class (or an all-ASCII byte class), return a single Unicode class
      .          .          .          .           /// corresponding to the union of the classes found.
      .          .          .          .           fn class_chars(hirs: &[Hir]) -> Option<Class> {
      .          .          .          .               let mut cls = ClassUnicode::new(vec![]);
      .          .          .          .               for hir in hirs.iter() {
  5,202 ( 0.00%) .          .          .                   match *hir.kind() {
      .          .          .          .                       HirKind::Class(Class::Unicode(ref cls2)) => {
      .          .          .          .                           cls.union(cls2);
      .          .          .          .                       }
      .          .          .          .                       HirKind::Class(Class::Bytes(ref cls2)) => {
      .          .          .          .                           cls.union(&cls2.to_unicode_class()?);
      .          .          .          .                       }
      .          .          .          .                       _ => return None,
      .          .          .          .                   };
-- line 2951 ----------------------------------------
-- line 2954 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Given a sequence of HIR values where each value corresponds to a byte class
      .          .          .          .           /// (or an all-ASCII Unicode class), return a single byte class corresponding
      .          .          .          .           /// to the union of the classes found.
      .          .          .          .           fn class_bytes(hirs: &[Hir]) -> Option<Class> {
      .          .          .          .               let mut cls = ClassBytes::new(vec![]);
      .          .          .          .               for hir in hirs.iter() {
  4,754 ( 0.00%) .          .          .                   match *hir.kind() {
      .          .          .          .                       HirKind::Class(Class::Unicode(ref cls2)) => {
      1 ( 0.00%) .          .          .                           cls.union(&cls2.to_byte_class()?);
      .          .          .          .                       }
      .          .          .          .                       HirKind::Class(Class::Bytes(ref cls2)) => {
      .          .          .          .                           cls.union(cls2);
      .          .          .          .                       }
      .          .          .          .                       _ => return None,
      .          .          .          .                   };
      .          .          .          .               }
      .          .          .          .               Some(Class::Bytes(cls))
-- line 2972 ----------------------------------------
-- line 2973 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Given a sequence of HIR values where each value corresponds to a literal
      .          .          .          .           /// that is a single `char`, return that sequence of `char`s. Otherwise return
      .          .          .          .           /// None. No deduplication is done.
      .          .          .          .           fn singleton_chars(hirs: &[Hir]) -> Option<Vec<char>> {
      .          .          .          .               let mut singletons = vec![];
      .          .          .          .               for hir in hirs.iter() {
  1,246 ( 0.00%) .          .          .                   let literal = match *hir.kind() {
      .          .          .          .                       HirKind::Literal(Literal(ref bytes)) => bytes,
      .          .          .          .                       _ => return None,
      .          .          .          .                   };
  4,131 ( 0.00%) .          .          .                   let ch = match crate::debug::utf8_decode(literal) {
  6,810 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/debug.rs:regex_syntax::debug::utf8_decode (454x)
      .          .          .          .                       None => return None,
      .          .          .          .                       Some(Err(_)) => return None,
      .          .          .          .                       Some(Ok(ch)) => ch,
      .          .          .          .                   };
    918 ( 0.00%) .          .          .                   if literal.len() != ch.len_utf8() {
      .          .          .          .                       return None;
      .          .          .          .                   }
      .          .          .          .                   singletons.push(ch);
      .          .          .          .               }
      1 ( 0.00%) .          .          .               Some(singletons)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Given a sequence of HIR values where each value corresponds to a literal
      .          .          .          .           /// that is a single byte, return that sequence of bytes. Otherwise return
      .          .          .          .           /// None. No deduplication is done.
      .          .          .          .           fn singleton_bytes(hirs: &[Hir]) -> Option<Vec<u8>> {
      .          .          .          .               let mut singletons = vec![];
      .          .          .          .               for hir in hirs.iter() {
  1,236 ( 0.00%) .          .          .                   let literal = match *hir.kind() {
      .          .          .          .                       HirKind::Literal(Literal(ref bytes)) => bytes,
      .          .          .          .                       _ => return None,
      .          .          .          .                   };
    908 ( 0.00%) .          .          .                   if literal.len() != 1 {
      .          .          .          .                       return None;
      .          .          .          .                   }
     78 ( 0.00%) .          .          .                   singletons.push(literal[0]);
      .          .          .          .               }
      .          .          .          .               Some(singletons)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Looks for a common prefix in the list of alternation branches given. If one
      .          .          .          .           /// is found, then an equivalent but (hopefully) simplified Hir is returned.
      .          .          .          .           /// Otherwise, the original given list of branches is returned unmodified.
      .          .          .          .           ///
-- line 3019 ----------------------------------------
-- line 3020 ----------------------------------------
      .          .          .          .           /// This is not quite as good as it could be. Right now, it requires that
      .          .          .          .           /// all branches are 'Concat' expressions. It also doesn't do well with
      .          .          .          .           /// literals. For example, given 'foofoo|foobar', it will not refactor it to
      .          .          .          .           /// 'foo(?:foo|bar)' because literals are flattened into their own special
      .          .          .          .           /// concatenation. (One wonders if perhaps 'Literal' should be a single atom
      .          .          .          .           /// instead of a string of bytes because of this. Otherwise, handling the
      .          .          .          .           /// current representation in this routine will be pretty gnarly. Sigh.)
      .          .          .          .           fn lift_common_prefix(hirs: Vec<Hir>) -> Result<Hir, Vec<Hir>> {
  1,158 ( 0.00%) .          .          .               if hirs.len() <= 1 {
      .          .          .          .                   return Err(hirs);
      .          .          .          .               }
  1,158 ( 0.00%) .          .          .               let mut prefix = match hirs[0].kind() {
      .          .          .          .                   HirKind::Concat(ref xs) => &**xs,
      .          .          .          .                   _ => return Err(hirs),
      .          .          .          .               };
    206 ( 0.00%) .          .          .               if prefix.is_empty() {
      .          .          .          .                   return Err(hirs);
      .          .          .          .               }
      .          .          .          .               for h in hirs.iter().skip(1) {
    464 ( 0.00%) .          .          .                   let concat = match h.kind() {
      .          .          .          .                       HirKind::Concat(ref xs) => xs,
      .          .          .          .                       _ => return Err(hirs),
      .          .          .          .                   };
      .          .          .          .                   let common_len = prefix
      .          .          .          .                       .iter()
      .          .          .          .                       .zip(concat.iter())
      .          .          .          .                       .take_while(|(x, y)| x == y)
      .          .          .          .                       .count();
      .          .          .          .                   prefix = &prefix[..common_len];
     96 ( 0.00%) .          .          .                   if prefix.is_empty() {
      .          .          .          .                       return Err(hirs);
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .               let len = prefix.len();
      .          .          .          .               assert_ne!(0, len);
      .          .          .          .               let mut prefix_concat = vec![];
      .          .          .          .               let mut suffix_alts = vec![];
     51 ( 0.00%) .          .          .               for h in hirs {
     10 ( 0.00%) .          .          .                   let mut concat = match h.into_kind() {
      .          .          .          .                       HirKind::Concat(xs) => xs,
      .          .          .          .                       // We required all sub-expressions to be
      .          .          .          .                       // concats above, so we're only here if we
      .          .          .          .                       // have a concat.
      .          .          .          .                       _ => unreachable!(),
      .          .          .          .                   };
     15 ( 0.00%) .          .          .                   suffix_alts.push(Hir::concat(concat.split_off(len)));
  6,308 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (5x)
     10 ( 0.00%) .          .          .                   if prefix_concat.is_empty() {
      .          .          .          .                       prefix_concat = concat;
      .          .          .          .                   }
      .          .          .          .               }
      4 ( 0.00%) .          .          .               let mut concat = prefix_concat;
      7 ( 0.00%) .          .          .               concat.push(Hir::alternation(suffix_alts));
  4,939 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation'2 (1x)
     12 ( 0.00%) .          .          .               Ok(Hir::concat(concat))
  1,101 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (1x)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[cfg(test)]
      .          .          .          .           mod tests {
      .          .          .          .               use super::*;
      .          .          .          .           
      .          .          .          .               fn uclass(ranges: &[(char, char)]) -> ClassUnicode {
      .          .          .          .                   let ranges: Vec<ClassUnicodeRange> = ranges
-- line 3080 ----------------------------------------

828,070 ( 0.25%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 17 ----------------------------------------
        .          .          .          .                       let $len = unsafe { &mut *(&raw mut $this.end_or_len).cast::<usize>() };
        .          .          .          .                       $zst_body
        .          .          .          .                   } else {
        .          .          .          .                       // SAFETY: for non-ZSTs, the type invariant ensures it cannot be null
        .          .          .          .                       let $end = unsafe { &mut *(&raw mut $this.end_or_len).cast::<NonNull<T>>() };
        .          .          .          .                       $other_body
        .          .          .          .                   }
        .          .          .          .               }};
1,694,119 ( 0.51%) .          .          .               ($this:ident, $len:ident => $zst_body:expr, $end:ident => $other_body:expr,) => {{
        .          .          .          .                   #![allow(unused_unsafe)] // we're sometimes used within an unsafe block
        .          .          .          .           
        .          .          .          .                   if T::IS_ZST {
        .          .          .          .                       let $len = $this.end_or_len.addr();
        .          .          .          .                       $zst_body
        .          .          .          .                   } else {
        .          .          .          .                       // SAFETY: for non-ZSTs, the type invariant ensures it cannot be null
   43,810 ( 0.01%) .          .          .                       let $end = unsafe { *(&raw const $this.end_or_len).cast::<NonNull<T>>() };
        .          .          .          .                       $other_body
        .          .          .          .                   }
        .          .          .          .               }};
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           // Inlining is_empty and len makes a huge performance difference
        .          .          .          .           macro_rules! is_empty {
        .          .          .          .               ($self: ident) => {
-- line 41 ----------------------------------------
-- line 49 ----------------------------------------
        .          .          .          .           macro_rules! len {
        .          .          .          .               ($self: ident) => {{
        .          .          .          .                   if_zst!($self,
        .          .          .          .                       len => len,
        .          .          .          .                       end => {
        .          .          .          .                           // To get rid of some bounds checks (see `position`), we use ptr_sub instead of
        .          .          .          .                           // offset_from (Tested by `codegen/slice-position-bounds-check`.)
        .          .          .          .                           // SAFETY: by the type invariant pointers are aligned and `start <= end`
    2,474 ( 0.00%) .          .          .                           unsafe { end.sub_ptr($self.ptr) }
        .          .          .          .                       },
        .          .          .          .                   )
        .          .          .          .               }};
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           // The shared definition of the `Iter` and `IterMut` iterators
        .          .          .          .           macro_rules! iterator {
        .          .          .          .               (
-- line 65 ----------------------------------------
-- line 100 ----------------------------------------
        .          .          .          .                           let old = self.ptr;
        .          .          .          .           
        .          .          .          .                           // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,
        .          .          .          .                           // so this new pointer is inside `self` and thus guaranteed to be non-null.
        .          .          .          .                           unsafe {
        .          .          .          .                               if_zst!(mut self,
        .          .          .          .                                   // Using the intrinsic directly avoids emitting a UbCheck
        .          .          .          .                                   len => *len = crate::intrinsics::unchecked_sub(*len, offset),
   71,661 ( 0.02%) .          .          .                                   _end => self.ptr = self.ptr.add(offset),
        .          .          .          .                               );
        .          .          .          .                           }
        .          .          .          .                           old
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       // Helper function for moving the end of the iterator backwards by `offset` elements,
        .          .          .          .                       // returning the new end.
        .          .          .          .                       // Unsafe because the offset must not exceed `self.len()`.
-- line 116 ----------------------------------------
-- line 165 ----------------------------------------
        .          .          .          .                                   Some(self.next_unchecked())
        .          .          .          .                               }
        .          .          .          .                           }
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       #[inline]
        .          .          .          .                       fn size_hint(&self) -> (usize, Option<usize>) {
        .          .          .          .                           let exact = len!(self);
       27 ( 0.00%) .          .          .                           (exact, Some(exact))
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       #[inline]
        .          .          .          .                       fn count(self) -> usize {
        .          .          .          .                           len!(self)
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       #[inline]
        .          .          .          .                       fn nth(&mut self, n: usize) -> Option<$elem> {
      177 ( 0.00%) .          .          .                           if n >= len!(self) {
        .          .          .          .                               // This iterator is now empty.
        .          .          .          .                               if_zst!(mut self,
        .          .          .          .                                   len => *len = 0,
        .          .          .          .                                   end => self.ptr = *end,
        .          .          .          .                               );
        .          .          .          .                               return None;
        .          .          .          .                           }
        .          .          .          .                           // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.
-- line 191 ----------------------------------------
-- line 221 ----------------------------------------
        .          .          .          .                           //   some optimizations, see #111603
        .          .          .          .                           // - avoids Option wrapping/matching
        .          .          .          .                           if is_empty!(self) {
        .          .          .          .                               return init;
        .          .          .          .                           }
        .          .          .          .                           let mut acc = init;
        .          .          .          .                           let mut i = 0;
        .          .          .          .                           let len = len!(self);
    1,494 ( 0.00%) .          .          .                           loop {
        .          .          .          .                               // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of
        .          .          .          .                               // the slice allocation
   12,577 ( 0.00%) .          .          .                               acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });
        .          .          .          .                               // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the
        .          .          .          .                               // slice had that length, in which case we'll break out of the loop
        .          .          .          .                               // after the increment
        .          .          .          .                               i = unsafe { i.unchecked_add(1) };
   70,226 ( 0.02%) .          .          .                               if i == len {
        .          .          .          .                                   break;
        .          .          .          .                               }
        .          .          .          .                           }
        .          .          .          .                           acc
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       // We override the default implementation, which uses `try_fold`,
        .          .          .          .                       // because this simple implementation generates less LLVM IR and is
-- line 245 ----------------------------------------
-- line 259 ----------------------------------------
        .          .          .          .                       // because this simple implementation generates less LLVM IR and is
        .          .          .          .                       // faster to compile.
        .          .          .          .                       #[inline]
        .          .          .          .                       fn all<F>(&mut self, mut f: F) -> bool
        .          .          .          .                       where
        .          .          .          .                           Self: Sized,
        .          .          .          .                           F: FnMut(Self::Item) -> bool,
        .          .          .          .                       {
    2,504 ( 0.00%) .          .          .                           while let Some(x) = self.next() {
   13,406 ( 0.00%) .          .          .                               if !f(x) {
        .          .          .          .                                   return false;
        .          .          .          .                               }
        .          .          .          .                           }
        .          .          .          .                           true
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       // We override the default implementation, which uses `try_fold`,
        .          .          .          .                       // because this simple implementation generates less LLVM IR and is
        .          .          .          .                       // faster to compile.
        .          .          .          .                       #[inline]
        .          .          .          .                       fn any<F>(&mut self, mut f: F) -> bool
        .          .          .          .                       where
        .          .          .          .                           Self: Sized,
        .          .          .          .                           F: FnMut(Self::Item) -> bool,
        .          .          .          .                       {
      282 ( 0.00%) .          .          .                           while let Some(x) = self.next() {
    4,894 ( 0.00%) .          .          .                               if f(x) {
        .          .          .          .                                   return true;
        .          .          .          .                               }
        .          .          .          .                           }
        .          .          .          .                           false
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       // We override the default implementation, which uses `try_fold`,
        .          .          .          .                       // because this simple implementation generates less LLVM IR and is
        .          .          .          .                       // faster to compile.
        .          .          .          .                       #[inline]
        .          .          .          .                       fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>
        .          .          .          .                       where
        .          .          .          .                           Self: Sized,
        .          .          .          .                           P: FnMut(&Self::Item) -> bool,
        .          .          .          .                       {
       30 ( 0.00%) .          .          .                           while let Some(x) = self.next() {
      192 ( 0.00%) .          .          .                               if predicate(&x) {
        .          .          .          .                                   return Some(x);
        .          .          .          .                               }
        .          .          .          .                           }
        .          .          .          .                           None
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       // We override the default implementation, which uses `try_fold`,
        .          .          .          .                       // because this simple implementation generates less LLVM IR and is
-- line 310 ----------------------------------------
-- line 311 ----------------------------------------
        .          .          .          .                       // faster to compile.
        .          .          .          .                       #[inline]
        .          .          .          .                       fn find_map<B, F>(&mut self, mut f: F) -> Option<B>
        .          .          .          .                       where
        .          .          .          .                           Self: Sized,
        .          .          .          .                           F: FnMut(Self::Item) -> Option<B>,
        .          .          .          .                       {
        .          .          .          .                           while let Some(x) = self.next() {
       13 ( 0.00%) .          .          .                               if let Some(y) = f(x) {
       91 ( 0.00%) .          .          .                                   return Some(y);
        .          .          .          .                               }
        .          .          .          .                           }
        2 ( 0.00%) .          .          .                           None
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       // We override the default implementation, which uses `try_fold`,
        .          .          .          .                       // because this simple implementation generates less LLVM IR and is
        .          .          .          .                       // faster to compile. Also, the `assume` avoids a bounds check.
        .          .          .          .                       #[inline]
        .          .          .          .                       #[rustc_inherit_overflow_checks]
        .          .          .          .                       fn position<P>(&mut self, mut predicate: P) -> Option<usize> where
        .          .          .          .                           Self: Sized,
        .          .          .          .                           P: FnMut(Self::Item) -> bool,
        .          .          .          .                       {
        .          .          .          .                           let n = len!(self);
        .          .          .          .                           let mut i = 0;
        .          .          .          .                           while let Some(x) = self.next() {
       86 ( 0.00%) .          .          .                               if predicate(x) {
        .          .          .          .                                   // SAFETY: we are guaranteed to be in bounds by the loop invariant:
        .          .          .          .                                   // when `i >= n`, `self.next()` returns `None` and the loop breaks.
        .          .          .          .                                   unsafe { assert_unchecked(i < n) };
        .          .          .          .                                   return Some(i);
        .          .          .          .                               }
       14 ( 0.00%) .          .          .                               i += 1;
        .          .          .          .                           }
        .          .          .          .                           None
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       // We override the default implementation, which uses `try_fold`,
        .          .          .          .                       // because this simple implementation generates less LLVM IR and is
        .          .          .          .                       // faster to compile. Also, the `assume` avoids a bounds check.
        .          .          .          .                       #[inline]
-- line 352 ----------------------------------------

  314,577 ( 0.09%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/prefilter.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 137 ----------------------------------------
     .          .          .          .                       .as_packed()
     .          .          .          .                       .map(|kind| packed::Config::new().match_kind(kind).builder());
     .          .          .          .                   Builder {
     .          .          .          .                       count: 0,
     .          .          .          .                       ascii_case_insensitive: false,
     .          .          .          .                       start_bytes: StartBytesBuilder::new(),
     .          .          .          .                       rare_bytes: RareBytesBuilder::new(),
     .          .          .          .                       memmem: MemmemBuilder::default(),
    96 ( 0.00%) .          .          .                       packed: pbuilder,
     .          .          .          .                       enabled: true,
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Enable ASCII case insensitivity. When set, byte strings added to this
     .          .          .          .               /// builder will be interpreted without respect to ASCII case.
     .          .          .          .               pub(crate) fn ascii_case_insensitive(mut self, yes: bool) -> Builder {
     .          .          .          .                   self.ascii_case_insensitive = yes;
-- line 153 ----------------------------------------
-- line 155 ----------------------------------------
     .          .          .          .                   self.rare_bytes = self.rare_bytes.ascii_case_insensitive(yes);
     .          .          .          .                   self
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return a prefilter suitable for quickly finding potential matches.
     .          .          .          .               ///
     .          .          .          .               /// All patterns added to an Aho-Corasick automaton should be added to this
     .          .          .          .               /// builder before attempting to construct the prefilter.
   480 ( 0.00%) .          .          .               pub(crate) fn build(&self) -> Option<Prefilter> {
    96 ( 0.00%) .          .          .                   if !self.enabled {
     .          .          .          .                       debug!("prefilter not enabled, skipping");
     .          .          .          .                       return None;
     .          .          .          .                   }
     .          .          .          .                   // If we only have one pattern, then deferring to memmem is always
     .          .          .          .                   // the best choice. This is kind of a weird case, because, well, why
     .          .          .          .                   // use Aho-Corasick if you only have one pattern? But maybe you don't
     .          .          .          .                   // know exactly how many patterns you'll get up front, and you need to
     .          .          .          .                   // support the option of multiple patterns. So instead of relying on
     .          .          .          .                   // the caller to branch and use memmem explicitly, we just do it for
     .          .          .          .                   // them.
   144 ( 0.00%) .          .          .                   if !self.ascii_case_insensitive {
     .          .          .          .                       if let Some(pre) = self.memmem.build() {
     .          .          .          .                           debug!("using memmem prefilter");
     .          .          .          .                           return Some(pre);
     .          .          .          .                       }
     .          .          .          .                   }
   192 ( 0.00%) .          .          .                   let (packed, patlen, minlen) = if self.ascii_case_insensitive {
     .          .          .          .                       (None, usize::MAX, 0)
     .          .          .          .                   } else {
    48 ( 0.00%) .          .          .                       let patlen = self.packed.as_ref().map_or(usize::MAX, |p| p.len());
     .          .          .          .                       let minlen = self.packed.as_ref().map_or(0, |p| p.minimum_len());
     .          .          .          .                       let packed =
    48 ( 0.00%) .          .          .                           self.packed.as_ref().and_then(|b| b.build()).map(|s| {
 1,200 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/api.rs:aho_corasick::packed::api::Builder::build (48x)
     .          .          .          .                               let memory_usage = s.memory_usage();
     .          .          .          .                               debug!(
     .          .          .          .                                   "built packed prefilter (len: {}, \
     .          .          .          .                                    minimum pattern len: {}, memory usage: {}) \
     .          .          .          .                                    for consideration",
     .          .          .          .                                   patlen, minlen, memory_usage,
     .          .          .          .                               );
     .          .          .          .                               Prefilter { finder: Arc::new(Packed(s)), memory_usage }
     .          .          .          .                           });
     .          .          .          .                       (packed, patlen, minlen)
     .          .          .          .                   };
   576 ( 0.00%) .          .          .                   match (self.start_bytes.build(), self.rare_bytes.build()) {
     .          .          .          .                       // If we could build both start and rare prefilters, then there are
     .          .          .          .                       // a few cases in which we'd want to use the start-byte prefilter
     .          .          .          .                       // over the rare-byte prefilter, since the former has lower
     .          .          .          .                       // overhead.
     .          .          .          .                       (prestart @ Some(_), prerare @ Some(_)) => {
     .          .          .          .                           debug!(
     .          .          .          .                               "both start (len={}, rank={}) and \
     .          .          .          .                                rare (len={}, rank={}) byte prefilters \
-- line 207 ----------------------------------------
-- line 281 ----------------------------------------
     .          .          .          .                               return packed;
     .          .          .          .                           }
     .          .          .          .                           debug!(
     .          .          .          .                               "have rare byte prefilter but not start byte prefilter, \
     .          .          .          .                                so using rare byte prefilter",
     .          .          .          .                           );
     .          .          .          .                           prerare
     .          .          .          .                       }
    96 ( 0.00%) .          .          .                       (None, None) if self.ascii_case_insensitive => {
     .          .          .          .                           debug!(
     .          .          .          .                               "no start or rare byte prefilter and ASCII case \
     .          .          .          .                                insensitivity was enabled, so skipping prefilter",
     .          .          .          .                           );
     .          .          .          .                           None
     .          .          .          .                       }
     .          .          .          .                       (None, None) => {
     .          .          .          .                           if packed.is_some() {
     .          .          .          .                               debug!("falling back to packed prefilter");
     .          .          .          .                           } else {
     .          .          .          .                               debug!("no prefilter available");
     .          .          .          .                           }
   240 ( 0.00%) .          .          .                           packed
     .          .          .          .                       }
     .          .          .          .                   }
   432 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add a literal string to this prefilter builder.
     .          .          .          .               pub(crate) fn add(&mut self, bytes: &[u8]) {
     .          .          .          .                   if bytes.is_empty() {
     .          .          .          .                       self.enabled = false;
     .          .          .          .                   }
     .          .          .          .                   if !self.enabled {
     .          .          .          .                       return;
-- line 313 ----------------------------------------
-- line 538 ----------------------------------------
     .          .          .          .               /// Build the rare bytes prefilter.
     .          .          .          .               ///
     .          .          .          .               /// If there are more than 3 distinct rare bytes found, or if heuristics
     .          .          .          .               /// otherwise determine that this prefilter should not be used, then `None`
     .          .          .          .               /// is returned.
     .          .          .          .               fn build(&self) -> Option<Prefilter> {
     .          .          .          .                   #[cfg(feature = "perf-literal")]
     .          .          .          .                   fn imp(builder: &RareBytesBuilder) -> Option<Prefilter> {
   144 ( 0.00%) .          .          .                       if !builder.available || builder.count > 3 {
     .          .          .          .                           return None;
     .          .          .          .                       }
   384 ( 0.00%) .          .          .                       let (mut bytes, mut len) = ([0; 3], 0);
     .          .          .          .                       for b in 0..=255 {
12,288 ( 0.00%) .          .          .                           if builder.rare_set.contains(b) {
     .          .          .          .                               bytes[len] = b as u8;
     .          .          .          .                               len += 1;
     .          .          .          .                           }
     .          .          .          .                       }
   240 ( 0.00%) .          .          .                       let finder: Arc<dyn PrefilterI> = match len {
     .          .          .          .                           0 => return None,
     .          .          .          .                           1 => Arc::new(RareBytesOne {
     .          .          .          .                               byte1: bytes[0],
     .          .          .          .                               offset: builder.byte_offsets.set[bytes[0] as usize],
     .          .          .          .                           }),
     .          .          .          .                           2 => Arc::new(RareBytesTwo {
     .          .          .          .                               offsets: builder.byte_offsets,
     .          .          .          .                               byte1: bytes[0],
-- line 564 ----------------------------------------
-- line 777 ----------------------------------------
     .          .          .          .               /// Build the starting bytes prefilter.
     .          .          .          .               ///
     .          .          .          .               /// If there are more than 3 distinct starting bytes, or if heuristics
     .          .          .          .               /// otherwise determine that this prefilter should not be used, then `None`
     .          .          .          .               /// is returned.
     .          .          .          .               fn build(&self) -> Option<Prefilter> {
     .          .          .          .                   #[cfg(feature = "perf-literal")]
     .          .          .          .                   fn imp(builder: &StartBytesBuilder) -> Option<Prefilter> {
   192 ( 0.00%) .          .          .                       if builder.count > 3 {
     .          .          .          .                           return None;
     .          .          .          .                       }
     .          .          .          .                       let (mut bytes, mut len) = ([0; 3], 0);
     .          .          .          .                       for b in 0..256 {
30,720 ( 0.01%) .          .          .                           if !builder.byteset[b] {
     .          .          .          .                               continue;
     .          .          .          .                           }
     .          .          .          .                           // We don't handle non-ASCII bytes for now. Getting non-ASCII
     .          .          .          .                           // bytes right is trickier, since we generally don't want to put
     .          .          .          .                           // a leading UTF-8 code unit into a prefilter that isn't ASCII,
     .          .          .          .                           // since they can frequently. Instead, it would be better to use a
     .          .          .          .                           // continuation byte, but this requires more sophisticated analysis
     .          .          .          .                           // of the automaton and a richer prefilter API.
-- line 798 ----------------------------------------

28,176 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/prefilter.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/sparse_set.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 37 ----------------------------------------
     .          .          .          .               pub(crate) set1: SparseSet,
     .          .          .          .               pub(crate) set2: SparseSet,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl SparseSets {
     .          .          .          .               /// Create a new pair of sparse sets where each set has the given capacity.
     .          .          .          .               ///
     .          .          .          .               /// This panics if the capacity given is bigger than `StateID::LIMIT`.
   819 ( 0.00%) .          .          .               pub(crate) fn new(capacity: usize) -> SparseSets {
     .          .          .          .                   SparseSets {
     .          .          .          .                       set1: SparseSet::new(capacity),
     .          .          .          .                       set2: SparseSet::new(capacity),
     .          .          .          .                   }
 1,053 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Resizes these sparse sets to have the new capacity given.
     .          .          .          .               ///
     .          .          .          .               /// The sets are automatically cleared.
     .          .          .          .               ///
     .          .          .          .               /// This panics if the capacity given is bigger than `StateID::LIMIT`.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn resize(&mut self, new_capacity: usize) {
-- line 58 ----------------------------------------
-- line 68 ----------------------------------------
     .          .          .          .           
     .          .          .          .               /// Swap set1 with set2.
     .          .          .          .               pub(crate) fn swap(&mut self) {
     .          .          .          .                   core::mem::swap(&mut self.set1, &mut self.set2);
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the memory usage, in bytes, used by this pair of sparse sets.
     .          .          .          .               pub(crate) fn memory_usage(&self) -> usize {
 1,568 ( 0.00%) .          .          .                   self.set1.memory_usage() + self.set2.memory_usage()
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A sparse set used for representing ordered NFA states.
     .          .          .          .           ///
     .          .          .          .           /// This supports constant time addition and membership testing. Clearing an
     .          .          .          .           /// entire set can also be done in constant time. Iteration yields elements
     .          .          .          .           /// in the order in which they were inserted.
-- line 84 ----------------------------------------
-- line 110 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// Sparse sets have a fixed size and they cannot grow. Attempting to
     .          .          .          .               /// insert more distinct elements than the total capacity of the set will
     .          .          .          .               /// result in a panic.
     .          .          .          .               ///
     .          .          .          .               /// This panics if the capacity given is bigger than `StateID::LIMIT`.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn new(capacity: usize) -> SparseSet {
 2,823 ( 0.00%) .          .          .                   let mut set = SparseSet { len: 0, dense: vec![], sparse: vec![] };
     .          .          .          .                   set.resize(capacity);
 5,653 ( 0.00%) .          .          .                   set
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Resizes this sparse set to have the new capacity given.
     .          .          .          .               ///
     .          .          .          .               /// This set is automatically cleared.
     .          .          .          .               ///
     .          .          .          .               /// This panics if the capacity given is bigger than `StateID::LIMIT`.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn resize(&mut self, new_capacity: usize) {
     .          .          .          .                   assert!(
 1,075 ( 0.00%) .          .          .                       new_capacity <= StateID::LIMIT,
     .          .          .          .                       "sparse set capacity cannot exceed {:?}",
     .          .          .          .                       StateID::LIMIT
     .          .          .          .                   );
     .          .          .          .                   self.clear();
     .          .          .          .                   self.dense.resize(new_capacity, StateID::ZERO);
     .          .          .          .                   self.sparse.resize(new_capacity, StateID::ZERO);
     .          .          .          .               }
     .          .          .          .           
-- line 139 ----------------------------------------
-- line 144 ----------------------------------------
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn capacity(&self) -> usize {
     .          .          .          .                   self.dense.len()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the number of elements in this set.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn len(&self) -> usize {
10,258 ( 0.00%) .          .          .                   self.len
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set is empty.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn is_empty(&self) -> bool {
     .          .          .          .                   self.len() == 0
     .          .          .          .               }
     .          .          .          .           
-- line 160 ----------------------------------------
-- line 165 ----------------------------------------
     .          .          .          .               /// set, then this is a no-op.
     .          .          .          .               ///
     .          .          .          .               /// If more than `capacity` ids are inserted, then this panics.
     .          .          .          .               ///
     .          .          .          .               /// This is marked as inline(always) since the compiler won't inline it
     .          .          .          .               /// otherwise, and it's a fairly hot piece of code in DFA determinization.
     .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
     .          .          .          .               pub(crate) fn insert(&mut self, id: StateID) -> bool {
 5,308 ( 0.00%) .          .          .                   if self.contains(id) {
     .          .          .          .                       return false;
     .          .          .          .                   }
     .          .          .          .           
     .          .          .          .                   let i = self.len();
     .          .          .          .                   assert!(
14,032 ( 0.00%) .          .          .                       i < self.capacity(),
     .          .          .          .                       "{:?} exceeds capacity of {:?} when inserting {:?}",
     .          .          .          .                       i,
     .          .          .          .                       self.capacity(),
     .          .          .          .                       id,
     .          .          .          .                   );
     .          .          .          .                   // OK since i < self.capacity() and self.capacity() is guaranteed to
     .          .          .          .                   // be <= StateID::LIMIT.
     .          .          .          .                   let index = StateID::new_unchecked(i);
 7,016 ( 0.00%) .          .          .                   self.dense[index] = id;
 7,016 ( 0.00%) .          .          .                   self.sparse[id] = index;
 9,806 ( 0.00%) .          .          .                   self.len += 1;
     .          .          .          .                   true
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this set contains the given value.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn contains(&self, id: StateID) -> bool {
 7,016 ( 0.00%) .          .          .                   let index = self.sparse[id];
14,032 ( 0.00%) .          .          .                   index.as_usize() < self.len() && self.dense[index] == id
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Clear this set such that it has no members.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn clear(&mut self) {
 1,465 ( 0.00%) .          .          .                   self.len = 0;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn iter(&self) -> SparseSetIter<'_> {
     .          .          .          .                   SparseSetIter(self.dense[..self.len()].iter())
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the heap memory usage, in bytes, used by this sparse set.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn memory_usage(&self) -> usize {
 1,568 ( 0.00%) .          .          .                   self.dense.len() * StateID::SIZE + self.sparse.len() * StateID::SIZE
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl core::fmt::Debug for SparseSet {
     .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
     .          .          .          .                   let elements: Vec<StateID> = self.iter().collect();
     .          .          .          .                   f.debug_tuple("SparseSet").field(&elements).finish()
     .          .          .          .               }
-- line 223 ----------------------------------------

 3,952 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/sparse_set.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/validations.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 4 ----------------------------------------
        .          .          .          .           use crate::intrinsics::const_eval_select;
        .          .          .          .           use crate::mem;
        .          .          .          .           
        .          .          .          .           /// Returns the initial codepoint accumulator for the first byte.
        .          .          .          .           /// The first byte is special, only want bottom 5 bits for width 2, 4 bits
        .          .          .          .           /// for width 3, and 3 bits for width 4.
        .          .          .          .           #[inline]
        .          .          .          .           const fn utf8_first_byte(byte: u8, width: u32) -> u32 {
      640 ( 0.00%) .          .          .               (byte & (0x7F >> width)) as u32
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// Returns the value of `ch` updated with continuation byte `byte`.
        .          .          .          .           #[inline]
        .          .          .          .           const fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {
    1,280 ( 0.00%) .          .          .               (ch << 6) | (byte & CONT_MASK) as u32
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// Checks whether the byte is a UTF-8 continuation byte (i.e., starts with the
        .          .          .          .           /// bits `10`).
        .          .          .          .           #[inline]
        .          .          .          .           pub(super) const fn utf8_is_cont_byte(byte: u8) -> bool {
        .          .          .          .               (byte as i8) < -64
        .          .          .          .           }
-- line 26 ----------------------------------------
-- line 30 ----------------------------------------
        .          .          .          .           ///
        .          .          .          .           /// # Safety
        .          .          .          .           ///
        .          .          .          .           /// `bytes` must produce a valid UTF-8-like (UTF-8 or WTF-8) string
        .          .          .          .           #[unstable(feature = "str_internals", issue = "none")]
        .          .          .          .           #[inline]
        .          .          .          .           pub unsafe fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {
        .          .          .          .               // Decode UTF-8
  583,171 ( 0.18%) .          .          .               let x = *bytes.next()?;
1,166,474 ( 0.35%) .          .          .               if x < 128 {
        6 ( 0.00%) .          .          .                   return Some(x as u32);
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               // Multibyte case follows
        .          .          .          .               // Decode from a byte combination out of: [[[x y] z] w]
        .          .          .          .               // NOTE: Performance is sensitive to the exact formulation here
        .          .          .          .               let init = utf8_first_byte(x, 2);
        .          .          .          .               // SAFETY: `bytes` produces an UTF-8-like string,
        .          .          .          .               // so the iterator must produce a value here.
        .          .          .          .               let y = unsafe { *bytes.next().unwrap_unchecked() };
        .          .          .          .               let mut ch = utf8_acc_cont_byte(init, y);
      720 ( 0.00%) .          .          .               if x >= 0xE0 {
        .          .          .          .                   // [[x y z] w] case
        .          .          .          .                   // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid
        .          .          .          .                   // SAFETY: `bytes` produces an UTF-8-like string,
        .          .          .          .                   // so the iterator must produce a value here.
        .          .          .          .                   let z = unsafe { *bytes.next().unwrap_unchecked() };
        .          .          .          .                   let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);
        .          .          .          .                   ch = init << 12 | y_z;
      640 ( 0.00%) .          .          .                   if x >= 0xF0 {
        .          .          .          .                       // [x y z w] case
        .          .          .          .                       // use only the lower 3 bits of `init`
        .          .          .          .                       // SAFETY: `bytes` produces an UTF-8-like string,
        .          .          .          .                       // so the iterator must produce a value here.
        .          .          .          .                       let w = unsafe { *bytes.next().unwrap_unchecked() };
        .          .          .          .                       ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);
        .          .          .          .                   }
        .          .          .          .               }
-- line 67 ----------------------------------------
-- line 77 ----------------------------------------
        .          .          .          .           /// `bytes` must produce a valid UTF-8-like (UTF-8 or WTF-8) string
        .          .          .          .           #[inline]
        .          .          .          .           pub(super) unsafe fn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>
        .          .          .          .           where
        .          .          .          .               I: DoubleEndedIterator<Item = &'a u8>,
        .          .          .          .           {
        .          .          .          .               // Decode UTF-8
        .          .          .          .               let w = match *bytes.next_back()? {
       99 ( 0.00%) .          .          .                   next_byte if next_byte < 128 => return Some(next_byte as u32),
        .          .          .          .                   back_byte => back_byte,
        .          .          .          .               };
        .          .          .          .           
        .          .          .          .               // Multibyte case follows
        .          .          .          .               // Decode from a byte combination out of: [x [y [z w]]]
        .          .          .          .               let mut ch;
        .          .          .          .               // SAFETY: `bytes` produces an UTF-8-like string,
        .          .          .          .               // so the iterator must produce a value here.
-- line 93 ----------------------------------------

   94,250 ( 0.03%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/validations.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/strategy.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 70 ----------------------------------------
      .          .          .          .               fn which_overlapping_matches(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .                   patset: &mut PatternSet,
      .          .          .          .               );
      .          .          .          .           }
      .          .          .          .           
  1,215 ( 0.00%) .          .          .           pub(super) fn new(
      .          .          .          .               info: &RegexInfo,
      .          .          .          .               hirs: &[&Hir],
      .          .          .          .           ) -> Result<Arc<dyn Strategy>, BuildError> {
      .          .          .          .               // At this point, we're committed to a regex engine of some kind. So pull
      .          .          .          .               // out a prefilter if we can, which will feed to each of the constituent
      .          .          .          .               // regex engines.
    162 ( 0.00%) .          .          .               let pre = if info.is_always_anchored_start() {
      .          .          .          .                   // PERF: I'm not sure we necessarily want to do this... We may want to
      .          .          .          .                   // run a prefilter for quickly rejecting in some cases. The problem
      .          .          .          .                   // is that anchored searches overlap quite a bit with the use case
      .          .          .          .                   // of "run a regex on every line to extract data." In that case, the
      .          .          .          .                   // regex always matches, so running a prefilter doesn't really help us
      .          .          .          .                   // there. The main place where a prefilter helps in an anchored search
      .          .          .          .                   // is if the anchored search is not expected to match frequently. That
      .          .          .          .                   // is, the prefilter gives us a way to possibly reject a haystack very
-- line 93 ----------------------------------------
-- line 97 ----------------------------------------
      .          .          .          .                   // Or maybe we should only use a prefilter when we think it's "fast"?
      .          .          .          .                   //
      .          .          .          .                   // Interestingly, I think we currently lack the infrastructure for
      .          .          .          .                   // disabling a prefilter based on haystack length. That would probably
      .          .          .          .                   // need to be a new 'Input' option. (Interestingly, an 'Input' used to
      .          .          .          .                   // carry a 'Prefilter' with it, but I moved away from that.)
      .          .          .          .                   debug!("skipping literal extraction since regex is anchored");
      .          .          .          .                   None
     16 ( 0.00%) .          .          .               } else if let Some(pre) = info.config().get_prefilter() {
      .          .          .          .                   debug!(
      .          .          .          .                       "skipping literal extraction since the caller provided a prefilter"
      .          .          .          .                   );
      .          .          .          .                   Some(pre.clone())
      .          .          .          .               } else if info.config().get_auto_prefilter() {
      .          .          .          .                   let kind = info.config().get_match_kind();
    128 ( 0.00%) .          .          .                   let prefixes = crate::util::prefilter::prefixes(kind, hirs);
7,207,125 ( 2.16%) 17,054 ( 2.11%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/prefilter/mod.rs:regex_automata::util::prefilter::prefixes (16x)
      .          .          .          .                   // If we can build a full `Strategy` from just the extracted prefixes,
      .          .          .          .                   // then we can short-circuit and avoid building a regex engine at all.
      .          .          .          .                   if let Some(pre) = Pre::from_prefixes(info, &prefixes) {
      .          .          .          .                       debug!(
      .          .          .          .                           "found that the regex can be broken down to a literal \
      .          .          .          .                            search, avoiding the regex engine entirely",
      .          .          .          .                       );
      .          .          .          .                       return Ok(pre);
-- line 120 ----------------------------------------
-- line 162 ----------------------------------------
      .          .          .          .               // engine for this case.
      .          .          .          .               core = match ReverseAnchored::new(core) {
      .          .          .          .                   Err(core) => core,
      .          .          .          .                   Ok(ra) => {
      .          .          .          .                       debug!("using reverse anchored strategy");
      .          .          .          .                       return Ok(Arc::new(ra));
      .          .          .          .                   }
      .          .          .          .               };
    405 ( 0.00%) .          .          .               core = match ReverseSuffix::new(core, hirs) {
      .          .          .          .                   Err(core) => core,
      .          .          .          .                   Ok(rs) => {
      .          .          .          .                       debug!("using reverse suffix strategy");
      .          .          .          .                       return Ok(Arc::new(rs));
      .          .          .          .                   }
      .          .          .          .               };
    444 ( 0.00%) .          .          .               core = match ReverseInner::new(core, hirs) {
      .          .          .          .                   Err(core) => core,
     26 ( 0.00%) .          .          .                   Ok(ri) => {
  1,313 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (13x)
      .          .          .          .                       debug!("using reverse inner strategy");
      .          .          .          .                       return Ok(Arc::new(ri));
      .          .          .          .                   }
      .          .          .          .               };
      .          .          .          .               debug!("using core strategy");
    272 ( 0.00%) .          .          .               Ok(Arc::new(core))
    729 ( 0.00%) .          .          .           }
      .          .          .          .           
      .          .          .          .           #[derive(Clone, Debug)]
      .          .          .          .           struct Pre<P> {
      .          .          .          .               pre: P,
      .          .          .          .               group_info: GroupInfo,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<P: PrefilterI> Pre<P> {
-- line 194 ----------------------------------------
-- line 312 ----------------------------------------
      .          .          .          .               /// them are alternation of literals, but I haven't had the time to go down
      .          .          .          .               /// that path yet.
      .          .          .          .               fn from_alternation_literals(
      .          .          .          .                   info: &RegexInfo,
      .          .          .          .                   hirs: &[&Hir],
      .          .          .          .               ) -> Option<Arc<dyn Strategy>> {
      .          .          .          .                   use crate::util::prefilter::AhoCorasick;
      .          .          .          .           
     64 ( 0.00%) .          .          .                   let lits = crate::meta::literal::alternation_literals(info, hirs)?;
    458 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/literal.rs:regex_automata::meta::literal::alternation_literals (16x)
      .          .          .          .                   let ac = AhoCorasick::new(MatchKind::LeftmostFirst, &lits)?;
      .          .          .          .                   Some(Pre::new(ac))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           // This implements Strategy for anything that implements PrefilterI.
      .          .          .          .           //
      .          .          .          .           // Note that this must only be used for regexes of length 1. Multi-regexes
-- line 328 ----------------------------------------
-- line 461 ----------------------------------------
      .          .          .          .                   let mut lookm = LookMatcher::new();
      .          .          .          .                   lookm.set_line_terminator(info.config().get_line_terminator());
      .          .          .          .                   let thompson_config = thompson::Config::new()
      .          .          .          .                       .utf8(info.config().get_utf8_empty())
      .          .          .          .                       .nfa_size_limit(info.config().get_nfa_size_limit())
      .          .          .          .                       .shrink(false)
      .          .          .          .                       .which_captures(info.config().get_which_captures())
      .          .          .          .                       .look_matcher(lookm);
    162 ( 0.00%) .          .          .                   let nfa = thompson::Compiler::new()
      .          .          .          .                       .configure(thompson_config.clone())
      .          .          .          .                       .build_many_from_hir(hirs)
     81 ( 0.00%) .          .          .                       .map_err(BuildError::nfa)?;
8,489,212 ( 2.55%) 22,299 ( 2.75%) 1 ( 0.33%) .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> (81x)
      .          .          .          .                   // It's possible for the PikeVM or the BB to fail to build, even though
      .          .          .          .                   // at this point, we already have a full NFA in hand. They can fail
      .          .          .          .                   // when a Unicode word boundary is used but where Unicode word boundary
      .          .          .          .                   // support is disabled at compile time, thus making it impossible to
      .          .          .          .                   // match. (Construction can also fail if the NFA was compiled without
      .          .          .          .                   // captures, but we always enable that above.)
    567 ( 0.00%) .          .          .                   let pikevm = wrappers::PikeVM::new(&info, pre.clone(), &nfa)?;
 44,560 ( 0.01%) 111 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::PikeVM::new (81x)
      .          .          .          .                   let backtrack =
    891 ( 0.00%) .          .          .                       wrappers::BoundedBacktracker::new(&info, pre.clone(), &nfa)?;
 45,250 ( 0.01%) 111 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::BoundedBacktracker::new (81x)
      .          .          .          .                   // The onepass engine can of course fail to build, but we expect it to
      .          .          .          .                   // fail in many cases because it is an optimization that doesn't apply
      .          .          .          .                   // to all regexes. The 'OnePass' wrapper encapsulates this failure (and
      .          .          .          .                   // logs a message if it occurs).
     81 ( 0.00%) .          .          .                   let onepass = wrappers::OnePass::new(&info, &nfa);
2,572,840 ( 0.77%) 2,469 ( 0.30%) 2 ( 0.66%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::OnePass::new (81x)
      .          .          .          .                   // We try to encapsulate whether a particular regex engine should be
      .          .          .          .                   // used within each respective wrapper, but the DFAs need a reverse NFA
      .          .          .          .                   // to build itself, and we really do not want to build a reverse NFA if
      .          .          .          .                   // we know we aren't going to use the lazy DFA. So we do a config check
      .          .          .          .                   // up front, which is in practice the only way we won't try to use the
      .          .          .          .                   // DFA.
      .          .          .          .                   let (nfarev, hybrid, dfa) =
      .          .          .          .                       if !info.config().get_hybrid() && !info.config().get_dfa() {
-- line 494 ----------------------------------------
-- line 499 ----------------------------------------
      .          .          .          .                           // fail to build just based on the forward NFA. In which case,
      .          .          .          .                           // building the reverse NFA was totally wasted work. But...
      .          .          .          .                           // fixing this requires breaking DFA construction apart into
      .          .          .          .                           // two pieces: one for the forward part and another for the
      .          .          .          .                           // reverse part. Quite annoying. Making it worse, when building
      .          .          .          .                           // both DFAs fails, it's quite likely that the NFA is large and
      .          .          .          .                           // that it will take quite some time to build the reverse NFA
      .          .          .          .                           // too. So... it's really probably worth it to do this!
    162 ( 0.00%) .          .          .                           let nfarev = thompson::Compiler::new()
      .          .          .          .                               // Currently, reverse NFAs don't support capturing groups,
      .          .          .          .                               // so we MUST disable them. But even if we didn't have to,
      .          .          .          .                               // we would, because nothing in this crate does anything
      .          .          .          .                               // useful with capturing groups in reverse. And of course,
      .          .          .          .                               // the lazy DFA ignores capturing groups in all cases.
      .          .          .          .                               .configure(
      .          .          .          .                                   thompson_config
      .          .          .          .                                       .clone()
      .          .          .          .                                       .which_captures(WhichCaptures::None)
      .          .          .          .                                       .reverse(true),
      .          .          .          .                               )
      .          .          .          .                               .build_many_from_hir(hirs)
     81 ( 0.00%) .          .          .                               .map_err(BuildError::nfa)?;
2,959,583 ( 0.89%) 15,442 ( 1.91%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> (81x)
      .          .          .          .                           let dfa = if !info.config().get_dfa() {
      .          .          .          .                               wrappers::DFA::none()
      .          .          .          .                           } else {
      .          .          .          .                               wrappers::DFA::new(&info, pre.clone(), &nfa, &nfarev)
      .          .          .          .                           };
      .          .          .          .                           let hybrid = if !info.config().get_hybrid() {
      .          .          .          .                               wrappers::Hybrid::none()
     81 ( 0.00%) .          .          .                           } else if dfa.is_some() {
      .          .          .          .                               debug!("skipping lazy DFA because we have a full DFA");
      .          .          .          .                               wrappers::Hybrid::none()
      .          .          .          .                           } else {
     81 ( 0.00%) .          .          .                               wrappers::Hybrid::new(&info, pre.clone(), &nfa, &nfarev)
1,135,526 ( 0.34%) 606 ( 0.07%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::new (81x)
      .          .          .          .                           };
    243 ( 0.00%) .          .          .                           (Some(nfarev), hybrid, dfa)
      .          .          .          .                       };
      .          .          .          .                   Ok(Core {
     81 ( 0.00%) .          .          .                       info,
  1,944 ( 0.00%) .          .          .                       pre,
    162 ( 0.00%) .          .          .                       nfa,
      .          .          .          .                       nfarev,
  2,916 ( 0.00%) .          .          .                       pikevm,
  3,078 ( 0.00%) .          .          .                       backtrack,
 10,125 ( 0.00%) .          .          .                       onepass,
      .          .          .          .                       hybrid,
      .          .          .          .                       dfa,
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn try_search_mayfail(
      .          .          .          .                   &self,
-- line 551 ----------------------------------------
-- line 602 ----------------------------------------
      .          .          .          .                   // Only the lazy/full DFA returns half-matches, since the DFA requires
      .          .          .          .                   // a reverse scan to find the start position. These fallback regex
      .          .          .          .                   // engines can find the start and end in a single pass, so we just do
      .          .          .          .                   // that and throw away the start offset to conform to the API.
      .          .          .          .                   let m = self.search_nofail(cache, input)?;
      .          .          .          .                   Some(HalfMatch::new(m.pattern(), m.end()))
      .          .          .          .               }
      .          .          .          .           
     24 ( 0.00%) .          .          .               fn search_slots_nofail(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .                   slots: &mut [Option<NonMaxUsize>],
      .          .          .          .               ) -> Option<PatternID> {
      .          .          .          .                   if let Some(ref e) = self.onepass.get(input) {
      .          .          .          .                       trace!(
      .          .          .          .                           "using OnePass for capture search at {:?}",
      .          .          .          .                           input.get_span()
      .          .          .          .                       );
      1 ( 0.00%) .          .          .                       e.search_slots(&mut cache.onepass, input, slots)
      .          .          .          .                   } else if let Some(ref e) = self.backtrack.get(input) {
      .          .          .          .                       trace!(
      .          .          .          .                           "using BoundedBacktracker for capture search at {:?}",
      .          .          .          .                           input.get_span()
      .          .          .          .                       );
      5 ( 0.00%) .          .          .                       e.search_slots(&mut cache.backtrack, input, slots)
      .          .          .          .                   } else {
      .          .          .          .                       trace!(
      .          .          .          .                           "using PikeVM for capture search at {:?}",
      .          .          .          .                           input.get_span()
      .          .          .          .                       );
      .          .          .          .                       let e = self.pikevm.get();
      .          .          .          .                       e.search_slots(&mut cache.pikevm, input, slots)
      .          .          .          .                   }
     12 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn is_match_nofail(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
      .          .          .          .                   if let Some(ref e) = self.onepass.get(input) {
      .          .          .          .                       trace!(
      .          .          .          .                           "using OnePass for is-match search at {:?}",
      .          .          .          .                           input.get_span()
      .          .          .          .                       );
      .          .          .          .                       e.search_slots(&mut cache.onepass, input, &mut []).is_some()
-- line 644 ----------------------------------------
-- line 654 ----------------------------------------
      .          .          .          .                           input.get_span()
      .          .          .          .                       );
      .          .          .          .                       let e = self.pikevm.get();
      .          .          .          .                       e.is_match(&mut cache.pikevm, input)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn is_capture_search_needed(&self, slots_len: usize) -> bool {
     70 ( 0.00%) .          .          .                   slots_len > self.nfa.group_info().implicit_slot_len()
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Strategy for Core {
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn group_info(&self) -> &GroupInfo {
      .          .          .          .                   self.nfa.group_info()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
    294 ( 0.00%) .          .          .               fn create_cache(&self) -> Cache {
    117 ( 0.00%) .          .          .                   Cache {
      .          .          .          .                       capmatches: Captures::all(self.group_info().clone()),
     53 ( 0.00%) .          .          .                       pikevm: self.pikevm.create_cache(),
      .          .          .          .                       backtrack: self.backtrack.create_cache(),
      .          .          .          .                       onepass: self.onepass.create_cache(),
    159 ( 0.00%) .          .          .                       hybrid: self.hybrid.create_cache(),
563,405 ( 0.17%) 354 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::Hybrid::create_cache (11x)
      .          .          .          .                       revhybrid: wrappers::ReverseHybridCache::none(),
      .          .          .          .                   }
    378 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn reset_cache(&self, cache: &mut Cache) {
      .          .          .          .                   cache.pikevm.reset(&self.pikevm);
      .          .          .          .                   cache.backtrack.reset(&self.backtrack);
      .          .          .          .                   cache.onepass.reset(&self.onepass);
      .          .          .          .                   cache.hybrid.reset(&self.hybrid);
      .          .          .          .               }
-- line 690 ----------------------------------------
-- line 788 ----------------------------------------
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   } else {
      .          .          .          .                       self.is_match_nofail(cache, input)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
    552 ( 0.00%) .          .          .               fn search_slots(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .                   slots: &mut [Option<NonMaxUsize>],
      .          .          .          .               ) -> Option<PatternID> {
      .          .          .          .                   // Even if the regex has explicit capture groups, if the caller didn't
      .          .          .          .                   // provide any explicit slots, then it doesn't make sense to try and do
      .          .          .          .                   // extra work to get offsets for those slots. Ideally the caller should
      .          .          .          .                   // realize this and not call this routine in the first place, but alas,
      .          .          .          .                   // we try to save the caller from themselves if they do.
     46 ( 0.00%) .          .          .                   if !self.is_capture_search_needed(slots.len()) {
      .          .          .          .                       trace!("asked for slots unnecessarily, trying fast path");
      .          .          .          .                       let m = self.search(cache, input)?;
      .          .          .          .                       copy_match_to_slots(m, slots);
      .          .          .          .                       return Some(m.pattern());
      .          .          .          .                   }
      .          .          .          .                   // If the onepass DFA is available for this search (which only happens
      .          .          .          .                   // when it's anchored), then skip running a fallible DFA. The onepass
      .          .          .          .                   // DFA isn't as fast as a full or lazy DFA, but it is typically quite
-- line 815 ----------------------------------------
-- line 821 ----------------------------------------
      .          .          .          .                   // to say "no match" much more quickly. This does hurt the case of,
      .          .          .          .                   // say, parsing each line in a log file into capture groups, because
      .          .          .          .                   // in that case, the line always matches. So the lazy DFA scan is
      .          .          .          .                   // usually just wasted work. But, the lazy DFA is usually quite fast
      .          .          .          .                   // and doesn't cost too much here.
      .          .          .          .                   if self.onepass.get(&input).is_some() {
      .          .          .          .                       return self.search_slots_nofail(cache, &input, slots);
      .          .          .          .                   }
     90 ( 0.00%) .          .          .                   let m = match self.try_search_mayfail(cache, input) {
      .          .          .          .                       Some(Ok(Some(m))) => m,
      .          .          .          .                       Some(Ok(None)) => return None,
      .          .          .          .                       Some(Err(_err)) => {
      .          .          .          .                           trace!("fast capture search failed: {_err}");
      .          .          .          .                           return self.search_slots_nofail(cache, input, slots);
      .          .          .          .                       }
      .          .          .          .                       None => {
      .          .          .          .                           return self.search_slots_nofail(cache, input, slots);
-- line 837 ----------------------------------------
-- line 847 ----------------------------------------
      .          .          .          .                       m.start(),
      .          .          .          .                       m.end(),
      .          .          .          .                   );
      .          .          .          .                   let input = input
      .          .          .          .                       .clone()
      .          .          .          .                       .span(m.start()..m.end())
      .          .          .          .                       .anchored(Anchored::Pattern(m.pattern()));
      .          .          .          .                   Some(
     25 ( 0.00%) .          .          .                       self.search_slots_nofail(cache, &input, slots)
 16,189 ( 0.00%) 6 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/strategy.rs:regex_automata::meta::strategy::Core::search_slots_nofail (5x)
      .          .          .          .                           .expect("should find a match"),
      .          .          .          .                   )
    373 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn which_overlapping_matches(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .                   patset: &mut PatternSet,
      .          .          .          .               ) {
-- line 866 ----------------------------------------
-- line 902 ----------------------------------------
      .          .          .          .           
      .          .          .          .           #[derive(Debug)]
      .          .          .          .           struct ReverseAnchored {
      .          .          .          .               core: Core,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ReverseAnchored {
      .          .          .          .               fn new(core: Core) -> Result<ReverseAnchored, Core> {
    162 ( 0.00%) .          .          .                   if !core.info.is_always_anchored_end() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse anchored optimization because \
      .          .          .          .           				 the regex is not always anchored at the end"
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   // Note that the caller can still request an anchored search even when
      .          .          .          .                   // the regex isn't anchored at the start. We detect that case in the
-- line 918 ----------------------------------------
-- line 975 ----------------------------------------
      .          .          .          .           // input.haystack().len()'. In particular, when that condition is false, a
      .          .          .          .           // match is always impossible because we know that the regex is always anchored
      .          .          .          .           // at the end (or else 'ReverseAnchored' won't be built). We don't check that
      .          .          .          .           // here because the 'Regex' wrapper actually does that for us in all cases.
      .          .          .          .           // Thus, in this impl, we can actually assume that the end position in 'input'
      .          .          .          .           // is equivalent to the length of the haystack.
      .          .          .          .           impl Strategy for ReverseAnchored {
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
     72 ( 0.00%) .          .          .               fn group_info(&self) -> &GroupInfo {
      .          .          .          .                   self.core.group_info()
     72 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn create_cache(&self) -> Cache {
      .          .          .          .                   self.core.create_cache()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn reset_cache(&self, cache: &mut Cache) {
-- line 993 ----------------------------------------
-- line 1137 ----------------------------------------
      .          .          .          .                   // do another forward scan to find the end position.)
      .          .          .          .                   //
      .          .          .          .                   // Note that the caller can still request an anchored search even
      .          .          .          .                   // when the regex isn't anchored. We detect that case in the search
      .          .          .          .                   // routines below and just fallback to the core engine. Currently this
      .          .          .          .                   // optimization assumes all searches are unanchored, so if we do want
      .          .          .          .                   // to enable this optimization for anchored searches, it will need a
      .          .          .          .                   // little work to support it.
    162 ( 0.00%) .          .          .                   if core.info.is_always_anchored_start() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse suffix optimization because \
      .          .          .          .           				 the regex is always anchored at the start",
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   // Only DFAs can do reverse searches (currently), so we need one of
      .          .          .          .                   // them in order to do this optimization. It's possible (although
      .          .          .          .                   // pretty unlikely) that we have neither and need to give up.
     16 ( 0.00%) .          .          .                   if !core.hybrid.is_some() && !core.dfa.is_some() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse suffix optimization because \
      .          .          .          .           				 we don't have a lazy DFA or a full DFA"
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
     30 ( 0.00%) .          .          .                   if core.pre.as_ref().map_or(false, |p| p.is_fast()) {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse suffix optimization because \
      .          .          .          .           				 we already have a prefilter that we think is fast"
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   let kind = core.info.config().get_match_kind();
     65 ( 0.00%) .          .          .                   let suffixes = crate::util::prefilter::suffixes(kind, hirs);
2,162,573 ( 0.65%) 5,148 ( 0.64%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/prefilter/mod.rs:regex_automata::util::prefilter::suffixes (13x)
      .          .          .          .                   let lcs = match suffixes.longest_common_suffix() {
      .          .          .          .                       None => {
      .          .          .          .                           debug!(
      .          .          .          .                               "skipping reverse suffix optimization because \
      .          .          .          .                                a longest common suffix could not be found",
      .          .          .          .                           );
      .          .          .          .                           return Err(core);
      .          .          .          .                       }
-- line 1178 ----------------------------------------
-- line 1507 ----------------------------------------
      .          .          .          .                            automatic prefilters are disabled"
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   // Currently we hard-code the assumption of leftmost-first match
      .          .          .          .                   // semantics. This isn't a huge deal because 'all' semantics tend to
      .          .          .          .                   // only be used for forward overlapping searches with multiple regexes,
      .          .          .          .                   // and this optimization only supports a single pattern at the moment.
    162 ( 0.00%) .          .          .                   if core.info.config().get_match_kind() != MatchKind::LeftmostFirst {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse inner optimization because \
      .          .          .          .           				 match kind is {:?} but this only supports leftmost-first",
      .          .          .          .                           core.info.config().get_match_kind(),
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   // It's likely that a reverse inner scan has too much overhead for it
-- line 1523 ----------------------------------------
-- line 1530 ----------------------------------------
      .          .          .          .                   // or reject, which is a fair bit of work.
      .          .          .          .                   //
      .          .          .          .                   // Note that the caller can still request an anchored search even
      .          .          .          .                   // when the regex isn't anchored. We detect that case in the search
      .          .          .          .                   // routines below and just fallback to the core engine. Currently this
      .          .          .          .                   // optimization assumes all searches are unanchored, so if we do want
      .          .          .          .                   // to enable this optimization for anchored searches, it will need a
      .          .          .          .                   // little work to support it.
    162 ( 0.00%) .          .          .                   if core.info.is_always_anchored_start() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse inner optimization because \
      .          .          .          .           				 the regex is always anchored at the start",
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
      .          .          .          .                   // Only DFAs can do reverse searches (currently), so we need one of
      .          .          .          .                   // them in order to do this optimization. It's possible (although
      .          .          .          .                   // pretty unlikely) that we have neither and need to give up.
     16 ( 0.00%) .          .          .                   if !core.hybrid.is_some() && !core.dfa.is_some() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse inner optimization because \
      .          .          .          .           				 we don't have a lazy DFA or a full DFA"
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   }
     30 ( 0.00%) .          .          .                   if core.pre.as_ref().map_or(false, |p| p.is_fast()) {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping reverse inner optimization because \
      .          .          .          .           				 we already have a prefilter that we think is fast"
      .          .          .          .                       );
      .          .          .          .                       return Err(core);
      .          .          .          .                   } else if core.pre.is_some() {
      .          .          .          .                       debug!(
      .          .          .          .                           "core engine has a prefix prefilter, but it is \
      .          .          .          .                            probably not fast, so continuing with attempt to \
      .          .          .          .                            use reverse inner prefilter"
      .          .          .          .                       );
      .          .          .          .                   }
     39 ( 0.00%) .          .          .                   let (concat_prefix, preinner) = match reverse_inner::extract(hirs) {
32,594,058 ( 9.79%) 58,128 ( 7.18%) 15 ( 4.98%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::extract (13x)
    130 ( 0.00%) .          .          .                       Some(x) => x,
      .          .          .          .                       // N.B. the 'extract' function emits debug messages explaining
      .          .          .          .                       // why we bailed out here.
      .          .          .          .                       None => return Err(core),
      .          .          .          .                   };
      .          .          .          .                   debug!("building reverse NFA for prefix before inner literal");
      .          .          .          .                   let mut lookm = LookMatcher::new();
      .          .          .          .                   lookm.set_line_terminator(core.info.config().get_line_terminator());
      .          .          .          .                   let thompson_config = thompson::Config::new()
      .          .          .          .                       .reverse(true)
      .          .          .          .                       .utf8(core.info.config().get_utf8_empty())
      .          .          .          .                       .nfa_size_limit(core.info.config().get_nfa_size_limit())
      .          .          .          .                       .shrink(false)
      .          .          .          .                       .which_captures(WhichCaptures::None)
      .          .          .          .                       .look_matcher(lookm);
     52 ( 0.00%) .          .          .                   let result = thompson::Compiler::new()
  3,809 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::new (13x)
    377 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::configure (13x)
      .          .          .          .                       .configure(thompson_config)
     26 ( 0.00%) .          .          .                       .build_from_hir(&concat_prefix);
 44,698 ( 0.01%) 231 ( 0.03%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::nfa::thompson::compiler::Compiler> (13x)
     26 ( 0.00%) .          .          .                   let nfarev = match result {
     26 ( 0.00%) .          .          .                       Ok(nfarev) => nfarev,
      .          .          .          .                       Err(_err) => {
      .          .          .          .                           debug!(
      .          .          .          .                               "skipping reverse inner optimization because the \
      .          .          .          .           					 reverse NFA failed to build: {}",
      .          .          .          .                               _err,
      .          .          .          .                           );
      .          .          .          .                           return Err(core);
      .          .          .          .                       }
-- line 1596 ----------------------------------------
-- line 1605 ----------------------------------------
      .          .          .          .                       wrappers::ReverseHybrid::none()
      .          .          .          .                   } else if dfa.is_some() {
      .          .          .          .                       debug!(
      .          .          .          .                           "skipping lazy DFA for reverse inner optimization \
      .          .          .          .           				 because we have a full DFA"
      .          .          .          .                       );
      .          .          .          .                       wrappers::ReverseHybrid::none()
      .          .          .          .                   } else {
     26 ( 0.00%) .          .          .                       wrappers::ReverseHybrid::new(&core.info, &nfarev)
 83,265 ( 0.02%) 39 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::new (13x)
      .          .          .          .                   };
  6,565 ( 0.00%) .          .          .                   Ok(ReverseInner { core, preinner, nfarev, hybrid, dfa })
  1,313 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (13x)
    143 ( 0.00%) .          .          .               }
232,863 ( 0.07%) 1,121 ( 0.14%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (13x)
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn try_search_full(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .               ) -> Result<Option<Match>, RetryError> {
      .          .          .          .                   let mut span = input.get_span();
      .          .          .          .                   let mut min_match_start = 0;
      .          .          .          .                   let mut min_pre_start = 0;
      .          .          .          .                   loop {
     24 ( 0.00%) .          .          .                       let litmatch = match self.preinner.find(input.haystack(), span) {
      .          .          .          .                           None => return Ok(None),
      .          .          .          .                           Some(span) => span,
      .          .          .          .                       };
      .          .          .          .                       if litmatch.start < min_pre_start {
      .          .          .          .                           trace!(
      .          .          .          .                               "found inner prefilter match at {litmatch:?}, which starts \
      .          .          .          .           					 before the end of the last forward scan at {min_pre_start}, \
      .          .          .          .           					 quitting to avoid quadratic behavior",
-- line 1636 ----------------------------------------
-- line 1737 ----------------------------------------
      .          .          .          .                   } else {
      .          .          .          .                       unreachable!("ReverseInner always has a DFA")
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Strategy for ReverseInner {
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
     14 ( 0.00%) .          .          .               fn group_info(&self) -> &GroupInfo {
      .          .          .          .                   self.core.group_info()
     14 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
     77 ( 0.00%) .          .          .               fn create_cache(&self) -> Cache {
      .          .          .          .                   let mut cache = self.core.create_cache();
     33 ( 0.00%) .          .          .                   cache.revhybrid = self.hybrid.create_cache();
149,869 ( 0.04%) 139 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/wrappers.rs:regex_automata::meta::wrappers::ReverseHybrid::create_cache (11x)
     44 ( 0.00%) .          .          .                   cache
  1,771 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (11x)
     99 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn reset_cache(&self, cache: &mut Cache) {
      .          .          .          .                   self.core.reset_cache(cache);
      .          .          .          .                   cache.revhybrid.reset(&self.hybrid);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn is_accelerated(&self) -> bool {
-- line 1762 ----------------------------------------
-- line 1826 ----------------------------------------
      .          .          .          .                           self.core.is_match_nofail(cache, input)
      .          .          .          .                       }
      .          .          .          .                       Ok(None) => false,
      .          .          .          .                       Ok(Some(_)) => true,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
    120 ( 0.00%) .          .          .               fn search_slots(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .                   slots: &mut [Option<NonMaxUsize>],
      .          .          .          .               ) -> Option<PatternID> {
      .          .          .          .                   if input.get_anchored().is_anchored() {
      .          .          .          .                       return self.core.search_slots(cache, input, slots);
      .          .          .          .                   }
     12 ( 0.00%) .          .          .                   if !self.core.is_capture_search_needed(slots.len()) {
      .          .          .          .                       trace!("asked for slots unnecessarily, trying fast path");
      .          .          .          .                       let m = self.search(cache, input)?;
      .          .          .          .                       copy_match_to_slots(m, slots);
      .          .          .          .                       return Some(m.pattern());
      .          .          .          .                   }
      .          .          .          .                   let m = match self.try_search_full(cache, input) {
      .          .          .          .                       Err(RetryError::Quadratic(_err)) => {
      .          .          .          .                           trace!("reverse inner captures optimization failed: {_err}");
-- line 1851 ----------------------------------------
-- line 1864 ----------------------------------------
      .          .          .          .                       m.start(),
      .          .          .          .                       m.end(),
      .          .          .          .                   );
      .          .          .          .                   let input = input
      .          .          .          .                       .clone()
      .          .          .          .                       .span(m.start()..m.end())
      .          .          .          .                       .anchored(Anchored::Pattern(m.pattern()));
      .          .          .          .                   self.core.search_slots_nofail(cache, &input, slots)
     96 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn which_overlapping_matches(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .                   patset: &mut PatternSet,
      .          .          .          .               ) {
-- line 1880 ----------------------------------------

408,186 ( 0.12%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/strategy.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/num.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 70 ----------------------------------------
     .          .          .          .               ($Small:ty => $Large:ty, #[$attr:meta], $doc:expr $(,)?) => {
     .          .          .          .                   #[$attr]
     .          .          .          .                   impl From<$Small> for $Large {
     .          .          .          .                       // Rustdocs on the impl block show a "[+] show undocumented items" toggle.
     .          .          .          .                       // Rustdocs on functions do not.
     .          .          .          .                       #[doc = $doc]
     .          .          .          .                       #[inline(always)]
     .          .          .          .                       fn from(small: $Small) -> Self {
24,977 ( 0.01%) .          .          .                           small as Self
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .               };
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           // boolean -> integer
     .          .          .          .           impl_from!(bool => u8);
     .          .          .          .           impl_from!(bool => u16);
-- line 86 ----------------------------------------
-- line 248 ----------------------------------------
     .          .          .          .                   impl TryFrom<$source> for $target {
     .          .          .          .                       type Error = TryFromIntError;
     .          .          .          .           
     .          .          .          .                       /// Tries to create the target number type from a source
     .          .          .          .                       /// number type. This returns an error if the source value
     .          .          .          .                       /// is outside of the range of the target type.
     .          .          .          .                       #[inline]
     .          .          .          .                       fn try_from(u: $source) -> Result<Self, Self::Error> {
    42 ( 0.00%) .          .          .                           if u > (Self::MAX as $source) {
     .          .          .          .                               Err(TryFromIntError(()))
     .          .          .          .                           } else {
     .          .          .          .                               Ok(u as Self)
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .               )*}
     .          .          .          .           }
-- line 264 ----------------------------------------
-- line 272 ----------------------------------------
     .          .          .          .           
     .          .          .          .                       /// Tries to create the target number type from a source
     .          .          .          .                       /// number type. This returns an error if the source value
     .          .          .          .                       /// is outside of the range of the target type.
     .          .          .          .                       #[inline]
     .          .          .          .                       fn try_from(u: $source) -> Result<Self, Self::Error> {
     .          .          .          .                           let min = Self::MIN as $source;
     .          .          .          .                           let max = Self::MAX as $source;
    24 ( 0.00%) .          .          .                           if u < min || u > max {
     .          .          .          .                               Err(TryFromIntError(()))
     .          .          .          .                           } else {
     .          .          .          .                               Ok(u as Self)
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .               )*}
     .          .          .          .           }
-- line 288 ----------------------------------------

   780 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/num.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 50 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           // Generic slice equality
      .          .          .          .           impl<A, B> SlicePartialEq<B> for [A]
      .          .          .          .           where
      .          .          .          .               A: PartialEq<B>,
      .          .          .          .           {
      .          .          .          .               default fn equal(&self, other: &[B]) -> bool {
  4,464 ( 0.00%) .          .          .                   if self.len() != other.len() {
      .          .          .          .                       return false;
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // Implemented as explicit indexing rather
      .          .          .          .                   // than zipped iterators for performance reasons.
      .          .          .          .                   // See PR https://github.com/rust-lang/rust/pull/116846
      .          .          .          .                   for idx in 0..self.len() {
      .          .          .          .                       // bound checks are optimized away
  3,270 ( 0.00%) .          .          .                       if self[idx] != other[idx] {
      .          .          .          .                           return false;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   true
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           // When each element can be compared byte-wise, we can compare all the bytes
      .          .          .          .           // from the whole size in one call to the intrinsics.
      .          .          .          .           impl<A, B> SlicePartialEq<B> for [A]
      .          .          .          .           where
      .          .          .          .               A: BytewiseEq<B>,
      .          .          .          .           {
      .          .          .          .               fn equal(&self, other: &[B]) -> bool {
180,697 ( 0.05%) .          .          .                   if self.len() != other.len() {
      .          .          .          .                       return false;
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // SAFETY: `self` and `other` are references and are thus guaranteed to be valid.
      .          .          .          .                   // The two slices have been checked to have the same size above.
      .          .          .          .                   unsafe {
      .          .          .          .                       let size = mem::size_of_val(self);
210,487 ( 0.06%) .          .          .                       compare_bytes(self.as_ptr() as *const u8, other.as_ptr() as *const u8, size) == 0
     10 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (1x)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[doc(hidden)]
      .          .          .          .           // intermediate trait for specialization of slice's PartialOrd
      .          .          .          .           trait SlicePartialOrd: Sized {
      .          .          .          .               fn partial_compare(left: &[Self], right: &[Self]) -> Option<Ordering>;
-- line 99 ----------------------------------------
-- line 204 ----------------------------------------
      .          .          .          .           impl<A: Ord + UnsignedBytewiseOrd> SliceOrd for A {
      .          .          .          .               #[inline]
      .          .          .          .               fn compare(left: &[Self], right: &[Self]) -> Ordering {
      .          .          .          .                   // Since the length of a slice is always less than or equal to
      .          .          .          .                   // isize::MAX, this never underflows.
      .          .          .          .                   let diff = left.len() as isize - right.len() as isize;
      .          .          .          .                   // This comparison gets optimized away (on x86_64 and ARM) because the
      .          .          .          .                   // subtraction updates flags.
 20,466 ( 0.01%) .          .          .                   let len = if left.len() < right.len() { left.len() } else { right.len() };
      .          .          .          .                   let left = left.as_ptr().cast();
      .          .          .          .                   let right = right.as_ptr().cast();
      .          .          .          .                   // SAFETY: `left` and `right` are references and are thus guaranteed to
      .          .          .          .                   // be valid. `UnsignedBytewiseOrd` is only implemented for types that
      .          .          .          .                   // are valid u8s and can be compared the same way. We use the minimum
      .          .          .          .                   // of both lengths which guarantees that both regions are valid for
      .          .          .          .                   // reads in that interval.
 18,065 ( 0.01%) .          .          .                   let mut order = unsafe { compare_bytes(left, right, len) as isize };
 32,843 ( 0.01%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe (1,453x)
 13,012 ( 0.00%) .          .          .                   if order == 0 {
      .          .          .          .                       order = diff;
      .          .          .          .                   }
      .          .          .          .                   order.cmp(&0)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           pub(super) trait SliceContains: Sized {
      .          .          .          .               fn slice_contains(&self, x: &[Self]) -> bool;
-- line 229 ----------------------------------------

 13,925 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 254 ----------------------------------------
        .          .          .          .           
        .          .          .          .               /// Tests for `!=`. The default implementation is almost always sufficient,
        .          .          .          .               /// and should not be overridden without very good reason.
        .          .          .          .               #[inline]
        .          .          .          .               #[must_use]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[rustc_diagnostic_item = "cmp_partialeq_ne"]
        .          .          .          .               fn ne(&self, other: &Rhs) -> bool {
       30 ( 0.00%) .          .          .                   !self.eq(other)
      286 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:<termcolor::ColorSpec as core::cmp::PartialEq>::eq (12x)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// Derive macro generating an impl of the trait [`PartialEq`].
        .          .          .          .           /// The behavior of this macro is described in detail [here](PartialEq#derivable).
        .          .          .          .           #[rustc_builtin_macro]
        .          .          .          .           #[stable(feature = "builtin_macro_prelude", since = "1.38.0")]
        .          .          .          .           #[allow_internal_unstable(core_intrinsics, structural_match)]
-- line 270 ----------------------------------------
-- line 372 ----------------------------------------
        .          .          .          .           /// use std::cmp::Ordering;
        .          .          .          .           ///
        .          .          .          .           /// assert_eq!(1.cmp(&2), Ordering::Less);
        .          .          .          .           ///
        .          .          .          .           /// assert_eq!(1.cmp(&1), Ordering::Equal);
        .          .          .          .           ///
        .          .          .          .           /// assert_eq!(2.cmp(&1), Ordering::Greater);
        .          .          .          .           /// ```
  220,089 ( 0.07%) .          .          .           #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           // This is a lang item only so that `BinOp::Cmp` in MIR can return it.
        .          .          .          .           // It has no special behavior, but does require that the three variants
        .          .          .          .           // `Less`/`Equal`/`Greater` remain `-1_i8`/`0_i8`/`+1_i8` respectively.
        .          .          .          .           #[lang = "Ordering"]
        .          .          .          .           #[repr(i8)]
        .          .          .          .           pub enum Ordering {
        .          .          .          .               /// An ordering where a compared value is less than another.
-- line 388 ----------------------------------------
-- line 976 ----------------------------------------
        .          .          .          .               #[stable(feature = "ord_max_min", since = "1.21.0")]
        .          .          .          .               #[inline]
        .          .          .          .               #[must_use]
        .          .          .          .               #[rustc_diagnostic_item = "cmp_ord_max"]
        .          .          .          .               fn max(self, other: Self) -> Self
        .          .          .          .               where
        .          .          .          .                   Self: Sized,
        .          .          .          .               {
        2 ( 0.00%) .          .          .                   max_by(self, other, Ord::cmp)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Compares and returns the minimum of two values.
        .          .          .          .               ///
        .          .          .          .               /// Returns the first argument if the comparison determines them to be equal.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
-- line 992 ----------------------------------------
-- line 1628 ----------------------------------------
        .          .          .          .               use crate::cmp::Ordering::{self, Equal, Greater, Less};
        .          .          .          .               use crate::hint::unreachable_unchecked;
        .          .          .          .           
        .          .          .          .               macro_rules! partial_eq_impl {
        .          .          .          .                   ($($t:ty)*) => ($(
        .          .          .          .                       #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .                       impl PartialEq for $t {
        .          .          .          .                           #[inline]
   74,797 ( 0.02%) .          .          .                           fn eq(&self, other: &$t) -> bool { (*self) == (*other) }
        .          .          .          .                           #[inline]
        .          .          .          .                           fn ne(&self, other: &$t) -> bool { (*self) != (*other) }
        .          .          .          .                       }
        .          .          .          .                   )*)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               impl PartialEq for () {
-- line 1644 ----------------------------------------
-- line 1709 ----------------------------------------
        .          .          .          .               partial_ord_impl! { f16 f32 f64 f128 }
        .          .          .          .           
        .          .          .          .               macro_rules! ord_impl {
        .          .          .          .                   ($($t:ty)*) => ($(
        .          .          .          .                       #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .                       impl PartialOrd for $t {
        .          .          .          .                           #[inline]
        .          .          .          .                           fn partial_cmp(&self, other: &$t) -> Option<Ordering> {
   25,950 ( 0.01%) .          .          .                               Some(crate::intrinsics::three_way_compare(*self, *other))
        .          .          .          .                           }
        .          .          .          .                           #[inline(always)]
1,164,336 ( 0.35%) .          .          .                           fn lt(&self, other: &$t) -> bool { (*self) < (*other) }
        .          .          .          .                           #[inline(always)]
    1,196 ( 0.00%) .          .          .                           fn le(&self, other: &$t) -> bool { (*self) <= (*other) }
        .          .          .          .                           #[inline(always)]
        5 ( 0.00%) .          .          .                           fn ge(&self, other: &$t) -> bool { (*self) >= (*other) }
        .          .          .          .                           #[inline(always)]
        4 ( 0.00%) .          .          .                           fn gt(&self, other: &$t) -> bool { (*self) > (*other) }
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .                       impl Ord for $t {
        .          .          .          .                           #[inline]
        .          .          .          .                           fn cmp(&self, other: &$t) -> Ordering {
  140,813 ( 0.04%) .          .          .                               crate::intrinsics::three_way_compare(*self, *other)
        .          .          .          .                           }
        .          .          .          .                       }
        .          .          .          .                   )*)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               impl Ord for () {
        .          .          .          .                   #[inline]
-- line 1741 ----------------------------------------
-- line 1810 ----------------------------------------
        .          .          .          .           
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &A
        .          .          .          .               where
        .          .          .          .                   A: PartialEq<B>,
        .          .          .          .               {
        .          .          .          .                   #[inline]
        .          .          .          .                   fn eq(&self, other: &&B) -> bool {
      560 ( 0.00%) .          .          .                       PartialEq::eq(*self, *other)
   10,907 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::cmp::PartialEq>::eq (65x)
        .          .          .          .                   }
        .          .          .          .                   #[inline]
        .          .          .          .                   fn ne(&self, other: &&B) -> bool {
        .          .          .          .                       PartialEq::ne(*self, *other)
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               impl<A: ?Sized, B: ?Sized> PartialOrd<&B> for &A
-- line 1826 ----------------------------------------
-- line 1850 ----------------------------------------
        .          .          .          .               }
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               impl<A: ?Sized> Ord for &A
        .          .          .          .               where
        .          .          .          .                   A: Ord,
        .          .          .          .               {
        .          .          .          .                   #[inline]
        .          .          .          .                   fn cmp(&self, other: &Self) -> Ordering {
       30 ( 0.00%) .          .          .                       Ord::cmp(*self, *other)
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               impl<A: ?Sized> Eq for &A where A: Eq {}
        .          .          .          .           
        .          .          .          .               // &mut pointers
        .          .          .          .           
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
-- line 1866 ----------------------------------------

1,285,538 ( 0.39%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/literal_trie.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 88 ----------------------------------------
      .          .          .          .               /// a reverse NFA automaton.
      .          .          .          .               rev: bool,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl LiteralTrie {
      .          .          .          .               /// Create a new literal trie that adds literals in the forward direction.
      .          .          .          .               pub(crate) fn forward() -> LiteralTrie {
      .          .          .          .                   let root = State::default();
  2,430 ( 0.00%) .          .          .                   LiteralTrie { states: vec![root], rev: false }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new literal trie that adds literals in reverse.
    504 ( 0.00%) .          .          .               pub(crate) fn reverse() -> LiteralTrie {
      .          .          .          .                   let root = State::default();
  2,520 ( 0.00%) .          .          .                   LiteralTrie { states: vec![root], rev: true }
    756 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add the given literal to this trie.
      .          .          .          .               ///
      .          .          .          .               /// If the literal could not be added because the `StateID` space was
      .          .          .          .               /// exhausted, then an error is returned. If an error returns, the trie
      .          .          .          .               /// is in an unspecified state.
267,110 ( 0.08%) .          .          .               pub(crate) fn add(&mut self, bytes: &[u8]) -> Result<(), BuildError> {
      .          .          .          .                   let mut prev = StateID::ZERO;
      .          .          .          .                   let mut it = bytes.iter().copied();
226,473 ( 0.07%) .          .          .                   while let Some(b) = if self.rev { it.next_back() } else { it.next() } {
      .          .          .          .                       prev = self.get_or_add_state(prev, b)?;
      .          .          .          .                   }
      .          .          .          .                   self.states[prev].add_match();
 80,133 ( 0.02%) .          .          .                   Ok(())
213,688 ( 0.06%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// If the given transition is defined, then return the next state ID.
      .          .          .          .               /// Otherwise, add the transition to `from` and point it to a new state.
      .          .          .          .               ///
      .          .          .          .               /// If a new state ID could not be allocated, then an error is returned.
      .          .          .          .               fn get_or_add_state(
      .          .          .          .                   &mut self,
      .          .          .          .                   from: StateID,
      .          .          .          .                   byte: u8,
      .          .          .          .               ) -> Result<StateID, BuildError> {
      .          .          .          .                   let active = self.states[from].active_chunk();
      .          .          .          .                   match active.binary_search_by_key(&byte, |t| t.byte) {
 60,752 ( 0.02%) .          .          .                       Ok(i) => Ok(active[i].next),
      .          .          .          .                       Err(i) => {
      .          .          .          .                           // Add a new state and get its ID.
      .          .          .          .                           let next = StateID::new(self.states.len()).map_err(|_| {
      .          .          .          .                               BuildError::too_many_states(self.states.len())
      .          .          .          .                           })?;
      .          .          .          .                           self.states.push(State::default());
      .          .          .          .                           // Offset our position to account for all transitions and not
      .          .          .          .                           // just the ones in the active chunk.
 81,602 ( 0.02%) .          .          .                           let i = self.states[from].active_chunk_start() + i;
      .          .          .          .                           let t = Transition { byte, next };
      .          .          .          .                           self.states[from].transitions.insert(i, t);
      .          .          .          .                           Ok(next)
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile this literal trie to the NFA builder given.
      .          .          .          .               ///
      .          .          .          .               /// This forwards any errors that may occur while using the given builder.
  5,445 ( 0.00%) .          .          .               pub(crate) fn compile(
      .          .          .          .                   &self,
      .          .          .          .                   builder: &mut Builder,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   // Compilation proceeds via depth-first traversal of the trie.
      .          .          .          .                   //
      .          .          .          .                   // This is overall pretty brutal. The recursive version of this is
      .          .          .          .                   // deliciously simple. (See 'compile_to_hir' below for what it might
      .          .          .          .                   // look like.) But recursion on a trie means your call stack grows
-- line 159 ----------------------------------------
-- line 167 ----------------------------------------
      .          .          .          .                   // 'end' is our match state for this trie, but represented in the the
      .          .          .          .                   // NFA. Any time we see a match in the trie, we insert a transition
      .          .          .          .                   // from the current state we're in to 'end'.
      .          .          .          .                   let end = builder.add_empty()?;
      .          .          .          .                   let mut stack = vec![];
      .          .          .          .                   let mut f = Frame::new(&self.states[StateID::ZERO]);
      .          .          .          .                   loop {
      .          .          .          .                       if let Some(t) = f.transitions.next() {
122,403 ( 0.04%) .          .          .                           if self.states[t.next].is_leaf() {
 49,682 ( 0.01%) .          .          .                               f.sparse.push(thompson::Transition {
      .          .          .          .                                   start: t.byte,
      .          .          .          .                                   end: t.byte,
      .          .          .          .                                   next: end,
      .          .          .          .                               });
      .          .          .          .                           } else {
 15,960 ( 0.00%) .          .          .                               f.sparse.push(thompson::Transition {
      .          .          .          .                                   start: t.byte,
      .          .          .          .                                   end: t.byte,
      .          .          .          .                                   // This is a little funny, but when the frame we create
      .          .          .          .                                   // below completes, it will pop this parent frame off
      .          .          .          .                                   // and modify this transition to point to the correct
      .          .          .          .                                   // state.
      .          .          .          .                                   next: StateID::ZERO,
      .          .          .          .                               });
255,360 ( 0.08%) .          .          .                               stack.push(f);
223,440 ( 0.07%) .          .          .                               f = Frame::new(&self.states[t.next]);
      .          .          .          .                           }
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       // At this point, we have visited all transitions in f.chunk, so
      .          .          .          .                       // add it as a sparse NFA state. Unless the chunk was empty, in
      .          .          .          .                       // which case, we don't do anything.
 71,702 ( 0.02%) .          .          .                       if !f.sparse.is_empty() {
      .          .          .          .                           let chunk_id = if f.sparse.len() == 1 {
      .          .          .          .                               builder.add_range(f.sparse.pop().unwrap())?
      .          .          .          .                           } else {
      .          .          .          .                               let sparse = mem::replace(&mut f.sparse, vec![]);
      .          .          .          .                               builder.add_sparse(sparse)?
      .          .          .          .                           };
      .          .          .          .                           f.union.push(chunk_id);
      .          .          .          .                       }
      .          .          .          .                       // Now we need to look to see if there are other chunks to visit.
 18,325 ( 0.01%) .          .          .                       if let Some(chunk) = f.chunks.next() {
      .          .          .          .                           // If we're here, it means we're on the second (or greater)
      .          .          .          .                           // chunk, which implies there is a match at this point. So
      .          .          .          .                           // connect this state to the final end state.
      .          .          .          .                           f.union.push(end);
      .          .          .          .                           // Advance to the next chunk.
  3,740 ( 0.00%) .          .          .                           f.transitions = chunk.iter();
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       // Now that we are out of chunks, we have completely visited
      .          .          .          .                       // this state. So turn our union of chunks into an NFA union
      .          .          .          .                       // state, and add that union state to the parent state's current
      .          .          .          .                       // sparse state. (If there is no parent, we're done.)
 82,275 ( 0.02%) .          .          .                       let start = builder.add_union(f.union)?;
 31,920 ( 0.01%) .          .          .                       match stack.pop() {
      .          .          .          .                           None => {
  2,970 ( 0.00%) .          .          .                               return Ok(ThompsonRef { start, end });
      .          .          .          .                           }
191,520 ( 0.06%) .          .          .                           Some(mut parent) => {
      .          .          .          .                               // OK because the only way a frame gets pushed on to the
      .          .          .          .                               // stack (aside from the root) is when a transition has
      .          .          .          .                               // been added to 'sparse'.
 15,960 ( 0.00%) .          .          .                               parent.sparse.last_mut().unwrap().next = start;
255,360 ( 0.08%) .          .          .                               f = parent;
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
  4,455 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Converts this trie to an equivalent HIR expression.
      .          .          .          .               ///
      .          .          .          .               /// We don't actually use this, but it's useful for tests. In particular,
      .          .          .          .               /// it provides a (somewhat) human readable representation of the trie
      .          .          .          .               /// itself.
      .          .          .          .               #[cfg(test)]
      .          .          .          .               fn compile_to_hir(&self) -> regex_syntax::hir::Hir {
-- line 244 ----------------------------------------
-- line 323 ----------------------------------------
      .          .          .          .               /// Create a new stack frame for trie traversal. This initializes the
      .          .          .          .               /// 'transitions' iterator to the transitions for the first chunk, with the
      .          .          .          .               /// 'chunks' iterator being every chunk after the first one.
      .          .          .          .               fn new(state: &'a State) -> Frame<'a> {
      .          .          .          .                   let mut chunks = state.chunks();
      .          .          .          .                   // every state has at least 1 chunk
      .          .          .          .                   let chunk = chunks.next().unwrap();
      .          .          .          .                   let transitions = chunk.iter();
 55,305 ( 0.02%) .          .          .                   Frame { chunks, transitions, union: vec![], sparse: vec![] }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A state in a trie.
      .          .          .          .           ///
      .          .          .          .           /// This uses a sparse representation. Since we don't use literal tries
      .          .          .          .           /// for searching, and ultimately (and compilation requires visiting every
      .          .          .          .           /// transition anyway), we use a sparse representation for transitions. This
-- line 339 ----------------------------------------
-- line 371 ----------------------------------------
      .          .          .          .               fn add_match(&mut self) {
      .          .          .          .                   // This is not strictly necessary, but there's no point in recording
      .          .          .          .                   // another match by adding another chunk if the state has no
      .          .          .          .                   // transitions. Note though that we only skip this if we already know
      .          .          .          .                   // this is a match state, which is only true if 'chunks' is not empty.
      .          .          .          .                   // Basically, if we didn't do this, nothing semantically would change,
      .          .          .          .                   // but we'd end up pushing another chunk and potentially triggering an
      .          .          .          .                   // alloc.
 78,458 ( 0.02%) .          .          .                   if self.transitions.is_empty() && !self.chunks.is_empty() {
      .          .          .          .                       return;
      .          .          .          .                   }
 78,458 ( 0.02%) .          .          .                   let chunk_start = self.active_chunk_start();
      .          .          .          .                   let chunk_end = self.transitions.len();
 26,711 ( 0.01%) .          .          .                   self.chunks.push((chunk_start, chunk_end));
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this state is a leaf state. That is, a
      .          .          .          .               /// state that has no outgoing transitions.
      .          .          .          .               fn is_leaf(&self) -> bool {
      .          .          .          .                   self.transitions.is_empty()
      .          .          .          .               }
      .          .          .          .           
-- line 392 ----------------------------------------
-- line 399 ----------------------------------------
      .          .          .          .                       transitions: &*self.transitions,
      .          .          .          .                       chunks: self.chunks.iter(),
      .          .          .          .                       active: Some(self.active_chunk()),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the active chunk as a slice of transitions.
      .          .          .          .               fn active_chunk(&self) -> &[Transition] {
 71,177 ( 0.02%) .          .          .                   let start = self.active_chunk_start();
      .          .          .          .                   &self.transitions[start..]
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the index into 'transitions' where the active chunk starts.
      .          .          .          .               fn active_chunk_start(&self) -> usize {
      .          .          .          .                   self.chunks.last().map_or(0, |&(_, end)| end)
      .          .          .          .               }
      .          .          .          .           }
-- line 415 ----------------------------------------
-- line 446 ----------------------------------------
      .          .          .          .               chunks: core::slice::Iter<'a, (usize, usize)>,
      .          .          .          .               active: Option<&'a [Transition]>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'a> Iterator for StateChunksIter<'a> {
      .          .          .          .               type Item = &'a [Transition];
      .          .          .          .           
      .          .          .          .               fn next(&mut self) -> Option<&'a [Transition]> {
  3,740 ( 0.00%) .          .          .                   if let Some(&(start, end)) = self.chunks.next() {
      .          .          .          .                       return Some(&self.transitions[start..end]);
      .          .          .          .                   }
 18,325 ( 0.01%) .          .          .                   if let Some(chunk) = self.active.take() {
      .          .          .          .                       return Some(chunk);
      .          .          .          .                   }
      .          .          .          .                   None
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A single transition in a trie to another state.
      .          .          .          .           #[derive(Clone, Copy)]
-- line 465 ----------------------------------------

479,514 ( 0.14%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/literal_trie.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/traits.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 155 ----------------------------------------
      .          .          .          .           /// // byte 100 is outside the string
      .          .          .          .           /// // &s[3 .. 100];
      .          .          .          .           /// ```
      .          .          .          .           #[stable(feature = "str_checked_slicing", since = "1.20.0")]
      .          .          .          .           unsafe impl SliceIndex<str> for ops::Range<usize> {
      .          .          .          .               type Output = str;
      .          .          .          .               #[inline]
      .          .          .          .               fn get(self, slice: &str) -> Option<&Self::Output> {
  4,068 ( 0.00%) .          .          .                   if self.start <= self.end
  1,356 ( 0.00%) .          .          .                       && slice.is_char_boundary(self.start)
  1,356 ( 0.00%) .          .          .                       && slice.is_char_boundary(self.end)
      .          .          .          .                   {
      .          .          .          .                       // SAFETY: just checked that `start` and `end` are on a char boundary,
      .          .          .          .                       // and we are passing in a safe reference, so the return value will also be one.
      .          .          .          .                       // We also checked char boundaries, so this is valid UTF-8.
      .          .          .          .                       Some(unsafe { &*self.get_unchecked(slice) })
      .          .          .          .                   } else {
      .          .          .          .                       None
      .          .          .          .                   }
-- line 173 ----------------------------------------
-- line 203 ----------------------------------------
      .          .          .          .                           end: usize = self.end,
      .          .          .          .                           len: usize = slice.len()
      .          .          .          .                       ) => end >= start && end <= len,
      .          .          .          .                   );
      .          .          .          .           
      .          .          .          .                   // SAFETY: the caller guarantees that `self` is in bounds of `slice`
      .          .          .          .                   // which satisfies all the conditions for `add`.
      .          .          .          .                   unsafe {
  1,508 ( 0.00%) .          .          .                       let new_len = unchecked_sub(self.end, self.start);
      .          .          .          .                       ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), new_len) as *const str
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .               #[inline]
      .          .          .          .               unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {
      .          .          .          .                   let slice = slice as *mut [u8];
      .          .          .          .           
      .          .          .          .                   assert_unsafe_precondition!(
-- line 219 ----------------------------------------
-- line 457 ----------------------------------------
      .          .          .          .               #[inline]
      .          .          .          .               unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {
      .          .          .          .                   // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.
      .          .          .          .                   unsafe { (0..self.end).get_unchecked_mut(slice) }
      .          .          .          .               }
      .          .          .          .               #[inline]
      .          .          .          .               fn index(self, slice: &str) -> &Self::Output {
      .          .          .          .                   let end = self.end;
     13 ( 0.00%) .          .          .                   match self.get(slice) {
      .          .          .          .                       Some(s) => s,
      .          .          .          .                       None => super::slice_error_fail(slice, 0, end),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .               #[inline]
      .          .          .          .               fn index_mut(self, slice: &mut str) -> &mut Self::Output {
      .          .          .          .                   if slice.is_char_boundary(self.end) {
      .          .          .          .                       // SAFETY: just checked that `end` is on a char boundary,
-- line 473 ----------------------------------------
-- line 494 ----------------------------------------
      .          .          .          .           ///
      .          .          .          .           /// Panics if `begin` does not point to the starting byte offset of
      .          .          .          .           /// a character (as defined by `is_char_boundary`), or if `begin > len`.
      .          .          .          .           #[stable(feature = "str_checked_slicing", since = "1.20.0")]
      .          .          .          .           unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {
      .          .          .          .               type Output = str;
      .          .          .          .               #[inline]
      .          .          .          .               fn get(self, slice: &str) -> Option<&Self::Output> {
586,620 ( 0.18%) .          .          .                   if slice.is_char_boundary(self.start) {
      .          .          .          .                       // SAFETY: just checked that `start` is on a char boundary,
      .          .          .          .                       // and we are passing in a safe reference, so the return value will also be one.
      .          .          .          .                       Some(unsafe { &*self.get_unchecked(slice) })
      .          .          .          .                   } else {
      .          .          .          .                       None
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .               #[inline]
-- line 510 ----------------------------------------
-- line 527 ----------------------------------------
      .          .          .          .               unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {
      .          .          .          .                   let len = (slice as *mut [u8]).len();
      .          .          .          .                   // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.
      .          .          .          .                   unsafe { (self.start..len).get_unchecked_mut(slice) }
      .          .          .          .               }
      .          .          .          .               #[inline]
      .          .          .          .               fn index(self, slice: &str) -> &Self::Output {
      .          .          .          .                   let (start, end) = (self.start, slice.len());
     54 ( 0.00%) .          .          .                   match self.get(slice) {
      .          .          .          .                       Some(s) => s,
      .          .          .          .                       None => super::slice_error_fail(slice, start, end),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .               #[inline]
      .          .          .          .               fn index_mut(self, slice: &mut str) -> &mut Self::Output {
      .          .          .          .                   if slice.is_char_boundary(self.start) {
      .          .          .          .                       // SAFETY: just checked that `start` is on a char boundary,
-- line 543 ----------------------------------------

  3,758 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/traits.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 215 ----------------------------------------
     .          .          .          .               range: Utf8Range,
     .          .          .          .               /// The next state to transition to.
     .          .          .          .               next_id: StateID,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl RangeTrie {
     .          .          .          .               /// Create a new empty range trie.
     .          .          .          .               pub fn new() -> RangeTrie {
10,758 ( 0.00%) .          .          .                   let mut trie = RangeTrie {
     .          .          .          .                       states: vec![],
     .          .          .          .                       free: vec![],
     .          .          .          .                       iter_stack: RefCell::new(vec![]),
     .          .          .          .                       iter_ranges: RefCell::new(vec![]),
     .          .          .          .                       dupe_stack: vec![],
     .          .          .          .                       insert_stack: vec![],
     .          .          .          .                   };
     .          .          .          .                   trie.clear();
 2,696 ( 0.00%) .          .          .                   trie
   390 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (13x)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Clear this range trie such that it is empty. Clearing a range trie
     .          .          .          .               /// and reusing it can beneficial because this may reuse allocations.
     .          .          .          .               pub fn clear(&mut self) {
     .          .          .          .                   self.free.append(&mut self.states);
 1,348 ( 0.00%) .          .          .                   self.add_empty(); // final
 2,093 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::nfa::thompson::range_trie::RangeTrie::add_empty (13x)
 1,348 ( 0.00%) .          .          .                   self.add_empty(); // root
   403 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs:regex_automata::nfa::thompson::range_trie::RangeTrie::add_empty (13x)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Iterate over all of the sequences of byte ranges in this trie, and
     .          .          .          .               /// call the provided function for each sequence. Iteration occurs in
     .          .          .          .               /// lexicographic order.
     .          .          .          .               pub fn iter<E, F: FnMut(&[Utf8Range]) -> Result<(), E>>(
     .          .          .          .                   &self,
     .          .          .          .                   mut f: F,
-- line 248 ----------------------------------------
-- line 420 ----------------------------------------
     .          .          .          .                           // no subsequent transitions with any overlap. Therefore, we
     .          .          .          .                           // can stop processing this range and move on to the next one.
     .          .          .          .                           break;
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   self.insert_stack = stack;
     .          .          .          .               }
     .          .          .          .           
 6,740 ( 0.00%) .          .          .               pub fn add_empty(&mut self) -> StateID {
     .          .          .          .                   let id = match StateID::try_from(self.states.len()) {
     .          .          .          .                       Ok(id) => id,
     .          .          .          .                       Err(_) => {
     .          .          .          .                           // This generally should not happen since a range trie is
     .          .          .          .                           // only ever used to compile a single sequence of Unicode
     .          .          .          .                           // scalar values. If we ever got to this point, we would, at
     .          .          .          .                           // *minimum*, be using 96GB in just the range trie alone.
     .          .          .          .                           panic!("too many sequences added to range trie");
-- line 436 ----------------------------------------
-- line 440 ----------------------------------------
     .          .          .          .                   // more allocations.
     .          .          .          .                   if let Some(mut state) = self.free.pop() {
     .          .          .          .                       state.clear();
     .          .          .          .                       self.states.push(state);
     .          .          .          .                   } else {
     .          .          .          .                       self.states.push(State { transitions: vec![] });
     .          .          .          .                   }
     .          .          .          .                   id
 9,436 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Performs a deep clone of the given state and returns the duplicate's
     .          .          .          .               /// state ID.
     .          .          .          .               ///
     .          .          .          .               /// A "deep clone" in this context means that the state given along with
     .          .          .          .               /// recursively all states that it points to are copied. Once complete,
     .          .          .          .               /// the given state ID and the returned state ID share nothing.
     .          .          .          .               ///
-- line 456 ----------------------------------------

 2,696 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/range_trie.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 56 ----------------------------------------
     .          .          .          .           impl<I: Interval> Eq for IntervalSet<I> {}
     .          .          .          .           
     .          .          .          .           // We implement PartialEq manually so that we don't consider the set's internal
     .          .          .          .           // 'folded' property to be part of its identity. The 'folded' property is
     .          .          .          .           // strictly an optimization.
     .          .          .          .           impl<I: Interval> PartialEq for IntervalSet<I> {
     .          .          .          .               fn eq(&self, other: &IntervalSet<I>) -> bool {
     .          .          .          .                   self.ranges.eq(&other.ranges)
    64 ( 0.00%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<I: Interval> IntervalSet<I> {
     .          .          .          .               /// Create a new set from a sequence of intervals. Each interval is
     .          .          .          .               /// specified as a pair of bounds, where both bounds are inclusive.
     .          .          .          .               ///
     .          .          .          .               /// The given ranges do not need to be in any specific order, and ranges
     .          .          .          .               /// may overlap.
 3,401 ( 0.00%) .          .          .               pub fn new<T: IntoIterator<Item = I>>(intervals: T) -> IntervalSet<I> {
     .          .          .          .                   let ranges: Vec<I> = intervals.into_iter().collect();
     .          .          .          .                   // An empty set is case folded.
     .          .          .          .                   let folded = ranges.is_empty();
28,850 ( 0.01%) .          .          .                   let mut set = IntervalSet { ranges, folded };
 5,994 ( 0.00%) .          .          .                   set.canonicalize();
 2,640 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (110x)
23,977 ( 0.01%) .          .          .                   set
 4,520 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add a new interval to this set.
     .          .          .          .               pub fn push(&mut self, interval: I) {
     .          .          .          .                   // TODO: This could be faster. e.g., Push the interval such that
     .          .          .          .                   // it preserves canonicalization.
     .          .          .          .                   self.ranges.push(interval);
 3,545 ( 0.00%) .          .          .                   self.canonicalize();
376,208 ( 0.11%) 336 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (3,545x)
     .          .          .          .                   // We don't know whether the new interval added here is considered
     .          .          .          .                   // case folded, so we conservatively assume that the entire set is
     .          .          .          .                   // no longer case folded if it was previously.
 3,545 ( 0.00%) .          .          .                   self.folded = false;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return an iterator over all intervals in this set.
     .          .          .          .               ///
     .          .          .          .               /// The iterator yields intervals in ascending order.
     .          .          .          .               pub fn iter(&self) -> IntervalSetIter<'_, I> {
     .          .          .          .                   IntervalSetIter(self.ranges.iter())
     .          .          .          .               }
-- line 99 ----------------------------------------
-- line 108 ----------------------------------------
     .          .          .          .               /// Expand this interval set such that it contains all case folded
     .          .          .          .               /// characters. For example, if this class consists of the range `a-z`,
     .          .          .          .               /// then applying case folding will result in the class containing both the
     .          .          .          .               /// ranges `a-z` and `A-Z`.
     .          .          .          .               ///
     .          .          .          .               /// This returns an error if the necessary case mapping data is not
     .          .          .          .               /// available.
     .          .          .          .               pub fn case_fold_simple(&mut self) -> Result<(), unicode::CaseFoldError> {
 2,660 ( 0.00%) .          .          .                   if self.folded {
     .          .          .          .                       return Ok(());
     .          .          .          .                   }
     .          .          .          .                   let len = self.ranges.len();
     .          .          .          .                   for i in 0..len {
 2,380 ( 0.00%) .          .          .                       let range = self.ranges[i];
 3,710 ( 0.00%) .          .          .                       if let Err(err) = range.case_fold_simple(&mut self.ranges) {
830,539 ( 0.25%) 2,240 ( 0.28%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::ClassUnicodeRange as regex_syntax::hir::interval::Interval>::case_fold_simple (1,120x)
     .          .          .          .                           self.canonicalize();
     .          .          .          .                           return Err(err);
     .          .          .          .                       }
     .          .          .          .                   }
 2,310 ( 0.00%) .          .          .                   self.canonicalize();
56,520 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (1,120x)
 1,190 ( 0.00%) .          .          .                   self.folded = true;
     .          .          .          .                   Ok(())
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Union this set with the given set, in place.
     .          .          .          .               pub fn union(&mut self, other: &IntervalSet<I>) {
 1,808 ( 0.00%) .          .          .                   if other.ranges.is_empty() || self.ranges == other.ranges {
     .          .          .          .                       return;
     .          .          .          .                   }
     .          .          .          .                   // This could almost certainly be done more efficiently.
     .          .          .          .                   self.ranges.extend(&other.ranges);
 1,090 ( 0.00%) .          .          .                   self.canonicalize();
 3,738 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs:regex_syntax::hir::interval::IntervalSet<I>::canonicalize (58x)
 4,264 ( 0.00%) .          .          .                   self.folded = self.folded && other.folded;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Intersect this set with the given set, in place.
     .          .          .          .               pub fn intersect(&mut self, other: &IntervalSet<I>) {
     .          .          .          .                   if self.ranges.is_empty() {
     .          .          .          .                       return;
     .          .          .          .                   }
     .          .          .          .                   if other.ranges.is_empty() {
-- line 148 ----------------------------------------
-- line 288 ----------------------------------------
     .          .          .          .                   self.union(other);
     .          .          .          .                   self.difference(&intersection);
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Negate this interval set.
     .          .          .          .               ///
     .          .          .          .               /// For all `x` where `x` is any element, if `x` was in this set, then it
     .          .          .          .               /// will not be in this set after negation.
   488 ( 0.00%) .          .          .               pub fn negate(&mut self) {
   122 ( 0.00%) .          .          .                   if self.ranges.is_empty() {
     .          .          .          .                       let (min, max) = (I::Bound::min_value(), I::Bound::max_value());
     .          .          .          .                       self.ranges.push(I::create(min, max));
     .          .          .          .                       // The set containing everything must case folded.
     .          .          .          .                       self.folded = true;
     .          .          .          .                       return;
     .          .          .          .                   }
     .          .          .          .           
     .          .          .          .                   // There should be a way to do this in-place with constant memory,
     .          .          .          .                   // but I couldn't figure out a simple way to do it. So just append
     .          .          .          .                   // the negation to the end of this range, and then drain it before
     .          .          .          .                   // we're done.
     .          .          .          .                   let drain_end = self.ranges.len();
     .          .          .          .           
     .          .          .          .                   // We do checked arithmetic below because of the canonical ordering
     .          .          .          .                   // invariant.
   366 ( 0.00%) .          .          .                   if self.ranges[0].lower() > I::Bound::min_value() {
     .          .          .          .                       let upper = self.ranges[0].lower().decrement();
     .          .          .          .                       self.ranges.push(I::create(I::Bound::min_value(), upper));
     .          .          .          .                   }
     .          .          .          .                   for i in 1..drain_end {
    34 ( 0.00%) .          .          .                       let lower = self.ranges[i - 1].upper().increment();
    34 ( 0.00%) .          .          .                       let upper = self.ranges[i].lower().decrement();
     .          .          .          .                       self.ranges.push(I::create(lower, upper));
     .          .          .          .                   }
   122 ( 0.00%) .          .          .                   if self.ranges[drain_end - 1].upper() < I::Bound::max_value() {
     .          .          .          .                       let lower = self.ranges[drain_end - 1].upper().increment();
     .          .          .          .                       self.ranges.push(I::create(lower, I::Bound::max_value()));
     .          .          .          .                   }
     .          .          .          .                   self.ranges.drain(..drain_end);
     .          .          .          .                   // We don't need to update whether this set is folded or not, because
     .          .          .          .                   // it is conservatively preserved through negation. Namely, if a set
     .          .          .          .                   // is not folded, then it is possible that its negation is folded, for
     .          .          .          .                   // example, [^]. But we're fine with assuming that the set is not
-- line 330 ----------------------------------------
-- line 332 ----------------------------------------
     .          .          .          .                   // positives.)
     .          .          .          .                   //
     .          .          .          .                   // But what about when a set is folded, is its negation also
     .          .          .          .                   // necessarily folded? Yes. Because if a set is folded, then for every
     .          .          .          .                   // character in the set, it necessarily included its equivalence class
     .          .          .          .                   // of case folded characters. Negating it in turn means that all
     .          .          .          .                   // equivalence classes in the set are negated, and any equivalence
     .          .          .          .                   // class that was previously not in the set is now entirely in the set.
   488 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Converts this set into a canonical ordering.
93,064 ( 0.03%) .          .          .               fn canonicalize(&mut self) {
69,798 ( 0.02%) .          .          .                   if self.is_canonical() {
     .          .          .          .                       return;
     .          .          .          .                   }
     .          .          .          .                   self.ranges.sort();
     .          .          .          .                   assert!(!self.ranges.is_empty());
     .          .          .          .           
     .          .          .          .                   // Is there a way to do this in-place with constant memory? I couldn't
     .          .          .          .                   // figure out a way to do it. So just append the canonicalization to
     .          .          .          .                   // the end of this range, and then drain it before we're done.
     .          .          .          .                   let drain_end = self.ranges.len();
     .          .          .          .                   for oldi in 0..drain_end {
     .          .          .          .                       // If we've added at least one new range, then check if we can
     .          .          .          .                       // merge this range in the previously added range.
 5,770 ( 0.00%) .          .          .                       if self.ranges.len() > drain_end {
     .          .          .          .                           let (last, rest) = self.ranges.split_last_mut().unwrap();
 3,134 ( 0.00%) .          .          .                           if let Some(union) = last.union(&rest[oldi]) {
 2,064 ( 0.00%) .          .          .                               *last = union;
     .          .          .          .                               continue;
     .          .          .          .                           }
     .          .          .          .                       }
 1,853 ( 0.00%) .          .          .                       let range = self.ranges[oldi];
     .          .          .          .                       self.ranges.push(range);
     .          .          .          .                   }
     .          .          .          .                   self.ranges.drain(..drain_end);
93,064 ( 0.03%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this class is in a canonical ordering.
     .          .          .          .               fn is_canonical(&self) -> bool {
     .          .          .          .                   for pair in self.ranges.windows(2) {
22,340 ( 0.01%) .          .          .                       if pair[0] >= pair[1] {
     .          .          .          .                           return false;
     .          .          .          .                       }
 8,364 ( 0.00%) .          .          .                       if pair[0].is_contiguous(&pair[1]) {
     .          .          .          .                           return false;
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   true
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// An iterator over intervals.
-- line 384 ----------------------------------------
-- line 405 ----------------------------------------
     .          .          .          .               fn case_fold_simple(
     .          .          .          .                   &self,
     .          .          .          .                   intervals: &mut Vec<Self>,
     .          .          .          .               ) -> Result<(), unicode::CaseFoldError>;
     .          .          .          .           
     .          .          .          .               /// Create a new interval.
     .          .          .          .               fn create(lower: Self::Bound, upper: Self::Bound) -> Self {
     .          .          .          .                   let mut int = Self::default();
11,135 ( 0.00%) .          .          .                   if lower <= upper {
     .          .          .          .                       int.set_lower(lower);
     .          .          .          .                       int.set_upper(upper);
     .          .          .          .                   } else {
     .          .          .          .                       int.set_lower(upper);
     .          .          .          .                       int.set_upper(lower);
     .          .          .          .                   }
     .          .          .          .                   int
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Union the given overlapping range into this range.
     .          .          .          .               ///
     .          .          .          .               /// If the two ranges aren't contiguous, then this returns `None`.
     .          .          .          .               fn union(&self, other: &Self) -> Option<Self> {
 1,567 ( 0.00%) .          .          .                   if !self.is_contiguous(other) {
     .          .          .          .                       return None;
     .          .          .          .                   }
     .          .          .          .                   let lower = cmp::min(self.lower(), other.lower());
     .          .          .          .                   let upper = cmp::max(self.upper(), other.upper());
     .          .          .          .                   Some(Self::create(lower, upper))
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Intersect this range with the given range and return the result.
-- line 435 ----------------------------------------
-- line 478 ----------------------------------------
     .          .          .          .                   }
     .          .          .          .                   ret
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if the two ranges are contiguous. Two ranges
     .          .          .          .               /// are contiguous if and only if the ranges are either overlapping or
     .          .          .          .               /// adjacent.
     .          .          .          .               fn is_contiguous(&self, other: &Self) -> bool {
 1,567 ( 0.00%) .          .          .                   let lower1 = self.lower().as_u32();
 1,567 ( 0.00%) .          .          .                   let upper1 = self.upper().as_u32();
 1,567 ( 0.00%) .          .          .                   let lower2 = other.lower().as_u32();
 1,567 ( 0.00%) .          .          .                   let upper2 = other.upper().as_u32();
 5,749 ( 0.00%) .          .          .                   cmp::max(lower1, lower2) <= cmp::min(upper1, upper2).saturating_add(1)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if the intersection of this range and the
     .          .          .          .               /// other range is empty.
     .          .          .          .               fn is_intersection_empty(&self, other: &Self) -> bool {
     .          .          .          .                   let (lower1, upper1) = (self.lower(), self.upper());
     .          .          .          .                   let (lower2, upper2) = (other.lower(), other.upper());
     .          .          .          .                   cmp::max(lower1, lower2) > cmp::min(upper1, upper2)
-- line 498 ----------------------------------------
-- line 542 ----------------------------------------
     .          .          .          .               fn max_value() -> Self {
     .          .          .          .                   '\u{10FFFF}'
     .          .          .          .               }
     .          .          .          .               fn as_u32(self) -> u32 {
     .          .          .          .                   u32::from(self)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               fn increment(self) -> Self {
   190 ( 0.00%) .          .          .                   match self {
     .          .          .          .                       '\u{D7FF}' => '\u{E000}',
     .          .          .          .                       c => char::from_u32(u32::from(c).checked_add(1).unwrap()).unwrap(),
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               fn decrement(self) -> Self {
   136 ( 0.00%) .          .          .                   match self {
     .          .          .          .                       '\u{E000}' => '\u{D7FF}',
     .          .          .          .                       c => char::from_u32(u32::from(c).checked_sub(1).unwrap()).unwrap(),
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           // Tests for interval sets are written in src/hir.rs against the public API.

11,422 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/interval.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 47 ----------------------------------------
        .          .          .          .                       Primitive::Dot(ref span) => span,
        .          .          .          .                       Primitive::Perl(ref x) => &x.span,
        .          .          .          .                       Primitive::Unicode(ref x) => &x.span,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Convert this primitive into a proper AST.
        .          .          .          .               fn into_ast(self) -> Ast {
  396,856 ( 0.12%) .          .          .                   match self {
        .          .          .          .                       Primitive::Literal(lit) => Ast::literal(lit),
        .          .          .          .                       Primitive::Assertion(assert) => Ast::assertion(assert),
        .          .          .          .                       Primitive::Dot(span) => Ast::dot(span),
        .          .          .          .                       Primitive::Perl(cls) => Ast::class_perl(cls),
        .          .          .          .                       Primitive::Unicode(cls) => Ast::class_unicode(cls),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
-- line 63 ----------------------------------------
-- line 67 ----------------------------------------
        .          .          .          .               /// then return an error.
        .          .          .          .               fn into_class_set_item<P: Borrow<Parser>>(
        .          .          .          .                   self,
        .          .          .          .                   p: &ParserI<'_, P>,
        .          .          .          .               ) -> Result<ast::ClassSetItem> {
        .          .          .          .                   use self::Primitive::*;
        .          .          .          .                   use crate::ast::ClassSetItem;
        .          .          .          .           
   24,853 ( 0.01%) .          .          .                   match self {
   35,440 ( 0.01%) .          .          .                       Literal(lit) => Ok(ClassSetItem::Literal(lit)),
       50 ( 0.00%) .          .          .                       Perl(cls) => Ok(ClassSetItem::Perl(cls)),
        .          .          .          .                       Unicode(cls) => Ok(ClassSetItem::Unicode(cls)),
        .          .          .          .                       x => Err(p.error(*x.span(), ast::ErrorKind::ClassEscapeInvalid)),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Convert this primitive into a literal in a character class. In
        .          .          .          .               /// particular, literals are the only valid items that can appear in
        .          .          .          .               /// ranges.
-- line 85 ----------------------------------------
-- line 104 ----------------------------------------
        .          .          .          .               ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// Returns true if the given character is a valid in a capture group name.
        .          .          .          .           ///
        .          .          .          .           /// If `first` is true, then `c` is treated as the first character in the
        .          .          .          .           /// group name (which must be alphabetic or underscore).
        .          .          .          .           fn is_capture_char(c: char, first: bool) -> bool {
    1,758 ( 0.00%) .          .          .               if first {
    1,172 ( 0.00%) .          .          .                   c == '_' || c.is_alphabetic()
        .          .          .          .               } else {
    6,753 ( 0.00%) .          .          .                   c == '_' || c == '.' || c == '[' || c == ']' || c.is_alphanumeric()
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// A builder for a regular expression parser.
        .          .          .          .           ///
        .          .          .          .           /// This builder permits modifying configuration options for the parser.
        .          .          .          .           #[derive(Clone, Debug)]
        .          .          .          .           pub struct ParserBuilder {
-- line 123 ----------------------------------------
-- line 141 ----------------------------------------
        .          .          .          .                       nest_limit: 250,
        .          .          .          .                       octal: false,
        .          .          .          .                       empty_min_range: false,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Build a parser from this configuration with the given pattern.
        .          .          .          .               pub fn build(&self) -> Parser {
    2,187 ( 0.00%) .          .          .                   Parser {
        .          .          .          .                       pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),
        .          .          .          .                       capture_index: Cell::new(0),
        .          .          .          .                       nest_limit: self.nest_limit,
        .          .          .          .                       octal: self.octal,
        .          .          .          .                       empty_min_range: self.empty_min_range,
        .          .          .          .                       initial_ignore_whitespace: self.ignore_whitespace,
        .          .          .          .                       ignore_whitespace: Cell::new(self.ignore_whitespace),
        .          .          .          .                       comments: RefCell::new(vec![]),
-- line 157 ----------------------------------------
-- line 183 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// Note that a nest limit of `0` will return a nest limit error for most
        .          .          .          .               /// patterns but not all. For example, a nest limit of `0` permits `a` but
        .          .          .          .               /// not `ab`, since `ab` requires a concatenation, which results in a nest
        .          .          .          .               /// depth of `1`. In general, a nest limit is not something that manifests
        .          .          .          .               /// in an obvious way in the concrete syntax, therefore, it should not be
        .          .          .          .               /// used in a granular way.
        .          .          .          .               pub fn nest_limit(&mut self, limit: u32) -> &mut ParserBuilder {
       81 ( 0.00%) .          .          .                   self.nest_limit = limit;
        .          .          .          .                   self
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Whether to support octal syntax or not.
        .          .          .          .               ///
        .          .          .          .               /// Octal syntax is a little-known way of uttering Unicode codepoints in
        .          .          .          .               /// a regular expression. For example, `a`, `\x61`, `\u0061` and
        .          .          .          .               /// `\141` are all equivalent regular expressions, where the last example
-- line 199 ----------------------------------------
-- line 203 ----------------------------------------
        .          .          .          .               /// make good error messages harder. That is, in PCRE based regex engines,
        .          .          .          .               /// syntax like `\0` invokes a backreference, which is explicitly
        .          .          .          .               /// unsupported in Rust's regex engine. However, many users expect it to
        .          .          .          .               /// be supported. Therefore, when octal support is disabled, the error
        .          .          .          .               /// message will explicitly mention that backreferences aren't supported.
        .          .          .          .               ///
        .          .          .          .               /// Octal syntax is disabled by default.
        .          .          .          .               pub fn octal(&mut self, yes: bool) -> &mut ParserBuilder {
       81 ( 0.00%) .          .          .                   self.octal = yes;
        .          .          .          .                   self
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Enable verbose mode in the regular expression.
        .          .          .          .               ///
        .          .          .          .               /// When enabled, verbose mode permits insignificant whitespace in many
        .          .          .          .               /// places in the regular expression, as well as comments. Comments are
        .          .          .          .               /// started using `#` and continue until the end of the line.
        .          .          .          .               ///
        .          .          .          .               /// By default, this is disabled. It may be selectively enabled in the
        .          .          .          .               /// regular expression by using the `x` flag regardless of this setting.
        .          .          .          .               pub fn ignore_whitespace(&mut self, yes: bool) -> &mut ParserBuilder {
       81 ( 0.00%) .          .          .                   self.ignore_whitespace = yes;
        .          .          .          .                   self
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Allow using `{,n}` as an equivalent to `{0,n}`.
        .          .          .          .               ///
        .          .          .          .               /// When enabled, the parser accepts `{,n}` as valid syntax for `{0,n}`.
        .          .          .          .               /// Most regular expression engines don't support the `{,n}` syntax, but
        .          .          .          .               /// some others do it, namely Python's `re` library.
-- line 232 ----------------------------------------
-- line 354 ----------------------------------------
        .          .          .          .               /// methods. The parse methods return an abstract syntax tree.
        .          .          .          .               ///
        .          .          .          .               /// To set configuration options on the parser, use [`ParserBuilder`].
        .          .          .          .               pub fn new() -> Parser {
        .          .          .          .                   ParserBuilder::new().build()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse the regular expression into an abstract syntax tree.
      648 ( 0.00%) .          .          .               pub fn parse(&mut self, pattern: &str) -> Result<Ast> {
        .          .          .          .                   ParserI::new(self, pattern).parse()
      729 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse the regular expression and return an abstract syntax tree with
        .          .          .          .               /// all of the comments found in the pattern.
        .          .          .          .               pub fn parse_with_comments(
        .          .          .          .                   &mut self,
        .          .          .          .                   pattern: &str,
        .          .          .          .               ) -> Result<ast::WithComments> {
        .          .          .          .                   ParserI::new(self, pattern).parse_with_comments()
-- line 372 ----------------------------------------
-- line 376 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// This is called at the beginning of every parse. This prevents the
        .          .          .          .               /// parser from running with inconsistent state (say, if a previous
        .          .          .          .               /// invocation returned an error and the parser is reused).
        .          .          .          .               fn reset(&self) {
        .          .          .          .                   // These settings should be in line with the construction
        .          .          .          .                   // in `ParserBuilder::build`.
        .          .          .          .                   self.pos.set(Position { offset: 0, line: 1, column: 1 });
       81 ( 0.00%) .          .          .                   self.ignore_whitespace.set(self.initial_ignore_whitespace);
        .          .          .          .                   self.comments.borrow_mut().clear();
        .          .          .          .                   self.stack_group.borrow_mut().clear();
        .          .          .          .                   self.stack_class.borrow_mut().clear();
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'s, P: Borrow<Parser>> ParserI<'s, P> {
        .          .          .          .               /// Build an internal parser from a parser configuration and a pattern.
        .          .          .          .               fn new(parser: P, pattern: &'s str) -> ParserI<'s, P> {
      243 ( 0.00%) .          .          .                   ParserI { parser, pattern }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return a reference to the parser state.
        .          .          .          .               fn parser(&self) -> &Parser {
  732,076 ( 0.22%) .          .          .                   self.parser.borrow()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return a reference to the pattern being parsed.
        .          .          .          .               fn pattern(&self) -> &str {
  198,353 ( 0.06%) .          .          .                   self.pattern
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Create a new error with the given span and error type.
        .          .          .          .               fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {
        .          .          .          .                   ast::Error { kind, pattern: self.pattern().to_string(), span }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return the current offset of the parser.
-- line 412 ----------------------------------------
-- line 468 ----------------------------------------
        .          .          .          .               /// Return whether the parser should ignore whitespace or not.
        .          .          .          .               fn ignore_whitespace(&self) -> bool {
        .          .          .          .                   self.parser().ignore_whitespace.get()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return the character at the current position of the parser.
        .          .          .          .               ///
        .          .          .          .               /// This panics if the current position does not point to a valid char.
  981,248 ( 0.29%) .          .          .               fn char(&self) -> char {
  981,248 ( 0.29%) .          .          .                   self.char_at(self.offset())
  981,248 ( 0.29%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return the character at the given position.
        .          .          .          .               ///
        .          .          .          .               /// This panics if the given position does not point to a valid char.
        .          .          .          .               fn char_at(&self, i: usize) -> char {
        .          .          .          .                   self.pattern()[i..]
        .          .          .          .                       .chars()
        .          .          .          .                       .next()
        .          .          .          .                       .unwrap_or_else(|| panic!("expected char at offset {}", i))
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Bump the parser to the next Unicode scalar value.
        .          .          .          .               ///
        .          .          .          .               /// If the end of the input has been reached, then `false` is returned.
  646,961 ( 0.19%) .          .          .               fn bump(&self) -> bool {
   92,423 ( 0.03%) .          .          .                   if self.is_eof() {
        .          .          .          .                       return false;
        .          .          .          .                   }
        .          .          .          .                   let Position { mut offset, mut line, mut column } = self.pos();
  277,269 ( 0.08%) .          .          .                   if self.char() == '\n' {
1,848,736 ( 0.56%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (92,423x)
        .          .          .          .                       line = line.checked_add(1).unwrap();
        .          .          .          .                       column = 1;
        .          .          .          .                   } else {
        .          .          .          .                       column = column.checked_add(1).unwrap();
        .          .          .          .                   }
  184,846 ( 0.06%) .          .          .                   offset += self.char().len_utf8();
1,848,736 ( 0.56%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (92,423x)
        .          .          .          .                   self.parser().pos.set(Position { offset, line, column });
        .          .          .          .                   self.pattern()[self.offset()..].chars().next().is_some()
  739,384 ( 0.22%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// If the substring starting at the current position of the parser has
        .          .          .          .               /// the given prefix, then bump the parser to the character immediately
        .          .          .          .               /// following the prefix and return true. Otherwise, don't bump the parser
        .          .          .          .               /// and return false.
        .          .          .          .               fn bump_if(&self, prefix: &str) -> bool {
    4,589 ( 0.00%) .          .          .                   if self.pattern()[self.offset()..].starts_with(prefix) {
        .          .          .          .                       for _ in 0..prefix.chars().count() {
    6,636 ( 0.00%) .          .          .                           self.bump();
  138,600 ( 0.04%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,540x)
        .          .          .          .                       }
        .          .          .          .                       true
        .          .          .          .                   } else {
        .          .          .          .                       false
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns true if and only if the parser is positioned at a look-around
-- line 524 ----------------------------------------
-- line 533 ----------------------------------------
        .          .          .          .                       || self.bump_if("?!")
        .          .          .          .                       || self.bump_if("?<=")
        .          .          .          .                       || self.bump_if("?<!")
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Bump the parser, and if the `x` flag is enabled, bump through any
        .          .          .          .               /// subsequent spaces. Return true if and only if the parser is not at
        .          .          .          .               /// EOF.
      344 ( 0.00%) .          .          .               fn bump_and_bump_space(&self) -> bool {
   13,979 ( 0.00%) .          .          .                   if !self.bump() {
   15,480 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (172x)
        .          .          .          .                       return false;
        .          .          .          .                   }
    7,263 ( 0.00%) .          .          .                   self.bump_space();
    3,096 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (172x)
        .          .          .          .                   !self.is_eof()
      344 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// If the `x` flag is enabled (i.e., whitespace insensitivity with
        .          .          .          .               /// comments), then this will advance the parser through all whitespace
        .          .          .          .               /// and comments to the next non-whitespace non-comment byte.
        .          .          .          .               ///
        .          .          .          .               /// If the `x` flag is disabled, then this is a no-op.
        .          .          .          .               ///
        .          .          .          .               /// This should be used selectively throughout the parser where
        .          .          .          .               /// arbitrary whitespace is permitted when the `x` flag is enabled. For
        .          .          .          .               /// example, `{   5  , 6}` is equivalent to `{5,6}`.
  625,569 ( 0.19%) .          .          .               fn bump_space(&self) {
  178,734 ( 0.05%) .          .          .                   if !self.ignore_whitespace() {
        .          .          .          .                       return;
        .          .          .          .                   }
        .          .          .          .                   while !self.is_eof() {
        .          .          .          .                       if self.char().is_whitespace() {
        .          .          .          .                           self.bump();
        .          .          .          .                       } else if self.char() == '#' {
        .          .          .          .                           let start = self.pos();
        .          .          .          .                           let mut comment_text = String::new();
-- line 567 ----------------------------------------
-- line 578 ----------------------------------------
        .          .          .          .                               span: Span::new(start, self.pos()),
        .          .          .          .                               comment: comment_text,
        .          .          .          .                           };
        .          .          .          .                           self.parser().comments.borrow_mut().push(comment);
        .          .          .          .                       } else {
        .          .          .          .                           break;
        .          .          .          .                       }
        .          .          .          .                   }
  714,936 ( 0.21%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Peek at the next character in the input without advancing the parser.
        .          .          .          .               ///
        .          .          .          .               /// If the input has been exhausted, then this returns `None`.
        .          .          .          .               fn peek(&self) -> Option<char> {
        .          .          .          .                   if self.is_eof() {
        .          .          .          .                       return None;
        .          .          .          .                   }
-- line 594 ----------------------------------------
-- line 618 ----------------------------------------
        .          .          .          .                           break;
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   self.pattern()[start..].chars().next()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns true if the next call to `bump` would return false.
        .          .          .          .               fn is_eof(&self) -> bool {
  185,812 ( 0.06%) .          .          .                   self.offset() == self.pattern().len()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return the current position of the parser, which includes the offset,
        .          .          .          .               /// line and column.
        .          .          .          .               fn pos(&self) -> Position {
        .          .          .          .                   self.parser().pos.get()
        .          .          .          .               }
        .          .          .          .           
-- line 634 ----------------------------------------
-- line 636 ----------------------------------------
        .          .          .          .               /// and end of the span are set.
        .          .          .          .               fn span(&self) -> Span {
        .          .          .          .                   Span::splat(self.pos())
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Create a span that covers the current character.
        .          .          .          .               fn span_char(&self) -> Span {
        .          .          .          .                   let mut next = Position {
  104,606 ( 0.03%) .          .          .                       offset: self.offset().checked_add(self.char().len_utf8()).unwrap(),
  991,880 ( 0.30%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (49,607x)
        .          .          .          .                       line: self.line(),
        .          .          .          .                       column: self.column().checked_add(1).unwrap(),
        .          .          .          .                   };
  419,657 ( 0.13%) .          .          .                   if self.char() == '\n' {
  991,880 ( 0.30%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (49,607x)
        .          .          .          .                       next.line += 1;
        .          .          .          .                       next.column = 1;
        .          .          .          .                   }
        .          .          .          .                   Span::new(self.pos(), next)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse and push a single alternation on to the parser's internal stack.
        .          .          .          .               /// If the top of the stack already has an alternation, then add to that
-- line 656 ----------------------------------------
-- line 657 ----------------------------------------
        .          .          .          .               /// instead of pushing a new one.
        .          .          .          .               ///
        .          .          .          .               /// The concatenation given corresponds to a single alternation branch.
        .          .          .          .               /// The concatenation returned starts the next branch and is empty.
        .          .          .          .               ///
        .          .          .          .               /// This assumes the parser is currently positioned at `|` and will advance
        .          .          .          .               /// the parser to the character following `|`.
        .          .          .          .               #[inline(never)]
  159,290 ( 0.05%) .          .          .               fn push_alternate(&self, mut concat: ast::Concat) -> Result<ast::Concat> {
   79,645 ( 0.02%) .          .          .                   assert_eq!(self.char(), '|');
  318,580 ( 0.10%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (15,929x)
   63,716 ( 0.02%) .          .          .                   concat.span.end = self.pos();
  159,290 ( 0.05%) .          .          .                   self.push_or_add_alternation(concat);
   15,929 ( 0.00%) .          .          .                   self.bump();
1,433,610 ( 0.43%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (15,929x)
  223,006 ( 0.07%) .          .          .                   Ok(ast::Concat { span: self.span(), asts: vec![] })
  127,432 ( 0.04%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Pushes or adds the given branch of an alternation to the parser's
        .          .          .          .               /// internal stack of state.
        .          .          .          .               fn push_or_add_alternation(&self, concat: ast::Concat) {
        .          .          .          .                   use self::GroupState::*;
        .          .          .          .           
        .          .          .          .                   let mut stack = self.parser().stack_group.borrow_mut();
   31,858 ( 0.01%) .          .          .                   if let Some(&mut Alternation(ref mut alts)) = stack.last_mut() {
   16,862 ( 0.01%) .          .          .                       alts.asts.push(concat.into_ast());
3,495,784 ( 1.05%) 21,843 ( 2.70%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (15,417x)
        .          .          .          .                       return;
        .          .          .          .                   }
    3,072 ( 0.00%) .          .          .                   stack.push(Alternation(ast::Alternation {
    2,048 ( 0.00%) .          .          .                       span: Span::new(concat.span.start, self.pos()),
    2,048 ( 0.00%) .          .          .                       asts: vec![concat.into_ast()],
  102,615 ( 0.03%) 516 ( 0.06%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (512x)
        .          .          .          .                   }));
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse and push a group AST (and its parent concatenation) on to the
        .          .          .          .               /// parser's internal stack. Return a fresh concatenation corresponding
        .          .          .          .               /// to the group's sub-AST.
        .          .          .          .               ///
        .          .          .          .               /// If a set of flags was found (with no group), then the concatenation
-- line 693 ----------------------------------------
-- line 695 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser is currently positioned on the opening
        .          .          .          .               /// parenthesis. It advances the parser to the character at the start
        .          .          .          .               /// of the sub-expression (or adjoining expression).
        .          .          .          .               ///
        .          .          .          .               /// If there was a problem parsing the start of the group, then an error
        .          .          .          .               /// is returned.
        .          .          .          .               #[inline(never)]
    7,130 ( 0.00%) .          .          .               fn push_group(&self, mut concat: ast::Concat) -> Result<ast::Concat> {
    3,565 ( 0.00%) .          .          .                   assert_eq!(self.char(), '(');
   14,244 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (713x)
    3,565 ( 0.00%) .          .          .                   match self.parse_group()? {
1,467,032 ( 0.44%) 656 ( 0.08%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_group (713x)
        .          .          .          .                       Either::Left(set) => {
        .          .          .          .                           let ignore = set.flags.flag_state(ast::Flag::IgnoreWhitespace);
        .          .          .          .                           if let Some(v) = ignore {
        .          .          .          .                               self.parser().ignore_whitespace.set(v);
        .          .          .          .                           }
        .          .          .          .           
        .          .          .          .                           concat.asts.push(Ast::flags(set));
      260 ( 0.00%) .          .          .                           Ok(concat)
       20 ( 0.00%) .          .          .                       }
        .          .          .          .                       Either::Right(group) => {
        .          .          .          .                           let old_ignore_whitespace = self.ignore_whitespace();
        .          .          .          .                           let new_ignore_whitespace = group
        .          .          .          .                               .flags()
        .          .          .          .                               .and_then(|f| f.flag_state(ast::Flag::IgnoreWhitespace))
        .          .          .          .                               .unwrap_or(old_ignore_whitespace);
       81 ( 0.00%) .          .          .                           self.parser().stack_group.borrow_mut().push(
        .          .          .          .                               GroupState::Group {
    6,930 ( 0.00%) .          .          .                                   concat,
        .          .          .          .                                   group,
        .          .          .          .                                   ignore_whitespace: old_ignore_whitespace,
        .          .          .          .                               },
        .          .          .          .                           );
        .          .          .          .                           self.parser().ignore_whitespace.set(new_ignore_whitespace);
   10,395 ( 0.00%) .          .          .                           Ok(ast::Concat { span: self.span(), asts: vec![] })
        .          .          .          .                       }
        .          .          .          .                   }
    5,704 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Pop a group AST from the parser's internal stack and set the group's
        .          .          .          .               /// AST to the given concatenation. Return the concatenation containing
        .          .          .          .               /// the group.
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser is currently positioned on the closing
        .          .          .          .               /// parenthesis and advances the parser to the character following the `)`.
        .          .          .          .               ///
        .          .          .          .               /// If no such group could be popped, then an unopened group error is
        .          .          .          .               /// returned.
        .          .          .          .               #[inline(never)]
    6,930 ( 0.00%) .          .          .               fn pop_group(&self, mut group_concat: ast::Concat) -> Result<ast::Concat> {
        .          .          .          .                   use self::GroupState::*;
        .          .          .          .           
    3,465 ( 0.00%) .          .          .                   assert_eq!(self.char(), ')');
   13,860 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (693x)
        .          .          .          .                   let mut stack = self.parser().stack_group.borrow_mut();
    8,678 ( 0.00%) .          .          .                   let (mut prior_concat, mut group, ignore_whitespace, alt) = match stack
        .          .          .          .                       .pop()
        .          .          .          .                   {
    4,887 ( 0.00%) .          .          .                       Some(Group { concat, group, ignore_whitespace }) => {
      181 ( 0.00%) .          .          .                           (concat, group, ignore_whitespace, None)
        .          .          .          .                       }
    5,120 ( 0.00%) .          .          .                       Some(Alternation(alt)) => match stack.pop() {
   13,824 ( 0.00%) .          .          .                           Some(Group { concat, group, ignore_whitespace }) => {
    4,096 ( 0.00%) .          .          .                               (concat, group, ignore_whitespace, Some(alt))
        .          .          .          .                           }
        .          .          .          .                           None | Some(Alternation(_)) => {
        .          .          .          .                               return Err(self.error(
        .          .          .          .                                   self.span_char(),
        .          .          .          .                                   ast::ErrorKind::GroupUnopened,
        .          .          .          .                               ));
        .          .          .          .                           }
        .          .          .          .                       },
        .          .          .          .                       None => {
        .          .          .          .                           return Err(self
        .          .          .          .                               .error(self.span_char(), ast::ErrorKind::GroupUnopened));
        .          .          .          .                       }
        .          .          .          .                   };
        .          .          .          .                   self.parser().ignore_whitespace.set(ignore_whitespace);
    2,772 ( 0.00%) .          .          .                   group_concat.span.end = self.pos();
    1,386 ( 0.00%) .          .          .                   self.bump();
   62,138 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (693x)
        .          .          .          .                   group.span.end = self.pos();
    1,386 ( 0.00%) .          .          .                   match alt {
    4,096 ( 0.00%) .          .          .                       Some(mut alt) => {
    2,048 ( 0.00%) .          .          .                           alt.span.end = group_concat.span.end;
    7,168 ( 0.00%) .          .          .                           alt.asts.push(group_concat.into_ast());
  110,095 ( 0.03%) 608 ( 0.08%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (512x)
    7,168 ( 0.00%) .          .          .                           group.ast = Box::new(alt.into_ast());
  107,264 ( 0.03%) 622 ( 0.08%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Alternation::into_ast (512x)
        .          .          .          .                       }
        .          .          .          .                       None => {
    2,353 ( 0.00%) .          .          .                           group.ast = Box::new(group_concat.into_ast());
   43,978 ( 0.01%) 264 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (181x)
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   prior_concat.asts.push(Ast::group(group));
    9,702 ( 0.00%) .          .          .                   Ok(prior_concat)
    5,544 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Pop the last state from the parser's internal stack, if it exists, and
        .          .          .          .               /// add the given concatenation to it. There either must be no state or a
        .          .          .          .               /// single alternation item on the stack. Any other scenario produces an
        .          .          .          .               /// error.
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser has advanced to the end.
        .          .          .          .               #[inline(never)]
      567 ( 0.00%) .          .          .               fn pop_group_end(&self, mut concat: ast::Concat) -> Result<Ast> {
      324 ( 0.00%) .          .          .                   concat.span.end = self.pos();
        .          .          .          .                   let mut stack = self.parser().stack_group.borrow_mut();
        .          .          .          .                   let ast = match stack.pop() {
    1,134 ( 0.00%) .          .          .                       None => Ok(concat.into_ast()),
   21,535 ( 0.01%) 136 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Concat::into_ast (81x)
        .          .          .          .                       Some(GroupState::Alternation(mut alt)) => {
        .          .          .          .                           alt.span.end = self.pos();
        .          .          .          .                           alt.asts.push(concat.into_ast());
        .          .          .          .                           Ok(Ast::alternation(alt))
        .          .          .          .                       }
        .          .          .          .                       Some(GroupState::Group { group, .. }) => {
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(group.span, ast::ErrorKind::GroupUnclosed)
        .          .          .          .                           );
        .          .          .          .                       }
        .          .          .          .                   };
        .          .          .          .                   // If we try to pop again, there should be nothing.
        .          .          .          .                   match stack.pop() {
    1,296 ( 0.00%) .          .          .                       None => ast,
        .          .          .          .                       Some(GroupState::Alternation(_)) => {
        .          .          .          .                           // This unreachable is unfortunate. This case can't happen
        .          .          .          .                           // because the only way we can be here is if there were two
        .          .          .          .                           // `GroupState::Alternation`s adjacent in the parser's stack,
        .          .          .          .                           // which we guarantee to never happen because we never push a
        .          .          .          .                           // `GroupState::Alternation` if one is already at the top of
        .          .          .          .                           // the stack.
        .          .          .          .                           unreachable!()
        .          .          .          .                       }
        .          .          .          .                       Some(GroupState::Group { group, .. }) => {
        .          .          .          .                           Err(self.error(group.span, ast::ErrorKind::GroupUnclosed))
        .          .          .          .                       }
        .          .          .          .                   }
      729 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse the opening of a character class and push the current class
        .          .          .          .               /// parsing context onto the parser's stack. This assumes that the parser
        .          .          .          .               /// is positioned at an opening `[`. The given union should correspond to
        .          .          .          .               /// the union of set items built up before seeing the `[`.
        .          .          .          .               ///
        .          .          .          .               /// If there was a problem parsing the opening of the class, then an error
        .          .          .          .               /// is returned. Otherwise, a new union of set items for the class is
        .          .          .          .               /// returned (which may be populated with either a `]` or a `-`).
        .          .          .          .               #[inline(never)]
   28,240 ( 0.01%) .          .          .               fn push_class_open(
        .          .          .          .                   &self,
        .          .          .          .                   parent_union: ast::ClassSetUnion,
        .          .          .          .               ) -> Result<ast::ClassSetUnion> {
   14,120 ( 0.00%) .          .          .                   assert_eq!(self.char(), '[');
   56,432 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,824x)
        .          .          .          .           
   14,120 ( 0.00%) .          .          .                   let (nested_set, nested_union) = self.parse_set_class_open()?;
  881,407 ( 0.26%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_open (2,824x)
   84,720 ( 0.03%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x)
        .          .          .          .                   self.parser()
        .          .          .          .                       .stack_class
        .          .          .          .                       .borrow_mut()
   39,536 ( 0.01%) .          .          .                       .push(ClassState::Open { union: parent_union, set: nested_set });
   84,720 ( 0.03%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x)
   28,240 ( 0.01%) .          .          .                   Ok(nested_union)
   22,592 ( 0.01%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse the end of a character class set and pop the character class
        .          .          .          .               /// parser stack. The union given corresponds to the last union built
        .          .          .          .               /// before seeing the closing `]`. The union returned corresponds to the
        .          .          .          .               /// parent character class set with the nested class added to it.
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser is positioned at a `]` and will advance
        .          .          .          .               /// the parser to the byte immediately following the `]`.
-- line 859 ----------------------------------------
-- line 860 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// If the stack is empty after popping, then this returns the final
        .          .          .          .               /// "top-level" character class AST (where a "top-level" character class
        .          .          .          .               /// is one that is not nested inside any other character class).
        .          .          .          .               ///
        .          .          .          .               /// If there is no corresponding opening bracket on the parser's stack,
        .          .          .          .               /// then an error is returned.
        .          .          .          .               #[inline(never)]
   25,416 ( 0.01%) .          .          .               fn pop_class(
        .          .          .          .                   &self,
        .          .          .          .                   nested_union: ast::ClassSetUnion,
        .          .          .          .               ) -> Result<Either<ast::ClassSetUnion, ast::ClassBracketed>> {
   14,120 ( 0.00%) .          .          .                   assert_eq!(self.char(), ']');
   56,480 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,824x)
        .          .          .          .           
        .          .          .          .                   let item = ast::ClassSet::Item(nested_union.into_item());
   14,120 ( 0.00%) .          .          .                   let prevset = self.pop_class_op(item);
  203,328 ( 0.06%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class_op (2,824x)
        .          .          .          .                   let mut stack = self.parser().stack_class.borrow_mut();
   14,120 ( 0.00%) .          .          .                   match stack.pop() {
        .          .          .          .                       None => {
        .          .          .          .                           // We can never observe an empty stack:
        .          .          .          .                           //
        .          .          .          .                           // 1) We are guaranteed to start with a non-empty stack since
        .          .          .          .                           //    the character class parser is only initiated when it sees
        .          .          .          .                           //    a `[`.
        .          .          .          .                           // 2) If we ever observe an empty stack while popping after
        .          .          .          .                           //    seeing a `]`, then we signal the character class parser
-- line 885 ----------------------------------------
-- line 890 ----------------------------------------
        .          .          .          .                           // This panic is unfortunate, but this case is impossible
        .          .          .          .                           // since we already popped the Op state if one exists above.
        .          .          .          .                           // Namely, every push to the class parser stack is guarded by
        .          .          .          .                           // whether an existing Op is already on the top of the stack.
        .          .          .          .                           // If it is, the existing Op is modified. That is, the stack
        .          .          .          .                           // can never have consecutive Op states.
        .          .          .          .                           panic!("unexpected ClassState::Op")
        .          .          .          .                       }
   39,536 ( 0.01%) .          .          .                       Some(ClassState::Open { mut union, mut set }) => {
   84,720 ( 0.03%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x)
    5,648 ( 0.00%) .          .          .                           self.bump();
  254,080 ( 0.08%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (2,824x)
        .          .          .          .                           set.span.end = self.pos();
   19,768 ( 0.01%) .          .          .                           set.kind = prevset;
   84,720 ( 0.03%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x)
  152,496 ( 0.05%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::ClassSet> (2,824x)
    5,648 ( 0.00%) .          .          .                           if stack.is_empty() {
    8,259 ( 0.00%) .          .          .                               Ok(Either::Right(set))
   82,590 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x)
        .          .          .          .                           } else {
      142 ( 0.00%) .          .          .                               union.push(ast::ClassSetItem::Bracketed(Box::new(set)));
    2,130 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (71x)
      994 ( 0.00%) .          .          .                               Ok(Either::Left(union))
        .          .          .          .                           }
        .          .          .          .                       }
        .          .          .          .                   }
   19,768 ( 0.01%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return an "unclosed class" error whose span points to the most
        .          .          .          .               /// recently opened class.
        .          .          .          .               ///
        .          .          .          .               /// This should only be called while parsing a character class.
        .          .          .          .               #[inline(never)]
        .          .          .          .               fn unclosed_class_error(&self) -> ast::Error {
        .          .          .          .                   for state in self.parser().stack_class.borrow().iter().rev() {
-- line 918 ----------------------------------------
-- line 946 ----------------------------------------
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Pop a character class set from the character class parser stack. If the
        .          .          .          .               /// top of the stack is just an item (not an operation), then return the
        .          .          .          .               /// given set unchanged. If the top of the stack is an operation, then the
        .          .          .          .               /// given set will be used as the rhs of the operation on the top of the
        .          .          .          .               /// stack. In that case, the binary operation is returned as a set.
        .          .          .          .               #[inline(never)]
   19,768 ( 0.01%) .          .          .               fn pop_class_op(&self, rhs: ast::ClassSet) -> ast::ClassSet {
        .          .          .          .                   let mut stack = self.parser().stack_class.borrow_mut();
   14,120 ( 0.00%) .          .          .                   let (kind, lhs) = match stack.pop() {
        .          .          .          .                       Some(ClassState::Op { kind, lhs }) => (kind, lhs),
        .          .          .          .                       Some(state @ ClassState::Open { .. }) => {
        .          .          .          .                           stack.push(state);
    8,472 ( 0.00%) .          .          .                           return rhs;
   84,720 ( 0.03%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,824x)
        .          .          .          .                       }
        .          .          .          .                       None => unreachable!(),
        .          .          .          .                   };
        .          .          .          .                   let span = Span::new(lhs.span().start, rhs.span().end);
        .          .          .          .                   ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {
        .          .          .          .                       span,
        .          .          .          .                       kind,
        .          .          .          .                       lhs: Box::new(lhs),
        .          .          .          .                       rhs: Box::new(rhs),
        .          .          .          .                   })
   22,592 ( 0.01%) .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'s, P: Borrow<Parser>> ParserI<'s, P> {
        .          .          .          .               /// Parse the regular expression into an abstract syntax tree.
        .          .          .          .               fn parse(&self) -> Result<Ast> {
       81 ( 0.00%) .          .          .                   self.parse_with_comments().map(|astc| astc.ast)
58,463,297 (17.55%) 143,996 (17.79%) 1 ( 0.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_with_comments (81x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse the regular expression and return an abstract syntax tree with
        .          .          .          .               /// all of the comments found in the pattern.
      567 ( 0.00%) .          .          .               fn parse_with_comments(&self) -> Result<ast::WithComments> {
      162 ( 0.00%) .          .          .                   assert_eq!(self.offset(), 0, "parser can only be used once");
        .          .          .          .                   self.parser().reset();
    1,134 ( 0.00%) .          .          .                   let mut concat = ast::Concat { span: self.span(), asts: vec![] };
        .          .          .          .                   loop {
  214,983 ( 0.06%) .          .          .                       self.bump_space();
1,289,898 ( 0.39%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (71,661x)
   71,661 ( 0.02%) .          .          .                       if self.is_eof() {
        .          .          .          .                           break;
        .          .          .          .                       }
  608,446 ( 0.18%) .          .          .                       match self.char() {
1,431,276 ( 0.43%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (71,580x)
   10,695 ( 0.00%) .          .          .                           '(' => concat = self.push_group(concat)?,
1,588,677 ( 0.48%) 660 ( 0.08%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_group (713x)
   10,395 ( 0.00%) .          .          .                           ')' => concat = self.pop_group(concat)?,
  916,137 ( 0.28%) 2,355 ( 0.29%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group (693x)
  238,935 ( 0.07%) .          .          .                           '|' => concat = self.push_alternate(concat)?,
7,753,142 ( 2.33%) 26,910 ( 3.32%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_alternate (15,929x)
        .          .          .          .                           '[' => {
   22,024 ( 0.01%) .          .          .                               let class = self.parse_set_class()?;
8,923,368 ( 2.68%) 1,216 ( 0.15%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class (2,753x)
   82,590 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x)
        .          .          .          .                               concat.asts.push(Ast::class_bracketed(class));
        .          .          .          .                           }
        .          .          .          .                           '?' => {
        .          .          .          .                               concat = self.parse_uncounted_repetition(
   16,370 ( 0.00%) .          .          .                                   concat,
    3,274 ( 0.00%) .          .          .                                   ast::RepetitionKind::ZeroOrOne,
        .          .          .          .                               )?;
        .          .          .          .                           }
        .          .          .          .                           '*' => {
        .          .          .          .                               concat = self.parse_uncounted_repetition(
      170 ( 0.00%) .          .          .                                   concat,
       17 ( 0.00%) .          .          .                                   ast::RepetitionKind::ZeroOrMore,
        .          .          .          .                               )?;
        .          .          .          .                           }
        .          .          .          .                           '+' => {
       59 ( 0.00%) .          .          .                               concat = self.parse_uncounted_repetition(
      590 ( 0.00%) .          .          .                                   concat,
       59 ( 0.00%) .          .          .                                   ast::RepetitionKind::OneOrMore,
        .          .          .          .                               )?;
        .          .          .          .                           }
        .          .          .          .                           '{' => {
    2,580 ( 0.00%) .          .          .                               concat = self.parse_counted_repetition(concat)?;
  243,845 ( 0.07%) 132 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_counted_repetition (172x)
        .          .          .          .                           }
   49,607 ( 0.01%) .          .          .                           _ => concat.asts.push(self.parse_primitive()?.into_ast()),
        .          .          .          .                       }
        .          .          .          .                   }
    1,458 ( 0.00%) .          .          .                   let ast = self.pop_group_end(concat)?;
   26,962 ( 0.01%) 136 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_group_end (81x)
      162 ( 0.00%) .          .          .                   NestLimiter::new(self).check(&ast)?;
4,259,921 ( 1.28%) 305 ( 0.04%) 1 ( 0.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::NestLimiter<P>::check (81x)
      324 ( 0.00%) .          .          .                   Ok(ast::WithComments {
        .          .          .          .                       ast,
        .          .          .          .                       comments: mem::replace(
        .          .          .          .                           &mut *self.parser().comments.borrow_mut(),
        .          .          .          .                           vec![],
        .          .          .          .                       ),
        .          .          .          .                   })
      729 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parses an uncounted repetition operation. An uncounted repetition
        .          .          .          .               /// operator includes ?, * and +, but does not include the {m,n} syntax.
        .          .          .          .               /// The given `kind` should correspond to the operator observed by the
        .          .          .          .               /// caller.
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser is currently positioned at the repetition
        .          .          .          .               /// operator and advances the parser to the first character after the
        .          .          .          .               /// operator. (Note that the operator may include a single additional `?`,
        .          .          .          .               /// which makes the operator ungreedy.)
        .          .          .          .               ///
        .          .          .          .               /// The caller should include the concatenation that is being built. The
        .          .          .          .               /// concatenation returned includes the repetition operator applied to the
        .          .          .          .               /// last expression in the given concatenation.
        .          .          .          .               #[inline(never)]
   18,843 ( 0.01%) .          .          .               fn parse_uncounted_repetition(
        .          .          .          .                   &self,
        .          .          .          .                   mut concat: ast::Concat,
        .          .          .          .                   kind: ast::RepetitionKind,
        .          .          .          .               ) -> Result<ast::Concat> {
        .          .          .          .                   assert!(
    7,392 ( 0.00%) .          .          .                       self.char() == '?' || self.char() == '*' || self.char() == '+'
   36,960 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (1,848x)
        .          .          .          .                   );
        .          .          .          .                   let op_start = self.pos();
        .          .          .          .                   let ast = match concat.asts.pop() {
    3,426 ( 0.00%) .          .          .                       Some(ast) => ast,
        .          .          .          .                       None => {
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(self.span(), ast::ErrorKind::RepetitionMissing)
        .          .          .          .                           )
        .          .          .          .                       }
        .          .          .          .                   };
    3,426 ( 0.00%) .          .          .                   match ast {
        .          .          .          .                       Ast::Empty(_) | Ast::Flags(_) => {
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(self.span(), ast::ErrorKind::RepetitionMissing)
        .          .          .          .                           )
        .          .          .          .                       }
        .          .          .          .                       _ => {}
        .          .          .          .                   }
        .          .          .          .                   let mut greedy = true;
   13,692 ( 0.00%) .          .          .                   if self.bump() && self.char() == '?' {
  154,158 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,713x)
   34,200 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (1,710x)
        .          .          .          .                       greedy = false;
        .          .          .          .                       self.bump();
        .          .          .          .                   }
   23,982 ( 0.01%) .          .          .                   concat.asts.push(Ast::repetition(ast::Repetition {
    6,852 ( 0.00%) .          .          .                       span: ast.span().with_end(self.pos()),
   23,982 ( 0.01%) .          .          .                       op: ast::RepetitionOp {
        .          .          .          .                           span: Span::new(op_start, self.pos()),
        .          .          .          .                           kind,
        .          .          .          .                       },
        .          .          .          .                       greedy,
        .          .          .          .                       ast: Box::new(ast),
        .          .          .          .                   }));
   23,982 ( 0.01%) .          .          .                   Ok(concat)
   13,704 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parses a counted repetition operation. A counted repetition operator
        .          .          .          .               /// corresponds to the {m,n} syntax, and does not include the ?, * or +
        .          .          .          .               /// operators.
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser is currently positioned at the opening `{`
        .          .          .          .               /// and advances the parser to the first character after the operator.
        .          .          .          .               /// (Note that the operator may include a single additional `?`, which
        .          .          .          .               /// makes the operator ungreedy.)
        .          .          .          .               ///
        .          .          .          .               /// The caller should include the concatenation that is being built. The
        .          .          .          .               /// concatenation returned includes the repetition operator applied to the
        .          .          .          .               /// last expression in the given concatenation.
        .          .          .          .               #[inline(never)]
    1,720 ( 0.00%) .          .          .               fn parse_counted_repetition(
        .          .          .          .                   &self,
        .          .          .          .                   mut concat: ast::Concat,
        .          .          .          .               ) -> Result<ast::Concat> {
      688 ( 0.00%) .          .          .                   assert!(self.char() == '{');
    3,440 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (172x)
        .          .          .          .                   let start = self.pos();
        .          .          .          .                   let ast = match concat.asts.pop() {
      344 ( 0.00%) .          .          .                       Some(ast) => ast,
        .          .          .          .                       None => {
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(self.span(), ast::ErrorKind::RepetitionMissing)
        .          .          .          .                           )
        .          .          .          .                       }
        .          .          .          .                   };
      344 ( 0.00%) .          .          .                   match ast {
        .          .          .          .                       Ast::Empty(_) | Ast::Flags(_) => {
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(self.span(), ast::ErrorKind::RepetitionMissing)
        .          .          .          .                           )
        .          .          .          .                       }
        .          .          .          .                       _ => {}
        .          .          .          .                   }
      172 ( 0.00%) .          .          .                   if !self.bump_and_bump_space() {
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(start, self.pos()),
        .          .          .          .                           ast::ErrorKind::RepetitionCountUnclosed,
        .          .          .          .                       ));
        .          .          .          .                   }
      516 ( 0.00%) .          .          .                   let count_start = specialize_err(
    6,192 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::specialize_err (172x)
      516 ( 0.00%) .          .          .                       self.parse_decimal(),
   74,080 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (172x)
      172 ( 0.00%) .          .          .                       ast::ErrorKind::DecimalEmpty,
      688 ( 0.00%) .          .          .                       ast::ErrorKind::RepetitionCountDecimalEmpty,
        .          .          .          .                   );
      172 ( 0.00%) .          .          .                   if self.is_eof() {
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(start, self.pos()),
        .          .          .          .                           ast::ErrorKind::RepetitionCountUnclosed,
        .          .          .          .                       ));
        .          .          .          .                   }
      688 ( 0.00%) .          .          .                   let range = if self.char() == ',' {
    3,440 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (172x)
       67 ( 0.00%) .          .          .                       if !self.bump_and_bump_space() {
        .          .          .          .                           return Err(self.error(
        .          .          .          .                               Span::new(start, self.pos()),
        .          .          .          .                               ast::ErrorKind::RepetitionCountUnclosed,
        .          .          .          .                           ));
        .          .          .          .                       }
      268 ( 0.00%) .          .          .                       if self.char() != '}' {
    1,340 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (67x)
      268 ( 0.00%) .          .          .                           let count_start = match count_start {
       67 ( 0.00%) .          .          .                               Ok(c) => c,
        .          .          .          .                               Err(err)
        .          .          .          .                                   if err.kind
        .          .          .          .                                       == ast::ErrorKind::RepetitionCountDecimalEmpty =>
        .          .          .          .                               {
        .          .          .          .                                   if self.parser().empty_min_range {
        .          .          .          .                                       0
        .          .          .          .                                   } else {
        .          .          .          .                                       return Err(err);
        .          .          .          .                                   }
        .          .          .          .                               }
        .          .          .          .                               err => err?,
        .          .          .          .                           };
      134 ( 0.00%) .          .          .                           let count_end = specialize_err(
    2,412 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::specialize_err (67x)
      335 ( 0.00%) .          .          .                               self.parse_decimal(),
   25,799 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_decimal (67x)
        .          .          .          .                               ast::ErrorKind::DecimalEmpty,
        .          .          .          .                               ast::ErrorKind::RepetitionCountDecimalEmpty,
        .          .          .          .                           )?;
        .          .          .          .                           ast::RepetitionRange::Bounded(count_start, count_end)
        .          .          .          .                       } else {
        .          .          .          .                           ast::RepetitionRange::AtLeast(count_start?)
        .          .          .          .                       }
        .          .          .          .                   } else {
      210 ( 0.00%) .          .          .                       ast::RepetitionRange::Exactly(count_start?)
        .          .          .          .                   };
        .          .          .          .           
      860 ( 0.00%) .          .          .                   if self.is_eof() || self.char() != '}' {
    3,440 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (172x)
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(start, self.pos()),
        .          .          .          .                           ast::ErrorKind::RepetitionCountUnclosed,
        .          .          .          .                       ));
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   let mut greedy = true;
    1,720 ( 0.00%) .          .          .                   if self.bump_and_bump_space() && self.char() == '?' {
   20,812 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_and_bump_space (172x)
    3,440 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (172x)
        .          .          .          .                       greedy = false;
        .          .          .          .                       self.bump();
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   let op_span = Span::new(start, self.pos());
        .          .          .          .                   if !range.is_valid() {
        .          .          .          .                       return Err(
        .          .          .          .                           self.error(op_span, ast::ErrorKind::RepetitionCountInvalid)
        .          .          .          .                       );
        .          .          .          .                   }
    2,752 ( 0.00%) .          .          .                   concat.asts.push(Ast::repetition(ast::Repetition {
   23,142 ( 0.01%) 84 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Ast::repetition (172x)
      688 ( 0.00%) .          .          .                       span: ast.span().with_end(self.pos()),
    1,032 ( 0.00%) .          .          .                       op: ast::RepetitionOp {
        .          .          .          .                           span: op_span,
        .          .          .          .                           kind: ast::RepetitionKind::Range(range),
        .          .          .          .                       },
        .          .          .          .                       greedy,
        .          .          .          .                       ast: Box::new(ast),
        .          .          .          .                   }));
    2,752 ( 0.00%) .          .          .                   Ok(concat)
    1,376 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a group (which contains a sub-expression) or a set of flags.
        .          .          .          .               ///
        .          .          .          .               /// If a group was found, then it is returned with an empty AST. If a set
        .          .          .          .               /// of flags is found, then that set is returned.
        .          .          .          .               ///
        .          .          .          .               /// The parser should be positioned at the opening parenthesis.
        .          .          .          .               ///
-- line 1214 ----------------------------------------
-- line 1219 ----------------------------------------
        .          .          .          .               /// # Errors
        .          .          .          .               ///
        .          .          .          .               /// If flags are given and incorrectly specified, then a corresponding
        .          .          .          .               /// error is returned.
        .          .          .          .               ///
        .          .          .          .               /// If a capture name is given and it is incorrectly specified, then a
        .          .          .          .               /// corresponding error is returned.
        .          .          .          .               #[inline(never)]
    6,417 ( 0.00%) .          .          .               fn parse_group(&self) -> Result<Either<ast::SetFlags, ast::Group>> {
    3,565 ( 0.00%) .          .          .                   assert_eq!(self.char(), '(');
   14,244 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (713x)
        .          .          .          .                   let open_span = self.span_char();
    1,426 ( 0.00%) .          .          .                   self.bump();
   64,138 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (713x)
    1,426 ( 0.00%) .          .          .                   self.bump_space();
   12,834 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (713x)
        .          .          .          .                   if self.is_lookaround_prefix() {
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(open_span.start, self.span().end),
        .          .          .          .                           ast::ErrorKind::UnsupportedLookAround,
        .          .          .          .                       ));
        .          .          .          .                   }
        .          .          .          .                   let inner_span = self.span();
        .          .          .          .                   let mut starts_with_p = true;
        .          .          .          .                   if self.bump_if("?P<") || {
        .          .          .          .                       starts_with_p = false;
        .          .          .          .                       self.bump_if("?<")
        .          .          .          .                   } {
        .          .          .          .                       let capture_index = self.next_capture_index(open_span)?;
    7,032 ( 0.00%) .          .          .                       let name = self.parse_capture_name(capture_index)?;
  861,284 ( 0.26%) 308 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_capture_name (586x)
   11,134 ( 0.00%) .          .          .                       Ok(Either::Right(ast::Group {
        .          .          .          .                           span: open_span,
        .          .          .          .                           kind: ast::GroupKind::CaptureName { starts_with_p, name },
        .          .          .          .                           ast: Box::new(Ast::empty(self.span())),
        .          .          .          .                       }))
        .          .          .          .                   } else if self.bump_if("?") {
       20 ( 0.00%) .          .          .                       if self.is_eof() {
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(open_span, ast::ErrorKind::GroupUnclosed)
        .          .          .          .                           );
        .          .          .          .                       }
      160 ( 0.00%) .          .          .                       let flags = self.parse_flags()?;
   14,690 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_flags (20x)
       80 ( 0.00%) .          .          .                       let char_end = self.char();
      400 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (20x)
       40 ( 0.00%) .          .          .                       self.bump();
    1,800 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (20x)
       60 ( 0.00%) .          .          .                       if char_end == ')' {
        .          .          .          .                           // We don't allow empty flags, e.g., `(?)`. We instead
        .          .          .          .                           // interpret it as a repetition operator missing its argument.
       40 ( 0.00%) .          .          .                           if flags.items.is_empty() {
        .          .          .          .                               return Err(self.error(
        .          .          .          .                                   inner_span,
        .          .          .          .                                   ast::ErrorKind::RepetitionMissing,
        .          .          .          .                               ));
        .          .          .          .                           }
      300 ( 0.00%) .          .          .                           Ok(Either::Left(ast::SetFlags {
       80 ( 0.00%) .          .          .                               span: Span { end: self.pos(), ..open_span },
      140 ( 0.00%) .          .          .                               flags,
        .          .          .          .                           }))
        .          .          .          .                       } else {
        .          .          .          .                           assert_eq!(char_end, ':');
        .          .          .          .                           Ok(Either::Right(ast::Group {
        .          .          .          .                               span: open_span,
        .          .          .          .                               kind: ast::GroupKind::NonCapturing(flags),
        .          .          .          .                               ast: Box::new(Ast::empty(self.span())),
        .          .          .          .                           }))
        .          .          .          .                       }
        .          .          .          .                   } else {
        .          .          .          .                       let capture_index = self.next_capture_index(open_span)?;
      856 ( 0.00%) .          .          .                       Ok(Either::Right(ast::Group {
        .          .          .          .                           span: open_span,
        .          .          .          .                           kind: ast::GroupKind::CaptureIndex(capture_index),
      321 ( 0.00%) .          .          .                           ast: Box::new(Ast::empty(self.span())),
   10,630 ( 0.00%) 24 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs:regex_syntax::ast::Ast::empty (107x)
        .          .          .          .                       }))
        .          .          .          .                   }
    5,704 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parses a capture group name. Assumes that the parser is positioned at
        .          .          .          .               /// the first character in the name following the opening `<` (and may
        .          .          .          .               /// possibly be EOF). This advances the parser to the first character
        .          .          .          .               /// following the closing `>`.
        .          .          .          .               ///
        .          .          .          .               /// The caller must provide the capture index of the group for this name.
        .          .          .          .               #[inline(never)]
    5,274 ( 0.00%) .          .          .               fn parse_capture_name(
        .          .          .          .                   &self,
        .          .          .          .                   capture_index: u32,
        .          .          .          .               ) -> Result<ast::CaptureName> {
      586 ( 0.00%) .          .          .                   if self.is_eof() {
        .          .          .          .                       return Err(self
        .          .          .          .                           .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));
        .          .          .          .                   }
        .          .          .          .                   let start = self.pos();
        .          .          .          .                   loop {
   13,692 ( 0.00%) .          .          .                       if self.char() == '>' {
   68,460 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (3,423x)
        .          .          .          .                           break;
        .          .          .          .                       }
    8,511 ( 0.00%) .          .          .                       if !is_capture_char(self.char(), self.pos() == start) {
   56,740 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,837x)
        .          .          .          .                           return Err(self.error(
        .          .          .          .                               self.span_char(),
        .          .          .          .                               ast::ErrorKind::GroupNameInvalid,
        .          .          .          .                           ));
        .          .          .          .                       }
   11,348 ( 0.00%) .          .          .                       if !self.bump() {
  255,330 ( 0.08%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (2,837x)
        .          .          .          .                           break;
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   let end = self.pos();
      586 ( 0.00%) .          .          .                   if self.is_eof() {
        .          .          .          .                       return Err(self
        .          .          .          .                           .error(self.span(), ast::ErrorKind::GroupNameUnexpectedEof));
        .          .          .          .                   }
    2,930 ( 0.00%) .          .          .                   assert_eq!(self.char(), '>');
   11,720 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (586x)
    1,172 ( 0.00%) .          .          .                   self.bump();
   52,740 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (586x)
        .          .          .          .                   let name = &self.pattern()[start.offset..end.offset];
    1,758 ( 0.00%) .          .          .                   if name.is_empty() {
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(start, start),
        .          .          .          .                           ast::ErrorKind::GroupNameEmpty,
        .          .          .          .                       ));
        .          .          .          .                   }
    7,618 ( 0.00%) .          .          .                   let capname = ast::CaptureName {
        .          .          .          .                       span: Span::new(start, end),
        .          .          .          .                       name: name.to_string(),
        .          .          .          .                       index: capture_index,
        .          .          .          .                   };
        .          .          .          .                   self.add_capture_name(&capname)?;
    7,032 ( 0.00%) .          .          .                   Ok(capname)
    4,688 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a sequence of flags starting at the current character.
        .          .          .          .               ///
        .          .          .          .               /// This advances the parser to the character immediately following the
        .          .          .          .               /// flags, which is guaranteed to be either `:` or `)`.
        .          .          .          .               ///
        .          .          .          .               /// # Errors
        .          .          .          .               ///
-- line 1350 ----------------------------------------
-- line 1351 ----------------------------------------
        .          .          .          .               /// If any flags are duplicated, then an error is returned.
        .          .          .          .               ///
        .          .          .          .               /// If the negation operator is used more than once, then an error is
        .          .          .          .               /// returned.
        .          .          .          .               ///
        .          .          .          .               /// If no flags could be found or if the negation operation is not followed
        .          .          .          .               /// by any flags, then an error is returned.
        .          .          .          .               #[inline(never)]
      180 ( 0.00%) .          .          .               fn parse_flags(&self) -> Result<ast::Flags> {
      240 ( 0.00%) .          .          .                   let mut flags = ast::Flags { span: self.span(), items: vec![] };
        .          .          .          .                   let mut last_was_negation = None;
      540 ( 0.00%) .          .          .                   while self.char() != ':' && self.char() != ')' {
    2,000 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (100x)
      180 ( 0.00%) .          .          .                       if self.char() == '-' {
      600 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (30x)
        .          .          .          .                           last_was_negation = Some(self.span_char());
        .          .          .          .                           let item = ast::FlagsItem {
        .          .          .          .                               span: self.span_char(),
        .          .          .          .                               kind: ast::FlagsItemKind::Negation,
        .          .          .          .                           };
        .          .          .          .                           if let Some(i) = flags.add_item(item) {
        .          .          .          .                               return Err(self.error(
        .          .          .          .                                   self.span_char(),
        .          .          .          .                                   ast::ErrorKind::FlagRepeatedNegation {
        .          .          .          .                                       original: flags.items[i].span,
        .          .          .          .                                   },
        .          .          .          .                               ));
        .          .          .          .                           }
        .          .          .          .                       } else {
        .          .          .          .                           last_was_negation = None;
       80 ( 0.00%) .          .          .                           let item = ast::FlagsItem {
        .          .          .          .                               span: self.span_char(),
       60 ( 0.00%) .          .          .                               kind: ast::FlagsItemKind::Flag(self.parse_flag()?),
    1,000 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_flag (20x)
        .          .          .          .                           };
        .          .          .          .                           if let Some(i) = flags.add_item(item) {
        .          .          .          .                               return Err(self.error(
        .          .          .          .                                   self.span_char(),
        .          .          .          .                                   ast::ErrorKind::FlagDuplicate {
        .          .          .          .                                       original: flags.items[i].span,
        .          .          .          .                                   },
        .          .          .          .                               ));
        .          .          .          .                           }
        .          .          .          .                       }
      120 ( 0.00%) .          .          .                       if !self.bump() {
    2,700 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (30x)
        .          .          .          .                           return Err(
        .          .          .          .                               self.error(self.span(), ast::ErrorKind::FlagUnexpectedEof)
        .          .          .          .                           );
        .          .          .          .                       }
        .          .          .          .                   }
       40 ( 0.00%) .          .          .                   if let Some(span) = last_was_negation {
        .          .          .          .                       return Err(self.error(span, ast::ErrorKind::FlagDanglingNegation));
        .          .          .          .                   }
        .          .          .          .                   flags.span.end = self.pos();
      200 ( 0.00%) .          .          .                   Ok(flags)
      180 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse the current character as a flag. Do not advance the parser.
        .          .          .          .               ///
        .          .          .          .               /// # Errors
        .          .          .          .               ///
        .          .          .          .               /// If the flag is not recognized, then an error is returned.
        .          .          .          .               #[inline(never)]
      180 ( 0.00%) .          .          .               fn parse_flag(&self) -> Result<ast::Flag> {
      160 ( 0.00%) .          .          .                   match self.char() {
      400 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (20x)
       40 ( 0.00%) .          .          .                       'i' => Ok(ast::Flag::CaseInsensitive),
        .          .          .          .                       'm' => Ok(ast::Flag::MultiLine),
        .          .          .          .                       's' => Ok(ast::Flag::DotMatchesNewLine),
        .          .          .          .                       'U' => Ok(ast::Flag::SwapGreed),
        .          .          .          .                       'u' => Ok(ast::Flag::Unicode),
        .          .          .          .                       'R' => Ok(ast::Flag::CRLF),
        .          .          .          .                       'x' => Ok(ast::Flag::IgnoreWhitespace),
        .          .          .          .                       _ => {
        .          .          .          .                           Err(self
        .          .          .          .                               .error(self.span_char(), ast::ErrorKind::FlagUnrecognized))
        .          .          .          .                       }
        .          .          .          .                   }
      160 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a primitive AST. e.g., A literal, non-set character class or
        .          .          .          .               /// assertion.
        .          .          .          .               ///
        .          .          .          .               /// This assumes that the parser expects a primitive at the current
        .          .          .          .               /// location. i.e., All other non-primitive cases have been handled.
        .          .          .          .               /// For example, if the parser's position is at `|`, then `|` will be
        .          .          .          .               /// treated as a literal (e.g., inside a character class).
        .          .          .          .               ///
        .          .          .          .               /// This advances the parser to the first character immediately following
        .          .          .          .               /// the primitive.
        .          .          .          .               fn parse_primitive(&self) -> Result<Primitive> {
  396,744 ( 0.12%) .          .          .                   match self.char() {
  991,880 ( 0.30%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (49,607x)
        .          .          .          .                       '\\' => self.parse_escape(),
        .          .          .          .                       '.' => {
        .          .          .          .                           let ast = Primitive::Dot(self.span_char());
       15 ( 0.00%) .          .          .                           self.bump();
      450 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (5x)
       30 ( 0.00%) .          .          .                           Ok(ast)
        5 ( 0.00%) .          .          .                       }
        .          .          .          .                       '^' => {
        .          .          .          .                           let ast = Primitive::Assertion(ast::Assertion {
        .          .          .          .                               span: self.span_char(),
        .          .          .          .                               kind: ast::AssertionKind::StartLine,
        .          .          .          .                           });
      198 ( 0.00%) .          .          .                           self.bump();
    5,420 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (66x)
      462 ( 0.00%) .          .          .                           Ok(ast)
       66 ( 0.00%) .          .          .                       }
        .          .          .          .                       '$' => {
        .          .          .          .                           let ast = Primitive::Assertion(ast::Assertion {
        .          .          .          .                               span: self.span_char(),
        .          .          .          .                               kind: ast::AssertionKind::EndLine,
        .          .          .          .                           });
      168 ( 0.00%) .          .          .                           self.bump();
    5,040 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (56x)
      448 ( 0.00%) .          .          .                           Ok(ast)
        .          .          .          .                       }
        .          .          .          .                       c => {
        .          .          .          .                           let ast = Primitive::Literal(ast::Literal {
        .          .          .          .                               span: self.span_char(),
        .          .          .          .                               kind: ast::LiteralKind::Verbatim,
        .          .          .          .                               c,
        .          .          .          .                           });
   98,960 ( 0.03%) .          .          .                           self.bump();
4,453,200 ( 1.34%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (49,480x)
  445,320 ( 0.13%) .          .          .                           Ok(ast)
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse an escape sequence as a primitive AST.
        .          .          .          .               ///
        .          .          .          .               /// This assumes the parser is positioned at the start of the escape
        .          .          .          .               /// sequence, i.e., `\`. It advances the parser to the first position
        .          .          .          .               /// immediately following the escape sequence.
        .          .          .          .               #[inline(never)]
   14,508 ( 0.00%) .          .          .               fn parse_escape(&self) -> Result<Primitive> {
    8,060 ( 0.00%) .          .          .                   assert_eq!(self.char(), '\\');
   32,240 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (1,612x)
        .          .          .          .                   let start = self.pos();
    6,448 ( 0.00%) .          .          .                   if !self.bump() {
  145,080 ( 0.04%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,612x)
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(start, self.pos()),
        .          .          .          .                           ast::ErrorKind::EscapeUnexpectedEof,
        .          .          .          .                       ));
        .          .          .          .                   }
    4,836 ( 0.00%) .          .          .                   let c = self.char();
   32,240 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (1,612x)
        .          .          .          .                   // Put some of the more complicated routines into helpers.
    4,836 ( 0.00%) .          .          .                   match c {
    4,836 ( 0.00%) .          .          .                       '0'..='7' => {
        .          .          .          .                           if !self.parser().octal {
        .          .          .          .                               return Err(self.error(
        .          .          .          .                                   Span::new(start, self.span_char().end),
        .          .          .          .                                   ast::ErrorKind::UnsupportedBackreference,
        .          .          .          .                               ));
        .          .          .          .                           }
        .          .          .          .                           let mut lit = self.parse_octal();
        .          .          .          .                           lit.span.start = start;
        .          .          .          .                           return Ok(Primitive::Literal(lit));
        .          .          .          .                       }
    6,448 ( 0.00%) .          .          .                       '8'..='9' if !self.parser().octal => {
        .          .          .          .                           return Err(self.error(
        .          .          .          .                               Span::new(start, self.span_char().end),
        .          .          .          .                               ast::ErrorKind::UnsupportedBackreference,
        .          .          .          .                           ));
        .          .          .          .                       }
        .          .          .          .                       'x' | 'u' | 'U' => {
        .          .          .          .                           let mut lit = self.parse_hex()?;
        .          .          .          .                           lit.span.start = start;
-- line 1510 ----------------------------------------
-- line 1511 ----------------------------------------
        .          .          .          .                           return Ok(Primitive::Literal(lit));
        .          .          .          .                       }
        .          .          .          .                       'p' | 'P' => {
        .          .          .          .                           let mut cls = self.parse_unicode_class()?;
        .          .          .          .                           cls.span.start = start;
        .          .          .          .                           return Ok(Primitive::Unicode(cls));
        .          .          .          .                       }
        .          .          .          .                       'd' | 's' | 'w' | 'D' | 'S' | 'W' => {
       10 ( 0.00%) .          .          .                           let mut cls = self.parse_perl_class();
    1,095 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_perl_class (5x)
       25 ( 0.00%) .          .          .                           cls.span.start = start;
       55 ( 0.00%) .          .          .                           return Ok(Primitive::Perl(cls));
        .          .          .          .                       }
        .          .          .          .                       _ => {}
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   // Handle all of the one letter sequences inline.
    3,214 ( 0.00%) .          .          .                   self.bump();
  144,710 ( 0.04%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,607x)
        .          .          .          .                   let span = Span::new(start, self.pos());
        .          .          .          .                   if is_meta_character(c) {
   17,666 ( 0.01%) .          .          .                       return Ok(Primitive::Literal(ast::Literal {
        .          .          .          .                           span,
        .          .          .          .                           kind: ast::LiteralKind::Meta,
        .          .          .          .                           c,
        .          .          .          .                       }));
        .          .          .          .                   }
        4 ( 0.00%) .          .          .                   if is_escapeable_character(c) {
       24 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/lib.rs:regex_syntax::is_escapeable_character (1x)
        .          .          .          .                       return Ok(Primitive::Literal(ast::Literal {
        .          .          .          .                           span,
        .          .          .          .                           kind: ast::LiteralKind::Superfluous,
        .          .          .          .                           c,
        .          .          .          .                       }));
        .          .          .          .                   }
        .          .          .          .                   let special = |kind, c| {
        5 ( 0.00%) .          .          .                       Ok(Primitive::Literal(ast::Literal {
        7 ( 0.00%) .          .          .                           span,
        .          .          .          .                           kind: ast::LiteralKind::Special(kind),
        .          .          .          .                           c,
        .          .          .          .                       }))
        .          .          .          .                   };
        6 ( 0.00%) .          .          .                   match c {
        .          .          .          .                       'a' => special(ast::SpecialLiteralKind::Bell, '\x07'),
        .          .          .          .                       'f' => special(ast::SpecialLiteralKind::FormFeed, '\x0C'),
        .          .          .          .                       't' => special(ast::SpecialLiteralKind::Tab, '\t'),
        .          .          .          .                       'n' => special(ast::SpecialLiteralKind::LineFeed, '\n'),
        .          .          .          .                       'r' => special(ast::SpecialLiteralKind::CarriageReturn, '\r'),
        .          .          .          .                       'v' => special(ast::SpecialLiteralKind::VerticalTab, '\x0B'),
    1,606 ( 0.00%) .          .          .                       'A' => Ok(Primitive::Assertion(ast::Assertion {
        .          .          .          .                           span,
        .          .          .          .                           kind: ast::AssertionKind::StartText,
        .          .          .          .                       })),
        .          .          .          .                       'z' => Ok(Primitive::Assertion(ast::Assertion {
        .          .          .          .                           span,
        .          .          .          .                           kind: ast::AssertionKind::EndText,
        .          .          .          .                       })),
        .          .          .          .                       'b' => {
-- line 1565 ----------------------------------------
-- line 1588 ----------------------------------------
        .          .          .          .                           kind: ast::AssertionKind::WordBoundaryStartAngle,
        .          .          .          .                       })),
        .          .          .          .                       '>' => Ok(Primitive::Assertion(ast::Assertion {
        .          .          .          .                           span,
        .          .          .          .                           kind: ast::AssertionKind::WordBoundaryEndAngle,
        .          .          .          .                       })),
        .          .          .          .                       _ => Err(self.error(span, ast::ErrorKind::EscapeUnrecognized)),
        .          .          .          .                   }
   12,896 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Attempt to parse a specialty word boundary. That is, `\b{start}`,
        .          .          .          .               /// `\b{end}`, `\b{start-half}` or `\b{end-half}`.
        .          .          .          .               ///
        .          .          .          .               /// This is similar to `maybe_parse_ascii_class` in that, in most cases,
        .          .          .          .               /// if it fails it will just return `None` with no error. This is done
        .          .          .          .               /// because `\b{5}` is a valid expression and we want to let that be parsed
        .          .          .          .               /// by the existing counted repetition parsing code. (I thought about just
-- line 1604 ----------------------------------------
-- line 1835 ----------------------------------------
        .          .          .          .               /// whitespace.
        .          .          .          .               ///
        .          .          .          .               /// This expects the parser to be positioned at the first position where
        .          .          .          .               /// a decimal digit could occur. This will advance the parser to the byte
        .          .          .          .               /// immediately following the last contiguous decimal digit.
        .          .          .          .               ///
        .          .          .          .               /// If no decimal digit could be found or if there was a problem parsing
        .          .          .          .               /// the complete set of digits into a u32, then an error is returned.
    1,673 ( 0.00%) .          .          .               fn parse_decimal(&self) -> Result<u32> {
        .          .          .          .                   let mut scratch = self.parser().scratch.borrow_mut();
        .          .          .          .                   scratch.clear();
        .          .          .          .           
      717 ( 0.00%) .          .          .                   while !self.is_eof() && self.char().is_whitespace() {
    4,780 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (239x)
        .          .          .          .                       self.bump();
        .          .          .          .                   }
        .          .          .          .                   let start = self.pos();
    4,043 ( 0.00%) .          .          .                   while !self.is_eof() && '0' <= self.char() && self.char() <= '9' {
   17,820 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (891x)
      720 ( 0.00%) .          .          .                       scratch.push(self.char());
    4,800 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (240x)
        .          .          .          .                       self.bump_and_bump_space();
        .          .          .          .                   }
        .          .          .          .                   let span = Span::new(start, self.pos());
      717 ( 0.00%) .          .          .                   while !self.is_eof() && self.char().is_whitespace() {
    4,780 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (239x)
        .          .          .          .                       self.bump_and_bump_space();
        .          .          .          .                   }
        .          .          .          .                   let digits = scratch.as_str();
      478 ( 0.00%) .          .          .                   if digits.is_empty() {
        .          .          .          .                       return Err(self.error(span, ast::ErrorKind::DecimalEmpty));
        .          .          .          .                   }
        .          .          .          .                   match u32::from_str_radix(digits, 10).ok() {
      956 ( 0.00%) .          .          .                       Some(n) => Ok(n),
        .          .          .          .                       None => Err(self.error(span, ast::ErrorKind::DecimalInvalid)),
        .          .          .          .                   }
    1,912 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a standard character class consisting primarily of characters or
        .          .          .          .               /// character ranges, but can also contain nested character classes of
        .          .          .          .               /// any type (sans `.`).
        .          .          .          .               ///
        .          .          .          .               /// This assumes the parser is positioned at the opening `[`. If parsing
        .          .          .          .               /// is successful, then the parser is advanced to the position immediately
        .          .          .          .               /// following the closing `]`.
        .          .          .          .               #[inline(never)]
   24,777 ( 0.01%) .          .          .               fn parse_set_class(&self) -> Result<ast::ClassBracketed> {
   13,765 ( 0.00%) .          .          .                   assert_eq!(self.char(), '[');
   55,012 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,753x)
        .          .          .          .           
        .          .          .          .                   let mut union =
   41,295 ( 0.01%) .          .          .                       ast::ClassSetUnion { span: self.span(), items: vec![] };
        .          .          .          .                   loop {
   20,704 ( 0.01%) .          .          .                       self.bump_space();
  179,406 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (9,967x)
    9,967 ( 0.00%) .          .          .                       if self.is_eof() {
        .          .          .          .                           return Err(self.unclosed_class_error());
        .          .          .          .                       }
   75,934 ( 0.02%) .          .          .                       match self.char() {
  199,892 ( 0.06%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (9,967x)
        .          .          .          .                           '[' => {
        .          .          .          .                               // If we've already parsed the opening bracket, then
        .          .          .          .                               // attempt to treat this as the beginning of an ASCII
        .          .          .          .                               // class. If ASCII class parsing fails, then the parser
        .          .          .          .                               // backs up to `[`.
    7,188 ( 0.00%) .          .          .                               if !self.parser().stack_class.borrow().is_empty() {
   10,365 ( 0.00%) .          .          .                                   if let Some(cls) = self.maybe_parse_ascii_class() {
  952,460 ( 0.29%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::maybe_parse_ascii_class (841x)
        .          .          .          .                                       union.push(ast::ClassSetItem::Ascii(cls));
        .          .          .          .                                       continue;
        .          .          .          .                                   }
        .          .          .          .                               }
   67,776 ( 0.02%) .          .          .                               union = self.push_class_open(union)?;
2,637,164 ( 0.79%) 330 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::push_class_open (2,824x)
        .          .          .          .                           }
   45,184 ( 0.01%) .          .          .                           ']' => match self.pop_class(union)? {
1,724,922 ( 0.52%) 10 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::pop_class (2,824x)
      781 ( 0.00%) .          .          .                               Either::Left(nested_union) => {
        .          .          .          .                                   union = nested_union;
        .          .          .          .                               }
   22,024 ( 0.01%) .          .          .                               Either::Right(class) => return Ok(class),
   82,590 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x)
        .          .          .          .                           },
    2,824 ( 0.00%) .          .          .                           '&' if self.peek() == Some('&') => {
        .          .          .          .                               assert!(self.bump_if("&&"));
        .          .          .          .                               union = self.push_class_op(
        .          .          .          .                                   ast::ClassSetBinaryOpKind::Intersection,
        .          .          .          .                                   union,
        .          .          .          .                               );
        .          .          .          .                           }
        .          .          .          .                           '-' if self.peek() == Some('-') => {
        .          .          .          .                               assert!(self.bump_if("--"));
-- line 1915 ----------------------------------------
-- line 1921 ----------------------------------------
        .          .          .          .                           '~' if self.peek() == Some('~') => {
        .          .          .          .                               assert!(self.bump_if("~~"));
        .          .          .          .                               union = self.push_class_op(
        .          .          .          .                                   ast::ClassSetBinaryOpKind::SymmetricDifference,
        .          .          .          .                                   union,
        .          .          .          .                               );
        .          .          .          .                           }
        .          .          .          .                           _ => {
   39,039 ( 0.01%) .          .          .                               union.push(self.parse_set_class_range()?);
1,428,189 ( 0.43%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_range (3,549x)
  106,470 ( 0.03%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (3,549x)
        .          .          .          .                           }
        .          .          .          .                       }
        .          .          .          .                   }
   22,024 ( 0.01%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a single primitive item in a character class set. The item to
        .          .          .          .               /// be parsed can either be one of a simple literal character, a range
        .          .          .          .               /// between two simple literal characters or a "primitive" character
        .          .          .          .               /// class like \w or \p{Greek}.
        .          .          .          .               ///
        .          .          .          .               /// If an invalid escape is found, or if a character class is found where
        .          .          .          .               /// a simple literal is expected (e.g., in a range), then an error is
        .          .          .          .               /// returned.
        .          .          .          .               #[inline(never)]
   35,490 ( 0.01%) .          .          .               fn parse_set_class_range(&self) -> Result<ast::ClassSetItem> {
   56,784 ( 0.02%) .          .          .                   let prim1 = self.parse_set_class_item()?;
1,005,248 ( 0.30%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_set_class_item (3,549x)
    7,098 ( 0.00%) .          .          .                   self.bump_space();
   63,882 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump_space (3,549x)
    3,549 ( 0.00%) .          .          .                   if self.is_eof() {
        .          .          .          .                       return Err(self.unclosed_class_error());
        .          .          .          .                   }
        .          .          .          .                   // If the next char isn't a `-`, then we don't have a range.
        .          .          .          .                   // There are two exceptions. If the char after a `-` is a `]`, then
        .          .          .          .                   // `-` is interpreted as a literal `-`. Alternatively, if the char
        .          .          .          .                   // after a `-` is a `-`, then `--` corresponds to a "difference"
        .          .          .          .                   // operation.
   14,196 ( 0.00%) .          .          .                   if self.char() != '-'
   71,580 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (3,549x)
        .          .          .          .                       || self.peek_space() == Some(']')
        .          .          .          .                       || self.peek_space() == Some('-')
        .          .          .          .                   {
    3,549 ( 0.00%) .          .          .                       return prim1.into_class_set_item(self);
        .          .          .          .                   }
        .          .          .          .                   // OK, now we're parsing a range, so bump past the `-` and parse the
        .          .          .          .                   // second half of the range.
        .          .          .          .                   if !self.bump_and_bump_space() {
        .          .          .          .                       return Err(self.unclosed_class_error());
        .          .          .          .                   }
        .          .          .          .                   let prim2 = self.parse_set_class_item()?;
        .          .          .          .                   let range = ast::ClassSetRange {
-- line 1967 ----------------------------------------
-- line 1970 ----------------------------------------
        .          .          .          .                       end: prim2.into_class_literal(self)?,
        .          .          .          .                   };
        .          .          .          .                   if !range.is_valid() {
        .          .          .          .                       return Err(
        .          .          .          .                           self.error(range.span, ast::ErrorKind::ClassRangeInvalid)
        .          .          .          .                       );
        .          .          .          .                   }
        .          .          .          .                   Ok(ast::ClassSetItem::Range(range))
   28,392 ( 0.01%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a single item in a character class as a primitive, where the
        .          .          .          .               /// primitive either consists of a verbatim literal or a single escape
        .          .          .          .               /// sequence.
        .          .          .          .               ///
        .          .          .          .               /// This assumes the parser is positioned at the beginning of a primitive,
        .          .          .          .               /// and advances the parser to the first position after the primitive if
        .          .          .          .               /// successful.
        .          .          .          .               ///
        .          .          .          .               /// Note that it is the caller's responsibility to report an error if an
        .          .          .          .               /// illegal primitive was parsed.
        .          .          .          .               #[inline(never)]
   31,941 ( 0.01%) .          .          .               fn parse_set_class_item(&self) -> Result<Primitive> {
   14,196 ( 0.00%) .          .          .                   if self.char() == '\\' {
   71,580 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (3,549x)
   16,120 ( 0.00%) .          .          .                       self.parse_escape()
  476,657 ( 0.14%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::parse_escape (1,612x)
        .          .          .          .                   } else {
        .          .          .          .                       let x = Primitive::Literal(ast::Literal {
        .          .          .          .                           span: self.span_char(),
        .          .          .          .                           kind: ast::LiteralKind::Verbatim,
    5,811 ( 0.00%) .          .          .                           c: self.char(),
   39,340 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (1,937x)
        .          .          .          .                       });
    5,811 ( 0.00%) .          .          .                       self.bump();
  175,770 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (1,937x)
   17,433 ( 0.01%) .          .          .                       Ok(x)
        .          .          .          .                   }
   15,496 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parses the opening of a character class set. This includes the opening
        .          .          .          .               /// bracket along with `^` if present to indicate negation. This also
        .          .          .          .               /// starts parsing the opening set of unioned items if applicable, since
        .          .          .          .               /// there are special rules applied to certain characters in the opening
        .          .          .          .               /// of a character class. For example, `[^]]` is the class of all
        .          .          .          .               /// characters not equal to `]`. (`]` would need to be escaped in any other
        .          .          .          .               /// position.) Similarly for `-`.
-- line 2011 ----------------------------------------
-- line 2014 ----------------------------------------
        .          .          .          .               /// empty union. This empty union should be replaced with the actual item
        .          .          .          .               /// when it is popped from the parser's stack.
        .          .          .          .               ///
        .          .          .          .               /// This assumes the parser is positioned at the opening `[` and advances
        .          .          .          .               /// the parser to the first non-special byte of the character class.
        .          .          .          .               ///
        .          .          .          .               /// An error is returned if EOF is found.
        .          .          .          .               #[inline(never)]
   25,416 ( 0.01%) .          .          .               fn parse_set_class_open(
        .          .          .          .                   &self,
        .          .          .          .               ) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {
   14,120 ( 0.00%) .          .          .                   assert_eq!(self.char(), '[');
   56,432 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,824x)
        .          .          .          .                   let start = self.pos();
    2,824 ( 0.00%) .          .          .                   if !self.bump_and_bump_space() {
        .          .          .          .                       return Err(self.error(
        .          .          .          .                           Span::new(start, self.pos()),
        .          .          .          .                           ast::ErrorKind::ClassUnclosed,
        .          .          .          .                       ));
        .          .          .          .                   }
        .          .          .          .           
   16,944 ( 0.01%) .          .          .                   let negated = if self.char() != '^' {
   56,480 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,824x)
        .          .          .          .                       false
        .          .          .          .                   } else {
        1 ( 0.00%) .          .          .                       if !self.bump_and_bump_space() {
        .          .          .          .                           return Err(self.error(
        .          .          .          .                               Span::new(start, self.pos()),
        .          .          .          .                               ast::ErrorKind::ClassUnclosed,
        .          .          .          .                           ));
        .          .          .          .                       }
        .          .          .          .                       true
        .          .          .          .                   };
        .          .          .          .                   // Accept any number of `-` as literal `-`.
        .          .          .          .                   let mut union =
   36,712 ( 0.01%) .          .          .                       ast::ClassSetUnion { span: self.span(), items: vec![] };
   11,300 ( 0.00%) .          .          .                   while self.char() == '-' {
   56,500 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,825x)
        .          .          .          .                       union.push(ast::ClassSetItem::Literal(ast::Literal {
        .          .          .          .                           span: self.span_char(),
        .          .          .          .                           kind: ast::LiteralKind::Verbatim,
        .          .          .          .                           c: '-',
        .          .          .          .                       }));
        1 ( 0.00%) .          .          .                       if !self.bump_and_bump_space() {
        .          .          .          .                           return Err(self.error(
        .          .          .          .                               Span::new(start, start),
        .          .          .          .                               ast::ErrorKind::ClassUnclosed,
        .          .          .          .                           ));
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   // If `]` is the *first* char in a set, then interpret it as a literal
        .          .          .          .                   // `]`. That is, an empty class is impossible to write.
   16,940 ( 0.01%) .          .          .                   if union.items.is_empty() && self.char() == ']' {
   56,460 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (2,823x)
        .          .          .          .                       union.push(ast::ClassSetItem::Literal(ast::Literal {
        .          .          .          .                           span: self.span_char(),
        .          .          .          .                           kind: ast::LiteralKind::Verbatim,
        .          .          .          .                           c: ']',
        .          .          .          .                       }));
        .          .          .          .                       if !self.bump_and_bump_space() {
        .          .          .          .                           return Err(self.error(
        .          .          .          .                               Span::new(start, self.pos()),
-- line 2071 ----------------------------------------
-- line 2072 ----------------------------------------
        .          .          .          .                               ast::ErrorKind::ClassUnclosed,
        .          .          .          .                           ));
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   let set = ast::ClassBracketed {
        .          .          .          .                       span: Span::new(start, self.pos()),
        .          .          .          .                       negated,
        .          .          .          .                       kind: ast::ClassSet::union(ast::ClassSetUnion {
   22,592 ( 0.01%) .          .          .                           span: Span::new(union.span.start, union.span.start),
        .          .          .          .                           items: vec![],
        .          .          .          .                       }),
        .          .          .          .                   };
   79,072 ( 0.02%) .          .          .                   Ok((set, union))
   25,416 ( 0.01%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Attempt to parse an ASCII character class, e.g., `[:alnum:]`.
        .          .          .          .               ///
        .          .          .          .               /// This assumes the parser is positioned at the opening `[`.
        .          .          .          .               ///
        .          .          .          .               /// If no valid ASCII character class could be found, then this does not
        .          .          .          .               /// advance the parser and `None` is returned. Otherwise, the parser is
        .          .          .          .               /// advanced to the first byte following the closing `]` and the
        .          .          .          .               /// corresponding ASCII class is returned.
        .          .          .          .               #[inline(never)]
    7,569 ( 0.00%) .          .          .               fn maybe_parse_ascii_class(&self) -> Option<ast::ClassAscii> {
        .          .          .          .                   // ASCII character classes are interesting from a parsing perspective
        .          .          .          .                   // because parsing cannot fail with any interesting error. For example,
        .          .          .          .                   // in order to use an ASCII character class, it must be enclosed in
        .          .          .          .                   // double brackets, e.g., `[[:alnum:]]`. Alternatively, you might think
        .          .          .          .                   // of it as "ASCII character classes have the syntax `[:NAME:]` which
        .          .          .          .                   // can only appear within character brackets." This means that things
        .          .          .          .                   // like `[[:lower:]A]` are legal constructs.
        .          .          .          .                   //
-- line 2104 ----------------------------------------
-- line 2108 ----------------------------------------
        .          .          .          .                   // should return an error instead since the repeated colons give away
        .          .          .          .                   // the intent to write an ASCII class. But what if the user typed
        .          .          .          .                   // `[[:lower]]` instead? How can we tell that was intended to be an
        .          .          .          .                   // ASCII class and not just a normal nested class?
        .          .          .          .                   //
        .          .          .          .                   // Reasonable people can probably disagree over this, but for better
        .          .          .          .                   // or worse, we implement semantics that never fails at the expense
        .          .          .          .                   // of better failure modes.
    4,205 ( 0.00%) .          .          .                   assert_eq!(self.char(), '[');
   16,820 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (841x)
        .          .          .          .                   // If parsing fails, then we back up the parser to this starting point.
        .          .          .          .                   let start = self.pos();
        .          .          .          .                   let mut negated = false;
    6,728 ( 0.00%) .          .          .                   if !self.bump() || self.char() != ':' {
   75,690 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (841x)
   16,820 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (841x)
        .          .          .          .                       self.parser().pos.set(start);
        .          .          .          .                       return None;
        .          .          .          .                   }
    3,080 ( 0.00%) .          .          .                   if !self.bump() {
   69,300 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (770x)
        .          .          .          .                       self.parser().pos.set(start);
        .          .          .          .                       return None;
        .          .          .          .                   }
    5,390 ( 0.00%) .          .          .                   if self.char() == '^' {
   15,400 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (770x)
        .          .          .          .                       negated = true;
      220 ( 0.00%) .          .          .                       if !self.bump() {
    4,950 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (55x)
        .          .          .          .                           self.parser().pos.set(start);
        .          .          .          .                           return None;
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   let name_start = self.offset();
   33,872 ( 0.01%) .          .          .                   while self.char() != ':' && self.bump() {}
  346,410 ( 0.10%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (3,849x)
   92,380 ( 0.03%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (4,619x)
      770 ( 0.00%) .          .          .                   if self.is_eof() {
        .          .          .          .                       self.parser().pos.set(start);
        .          .          .          .                       return None;
        .          .          .          .                   }
        .          .          .          .                   let name = &self.pattern()[name_start..self.offset()];
        .          .          .          .                   if !self.bump_if(":]") {
        .          .          .          .                       self.parser().pos.set(start);
        .          .          .          .                       return None;
        .          .          .          .                   }
    3,080 ( 0.00%) .          .          .                   let kind = match ast::ClassAsciiKind::from_name(name) {
   31,216 ( 0.01%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:regex_syntax::ast::ClassAsciiKind::from_name (770x)
        .          .          .          .                       Some(kind) => kind,
        .          .          .          .                       None => {
        .          .          .          .                           self.parser().pos.set(start);
        .          .          .          .                           return None;
        .          .          .          .                       }
        .          .          .          .                   };
    8,470 ( 0.00%) .          .          .                   Some(ast::ClassAscii {
        .          .          .          .                       span: Span::new(start, self.pos()),
        .          .          .          .                       kind,
        .          .          .          .                       negated,
        .          .          .          .                   })
    6,728 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a Unicode class in either the single character notation, `\pN`
        .          .          .          .               /// or the multi-character bracketed notation, `\p{Greek}`. This assumes
        .          .          .          .               /// the parser is positioned at the `p` (or `P` for negation) and will
        .          .          .          .               /// advance the parser to the character immediately following the class.
        .          .          .          .               ///
        .          .          .          .               /// Note that this does not check whether the class name is valid or not.
        .          .          .          .               #[inline(never)]
-- line 2166 ----------------------------------------
-- line 2238 ----------------------------------------
        .          .          .          .                       kind,
        .          .          .          .                   })
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Parse a Perl character class, e.g., `\d` or `\W`. This assumes the
        .          .          .          .               /// parser is currently at a valid character class name and will be
        .          .          .          .               /// advanced to the character immediately following the class.
        .          .          .          .               #[inline(never)]
       45 ( 0.00%) .          .          .               fn parse_perl_class(&self) -> ast::ClassPerl {
       10 ( 0.00%) .          .          .                   let c = self.char();
      100 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::char (5x)
        .          .          .          .                   let span = self.span_char();
       15 ( 0.00%) .          .          .                   self.bump();
      450 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::ParserI<P>::bump (5x)
       30 ( 0.00%) .          .          .                   let (negated, kind) = match c {
        .          .          .          .                       'd' => (false, ast::ClassPerlKind::Digit),
        .          .          .          .                       'D' => (true, ast::ClassPerlKind::Digit),
        .          .          .          .                       's' => (false, ast::ClassPerlKind::Space),
        .          .          .          .                       'S' => (true, ast::ClassPerlKind::Space),
        .          .          .          .                       'w' => (false, ast::ClassPerlKind::Word),
        .          .          .          .                       'W' => (true, ast::ClassPerlKind::Word),
        .          .          .          .                       c => panic!("expected valid Perl class but got '{}'", c),
        .          .          .          .                   };
       45 ( 0.00%) .          .          .                   ast::ClassPerl { span, kind, negated }
       40 ( 0.00%) .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// A type that traverses a fully parsed Ast and checks whether its depth
        .          .          .          .           /// exceeds the specified nesting limit. If it does, then an error is returned.
        .          .          .          .           #[derive(Debug)]
        .          .          .          .           struct NestLimiter<'p, 's, P> {
        .          .          .          .               /// The parser that is checking the nest limit.
        .          .          .          .               p: &'p ParserI<'s, P>,
-- line 2268 ----------------------------------------
-- line 2271 ----------------------------------------
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'p, 's, P: Borrow<Parser>> NestLimiter<'p, 's, P> {
        .          .          .          .               fn new(p: &'p ParserI<'s, P>) -> NestLimiter<'p, 's, P> {
        .          .          .          .                   NestLimiter { p, depth: 0 }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline(never)]
       81 ( 0.00%) .          .          .               fn check(self, ast: &Ast) -> Result<()> {
      324 ( 0.00%) .          .          .                   ast::visit(ast, self)
4,259,516 ( 1.28%) 305 ( 0.04%) 1 ( 0.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/visitor.rs:regex_syntax::ast::visitor::visit (81x)
        .          .          .          .               }
        .          .          .          .           
  200,025 ( 0.06%) .          .          .               fn increment_depth(&mut self, span: &Span) -> Result<()> {
   22,225 ( 0.01%) .          .          .                   let new = self.depth.checked_add(1).ok_or_else(|| {
        .          .          .          .                       self.p.error(
        .          .          .          .                           span.clone(),
        .          .          .          .                           ast::ErrorKind::NestLimitExceeded(u32::MAX),
        .          .          .          .                       )
        .          .          .          .                   })?;
   22,225 ( 0.01%) .          .          .                   let limit = self.p.parser().nest_limit;
   44,450 ( 0.01%) .          .          .                   if new > limit {
        .          .          .          .                       return Err(self.p.error(
        .          .          .          .                           span.clone(),
        .          .          .          .                           ast::ErrorKind::NestLimitExceeded(limit),
        .          .          .          .                       ));
        .          .          .          .                   }
   44,450 ( 0.01%) .          .          .                   self.depth = new;
   44,450 ( 0.01%) .          .          .                   Ok(())
  177,800 ( 0.05%) .          .          .               }
        .          .          .          .           
        .          .          .          .               fn decrement_depth(&mut self) {
        .          .          .          .                   // Assuming the correctness of the visitor, this should never drop
        .          .          .          .                   // below 0.
   57,805 ( 0.02%) .          .          .                   self.depth = self.depth.checked_sub(1).unwrap();
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'p, 's, P: Borrow<Parser>> ast::Visitor for NestLimiter<'p, 's, P> {
        .          .          .          .               type Output = ();
        .          .          .          .               type Err = ast::Error;
        .          .          .          .           
        .          .          .          .               fn finish(self) -> Result<()> {
       81 ( 0.00%) .          .          .                   Ok(())
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn visit_pre(&mut self, ast: &Ast) -> Result<()> {
  408,660 ( 0.12%) .          .          .                   let span = match *ast {
        .          .          .          .                       Ast::Empty(_)
        .          .          .          .                       | Ast::Flags(_)
        .          .          .          .                       | Ast::Literal(_)
        .          .          .          .                       | Ast::Dot(_)
        .          .          .          .                       | Ast::Assertion(_)
        .          .          .          .                       | Ast::ClassUnicode(_)
        .          .          .          .                       | Ast::ClassPerl(_) => {
        .          .          .          .                           // These are all base cases, so we don't increment depth.
        .          .          .          .                           return Ok(());
        .          .          .          .                       }
        .          .          .          .                       Ast::ClassBracketed(ref x) => &x.span,
        .          .          .          .                       Ast::Repetition(ref x) => &x.span,
    2,079 ( 0.00%) .          .          .                       Ast::Group(ref x) => &x.span,
        .          .          .          .                       Ast::Alternation(ref x) => &x.span,
        .          .          .          .                       Ast::Concat(ref x) => &x.span,
        .          .          .          .                   };
   21,629 ( 0.01%) .          .          .                   self.increment_depth(span)
  648,870 ( 0.19%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::NestLimiter<P>::increment_depth (21,629x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn visit_post(&mut self, ast: &Ast) -> Result<()> {
   43,258 ( 0.01%) .          .          .                   match *ast {
        .          .          .          .                       Ast::Empty(_)
        .          .          .          .                       | Ast::Flags(_)
        .          .          .          .                       | Ast::Literal(_)
        .          .          .          .                       | Ast::Dot(_)
        .          .          .          .                       | Ast::Assertion(_)
        .          .          .          .                       | Ast::ClassUnicode(_)
        .          .          .          .                       | Ast::ClassPerl(_) => {
        .          .          .          .                           // These are all base cases, so we don't decrement depth.
-- line 2346 ----------------------------------------
-- line 2356 ----------------------------------------
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn visit_class_set_item_pre(
        .          .          .          .                   &mut self,
        .          .          .          .                   ast: &ast::ClassSetItem,
        .          .          .          .               ) -> Result<()> {
   35,008 ( 0.01%) .          .          .                   let span = match *ast {
        .          .          .          .                       ast::ClassSetItem::Empty(_)
        .          .          .          .                       | ast::ClassSetItem::Literal(_)
        .          .          .          .                       | ast::ClassSetItem::Range(_)
        .          .          .          .                       | ast::ClassSetItem::Ascii(_)
        .          .          .          .                       | ast::ClassSetItem::Unicode(_)
        .          .          .          .                       | ast::ClassSetItem::Perl(_) => {
        .          .          .          .                           // These are all base cases, so we don't increment depth.
        .          .          .          .                           return Ok(());
        .          .          .          .                       }
      142 ( 0.00%) .          .          .                       ast::ClassSetItem::Bracketed(ref x) => &x.span,
      525 ( 0.00%) .          .          .                       ast::ClassSetItem::Union(ref x) => &x.span,
        .          .          .          .                   };
      596 ( 0.00%) .          .          .                   self.increment_depth(span)
   17,880 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs:regex_syntax::ast::parse::NestLimiter<P>::increment_depth (596x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn visit_class_set_item_post(
        .          .          .          .                   &mut self,
        .          .          .          .                   ast: &ast::ClassSetItem,
        .          .          .          .               ) -> Result<()> {
    1,192 ( 0.00%) .          .          .                   match *ast {
        .          .          .          .                       ast::ClassSetItem::Empty(_)
        .          .          .          .                       | ast::ClassSetItem::Literal(_)
        .          .          .          .                       | ast::ClassSetItem::Range(_)
        .          .          .          .                       | ast::ClassSetItem::Ascii(_)
        .          .          .          .                       | ast::ClassSetItem::Unicode(_)
        .          .          .          .                       | ast::ClassSetItem::Perl(_) => {
        .          .          .          .                           // These are all base cases, so we don't decrement depth.
        .          .          .          .                           Ok(())
-- line 2392 ----------------------------------------
-- line 2412 ----------------------------------------
        .          .          .          .                   self.decrement_depth();
        .          .          .          .                   Ok(())
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// When the result is an error, transforms the ast::ErrorKind from the source
        .          .          .          .           /// Result into another one. This function is used to return clearer error
        .          .          .          .           /// messages when possible.
    1,912 ( 0.00%) .          .          .           fn specialize_err<T>(
        .          .          .          .               result: Result<T>,
        .          .          .          .               from: ast::ErrorKind,
        .          .          .          .               to: ast::ErrorKind,
        .          .          .          .           ) -> Result<T> {
      478 ( 0.00%) .          .          .               if let Err(e) = result {
        .          .          .          .                   if e.kind == from {
        .          .          .          .                       Err(ast::Error { kind: to, pattern: e.pattern, span: e.span })
        .          .          .          .                   } else {
        .          .          .          .                       Err(e)
        .          .          .          .                   }
        .          .          .          .               } else {
    3,824 ( 0.00%) .          .          .                   result
        .          .          .          .               }
    1,912 ( 0.00%) .          .          .           }
        .          .          .          .           
        .          .          .          .           #[cfg(test)]
        .          .          .          .           mod tests {
        .          .          .          .               use core::ops::Range;
        .          .          .          .           
        .          .          .          .               use alloc::format;
        .          .          .          .           
        .          .          .          .               use super::*;
-- line 2442 ----------------------------------------

1,515,491 ( 0.45%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/parse.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 448 ----------------------------------------
      .          .          .          .               ///     None,
      .          .          .          .               ///     re.find(&mut cache, b"\nabc\n"),
      .          .          .          .               /// );
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn look_matcher(mut self, m: LookMatcher) -> Config {
      .          .          .          .                   self.look_matcher = Some(m);
     91 ( 0.00%) .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Whether to compile an unanchored prefix into this NFA.
      .          .          .          .               ///
      .          .          .          .               /// This is enabled by default. It is made available for tests only to make
      .          .          .          .               /// it easier to unit test the output of the compiler.
      .          .          .          .               #[cfg(test)]
      .          .          .          .               fn unanchored_prefix(mut self, yes: bool) -> Config {
-- line 464 ----------------------------------------
-- line 468 ----------------------------------------
      .          .          .          .           
      .          .          .          .               /// Returns whether this configuration has enabled UTF-8 mode.
      .          .          .          .               pub fn get_utf8(&self) -> bool {
      .          .          .          .                   self.utf8.unwrap_or(true)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns whether this configuration has enabled reverse NFA compilation.
      .          .          .          .               pub fn get_reverse(&self) -> bool {
 56,259 ( 0.02%) .          .          .                   self.reverse.unwrap_or(false)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the configured NFA size limit, if it exists, in the number of
      .          .          .          .               /// bytes of heap used.
      .          .          .          .               pub fn get_nfa_size_limit(&self) -> Option<usize> {
    350 ( 0.00%) .          .          .                   self.nfa_size_limit.unwrap_or(None)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return whether NFA shrinking is enabled.
      .          .          .          .               pub fn get_shrink(&self) -> bool {
    127 ( 0.00%) .          .          .                   self.shrink.unwrap_or(false)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return whether NFA compilation is configured to produce capture states.
      .          .          .          .               #[deprecated(since = "0.3.5", note = "use get_which_captures instead")]
      .          .          .          .               pub fn get_captures(&self) -> bool {
      .          .          .          .                   self.get_which_captures().is_any()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return what kinds of capture states will be compiled into an NFA.
      .          .          .          .               pub fn get_which_captures(&self) -> WhichCaptures {
  1,561 ( 0.00%) .          .          .                   self.which_captures.unwrap_or(WhichCaptures::All)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the look-around matcher for this NFA.
      .          .          .          .               pub fn get_look_matcher(&self) -> LookMatcher {
      .          .          .          .                   self.look_matcher.clone().unwrap_or(LookMatcher::default())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return whether NFA compilation is configured to include an unanchored
-- line 506 ----------------------------------------
-- line 518 ----------------------------------------
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Overwrite the default configuration such that the options in `o` are
      .          .          .          .               /// always used. If an option in `o` is not set, then the corresponding
      .          .          .          .               /// option in `self` is used. If it's not set in `self` either, then it
      .          .          .          .               /// remains not set.
      .          .          .          .               pub(crate) fn overwrite(&self, o: Config) -> Config {
     52 ( 0.00%) .          .          .                   Config {
     26 ( 0.00%) .          .          .                       utf8: o.utf8.or(self.utf8),
      .          .          .          .                       reverse: o.reverse.or(self.reverse),
     13 ( 0.00%) .          .          .                       nfa_size_limit: o.nfa_size_limit.or(self.nfa_size_limit),
      .          .          .          .                       shrink: o.shrink.or(self.shrink),
      .          .          .          .                       which_captures: o.which_captures.or(self.which_captures),
     39 ( 0.00%) .          .          .                       look_matcher: o.look_matcher.or_else(|| self.look_matcher.clone()),
      .          .          .          .                       #[cfg(test)]
      .          .          .          .                       unanchored_prefix: o.unanchored_prefix.or(self.unanchored_prefix),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A configuration indicating which kinds of
      .          .          .          .           /// [`State::Capture`](crate::nfa::thompson::State::Capture) states to include.
-- line 540 ----------------------------------------
-- line 571 ----------------------------------------
      .          .          .          .                   WhichCaptures::All
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl WhichCaptures {
      .          .          .          .               /// Returns true if this configuration indicates that no capture states
      .          .          .          .               /// should be produced in an NFA.
      .          .          .          .               pub fn is_none(&self) -> bool {
     94 ( 0.00%) .          .          .                   matches!(*self, WhichCaptures::None)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if this configuration indicates that some capture states
      .          .          .          .               /// should be added to an NFA. Note that this might only include capture
      .          .          .          .               /// states for implicit capture groups.
      .          .          .          .               pub fn is_any(&self) -> bool {
      .          .          .          .                   !self.is_none()
      .          .          .          .               }
-- line 587 ----------------------------------------
-- line 710 ----------------------------------------
      .          .          .          .               trie_state: RefCell<RangeTrie>,
      .          .          .          .               /// State used for caching common suffixes when compiling reverse UTF-8
      .          .          .          .               /// automata (for Unicode character classes).
      .          .          .          .               utf8_suffix: RefCell<Utf8SuffixMap>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Compiler {
      .          .          .          .               /// Create a new NFA builder with its default configuration.
     65 ( 0.00%) .          .          .               pub fn new() -> Compiler {
 19,222 ( 0.01%) .          .          .                   Compiler {
      .          .          .          .                       parser: ParserBuilder::new(),
      .          .          .          .                       config: Config::default(),
      .          .          .          .                       builder: RefCell::new(Builder::new()),
      .          .          .          .                       utf8_state: RefCell::new(Utf8State::new()),
      .          .          .          .                       trie_state: RefCell::new(RangeTrie::new()),
      .          .          .          .                       utf8_suffix: RefCell::new(Utf8SuffixMap::new(1000)),
      .          .          .          .                   }
     78 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given regular expression pattern into an NFA.
      .          .          .          .               ///
      .          .          .          .               /// If there was a problem parsing the regex, then that error is returned.
      .          .          .          .               ///
      .          .          .          .               /// Otherwise, if there was a problem building the NFA, then an error is
      .          .          .          .               /// returned. The only error that can occur is if the compiled regex would
      .          .          .          .               /// exceed the size limits configured on this builder, or if any part of
-- line 735 ----------------------------------------
-- line 829 ----------------------------------------
      .          .          .          .               /// let mut caps = re.create_captures();
      .          .          .          .               /// let expected = Some(Match::must(0, 3..4));
      .          .          .          .               /// re.captures(&mut cache, "!@#A#@!", &mut caps);
      .          .          .          .               /// assert_eq!(expected, caps.get_match());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn build_from_hir(&self, expr: &Hir) -> Result<NFA, BuildError> {
     26 ( 0.00%) .          .          .                   self.build_many_from_hir(&[expr])
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given high level intermediate representations of regular
      .          .          .          .               /// expressions into a single NFA.
      .          .          .          .               ///
      .          .          .          .               /// When matches are returned, the pattern ID corresponds to the index of
      .          .          .          .               /// the pattern in the slice given.
      .          .          .          .               ///
-- line 845 ----------------------------------------
-- line 873 ----------------------------------------
      .          .          .          .               /// assert_eq!(expected, caps.get_match());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn build_many_from_hir<H: Borrow<Hir>>(
      .          .          .          .                   &self,
      .          .          .          .                   exprs: &[H],
      .          .          .          .               ) -> Result<NFA, BuildError> {
    201 ( 0.00%) .          .          .                   self.compile(exprs)
89,137,842 (26.76%) 225,040 (27.80%) 85 (28.24%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::compile (175x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Apply the given NFA configuration options to this builder.
      .          .          .          .               ///
      .          .          .          .               /// # Example
      .          .          .          .               ///
      .          .          .          .               /// ```
      .          .          .          .               /// use regex_automata::nfa::thompson::NFA;
      .          .          .          .               ///
      .          .          .          .               /// let config = NFA::config().nfa_size_limit(Some(1_000));
      .          .          .          .               /// let nfa = NFA::compiler().configure(config).build(r"(?-u)\w")?;
      .          .          .          .               /// assert_eq!(nfa.pattern_len(), 1);
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
     13 ( 0.00%) .          .          .               pub fn configure(&mut self, config: Config) -> &mut Compiler {
  1,523 ( 0.00%) .          .          .                   self.config = self.config.overwrite(config);
      .          .          .          .                   self
     13 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the syntax configuration for this builder using
      .          .          .          .               /// [`syntax::Config`](crate::util::syntax::Config).
      .          .          .          .               ///
      .          .          .          .               /// This permits setting things like case insensitivity, Unicode and multi
      .          .          .          .               /// line mode.
      .          .          .          .               ///
      .          .          .          .               /// This syntax configuration only applies when an NFA is built directly
-- line 908 ----------------------------------------
-- line 931 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Compiler {
      .          .          .          .               /// Compile the sequence of HIR expressions given. Pattern IDs are
      .          .          .          .               /// allocated starting from 0, in correspondence with the slice given.
      .          .          .          .               ///
      .          .          .          .               /// It is legal to provide an empty slice. In that case, the NFA returned
      .          .          .          .               /// has no patterns and will never match anything.
  1,575 ( 0.00%) .          .          .               fn compile<H: Borrow<Hir>>(&self, exprs: &[H]) -> Result<NFA, BuildError> {
    350 ( 0.00%) .          .          .                   if exprs.len() > PatternID::LIMIT {
      .          .          .          .                       return Err(BuildError::too_many_patterns(exprs.len()));
      .          .          .          .                   }
    188 ( 0.00%) .          .          .                   if self.config.get_reverse()
     94 ( 0.00%) .          .          .                       && self.config.get_which_captures().is_any()
      .          .          .          .                   {
      .          .          .          .                       return Err(BuildError::unsupported_captures());
      .          .          .          .                   }
      .          .          .          .           
    350 ( 0.00%) .          .          .                   self.builder.borrow_mut().clear();
  5,600 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::clear (175x)
      .          .          .          .                   self.builder.borrow_mut().set_utf8(self.config.get_utf8());
      .          .          .          .                   self.builder.borrow_mut().set_reverse(self.config.get_reverse());
      .          .          .          .                   self.builder
      .          .          .          .                       .borrow_mut()
      .          .          .          .                       .set_look_matcher(self.config.get_look_matcher());
      .          .          .          .                   self.builder
      .          .          .          .                       .borrow_mut()
      .          .          .          .                       .set_size_limit(self.config.get_nfa_size_limit())?;
-- line 957 ----------------------------------------
-- line 962 ----------------------------------------
      .          .          .          .                   // NFA's anchored and unanchored start states are equivalent.
      .          .          .          .                   let all_anchored = exprs.iter().all(|e| {
      .          .          .          .                       let props = e.borrow().properties();
      .          .          .          .                       if self.config.get_reverse() {
      .          .          .          .                           props.look_set_suffix().contains(hir::Look::End)
      .          .          .          .                       } else {
      .          .          .          .                           props.look_set_prefix().contains(hir::Look::Start)
      .          .          .          .                       }
     94 ( 0.00%) .          .          .                   });
      .          .          .          .                   let anchored = !self.config.get_unanchored_prefix() || all_anchored;
      .          .          .          .                   let unanchored_prefix = if anchored {
      .          .          .          .                       self.c_empty()?
      .          .          .          .                   } else {
    880 ( 0.00%) .          .          .                       self.c_at_least(&Hir::dot(hir::Dot::AnyByte), false, 0)?
 84,121 ( 0.03%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (110x)
 34,274 ( 0.01%) 38 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::dot (110x)
    220 ( 0.00%) .          .          .                   };
 27,590 ( 0.01%) 1 ( 0.00%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::hir::Hir> (110x)
      .          .          .          .           
      .          .          .          .                   let compiled = self.c_alt_iter(exprs.iter().map(|e| {
      .          .          .          .                       let _ = self.start_pattern()?;
    875 ( 0.00%) .          .          .                       let one = self.c_cap(0, None, e.borrow())?;
70,262,347 (21.09%) 191,036 (23.60%) 77 (25.58%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap (175x)
      .          .          .          .                       let match_state_id = self.add_match()?;
      .          .          .          .                       self.patch(one.end, match_state_id)?;
      .          .          .          .                       let _ = self.finish_pattern(one.start)?;
      .          .          .          .                       Ok(ThompsonRef { start: one.start, end: match_state_id })
      .          .          .          .                   }))?;
      .          .          .          .                   self.patch(unanchored_prefix.end, compiled.start)?;
    525 ( 0.00%) .          .          .                   let nfa = self
18,604,395 ( 5.59%) 33,833 ( 4.18%) 7 ( 2.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::build (175x)
      .          .          .          .                       .builder
      .          .          .          .                       .borrow_mut()
      .          .          .          .                       .build(compiled.start, unanchored_prefix.start)?;
      .          .          .          .           
      .          .          .          .                   debug!("HIR-to-NFA compilation complete, config: {:?}", self.config);
    350 ( 0.00%) .          .          .                   Ok(nfa)
  1,750 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile an arbitrary HIR expression.
199,008 ( 0.06%) .          .          .               fn c(&self, expr: &Hir) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   use regex_syntax::hir::{Class, HirKind::*};
      .          .          .          .           
260,242 ( 0.08%) .          .          .                   match *expr.kind() {
    245 ( 0.00%) .          .          .                       Empty => self.c_empty(),
 26,493 ( 0.01%) .          .          .                       Literal(hir::Literal(ref bytes)) => self.c_literal(bytes),
      .          .          .          .                       Class(Class::Bytes(ref c)) => self.c_byte_class(c),
 11,630 ( 0.00%) .          .          .                       Class(Class::Unicode(ref c)) => self.c_unicode_class(c),
      .          .          .          .                       Look(ref look) => self.c_look(look),
      .          .          .          .                       Repetition(ref rep) => self.c_repetition(rep),
 18,018 ( 0.01%) .          .          .                       Capture(ref c) => self.c_cap(c.index, c.name.as_deref(), &c.sub),
73,121,553 (21.95%) 200,912 (24.82%) 76 (25.25%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_cap'2 (1,386x)
 40,251 ( 0.01%) .          .          .                       Concat(ref es) => self.c_concat(es.iter().map(|e| self.c(e))),
69,916,132 (20.99%) 190,902 (23.58%) 77 (25.58%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (2,839x)
      .          .          .          .                       Alternation(ref es) => self.c_alt_slice(es),
      .          .          .          .                   }
185,632 ( 0.06%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile a concatenation of the sub-expressions yielded by the given
      .          .          .          .               /// iterator. If the iterator yields no elements, then this compiles down
      .          .          .          .               /// to an "empty" state that always matches.
      .          .          .          .               ///
      .          .          .          .               /// If the compiler is in reverse mode, then the expressions given are
      .          .          .          .               /// automatically compiled in reverse.
  3,440 ( 0.00%) .          .          .               fn c_concat<I>(&self, mut it: I) -> Result<ThompsonRef, BuildError>
      .          .          .          .               where
      .          .          .          .                   I: DoubleEndedIterator<Item = Result<ThompsonRef, BuildError>>,
      .          .          .          .               {
 20,956 ( 0.01%) .          .          .                   let first = if self.is_reverse() { it.next_back() } else { it.next() };
195,649 ( 0.06%) 532 ( 0.07%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (344x)
  8,750 ( 0.00%) .          .          .                   let ThompsonRef { start, mut end } = match first {
      .          .          .          .                       Some(result) => result?,
      .          .          .          .                       None => return self.c_empty(),
      .          .          .          .                   };
      .          .          .          .                   loop {
      .          .          .          .                       let next =
332,774 ( 0.10%) .          .          .                           if self.is_reverse() { it.next_back() } else { it.next() };
108,172 ( 0.03%) 332 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (236x)
 17,088 ( 0.01%) .          .          .                       let compiled = match next {
      .          .          .          .                           Some(result) => result?,
      .          .          .          .                           None => break,
      .          .          .          .                       };
      .          .          .          .                       self.patch(end, compiled.start)?;
      .          .          .          .                       end = compiled.end;
      .          .          .          .                   }
 48,621 ( 0.01%) .          .          .                   Ok(ThompsonRef { start, end })
  6,611 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile an alternation of the given HIR values.
      .          .          .          .               ///
      .          .          .          .               /// This is like 'c_alt_iter', but it accepts a slice of HIR values instead
      .          .          .          .               /// of an iterator of compiled NFA sub-graphs. The point of accepting a
      .          .          .          .               /// slice here is that it opens up some optimization opportunities. For
      .          .          .          .               /// example, if all of the HIR values are literals, then this routine might
      .          .          .          .               /// re-shuffle them to make NFA epsilon closures substantially faster.
      .          .          .          .               fn c_alt_slice(&self, exprs: &[Hir]) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   // self.c_alt_iter(exprs.iter().map(|e| self.c(e)))
      .          .          .          .                   let literal_count = exprs
      .          .          .          .                       .iter()
      .          .          .          .                       .filter(|e| {
 99,975 ( 0.03%) .          .          .                           matches!(*e.kind(), hir::HirKind::Literal(hir::Literal(_)))
      .          .          .          .                       })
      .          .          .          .                       .count();
  6,204 ( 0.00%) .          .          .                   if literal_count <= 1 || literal_count < exprs.len() {
 28,073 ( 0.01%) .          .          .                       return self.c_alt_iter(exprs.iter().map(|e| self.c(e)));
14,280,992 ( 4.29%) 14,076 ( 1.74%) 24 ( 7.97%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (6,614x)
      .          .          .          .                   }
      .          .          .          .           
    504 ( 0.00%) .          .          .                   let mut trie = if self.is_reverse() {
    252 ( 0.00%) .          .          .                       LiteralTrie::reverse()
 20,688 ( 0.01%) 18 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::reverse (252x)
      .          .          .          .                   } else {
      .          .          .          .                       LiteralTrie::forward()
      .          .          .          .                   };
      .          .          .          .                   for expr in exprs.iter() {
 53,422 ( 0.02%) .          .          .                       let literal = match *expr.kind() {
      .          .          .          .                           hir::HirKind::Literal(hir::Literal(ref bytes)) => bytes,
      .          .          .          .                           _ => unreachable!(),
      .          .          .          .                       };
133,555 ( 0.04%) .          .          .                       trie.add(literal)?;
24,167,248 ( 7.26%) 80,603 ( 9.96%) 12 ( 3.99%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::add (26,711x)
      .          .          .          .                   }
  1,485 ( 0.00%) .          .          .                   trie.compile(&mut self.builder.borrow_mut())
17,181,242 ( 5.16%) 45,823 ( 5.66%) 23 ( 7.64%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/literal_trie.rs:regex_automata::nfa::thompson::literal_trie::LiteralTrie::compile (495x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile an alternation, where each element yielded by the given
      .          .          .          .               /// iterator represents an item in the alternation. If the iterator yields
      .          .          .          .               /// no elements, then this compiles down to a "fail" state.
      .          .          .          .               ///
      .          .          .          .               /// In an alternation, expressions appearing earlier are "preferred" at
      .          .          .          .               /// match time over expressions appearing later. At least, this is true
      .          .          .          .               /// when using "leftmost first" match semantics. (If "leftmost longest" are
      .          .          .          .               /// ever added in the future, then this preference order of priority would
      .          .          .          .               /// not apply in that mode.)
  4,312 ( 0.00%) .          .          .               fn c_alt_iter<I>(&self, mut it: I) -> Result<ThompsonRef, BuildError>
      .          .          .          .               where
      .          .          .          .                   I: Iterator<Item = Result<ThompsonRef, BuildError>>,
      .          .          .          .               {
  1,953 ( 0.00%) .          .          .                   let first = match it.next() {
70,328,109 (21.11%) 191,122 (23.61%) 78 (25.91%) 1 ( 0.07%)  => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (175x)
      .          .          .          .                       None => return self.c_fail(),
    350 ( 0.00%) .          .          .                       Some(result) => result?,
      .          .          .          .                   };
  2,317 ( 0.00%) .          .          .                   let second = match it.next() {
  3,850 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (175x)
    539 ( 0.00%) .          .          .                       None => return Ok(first),
      .          .          .          .                       Some(result) => result?,
      .          .          .          .                   };
      .          .          .          .           
      .          .          .          .                   let union = self.add_union()?;
      .          .          .          .                   let end = self.add_empty()?;
  2,156 ( 0.00%) .          .          .                   self.patch(union, first.start)?;
178,015 ( 0.05%) 708 ( 0.09%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (539x)
  2,156 ( 0.00%) .          .          .                   self.patch(first.end, end)?;
 27,501 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (539x)
  2,156 ( 0.00%) .          .          .                   self.patch(union, second.start)?;
 34,496 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (539x)
  2,156 ( 0.00%) .          .          .                   self.patch(second.end, end)?;
 27,527 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (539x)
 27,680 ( 0.01%) .          .          .                   for result in it {
      .          .          .          .                       let compiled = result?;
 22,144 ( 0.01%) .          .          .                       self.patch(union, compiled.start)?;
602,726 ( 0.18%) 1,063 ( 0.13%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (5,536x)
 27,680 ( 0.01%) .          .          .                       self.patch(compiled.end, end)?;
282,372 ( 0.08%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::patch (5,536x)
      .          .          .          .                   }
  2,156 ( 0.00%) .          .          .                   Ok(ThompsonRef { start: union, end })
  4,312 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given capture sub-expression. `expr` should be the
      .          .          .          .               /// sub-expression contained inside the capture. If "capture" states are
      .          .          .          .               /// enabled, then they are added as appropriate.
      .          .          .          .               ///
      .          .          .          .               /// This accepts the pieces of a capture instead of a `hir::Capture` so
      .          .          .          .               /// that it's easy to manufacture a "fake" group when necessary, e.g., for
      .          .          .          .               /// adding the entire pattern as if it were a group in order to create
      .          .          .          .               /// appropriate "capture" states in the NFA.
 17,171 ( 0.01%) .          .          .               fn c_cap(
      .          .          .          .                   &self,
      .          .          .          .                   index: u32,
      .          .          .          .                   name: Option<&str>,
      .          .          .          .                   expr: &Hir,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   match self.config.get_which_captures() {
      .          .          .          .                       // No capture states means we always skip them.
      .          .          .          .                       WhichCaptures::None => return self.c(expr),
      .          .          .          .                       // Implicit captures states means we only add when index==0 since
      .          .          .          .                       // index==0 implies the group is implicit.
      .          .          .          .                       WhichCaptures::Implicit if index > 0 => return self.c(expr),
      .          .          .          .                       _ => {}
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   let start = self.add_capture_start(index, name)?;
  2,322 ( 0.00%) .          .          .                   let inner = self.c(expr)?;
39,620,899 (11.90%) 107,700 (13.30%) 75 (24.92%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (81x)
      .          .          .          .                   let end = self.add_capture_end(index)?;
      .          .          .          .                   self.patch(start, inner.start)?;
      .          .          .          .                   self.patch(inner.end, end)?;
  2,322 ( 0.00%) .          .          .                   Ok(ThompsonRef { start, end })
 14,823 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given repetition expression. This handles all types of
      .          .          .          .               /// repetitions and greediness.
      .          .          .          .               fn c_repetition(
      .          .          .          .                   &self,
      .          .          .          .                   rep: &hir::Repetition,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
 38,792 ( 0.01%) .          .          .                   match (rep.min, rep.max) {
  3,284 ( 0.00%) .          .          .                       (0, Some(1)) => self.c_zero_or_one(&rep.sub, rep.greedy),
  1,976 ( 0.00%) .          .          .                       (min, None) => self.c_at_least(&rep.sub, rep.greedy, min),
1,164,077 ( 0.35%) 764 ( 0.09%) 2 ( 0.66%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least (142x)
798,648 ( 0.24%) 54 ( 0.01%) 1 ( 0.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_at_least'2 (10x)
    688 ( 0.00%) .          .          .                       (min, Some(max)) if min == max => self.c_exactly(&rep.sub, min),
  1,608 ( 0.00%) .          .          .                       (min, Some(max)) => self.c_bounded(&rep.sub, rep.greedy, min, max),
691,299 ( 0.21%) 2,005 ( 0.25%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_bounded (134x)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given expression such that it matches at least `min` times,
      .          .          .          .               /// but no more than `max` times.
      .          .          .          .               ///
      .          .          .          .               /// When `greedy` is true, then the preference is for the expression to
      .          .          .          .               /// match as much as possible. Otherwise, it will match as little as
      .          .          .          .               /// possible.
  1,742 ( 0.00%) .          .          .               fn c_bounded(
      .          .          .          .                   &self,
      .          .          .          .                   expr: &Hir,
      .          .          .          .                   greedy: bool,
      .          .          .          .                   min: u32,
      .          .          .          .                   max: u32,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   let prefix = self.c_exactly(expr, min)?;
    268 ( 0.00%) .          .          .                   if min == max {
      .          .          .          .                       return Ok(prefix);
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // It is tempting here to compile the rest here as a concatenation
      .          .          .          .                   // of zero-or-one matches. i.e., for `a{2,5}`, compile it as if it
      .          .          .          .                   // were `aaa?a?a?`. The problem here is that it leads to this program:
      .          .          .          .                   //
      .          .          .          .                   //     >000000: 61 => 01
-- line 1178 ----------------------------------------
-- line 1198 ----------------------------------------
      .          .          .          .                   //      000006: union(07, 08)
      .          .          .          .                   //      000007: 61 => 08
      .          .          .          .                   //      000008: MATCH
      .          .          .          .                   //
      .          .          .          .                   // So that the epsilon closure of state 2 is now just 3 and 8.
      .          .          .          .                   let empty = self.add_empty()?;
      .          .          .          .                   let mut prev_end = prefix.end;
      .          .          .          .                   for _ in min..max {
  1,052 ( 0.00%) .          .          .                       let union = if greedy {
      .          .          .          .                           self.add_union()
      .          .          .          .                       } else {
      .          .          .          .                           self.add_union_reverse()
      .          .          .          .                       }?;
  2,104 ( 0.00%) .          .          .                       let compiled = self.c(expr)?;
264,671 ( 0.08%) 901 ( 0.11%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (526x)
      .          .          .          .                       self.patch(prev_end, union)?;
      .          .          .          .                       self.patch(union, compiled.start)?;
      .          .          .          .                       self.patch(union, empty)?;
      .          .          .          .                       prev_end = compiled.end;
      .          .          .          .                   }
      .          .          .          .                   self.patch(prev_end, empty)?;
    402 ( 0.00%) .          .          .                   Ok(ThompsonRef { start: prefix.start, end: empty })
  1,206 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given expression such that it may be matched `n` or more
      .          .          .          .               /// times, where `n` can be any integer. (Although a particularly large
      .          .          .          .               /// integer is likely to run afoul of any configured size limits.)
      .          .          .          .               ///
      .          .          .          .               /// When `greedy` is true, then the preference is for the expression to
      .          .          .          .               /// match as much as possible. Otherwise, it will match as little as
      .          .          .          .               /// possible.
  2,620 ( 0.00%) .          .          .               fn c_at_least(
      .          .          .          .                   &self,
      .          .          .          .                   expr: &Hir,
      .          .          .          .                   greedy: bool,
      .          .          .          .                   n: u32,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
    812 ( 0.00%) .          .          .                   if n == 0 {
      .          .          .          .                       // When the expression cannot match the empty string, then we
      .          .          .          .                       // can get away with something much simpler: just one 'alt'
      .          .          .          .                       // instruction that optionally repeats itself. But if the expr
      .          .          .          .                       // can match the empty string... see below.
    576 ( 0.00%) .          .          .                       if expr.properties().minimum_len().map_or(false, |len| len > 0) {
    288 ( 0.00%) .          .          .                           let union = if greedy {
      .          .          .          .                               self.add_union()
      .          .          .          .                           } else {
      .          .          .          .                               self.add_union_reverse()
      .          .          .          .                           }?;
    288 ( 0.00%) .          .          .                           let compiled = self.c(expr)?;
 66,142 ( 0.02%) 80 ( 0.01%) 1 ( 0.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (34x)
 29,920 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c (110x)
      .          .          .          .                           self.patch(union, compiled.start)?;
      .          .          .          .                           self.patch(compiled.end, union)?;
    432 ( 0.00%) .          .          .                           return Ok(ThompsonRef { start: union, end: union });
      .          .          .          .                       }
      .          .          .          .           
      .          .          .          .                       // What's going on here? Shouldn't x* be simpler than this? It
      .          .          .          .                       // turns out that when implementing leftmost-first (Perl-like)
      .          .          .          .                       // match semantics, x* results in an incorrect preference order
      .          .          .          .                       // when computing the transitive closure of states if and only if
      .          .          .          .                       // 'x' can match the empty string. So instead, we compile x* as
      .          .          .          .                       // (x+)?, which preserves the correct preference order.
-- line 1256 ----------------------------------------
-- line 1270 ----------------------------------------
      .          .          .          .                       } else {
      .          .          .          .                           self.add_union_reverse()
      .          .          .          .                       }?;
      .          .          .          .                       let empty = self.add_empty()?;
      .          .          .          .                       self.patch(question, compiled.start)?;
      .          .          .          .                       self.patch(question, empty)?;
      .          .          .          .                       self.patch(plus, empty)?;
      .          .          .          .                       Ok(ThompsonRef { start: question, end: empty })
    262 ( 0.00%) .          .          .                   } else if n == 1 {
    236 ( 0.00%) .          .          .                       let compiled = self.c(expr)?;
1,027,855 ( 0.31%) 468 ( 0.06%) 1 ( 0.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (108x)
    236 ( 0.00%) .          .          .                       let union = if greedy {
      .          .          .          .                           self.add_union()
      .          .          .          .                       } else {
      .          .          .          .                           self.add_union_reverse()
      .          .          .          .                       }?;
      .          .          .          .                       self.patch(compiled.end, union)?;
      .          .          .          .                       self.patch(union, compiled.start)?;
    354 ( 0.00%) .          .          .                       Ok(ThompsonRef { start: compiled.start, end: union })
      .          .          .          .                   } else {
      .          .          .          .                       let prefix = self.c_exactly(expr, n - 1)?;
      .          .          .          .                       let last = self.c(expr)?;
      .          .          .          .                       let union = if greedy {
      .          .          .          .                           self.add_union()
      .          .          .          .                       } else {
      .          .          .          .                           self.add_union_reverse()
      .          .          .          .                       }?;
      .          .          .          .                       self.patch(prefix.end, last.start)?;
      .          .          .          .                       self.patch(last.end, union)?;
      .          .          .          .                       self.patch(union, last.start)?;
      .          .          .          .                       Ok(ThompsonRef { start: prefix.start, end: union })
      .          .          .          .                   }
  2,358 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given expression such that it may be matched zero or one
      .          .          .          .               /// times.
      .          .          .          .               ///
      .          .          .          .               /// When `greedy` is true, then the preference is for the expression to
      .          .          .          .               /// match as much as possible. Otherwise, it will match as little as
      .          .          .          .               /// possible.
      .          .          .          .               fn c_zero_or_one(
      .          .          .          .                   &self,
      .          .          .          .                   expr: &Hir,
      .          .          .          .                   greedy: bool,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   let union =
 22,988 ( 0.01%) .          .          .                       if greedy { self.add_union() } else { self.add_union_reverse() }?;
     48 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (1x)
  9,852 ( 0.00%) .          .          .                   let compiled = self.c(expr)?;
    587 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c'2 (1x)
      .          .          .          .                   let empty = self.add_empty()?;
      .          .          .          .                   self.patch(union, compiled.start)?;
      .          .          .          .                   self.patch(union, empty)?;
      .          .          .          .                   self.patch(compiled.end, empty)?;
  9,852 ( 0.00%) .          .          .                   Ok(ThompsonRef { start: union, end: empty })
  3,284 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given HIR expression exactly `n` times.
      .          .          .          .               fn c_exactly(
      .          .          .          .                   &self,
      .          .          .          .                   expr: &Hir,
      .          .          .          .                   n: u32,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   let it = (0..n).map(|_| self.c(expr));
    764 ( 0.00%) .          .          .                   self.c_concat(it)
234,769 ( 0.07%) 606 ( 0.07%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Compiler::c_concat (210x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given byte oriented character class.
      .          .          .          .               ///
      .          .          .          .               /// This uses "sparse" states to represent an alternation between ranges in
      .          .          .          .               /// this character class. We can use "sparse" states instead of stitching
      .          .          .          .               /// together a "union" state because all ranges in a character class have
      .          .          .          .               /// equal priority *and* are non-overlapping (thus, only one can match, so
-- line 1339 ----------------------------------------
-- line 1342 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// This routine compiles an empty character class into a "fail" state.
      .          .          .          .               fn c_byte_class(
      .          .          .          .                   &self,
      .          .          .          .                   cls: &hir::ClassBytes,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   let end = self.add_empty()?;
      .          .          .          .                   let mut trans = Vec::with_capacity(cls.ranges().len());
  1,100 ( 0.00%) .          .          .                   for r in cls.iter() {
  1,210 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassBytesIter as core::iter::traits::iterator::Iterator>::next (220x)
    110 ( 0.00%) .          .          .                       trans.push(Transition {
      .          .          .          .                           start: r.start(),
      .          .          .          .                           end: r.end(),
      .          .          .          .                           next: end,
      .          .          .          .                       });
      .          .          .          .                   }
    330 ( 0.00%) .          .          .                   Ok(ThompsonRef { start: self.add_sparse(trans)?, end })
    110 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given Unicode character class.
      .          .          .          .               ///
      .          .          .          .               /// This routine specifically tries to use various types of compression,
      .          .          .          .               /// since UTF-8 automata of large classes can get quite large. The specific
      .          .          .          .               /// type of compression used depends on forward vs reverse compilation, and
      .          .          .          .               /// whether NFA shrinking is enabled or not.
      .          .          .          .               ///
-- line 1366 ----------------------------------------
-- line 1372 ----------------------------------------
      .          .          .          .               /// This routine compiles an empty character class into a "fail" state.
      .          .          .          .               fn c_unicode_class(
      .          .          .          .                   &self,
      .          .          .          .                   cls: &hir::ClassUnicode,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   // If all we have are ASCII ranges wrapped in a Unicode package, then
      .          .          .          .                   // there is zero reason to bring out the big guns. We can fit all ASCII
      .          .          .          .                   // ranges within a single sparse state.
 16,893 ( 0.01%) .          .          .                   if cls.is_ascii() {
     26 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:regex_syntax::hir::ClassUnicode::is_ascii (2x)
      .          .          .          .                       let end = self.add_empty()?;
      .          .          .          .                       let mut trans = Vec::with_capacity(cls.ranges().len());
 68,968 ( 0.02%) .          .          .                       for r in cls.iter() {
     58 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next (10x)
      .          .          .          .                           // The unwraps below are OK because we've verified that this
      .          .          .          .                           // class only contains ASCII codepoints.
 36,700 ( 0.01%) .          .          .                           trans.push(Transition {
      .          .          .          .                               // FIXME(1.59): use the 'TryFrom<char> for u8' impl.
      .          .          .          .                               start: u8::try_from(u32::from(r.start())).unwrap(),
      .          .          .          .                               end: u8::try_from(u32::from(r.end())).unwrap(),
      .          .          .          .                               next: end,
      .          .          .          .                           });
      .          .          .          .                       }
 21,512 ( 0.01%) .          .          .                       Ok(ThompsonRef { start: self.add_sparse(trans)?, end })
    254 ( 0.00%) .          .          .                   } else if self.is_reverse() {
    254 ( 0.00%) .          .          .                       if !self.config.get_shrink() {
      .          .          .          .                           // When we don't want to spend the extra time shrinking, we
      .          .          .          .                           // compile the UTF-8 automaton in reverse using something like
      .          .          .          .                           // the "naive" approach, but will attempt to re-use common
      .          .          .          .                           // suffixes.
    254 ( 0.00%) .          .          .                           self.c_unicode_class_reverse_with_suffix(cls)
      .          .          .          .                       } else {
      .          .          .          .                           // When we want to shrink our NFA for reverse UTF-8 automata,
      .          .          .          .                           // we cannot feed UTF-8 sequences directly to the UTF-8
      .          .          .          .                           // compiler, since the UTF-8 compiler requires all sequences
      .          .          .          .                           // to be lexicographically sorted. Instead, we organize our
      .          .          .          .                           // sequences into a range trie, which can then output our
      .          .          .          .                           // sequences in the correct order. Unfortunately, building the
      .          .          .          .                           // range trie is fairly expensive (but not nearly as expensive
-- line 1408 ----------------------------------------
-- line 1432 ----------------------------------------
      .          .          .          .                   } else {
      .          .          .          .                       // In the forward direction, we always shrink our UTF-8 automata
      .          .          .          .                       // because we can stream it right into the UTF-8 compiler. There
      .          .          .          .                       // is almost no downside (in either memory or time) to using this
      .          .          .          .                       // approach.
      .          .          .          .                       let mut builder = self.builder.borrow_mut();
      .          .          .          .                       let mut utf8_state = self.utf8_state.borrow_mut();
      .          .          .          .                       let mut utf8c =
    630 ( 0.00%) .          .          .                           Utf8Compiler::new(&mut *builder, &mut *utf8_state)?;
4,772,349 ( 1.43%) 662 ( 0.08%) 38 (12.62%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::new (126x)
  3,520 ( 0.00%) .          .          .                       for rng in cls.iter() {
  4,776 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next (817x)
 18,212 ( 0.01%) .          .          .                           for seq in Utf8Sequences::new(rng.start(), rng.end()) {
218,118 ( 0.07%) 101 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/utf8.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next (1,870x)
 84,427 ( 0.03%) 320 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/utf8.rs:regex_syntax::utf8::Utf8Sequences::new (691x)
  4,716 ( 0.00%) .          .          .                               utf8c.add(seq.as_slice())?;
926,427 ( 0.28%) 1,443 ( 0.18%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::add (1,179x)
      .          .          .          .                           }
      .          .          .          .                       }
    126 ( 0.00%) .          .          .                       utf8c.finish()
204,016 ( 0.06%) 394 ( 0.05%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::finish (126x)
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // For reference, the code below is the "naive" version of compiling a
      .          .          .          .                   // UTF-8 automaton. It is deliciously simple (and works for both the
      .          .          .          .                   // forward and reverse cases), but will unfortunately produce very
      .          .          .          .                   // large NFAs. When compiling a forward automaton, the size difference
      .          .          .          .                   // can sometimes be an order of magnitude. For example, the '\w' regex
      .          .          .          .                   // will generate about ~3000 NFA states using the naive approach below,
-- line 1454 ----------------------------------------
-- line 1510 ----------------------------------------
      .          .          .          .                   &self,
      .          .          .          .                   cls: &hir::ClassUnicode,
      .          .          .          .               ) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   // N.B. It would likely be better to cache common *prefixes* in the
      .          .          .          .                   // reverse direction, but it's not quite clear how to do that. The
      .          .          .          .                   // advantage of caching suffixes is that it does give us a win, and
      .          .          .          .                   // has a very small additional overhead.
      .          .          .          .                   let mut cache = self.utf8_suffix.borrow_mut();
    127 ( 0.00%) .          .          .                   cache.clear();
392,673 ( 0.12%) 364 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/map.rs:regex_automata::nfa::thompson::map::Utf8SuffixMap::clear (127x)
      .          .          .          .           
      .          .          .          .                   let union = self.add_union()?;
      .          .          .          .                   let alt_end = self.add_empty()?;
  5,186 ( 0.00%) .          .          .                   for urng in cls.iter() {
  4,805 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<regex_syntax::hir::ClassUnicodeIter as core::iter::traits::iterator::Iterator>::next (822x)
 17,669 ( 0.01%) .          .          .                       for seq in Utf8Sequences::new(urng.start(), urng.end()) {
224,219 ( 0.07%) 128 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/utf8.rs:<regex_syntax::utf8::Utf8Sequences as core::iter::traits::iterator::Iterator>::next (1,886x)
 61,674 ( 0.02%) 98 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/utf8.rs:regex_syntax::utf8::Utf8Sequences::new (695x)
      .          .          .          .                           let mut end = alt_end;
      .          .          .          .                           for brng in seq.as_slice() {
      .          .          .          .                               let key = Utf8SuffixKey {
      .          .          .          .                                   from: end,
      .          .          .          .                                   start: brng.start,
      .          .          .          .                                   end: brng.end,
      .          .          .          .                               };
      .          .          .          .                               let hash = cache.hash(&key);
      .          .          .          .                               if let Some(id) = cache.get(&key, hash) {
      .          .          .          .                                   end = id;
      .          .          .          .                                   continue;
      .          .          .          .                               }
      .          .          .          .           
  5,596 ( 0.00%) .          .          .                               let compiled = self.c_range(brng.start, brng.end)?;
      .          .          .          .                               self.patch(compiled.end, end)?;
      .          .          .          .                               end = compiled.start;
 11,192 ( 0.00%) .          .          .                               cache.set(key, hash, end);
      .          .          .          .                           }
      .          .          .          .                           self.patch(union, end)?;
      .          .          .          .                       }
      .          .          .          .                   }
    508 ( 0.00%) .          .          .                   Ok(ThompsonRef { start: union, end: alt_end })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given HIR look-around assertion to an NFA look-around
      .          .          .          .               /// assertion.
      .          .          .          .               fn c_look(&self, anchor: &hir::Look) -> Result<ThompsonRef, BuildError> {
    735 ( 0.00%) .          .          .                   let look = match *anchor {
      .          .          .          .                       hir::Look::Start => Look::Start,
      .          .          .          .                       hir::Look::End => Look::End,
      .          .          .          .                       hir::Look::StartLF => Look::StartLF,
      .          .          .          .                       hir::Look::EndLF => Look::EndLF,
      .          .          .          .                       hir::Look::StartCRLF => Look::StartCRLF,
      .          .          .          .                       hir::Look::EndCRLF => Look::EndCRLF,
      .          .          .          .                       hir::Look::WordAscii => Look::WordAscii,
      .          .          .          .                       hir::Look::WordAsciiNegate => Look::WordAsciiNegate,
-- line 1559 ----------------------------------------
-- line 1565 ----------------------------------------
      .          .          .          .                       hir::Look::WordEndUnicode => Look::WordEndUnicode,
      .          .          .          .                       hir::Look::WordStartHalfAscii => Look::WordStartHalfAscii,
      .          .          .          .                       hir::Look::WordEndHalfAscii => Look::WordEndHalfAscii,
      .          .          .          .                       hir::Look::WordStartHalfUnicode => Look::WordStartHalfUnicode,
      .          .          .          .                       hir::Look::WordEndHalfUnicode => Look::WordEndHalfUnicode,
      .          .          .          .                   };
      .          .          .          .                   let id = self.add_look(look)?;
      .          .          .          .                   Ok(ThompsonRef { start: id, end: id })
    245 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile the given byte string to a concatenation of bytes.
      .          .          .          .               fn c_literal(&self, bytes: &[u8]) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   self.c_concat(bytes.iter().copied().map(|b| self.c_range(b, b)))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile a "range" state with one transition that may only be followed
      .          .          .          .               /// if the input byte is in the (inclusive) range given.
      .          .          .          .               ///
      .          .          .          .               /// Both the `start` and `end` locations point to the state created.
      .          .          .          .               /// Callers will likely want to keep the `start`, but patch the `end` to
      .          .          .          .               /// point to some other state.
      .          .          .          .               fn c_range(&self, start: u8, end: u8) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   let id = self.add_range(start, end)?;
      .          .          .          .                   Ok(ThompsonRef { start: id, end: id })
 10,211 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compile an "empty" state with one unconditional epsilon transition.
      .          .          .          .               ///
      .          .          .          .               /// Both the `start` and `end` locations point to the state created.
      .          .          .          .               /// Callers will likely want to keep the `start`, but patch the `end` to
      .          .          .          .               /// point to some other state.
      .          .          .          .               fn c_empty(&self) -> Result<ThompsonRef, BuildError> {
      .          .          .          .                   let id = self.add_empty()?;
-- line 1597 ----------------------------------------
-- line 1606 ----------------------------------------
      .          .          .          .           
      .          .          .          .               // The below helpers are meant to be simple wrappers around the
      .          .          .          .               // corresponding Builder methods. For the most part, they let us write
      .          .          .          .               // 'self.add_foo()' instead of 'self.builder.borrow_mut().add_foo()', where
      .          .          .          .               // the latter is a mouthful. Some of the methods do inject a little bit
      .          .          .          .               // of extra logic. e.g., Flipping look-around operators when compiling in
      .          .          .          .               // reverse mode.
      .          .          .          .           
 39,684 ( 0.01%) .          .          .               fn patch(&self, from: StateID, to: StateID) -> Result<(), BuildError> {
208,361 ( 0.06%) .          .          .                   self.builder.borrow_mut().patch(from, to)
  5,570 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::patch (162x)
 66,140 ( 0.02%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn start_pattern(&self) -> Result<PatternID, BuildError> {
      .          .          .          .                   self.builder.borrow_mut().start_pattern()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn finish_pattern(
      .          .          .          .                   &self,
      .          .          .          .                   start_id: StateID,
-- line 1624 ----------------------------------------
-- line 1626 ----------------------------------------
      .          .          .          .                   self.builder.borrow_mut().finish_pattern(start_id)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_empty(&self) -> Result<StateID, BuildError> {
      .          .          .          .                   self.builder.borrow_mut().add_empty()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_range(&self, start: u8, end: u8) -> Result<StateID, BuildError> {
 49,675 ( 0.01%) .          .          .                   self.builder.borrow_mut().add_range(Transition {
      .          .          .          .                       start,
      .          .          .          .                       end,
      .          .          .          .                       next: StateID::ZERO,
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_sparse(
      .          .          .          .                   &self,
      .          .          .          .                   ranges: Vec<Transition>,
      .          .          .          .               ) -> Result<StateID, BuildError> {
      .          .          .          .                   self.builder.borrow_mut().add_sparse(ranges)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_look(&self, mut look: Look) -> Result<StateID, BuildError> {
    246 ( 0.00%) .          .          .                   if self.is_reverse() {
      .          .          .          .                       look = look.reversed();
      .          .          .          .                   }
      .          .          .          .                   self.builder.borrow_mut().add_look(StateID::ZERO, look)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_union(&self) -> Result<StateID, BuildError> {
      .          .          .          .                   self.builder.borrow_mut().add_union(vec![])
      .          .          .          .               }
-- line 1657 ----------------------------------------
-- line 1661 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_capture_start(
      .          .          .          .                   &self,
      .          .          .          .                   capture_index: u32,
      .          .          .          .                   name: Option<&str>,
      .          .          .          .               ) -> Result<StateID, BuildError> {
      .          .          .          .                   let name = name.map(Arc::from);
  4,644 ( 0.00%) .          .          .                   self.builder.borrow_mut().add_capture_start(
 41,168 ( 0.01%) 80 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add_capture_start (81x)
      .          .          .          .                       StateID::ZERO,
      .          .          .          .                       capture_index,
      .          .          .          .                       name,
      .          .          .          .                   )
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_capture_end(
      .          .          .          .                   &self,
-- line 1677 ----------------------------------------
-- line 1748 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Utf8State {
      .          .          .          .               fn new() -> Utf8State {
      .          .          .          .                   Utf8State { compiled: Utf8BoundedMap::new(10_000), uncompiled: vec![] }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn clear(&mut self) {
    252 ( 0.00%) .          .          .                   self.compiled.clear();
4,741,125 ( 1.42%) 626 ( 0.08%) 38 (12.62%) 1 ( 0.07%)  => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/map.rs:regex_automata::nfa::thompson::map::Utf8BoundedMap::clear (126x)
      .          .          .          .                   self.uncompiled.clear();
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'a> Utf8Compiler<'a> {
  1,386 ( 0.00%) .          .          .               fn new(
      .          .          .          .                   builder: &'a mut Builder,
      .          .          .          .                   state: &'a mut Utf8State,
      .          .          .          .               ) -> Result<Utf8Compiler<'a>, BuildError> {
      .          .          .          .                   let target = builder.add_empty()?;
      .          .          .          .                   state.clear();
      .          .          .          .                   let mut utf8c = Utf8Compiler { builder, state, target };
      .          .          .          .                   utf8c.add_empty();
    630 ( 0.00%) .          .          .                   Ok(utf8c)
  1,008 ( 0.00%) .          .          .               }
      .          .          .          .           
  1,008 ( 0.00%) .          .          .               fn finish(&mut self) -> Result<ThompsonRef, BuildError> {
    252 ( 0.00%) .          .          .                   self.compile_from(0)?;
150,577 ( 0.05%) 296 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from (126x)
    126 ( 0.00%) .          .          .                   let node = self.pop_root();
    504 ( 0.00%) .          .          .                   let start = self.compile(node)?;
 48,021 ( 0.01%) 98 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (126x)
    504 ( 0.00%) .          .          .                   Ok(ThompsonRef { start, end: self.target })
    756 ( 0.00%) .          .          .               }
      .          .          .          .           
 11,790 ( 0.00%) .          .          .               fn add(&mut self, ranges: &[Utf8Range]) -> Result<(), BuildError> {
      .          .          .          .                   let prefix_len = ranges
      .          .          .          .                       .iter()
  1,179 ( 0.00%) .          .          .                       .zip(&self.state.uncompiled)
      .          .          .          .                       .take_while(|&(range, node)| {
      .          .          .          .                           node.last.as_ref().map_or(false, |t| {
      .          .          .          .                               (t.start, t.end) == (range.start, range.end)
      .          .          .          .                           })
      .          .          .          .                       })
      .          .          .          .                       .count();
  2,358 ( 0.00%) .          .          .                   assert!(prefix_len < ranges.len());
  2,358 ( 0.00%) .          .          .                   self.compile_from(prefix_len)?;
810,871 ( 0.24%) 1,443 ( 0.18%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile_from (1,179x)
  1,179 ( 0.00%) .          .          .                   self.add_suffix(&ranges[prefix_len..]);
  3,537 ( 0.00%) .          .          .                   Ok(())
 10,611 ( 0.00%) .          .          .               }
      .          .          .          .           
 13,050 ( 0.00%) .          .          .               fn compile_from(&mut self, from: usize) -> Result<(), BuildError> {
  1,305 ( 0.00%) .          .          .                   let mut next = self.target;
  5,786 ( 0.00%) .          .          .                   while from + 1 < self.state.uncompiled.len() {
      .          .          .          .                       let node = self.pop_freeze(next);
  7,940 ( 0.00%) .          .          .                       next = self.compile(node)?;
442,320 ( 0.13%) 860 ( 0.11%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs:regex_automata::nfa::thompson::compiler::Utf8Compiler::compile (1,588x)
      .          .          .          .                   }
      .          .          .          .                   self.top_last_freeze(next);
  2,610 ( 0.00%) .          .          .                   Ok(())
 10,440 ( 0.00%) .          .          .               }
      .          .          .          .           
 15,426 ( 0.00%) .          .          .               fn compile(
      .          .          .          .                   &mut self,
      .          .          .          .                   node: Vec<Transition>,
      .          .          .          .               ) -> Result<StateID, BuildError> {
      .          .          .          .                   let hash = self.state.compiled.hash(&node);
      .          .          .          .                   if let Some(id) = self.state.compiled.get(&node, hash) {
  1,882 ( 0.00%) .          .          .                       return Ok(id);
      .          .          .          .                   }
      .          .          .          .                   let id = self.builder.add_sparse(node.clone())?;
      .          .          .          .                   self.state.compiled.set(node, hash, id);
  3,092 ( 0.00%) .          .          .                   Ok(id)
  6,184 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_suffix(&mut self, ranges: &[Utf8Range]) {
      .          .          .          .                   assert!(!ranges.is_empty());
      .          .          .          .                   let last = self
      .          .          .          .                       .state
      .          .          .          .                       .uncompiled
      .          .          .          .                       .len()
      .          .          .          .                       .checked_sub(1)
      .          .          .          .                       .expect("non-empty nodes");
  2,358 ( 0.00%) .          .          .                   assert!(self.state.uncompiled[last].last.is_none());
  2,358 ( 0.00%) .          .          .                   self.state.uncompiled[last].last = Some(Utf8LastTransition {
  1,179 ( 0.00%) .          .          .                       start: ranges[0].start,
      .          .          .          .                       end: ranges[0].end,
      .          .          .          .                   });
  3,344 ( 0.00%) .          .          .                   for r in &ranges[1..] {
      .          .          .          .                       self.state.uncompiled.push(Utf8Node {
      .          .          .          .                           trans: vec![],
  3,176 ( 0.00%) .          .          .                           last: Some(Utf8LastTransition { start: r.start, end: r.end }),
      .          .          .          .                       });
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn add_empty(&mut self) {
     67 ( 0.00%) .          .          .                   self.state.uncompiled.push(Utf8Node { trans: vec![], last: None });
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn pop_freeze(&mut self, next: StateID) -> Vec<Transition> {
      .          .          .          .                   let mut uncompiled = self.state.uncompiled.pop().unwrap();
      .          .          .          .                   uncompiled.set_last_transition(next);
  9,528 ( 0.00%) .          .          .                   uncompiled.trans
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn pop_root(&mut self) -> Vec<Transition> {
    252 ( 0.00%) .          .          .                   assert_eq!(self.state.uncompiled.len(), 1);
    252 ( 0.00%) .          .          .                   assert!(self.state.uncompiled[0].last.is_none());
      .          .          .          .                   self.state.uncompiled.pop().expect("non-empty nodes").trans
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn top_last_freeze(&mut self, next: StateID) {
      .          .          .          .                   let last = self
      .          .          .          .                       .state
      .          .          .          .                       .uncompiled
      .          .          .          .                       .len()
      .          .          .          .                       .checked_sub(1)
      .          .          .          .                       .expect("non-empty nodes");
  1,895 ( 0.00%) .          .          .                   self.state.uncompiled[last].set_last_transition(next);
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Utf8Node {
      .          .          .          .               fn set_last_transition(&mut self, next: StateID) {
  5,786 ( 0.00%) .          .          .                   if let Some(last) = self.last.take() {
  5,534 ( 0.00%) .          .          .                       self.trans.push(Transition {
      .          .          .          .                           start: last.start,
      .          .          .          .                           end: last.end,
      .          .          .          .                           next,
      .          .          .          .                       });
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
-- line 1878 ----------------------------------------

132,045 ( 0.04%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/compiler.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 61 ----------------------------------------
     .          .          .          .           pub struct Map<I, F> {
     .          .          .          .               // Used for `SplitWhitespace` and `SplitAsciiWhitespace` `as_str` methods
     .          .          .          .               pub(crate) iter: I,
     .          .          .          .               f: F,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<I, F> Map<I, F> {
     .          .          .          .               pub(in crate::iter) fn new(iter: I, f: F) -> Map<I, F> {
 4,679 ( 0.00%) .          .          .                   Map { iter, f }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               pub(crate) fn into_inner(self) -> I {
     .          .          .          .                   self.iter
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[stable(feature = "core_impl_debug", since = "1.9.0")]
-- line 77 ----------------------------------------
-- line 80 ----------------------------------------
     .          .          .          .                   f.debug_struct("Map").field("iter", &self.iter).finish()
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           fn map_fold<T, B, Acc>(
     .          .          .          .               mut f: impl FnMut(T) -> B,
     .          .          .          .               mut g: impl FnMut(Acc, B) -> Acc,
     .          .          .          .           ) -> impl FnMut(Acc, T) -> Acc {
 2,448 ( 0.00%) .          .          .               move |acc, elt| g(acc, f(elt))
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           fn map_try_fold<'a, T, B, Acc, R>(
     .          .          .          .               f: &'a mut impl FnMut(T) -> B,
     .          .          .          .               mut g: impl FnMut(Acc, B) -> R + 'a,
     .          .          .          .           ) -> impl FnMut(Acc, T) -> R + 'a {
     .          .          .          .               move |acc, elt| g(acc, f(elt))
     .          .          .          .           }
-- line 96 ----------------------------------------
-- line 98 ----------------------------------------
     .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .           impl<B, I: Iterator, F> Iterator for Map<I, F>
     .          .          .          .           where
     .          .          .          .               F: FnMut(I::Item) -> B,
     .          .          .          .           {
     .          .          .          .               type Item = B;
     .          .          .          .           
     .          .          .          .               #[inline]
 2,477 ( 0.00%) .          .          .               fn next(&mut self) -> Option<B> {
14,643 ( 0.00%) .          .          .                   self.iter.next().map(&mut self.f)
    94 ( 0.00%) .          .          .           => /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/env.rs:<std::env::ArgsOs as core::iter::traits::iterator::Iterator>::next (7x)
 2,827 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     9 ( 0.00%) .          .          .               fn size_hint(&self) -> (usize, Option<usize>) {
     2 ( 0.00%) .          .          .                   self.iter.size_hint()
    13 ( 0.00%) .          .          .           => /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/env.rs:<std::env::ArgsOs as core::iter::traits::iterator::Iterator>::size_hint (1x)
     9 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               fn try_fold<Acc, G, R>(&mut self, init: Acc, g: G) -> R
     .          .          .          .               where
     .          .          .          .                   Self: Sized,
     .          .          .          .                   G: FnMut(Acc, Self::Item) -> R,
     .          .          .          .                   R: Try<Output = Acc>,
     .          .          .          .               {
     .          .          .          .                   self.iter.try_fold(init, map_try_fold(&mut self.f, g))
     .          .          .          .               }
     .          .          .          .           
   577 ( 0.00%) .          .          .               fn fold<Acc, G>(self, init: Acc, g: G) -> Acc
     .          .          .          .               where
     .          .          .          .                   G: FnMut(Acc, Self::Item) -> Acc,
     .          .          .          .               {
    81 ( 0.00%) .          .          .                   self.iter.fold(init, map_fold(self.f, g))
   660 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> B
     .          .          .          .               where
     .          .          .          .                   Self: TrustedRandomAccessNoCoerce,
     .          .          .          .               {
     .          .          .          .                   // SAFETY: the caller must uphold the contract for
     .          .          .          .                   // `Iterator::__iterator_get_unchecked`.
-- line 137 ----------------------------------------
-- line 141 ----------------------------------------
     .          .          .          .           
     .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .           impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F>
     .          .          .          .           where
     .          .          .          .               F: FnMut(I::Item) -> B,
     .          .          .          .           {
     .          .          .          .               #[inline]
     .          .          .          .               fn next_back(&mut self) -> Option<B> {
14,627 ( 0.00%) .          .          .                   self.iter.next_back().map(&mut self.f)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               fn try_rfold<Acc, G, R>(&mut self, init: Acc, g: G) -> R
     .          .          .          .               where
     .          .          .          .                   Self: Sized,
     .          .          .          .                   G: FnMut(Acc, Self::Item) -> R,
     .          .          .          .                   R: Try<Output = Acc>,
     .          .          .          .               {
-- line 157 ----------------------------------------

   369 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/hash/random.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 61 ----------------------------------------
     .          .          .          .                   // many hash maps are created on a thread. To solve this performance
     .          .          .          .                   // trap we cache the first set of randomly generated keys per-thread.
     .          .          .          .                   //
     .          .          .          .                   // Later in #36481 it was discovered that exposing a deterministic
     .          .          .          .                   // iteration order allows a form of DOS attack. To counter that we
     .          .          .          .                   // increment one of the seeds on every RandomState creation, giving
     .          .          .          .                   // every corresponding HashMap a different iteration order.
     .          .          .          .                   thread_local!(static KEYS: Cell<(u64, u64)> = {
     6 ( 0.00%) .          .          .                       Cell::new(hashmap_random_keys())
   191 ( 0.00%) 2 ( 0.00%) 2 ( 0.66%) .           => /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/random/linux.rs:std::sys::random::linux::hashmap_random_keys (2x)
     .          .          .          .                   });
     .          .          .          .           
     .          .          .          .                   KEYS.with(|keys| {
     .          .          .          .                       let (k0, k1) = keys.get();
     .          .          .          .                       keys.set((k0.wrapping_add(1), k1));
     .          .          .          .                       RandomState { k0, k1 }
     .          .          .          .                   })
     .          .          .          .               }
-- line 77 ----------------------------------------
-- line 78 ----------------------------------------
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[stable(feature = "hashmap_build_hasher", since = "1.7.0")]
     .          .          .          .           impl BuildHasher for RandomState {
     .          .          .          .               type Hasher = DefaultHasher;
     .          .          .          .               #[inline]
     .          .          .          .               #[allow(deprecated)]
     .          .          .          .               fn build_hasher(&self) -> DefaultHasher {
17,076 ( 0.01%) .          .          .                   DefaultHasher(SipHasher13::new_with_keys(self.k0, self.k1))
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// The default [`Hasher`] used by [`RandomState`].
     .          .          .          .           ///
     .          .          .          .           /// The internal algorithm is not specified, and so it and its hashes should
     .          .          .          .           /// not be relied upon over releases.
     .          .          .          .           #[allow(deprecated)]
-- line 94 ----------------------------------------

   570 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/hash/random.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/alphabet.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 96 ----------------------------------------
        .          .          .          .               /// All possible byte values are legal. However, when creating a haystack
        .          .          .          .               /// unit for a specific DFA, one should be careful to only construct units
        .          .          .          .               /// that are in that DFA's alphabet. Namely, one way to compact a DFA's
        .          .          .          .               /// in-memory representation is to collapse its transitions to a set of
        .          .          .          .               /// equivalence classes into a set of all possible byte values. If a DFA
        .          .          .          .               /// uses equivalence classes instead of byte values, then the byte given
        .          .          .          .               /// here should be the equivalence class.
        .          .          .          .               pub fn u8(byte: u8) -> Unit {
      218 ( 0.00%) .          .          .                   Unit(UnitKind::U8(byte))
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Create a new "end of input" haystack unit.
        .          .          .          .               ///
        .          .          .          .               /// The value given is the sentinel value used by this unit to represent
        .          .          .          .               /// the "end of input." The value should be the total number of equivalence
        .          .          .          .               /// classes in the corresponding alphabet. Its maximum value is `256`,
        .          .          .          .               /// which occurs when every byte is its own equivalence class.
-- line 112 ----------------------------------------
-- line 115 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// This panics when `num_byte_equiv_classes` is greater than `256`.
        .          .          .          .               pub fn eoi(num_byte_equiv_classes: usize) -> Unit {
        .          .          .          .                   assert!(
        .          .          .          .                       num_byte_equiv_classes <= 256,
        .          .          .          .                       "max number of byte-based equivalent classes is 256, but got \
        .          .          .          .                        {num_byte_equiv_classes}",
        .          .          .          .                   );
      702 ( 0.00%) .          .          .                   Unit(UnitKind::EOI(u16::try_from(num_byte_equiv_classes).unwrap()))
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// If this unit is not an "end of input" sentinel, then returns its
        .          .          .          .               /// underlying byte value. Otherwise return `None`.
        .          .          .          .               pub fn as_u8(self) -> Option<u8> {
        .          .          .          .                   match self.0 {
        .          .          .          .                       UnitKind::U8(b) => Some(b),
        .          .          .          .                       UnitKind::EOI(_) => None,
-- line 131 ----------------------------------------
-- line 206 ----------------------------------------
        .          .          .          .           /// let classes = nfa.byte_classes();
        .          .          .          .           /// // 'a' and 'z' are in the same class for this regex.
        .          .          .          .           /// assert_eq!(classes.get(b'a'), classes.get(b'z'));
        .          .          .          .           /// // But 'a' and 'A' are not.
        .          .          .          .           /// assert_ne!(classes.get(b'a'), classes.get(b'A'));
        .          .          .          .           ///
        .          .          .          .           /// # Ok::<(), Box<dyn std::error::Error>>(())
        .          .          .          .           /// ```
    2,754 ( 0.00%) .          .          .           #[derive(Clone, Copy)]
        .          .          .          .           pub struct ByteClasses([u8; 256]);
        .          .          .          .           
        .          .          .          .           impl ByteClasses {
        .          .          .          .               /// Creates a new set of equivalence classes where all bytes are mapped to
        .          .          .          .               /// the same class.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn empty() -> ByteClasses {
        .          .          .          .                   ByteClasses([0; 256])
-- line 222 ----------------------------------------
-- line 225 ----------------------------------------
        .          .          .          .               /// Creates a new set of equivalence classes where each byte belongs to
        .          .          .          .               /// its own equivalence class.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn singletons() -> ByteClasses {
        .          .          .          .                   let mut classes = ByteClasses::empty();
        .          .          .          .                   for b in 0..=255 {
        .          .          .          .                       classes.set(b, b);
        .          .          .          .                   }
    5,600 ( 0.00%) .          .          .                   classes
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Deserializes a byte class map from the given slice. If the slice is of
        .          .          .          .               /// insufficient length or otherwise contains an impossible mapping, then
        .          .          .          .               /// an error is returned. Upon success, the number of bytes read along with
        .          .          .          .               /// the map are returned. The number of bytes read is always a multiple of
        .          .          .          .               /// 8.
        .          .          .          .               pub(crate) fn from_bytes(
-- line 241 ----------------------------------------
-- line 281 ----------------------------------------
        .          .          .          .               /// Returns the total number of bytes written by `write_to`.
        .          .          .          .               pub(crate) fn write_to_len(&self) -> usize {
        .          .          .          .                   256
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Set the equivalence class for the given byte.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn set(&mut self, byte: u8, class: u8) {
   96,775 ( 0.03%) .          .          .                   self.0[usize::from(byte)] = class;
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Get the equivalence class for the given byte.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn get(&self, byte: u8) -> u8 {
  116,748 ( 0.04%) .          .          .                   self.0[usize::from(byte)]
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Get the equivalence class for the given haystack unit and return the
        .          .          .          .               /// class as a `usize`.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn get_by_unit(&self, unit: Unit) -> usize {
   45,613 ( 0.01%) .          .          .                   match unit.0 {
        .          .          .          .                       UnitKind::U8(b) => usize::from(self.get(b)),
        .          .          .          .                       UnitKind::EOI(b) => usize::from(b),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Create a unit that represents the "end of input" sentinel based on the
        .          .          .          .               /// number of equivalence classes.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn eoi(&self) -> Unit {
        .          .          .          .                   // The alphabet length already includes the EOI sentinel, hence why
        .          .          .          .                   // we subtract 1.
    1,053 ( 0.00%) .          .          .                   Unit::eoi(self.alphabet_len().checked_sub(1).unwrap())
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return the total number of elements in the alphabet represented by
        .          .          .          .               /// these equivalence classes. Equivalently, this returns the total number
        .          .          .          .               /// of equivalence classes.
        .          .          .          .               #[inline]
        .          .          .          .               pub fn alphabet_len(&self) -> usize {
        .          .          .          .                   // Add one since the number of equivalence classes is one bigger than
        .          .          .          .                   // the last one. But add another to account for the final EOI class
        .          .          .          .                   // that isn't explicitly represented.
      688 ( 0.00%) .          .          .                   usize::from(self.0[255]) + 1 + 1
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the stride, as a base-2 exponent, required for these
        .          .          .          .               /// equivalence classes.
        .          .          .          .               ///
        .          .          .          .               /// The stride is always the smallest power of 2 that is greater than or
        .          .          .          .               /// equal to the alphabet length, and the `stride2` returned here is the
        .          .          .          .               /// exponent applied to `2` to get the smallest power. This is done so that
-- line 333 ----------------------------------------
-- line 415 ----------------------------------------
        .          .          .          .               ) -> ByteClassRepresentatives<'_> {
        .          .          .          .                   use core::ops::Bound;
        .          .          .          .           
        .          .          .          .                   let cur_byte = match range.start_bound() {
        .          .          .          .                       Bound::Included(&i) => usize::from(i),
        .          .          .          .                       Bound::Excluded(&i) => usize::from(i).checked_add(1).unwrap(),
        .          .          .          .                       Bound::Unbounded => 0,
        .          .          .          .                   };
    1,451 ( 0.00%) .          .          .                   let end_byte = match range.end_bound() {
        .          .          .          .                       Bound::Included(&i) => {
        .          .          .          .                           Some(usize::from(i).checked_add(1).unwrap())
        .          .          .          .                       }
        .          .          .          .                       Bound::Excluded(&i) => Some(usize::from(i)),
        .          .          .          .                       Bound::Unbounded => None,
        .          .          .          .                   };
        .          .          .          .                   assert_ne!(
        .          .          .          .                       cur_byte,
-- line 431 ----------------------------------------
-- line 557 ----------------------------------------
        .          .          .          .               end_byte: Option<usize>,
        .          .          .          .               last_class: Option<u8>,
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'a> Iterator for ByteClassRepresentatives<'a> {
        .          .          .          .               type Item = Unit;
        .          .          .          .           
        .          .          .          .               fn next(&mut self) -> Option<Unit> {
  300,439 ( 0.09%) .          .          .                   while self.cur_byte < self.end_byte.unwrap_or(256) {
        .          .          .          .                       let byte = u8::try_from(self.cur_byte).unwrap();
        .          .          .          .                       let class = self.classes.get(byte);
   92,114 ( 0.03%) .          .          .                       self.cur_byte += 1;
        .          .          .          .           
        .          .          .          .                       if self.last_class != Some(class) {
        .          .          .          .                           self.last_class = Some(class);
        .          .          .          .                           return Some(Unit::u8(byte));
        .          .          .          .                       }
        .          .          .          .                   }
    1,404 ( 0.00%) .          .          .                   if self.cur_byte != usize::MAX && self.end_byte.is_none() {
        .          .          .          .                       // Using usize::MAX as a sentinel is OK because we ban usize::MAX
        .          .          .          .                       // from appearing as a start bound in iterator construction. But
        .          .          .          .                       // why do it this way? Well, we want to return the EOI class
        .          .          .          .                       // whenever the end of the given range is unbounded because EOI
        .          .          .          .                       // isn't really a "byte" per se, so the only way it should be
        .          .          .          .                       // excluded is if there is a bounded end to the range. Therefore,
        .          .          .          .                       // when the end is unbounded, we just need to know whether we've
        .          .          .          .                       // reported EOI or not. When we do, we set cur_byte to a value it
        .          .          .          .                       // can never otherwise be.
        .          .          .          .                       self.cur_byte = usize::MAX;
        .          .          .          .                       return Some(self.classes.eoi());
        .          .          .          .                   }
        .          .          .          .                   None
   44,826 ( 0.01%) .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// An iterator over all elements in an equivalence class.
        .          .          .          .           ///
        .          .          .          .           /// This is created by the [`ByteClasses::elements`] method.
        .          .          .          .           ///
        .          .          .          .           /// The lifetime `'a` refers to the lifetime of the byte classes that this
        .          .          .          .           /// iterator was created from.
-- line 597 ----------------------------------------
-- line 698 ----------------------------------------
        .          .          .          .               pub(crate) fn empty() -> Self {
        .          .          .          .                   ByteClassSet(ByteSet::empty())
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Indicate the range of byte given (inclusive) can discriminate a
        .          .          .          .               /// match between it and all other bytes outside of the range.
        .          .          .          .               pub(crate) fn set_range(&mut self, start: u8, end: u8) {
        .          .          .          .                   debug_assert!(start <= end);
  167,916 ( 0.05%) .          .          .                   if start > 0 {
   83,725 ( 0.03%) .          .          .                       self.0.add(start - 1);
        .          .          .          .                   }
        .          .          .          .                   self.0.add(end);
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Add the contiguous ranges in the set given to this byte class set.
        .          .          .          .               pub(crate) fn add_set(&mut self, set: &ByteSet) {
        .          .          .          .                   for (start, end) in set.iter_ranges() {
        .          .          .          .                       self.set_range(start, end);
-- line 715 ----------------------------------------
-- line 720 ----------------------------------------
        .          .          .          .               /// corresponding equivalence class. The last mapping indicates the largest
        .          .          .          .               /// equivalence class identifier (which is never bigger than 255).
        .          .          .          .               pub(crate) fn byte_classes(&self) -> ByteClasses {
        .          .          .          .                   let mut classes = ByteClasses::empty();
        .          .          .          .                   let mut class = 0u8;
        .          .          .          .                   let mut b = 0u8;
        .          .          .          .                   loop {
        .          .          .          .                       classes.set(b, class);
  178,500 ( 0.05%) .          .          .                       if b == 255 {
        .          .          .          .                           break;
        .          .          .          .                       }
   89,250 ( 0.03%) .          .          .                       if self.0.contains(b) {
        .          .          .          .                           class = class.checked_add(1).unwrap();
        .          .          .          .                       }
        .          .          .          .                       b = b.checked_add(1).unwrap();
        .          .          .          .                   }
    6,125 ( 0.00%) .          .          .                   classes
    5,250 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// A simple set of bytes that is reasonably cheap to copy and allocation free.
      700 ( 0.00%) .          .          .           #[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
        .          .          .          .           pub(crate) struct ByteSet {
        .          .          .          .               bits: BitSet,
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// The representation of a byte set. Split out so that we can define a
        .          .          .          .           /// convenient Debug impl for it while keeping "ByteSet" in the output.
        .          .          .          .           #[derive(Clone, Copy, Default, Eq, PartialEq)]
        .          .          .          .           struct BitSet([u128; 2]);
-- line 749 ----------------------------------------
-- line 753 ----------------------------------------
        .          .          .          .               pub(crate) fn empty() -> ByteSet {
        .          .          .          .                   ByteSet { bits: BitSet([0; 2]) }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Add a byte to this set.
        .          .          .          .               ///
        .          .          .          .               /// If the given byte already belongs to this set, then this is a no-op.
        .          .          .          .               pub(crate) fn add(&mut self, byte: u8) {
  167,450 ( 0.05%) .          .          .                   let bucket = byte / 128;
        .          .          .          .                   let bit = byte % 128;
1,966,924 ( 0.59%) .          .          .                   self.bits.0[usize::from(bucket)] |= 1 << bit;
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Remove a byte from this set.
        .          .          .          .               ///
        .          .          .          .               /// If the given byte is not in this set, then this is a no-op.
        .          .          .          .               pub(crate) fn remove(&mut self, byte: u8) {
        .          .          .          .                   let bucket = byte / 128;
        .          .          .          .                   let bit = byte % 128;
        .          .          .          .                   self.bits.0[usize::from(bucket)] &= !(1 << bit);
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return true if and only if the given byte is in this set.
        .          .          .          .               pub(crate) fn contains(&self, byte: u8) -> bool {
        .          .          .          .                   let bucket = byte / 128;
        .          .          .          .                   let bit = byte % 128;
1,160,250 ( 0.35%) .          .          .                   self.bits.0[usize::from(bucket)] & (1 << bit) > 0
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return true if and only if the given inclusive range of bytes is in
        .          .          .          .               /// this set.
        .          .          .          .               pub(crate) fn contains_range(&self, start: u8, end: u8) -> bool {
        .          .          .          .                   (start..=end).all(|b| self.contains(b))
        .          .          .          .               }
        .          .          .          .           
-- line 787 ----------------------------------------
-- line 793 ----------------------------------------
        .          .          .          .               /// Returns an iterator over all contiguous ranges of bytes in this set.
        .          .          .          .               pub(crate) fn iter_ranges(&self) -> ByteSetRangeIter<'_> {
        .          .          .          .                   ByteSetRangeIter { set: self, b: 0 }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Return true if and only if this set is empty.
        .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
        .          .          .          .               pub(crate) fn is_empty(&self) -> bool {
      234 ( 0.00%) .          .          .                   self.bits.0 == [0, 0]
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Deserializes a byte set from the given slice. If the slice is of
        .          .          .          .               /// incorrect length or is otherwise malformed, then an error is returned.
        .          .          .          .               /// Upon success, the number of bytes read along with the set are returned.
        .          .          .          .               /// The number of bytes read is always a multiple of 8.
        .          .          .          .               pub(crate) fn from_bytes(
        .          .          .          .                   slice: &[u8],
-- line 809 ----------------------------------------

  368,034 ( 0.11%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/alphabet.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 221 ----------------------------------------
    .          .          .          .                   NodeRef { height: 0, node: NonNull::from(Box::leak(leaf)), _marker: PhantomData }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {
    .          .          .          .               fn new_internal<A: Allocator + Clone>(child: Root<K, V>, alloc: A) -> Self {
    .          .          .          .                   let mut new_node = unsafe { InternalNode::new(alloc) };
    .          .          .          .                   new_node.edges[0].write(child.node);
   23 ( 0.00%) .          .          .                   unsafe { NodeRef::from_new_internal(new_node, child.height + 1) }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// # Safety
    .          .          .          .               /// `height` must not be zero.
    .          .          .          .               unsafe fn from_new_internal<A: Allocator + Clone>(
    .          .          .          .                   internal: Box<InternalNode<K, V>, A>,
    .          .          .          .                   height: usize,
    .          .          .          .               ) -> Self {
-- line 237 ----------------------------------------
-- line 272 ----------------------------------------
    .          .          .          .           impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {
    .          .          .          .               /// Finds the length of the node. This is the number of keys or values.
    .          .          .          .               /// The number of edges is `len() + 1`.
    .          .          .          .               /// Note that, despite being safe, calling this function can have the side effect
    .          .          .          .               /// of invalidating mutable references that unsafe code has created.
    .          .          .          .               pub fn len(&self) -> usize {
    .          .          .          .                   // Crucially, we only access the `len` field here. If BorrowType is marker::ValMut,
    .          .          .          .                   // there might be outstanding mutable references to values that we must not invalidate.
3,581 ( 0.00%) .          .          .                   unsafe { usize::from((*Self::as_leaf_ptr(self)).len) }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the number of levels that the node and leaves are apart. Zero
    .          .          .          .               /// height means the node is a leaf itself. If you picture trees with the
    .          .          .          .               /// root on top, the number says at which elevation the node appears.
    .          .          .          .               /// If you picture trees with leaves on top, the number says how high
    .          .          .          .               /// the tree extends above the node.
    .          .          .          .               pub fn height(&self) -> usize {
    .          .          .          .                   self.height
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Temporarily takes out another, immutable reference to the same node.
    .          .          .          .               pub fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {
  100 ( 0.00%) .          .          .                   NodeRef { height: self.height, node: self.node, _marker: PhantomData }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Exposes the leaf portion of any leaf or internal node.
    .          .          .          .               ///
    .          .          .          .               /// Returns a raw ptr to avoid invalidating other references to this node.
    .          .          .          .               fn as_leaf_ptr(this: &Self) -> *mut LeafNode<K, V> {
    .          .          .          .                   // The node must be valid for at least the LeafNode portion.
    .          .          .          .                   // This is not a reference in the NodeRef type because we don't know if
    .          .          .          .                   // it should be unique or shared.
  728 ( 0.00%) .          .          .                   this.node.as_ptr()
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<BorrowType: marker::BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {
    .          .          .          .               /// Finds the parent of the current node. Returns `Ok(handle)` if the current
    .          .          .          .               /// node actually has a parent, where `handle` points to the edge of the parent
    .          .          .          .               /// that points to the current node. Returns `Err(self)` if the current node has
    .          .          .          .               /// no parent, giving back the original `NodeRef`.
-- line 312 ----------------------------------------
-- line 320 ----------------------------------------
    .          .          .          .               ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {
    .          .          .          .                   const {
    .          .          .          .                       assert!(BorrowType::TRAVERSAL_PERMIT);
    .          .          .          .                   }
    .          .          .          .           
    .          .          .          .                   // We need to use raw pointers to nodes because, if BorrowType is marker::ValMut,
    .          .          .          .                   // there might be outstanding mutable references to values that we must not invalidate.
    .          .          .          .                   let leaf_ptr: *const _ = Self::as_leaf_ptr(&self);
  494 ( 0.00%) .          .          .                   unsafe { (*leaf_ptr).parent }
    .          .          .          .                       .as_ref()
    .          .          .          .                       .map(|parent| Handle {
  287 ( 0.00%) .          .          .                           node: NodeRef::from_internal(*parent, self.height + 1),
  293 ( 0.00%) .          .          .                           idx: unsafe { usize::from((*leaf_ptr).parent_idx.assume_init()) },
    .          .          .          .                           _marker: PhantomData,
    .          .          .          .                       })
    .          .          .          .                       .ok_or(self)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub fn first_edge(self) -> Handle<Self, marker::Edge> {
    .          .          .          .                   unsafe { Handle::new_edge(self, 0) }
    .          .          .          .               }
-- line 340 ----------------------------------------
-- line 379 ----------------------------------------
    .          .          .          .                   // SAFETY: there can be no mutable references into this tree borrowed as `Immut`.
    .          .          .          .                   unsafe { &*ptr }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Borrows a view into the keys stored in the node.
    .          .          .          .               pub fn keys(&self) -> &[K] {
    .          .          .          .                   let leaf = self.into_leaf();
    .          .          .          .                   unsafe {
1,988 ( 0.00%) .          .          .                       MaybeUninit::slice_assume_init_ref(leaf.keys.get_unchecked(..usize::from(leaf.len)))
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<K, V> NodeRef<marker::Dying, K, V, marker::LeafOrInternal> {
    .          .          .          .               /// Similar to `ascend`, gets a reference to a node's parent node, but also
    .          .          .          .               /// deallocates the current node in the process. This is unsafe because the
    .          .          .          .               /// current node will still be accessible despite being deallocated.
-- line 395 ----------------------------------------
-- line 398 ----------------------------------------
    .          .          .          .                   alloc: A,
    .          .          .          .               ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::Internal>, marker::Edge>> {
    .          .          .          .                   let height = self.height;
    .          .          .          .                   let node = self.node;
    .          .          .          .                   let ret = self.ascend().ok();
    .          .          .          .                   unsafe {
    .          .          .          .                       alloc.deallocate(
    .          .          .          .                           node.cast(),
  111 ( 0.00%) .          .          .                           if height > 0 {
    .          .          .          .                               Layout::new::<InternalNode<K, V>>()
    .          .          .          .                           } else {
    .          .          .          .                               Layout::new::<LeafNode<K, V>>()
    .          .          .          .                           },
    .          .          .          .                       );
    .          .          .          .                   }
    .          .          .          .                   ret
    .          .          .          .               }
-- line 414 ----------------------------------------
-- line 421 ----------------------------------------
    .          .          .          .               ///
    .          .          .          .               /// Because mutable pointers can roam anywhere around the tree, the returned
    .          .          .          .               /// pointer can easily be used to make the original pointer dangling, out of
    .          .          .          .               /// bounds, or invalid under stacked borrow rules.
    .          .          .          .               // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef`
    .          .          .          .               // that restricts the use of navigation methods on reborrowed pointers,
    .          .          .          .               // preventing this unsafety.
    .          .          .          .               unsafe fn reborrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {
    5 ( 0.00%) .          .          .                   NodeRef { height: self.height, node: self.node, _marker: PhantomData }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Borrows exclusive access to the leaf portion of a leaf or internal node.
    .          .          .          .               fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {
    .          .          .          .                   let ptr = Self::as_leaf_ptr(self);
    .          .          .          .                   // SAFETY: we have exclusive access to the entire node.
    .          .          .          .                   unsafe { &mut *ptr }
    .          .          .          .               }
-- line 437 ----------------------------------------
-- line 478 ----------------------------------------
    .          .          .          .               /// `index` is in bounds of 0..CAPACITY
    .          .          .          .               unsafe fn key_area_mut<I, Output: ?Sized>(&mut self, index: I) -> &mut Output
    .          .          .          .               where
    .          .          .          .                   I: SliceIndex<[MaybeUninit<K>], Output = Output>,
    .          .          .          .               {
    .          .          .          .                   // SAFETY: the caller will not be able to call further methods on self
    .          .          .          .                   // until the key slice reference is dropped, as we have unique access
    .          .          .          .                   // for the lifetime of the borrow.
   36 ( 0.00%) .          .          .                   unsafe { self.as_leaf_mut().keys.as_mut_slice().get_unchecked_mut(index) }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Borrows exclusive access to an element or slice of the node's value storage area.
    .          .          .          .               ///
    .          .          .          .               /// # Safety
    .          .          .          .               /// `index` is in bounds of 0..CAPACITY
    .          .          .          .               unsafe fn val_area_mut<I, Output: ?Sized>(&mut self, index: I) -> &mut Output
    .          .          .          .               where
    .          .          .          .                   I: SliceIndex<[MaybeUninit<V>], Output = Output>,
    .          .          .          .               {
    .          .          .          .                   // SAFETY: the caller will not be able to call further methods on self
    .          .          .          .                   // until the value slice reference is dropped, as we have unique access
    .          .          .          .                   // for the lifetime of the borrow.
   26 ( 0.00%) .          .          .                   unsafe { self.as_leaf_mut().vals.as_mut_slice().get_unchecked_mut(index) }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {
    .          .          .          .               /// Borrows exclusive access to an element or slice of the node's storage area for edge contents.
    .          .          .          .               ///
    .          .          .          .               /// # Safety
    .          .          .          .               /// `index` is in bounds of 0..CAPACITY + 1
    .          .          .          .               unsafe fn edge_area_mut<I, Output: ?Sized>(&mut self, index: I) -> &mut Output
    .          .          .          .               where
    .          .          .          .                   I: SliceIndex<[MaybeUninit<BoxedNode<K, V>>], Output = Output>,
    .          .          .          .               {
    .          .          .          .                   // SAFETY: the caller will not be able to call further methods on self
    .          .          .          .                   // until the edge slice reference is dropped, as we have unique access
    .          .          .          .                   // for the lifetime of the borrow.
    8 ( 0.00%) .          .          .                   unsafe { self.as_internal_mut().edges.as_mut_slice().get_unchecked_mut(index) }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K, V, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {
    .          .          .          .               /// # Safety
    .          .          .          .               /// - The node has more than `idx` initialized elements.
    .          .          .          .               unsafe fn into_key_val_mut_at(mut self, idx: usize) -> (&'a K, &'a mut V) {
    .          .          .          .                   // We only create a reference to the one element we are interested in,
-- line 524 ----------------------------------------
-- line 559 ----------------------------------------
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {
    .          .          .          .               /// Sets the node's link to its parent edge,
    .          .          .          .               /// without invalidating other references to the node.
    .          .          .          .               fn set_parent_link(&mut self, parent: NonNull<InternalNode<K, V>>, parent_idx: usize) {
    .          .          .          .                   let leaf = Self::as_leaf_ptr(self);
  272 ( 0.00%) .          .          .                   unsafe { (*leaf).parent = Some(parent) };
    .          .          .          .                   unsafe { (*leaf).parent_idx.write(parent_idx as u16) };
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {
    .          .          .          .               /// Clears the root's link to its parent edge.
    .          .          .          .               fn clear_parent_link(&mut self) {
    .          .          .          .                   let mut root_node = self.borrow_mut();
    .          .          .          .                   let leaf = root_node.as_leaf_mut();
    2 ( 0.00%) .          .          .                   leaf.parent = None;
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {
    .          .          .          .               /// Returns a new owned tree, with its own root node that is initially empty.
    .          .          .          .               pub fn new<A: Allocator + Clone>(alloc: A) -> Self {
    .          .          .          .                   NodeRef::new_leaf(alloc).forget_type()
    .          .          .          .               }
-- line 585 ----------------------------------------
-- line 602 ----------------------------------------
    .          .          .          .               /// no cleanup is done on any of the keys, values and other children.
    .          .          .          .               /// This decreases the height by 1 and is the opposite of `push_internal_level`.
    .          .          .          .               ///
    .          .          .          .               /// Requires exclusive access to the `NodeRef` object but not to the root node;
    .          .          .          .               /// it will not invalidate other handles or references to the root node.
    .          .          .          .               ///
    .          .          .          .               /// Panics if there is no internal level, i.e., if the root node is a leaf.
    .          .          .          .               pub fn pop_internal_level<A: Allocator + Clone>(&mut self, alloc: A) {
    6 ( 0.00%) .          .          .                   assert!(self.height > 0);
    .          .          .          .           
    2 ( 0.00%) .          .          .                   let top = self.node;
    .          .          .          .           
    .          .          .          .                   // SAFETY: we asserted to be internal.
    .          .          .          .                   let internal_self = unsafe { self.borrow_mut().cast_to_internal_unchecked() };
    .          .          .          .                   // SAFETY: we borrowed `self` exclusively and its borrow type is exclusive.
    .          .          .          .                   let internal_node = unsafe { &mut *NodeRef::as_internal_ptr(&internal_self) };
    .          .          .          .                   // SAFETY: the first edge is always initialized.
    2 ( 0.00%) .          .          .                   self.node = unsafe { internal_node.edges[0].assume_init_read() };
    4 ( 0.00%) .          .          .                   self.height -= 1;
    .          .          .          .                   self.clear_parent_link();
    .          .          .          .           
    .          .          .          .                   unsafe {
    .          .          .          .                       alloc.deallocate(top.cast(), Layout::new::<InternalNode<K, V>>());
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<K, V, Type> NodeRef<marker::Owned, K, V, Type> {
    .          .          .          .               /// Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe
    .          .          .          .               /// because the return value cannot be used to destroy the root, and there
    .          .          .          .               /// cannot be other references to the tree.
    .          .          .          .               pub fn borrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {
1,107 ( 0.00%) .          .          .                   NodeRef { height: self.height, node: self.node, _marker: PhantomData }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Slightly mutably borrows the owned root node.
    .          .          .          .               pub fn borrow_valmut(&mut self) -> NodeRef<marker::ValMut<'_>, K, V, Type> {
    3 ( 0.00%) .          .          .                   NodeRef { height: self.height, node: self.node, _marker: PhantomData }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Irreversibly transitions to a reference that permits traversal and offers
    .          .          .          .               /// destructive methods and little else.
    .          .          .          .               pub fn into_dying(self) -> NodeRef<marker::Dying, K, V, Type> {
    .          .          .          .                   NodeRef { height: self.height, node: self.node, _marker: PhantomData }
    .          .          .          .               }
    .          .          .          .           }
-- line 647 ----------------------------------------
-- line 656 ----------------------------------------
    .          .          .          .               pub unsafe fn push_with_handle<'b>(
    .          .          .          .                   &mut self,
    .          .          .          .                   key: K,
    .          .          .          .                   val: V,
    .          .          .          .               ) -> Handle<NodeRef<marker::Mut<'b>, K, V, marker::Leaf>, marker::KV> {
    .          .          .          .                   let len = self.len_mut();
    .          .          .          .                   let idx = usize::from(*len);
    .          .          .          .                   assert!(idx < CAPACITY);
   73 ( 0.00%) .          .          .                   *len += 1;
    .          .          .          .                   unsafe {
    .          .          .          .                       self.key_area_mut(idx).write(key);
    .          .          .          .                       self.val_area_mut(idx).write(val);
    .          .          .          .                       Handle::new_kv(
    .          .          .          .                           NodeRef { height: self.height, node: self.node, _marker: PhantomData },
    .          .          .          .                           idx,
    .          .          .          .                       )
    .          .          .          .                   }
-- line 672 ----------------------------------------
-- line 679 ----------------------------------------
    .          .          .          .                   unsafe { self.push_with_handle(key, val).into_val_mut() }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {
    .          .          .          .               /// Adds a key-value pair, and an edge to go to the right of that pair,
    .          .          .          .               /// to the end of the node.
    .          .          .          .               pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {
   46 ( 0.00%) .          .          .                   assert!(edge.height == self.height - 1);
    .          .          .          .           
    .          .          .          .                   let len = self.len_mut();
    .          .          .          .                   let idx = usize::from(*len);
    .          .          .          .                   assert!(idx < CAPACITY);
   23 ( 0.00%) .          .          .                   *len += 1;
    .          .          .          .                   unsafe {
    .          .          .          .                       self.key_area_mut(idx).write(key);
    .          .          .          .                       self.val_area_mut(idx).write(val);
    .          .          .          .                       self.edge_area_mut(idx + 1).write(edge.node);
    .          .          .          .                       Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           }
-- line 700 ----------------------------------------
-- line 716 ----------------------------------------
    .          .          .          .           impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {
    .          .          .          .               /// Checks whether a node is an `Internal` node or a `Leaf` node.
    .          .          .          .               pub fn force(
    .          .          .          .                   self,
    .          .          .          .               ) -> ForceResult<
    .          .          .          .                   NodeRef<BorrowType, K, V, marker::Leaf>,
    .          .          .          .                   NodeRef<BorrowType, K, V, marker::Internal>,
    .          .          .          .               > {
8,123 ( 0.00%) .          .          .                   if self.height == 0 {
    .          .          .          .                       ForceResult::Leaf(NodeRef {
    .          .          .          .                           height: self.height,
    .          .          .          .                           node: self.node,
    .          .          .          .                           _marker: PhantomData,
    .          .          .          .                       })
    .          .          .          .                   } else {
    .          .          .          .                       ForceResult::Internal(NodeRef {
    .          .          .          .                           height: self.height,
-- line 732 ----------------------------------------
-- line 787 ----------------------------------------
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {
    .          .          .          .               /// Creates a new handle to a key-value pair in `node`.
    .          .          .          .               /// Unsafe because the caller must ensure that `idx < node.len()`.
    .          .          .          .               pub unsafe fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {
    .          .          .          .                   debug_assert!(idx < node.len());
    .          .          .          .           
    6 ( 0.00%) .          .          .                   Handle { node, idx, _marker: PhantomData }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub fn left_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {
    .          .          .          .                   unsafe { Handle::new_edge(self.node, self.idx) }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub fn right_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {
    .          .          .          .                   unsafe { Handle::new_edge(self.node, self.idx + 1) }
-- line 803 ----------------------------------------
-- line 804 ----------------------------------------
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<BorrowType, K, V, NodeType, HandleType> PartialEq
    .          .          .          .               for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>
    .          .          .          .           {
    .          .          .          .               fn eq(&self, other: &Self) -> bool {
    .          .          .          .                   let Self { node, idx, _marker } = self;
   22 ( 0.00%) .          .          .                   node.eq(&other.node) && *idx == other.idx
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<BorrowType, K, V, NodeType, HandleType>
    .          .          .          .               Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>
    .          .          .          .           {
    .          .          .          .               /// Temporarily takes out another immutable handle on the same location.
    .          .          .          .               pub fn reborrow(&self) -> Handle<NodeRef<marker::Immut<'_>, K, V, NodeType>, HandleType> {
-- line 820 ----------------------------------------
-- line 847 ----------------------------------------
    .          .          .          .           impl<K, V, NodeType, HandleType> Handle<NodeRef<marker::DormantMut, K, V, NodeType>, HandleType> {
    .          .          .          .               /// Revert to the unique borrow initially captured.
    .          .          .          .               ///
    .          .          .          .               /// # Safety
    .          .          .          .               ///
    .          .          .          .               /// The reborrow must have ended, i.e., the reference returned by `new` and
    .          .          .          .               /// all pointers and references derived from it, must not be used anymore.
    .          .          .          .               pub unsafe fn awaken<'a>(self) -> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {
2,166 ( 0.00%) .          .          .                   Handle { node: unsafe { self.node.awaken() }, idx: self.idx, _marker: PhantomData }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {
    .          .          .          .               /// Creates a new handle to an edge in `node`.
    .          .          .          .               /// Unsafe because the caller must ensure that `idx <= node.len()`.
    .          .          .          .               pub unsafe fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {
    .          .          .          .                   debug_assert!(idx <= node.len());
    .          .          .          .           
    .          .          .          .                   Handle { node, idx, _marker: PhantomData }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub fn left_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {
   70 ( 0.00%) .          .          .                   if self.idx > 0 {
   17 ( 0.00%) .          .          .                       Ok(unsafe { Handle::new_kv(self.node, self.idx - 1) })
    .          .          .          .                   } else {
    .          .          .          .                       Err(self)
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub fn right_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {
5,987 ( 0.00%) .          .          .                   if self.idx < self.node.len() {
    .          .          .          .                       Ok(unsafe { Handle::new_kv(self.node, self.idx) })
    .          .          .          .                   } else {
    .          .          .          .                       Err(self)
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           pub enum LeftOrRight<T> {
-- line 885 ----------------------------------------
-- line 890 ----------------------------------------
    .          .          .          .           /// Given an edge index where we want to insert into a node filled to capacity,
    .          .          .          .           /// computes a sensible KV index of a split point and where to perform the insertion.
    .          .          .          .           /// The goal of the split point is for its key and value to end up in a parent node;
    .          .          .          .           /// the keys, values and edges to the left of the split point become the left child;
    .          .          .          .           /// the keys, values and edges to the right of the split point become the right child.
    .          .          .          .           fn splitpoint(edge_idx: usize) -> (usize, LeftOrRight<usize>) {
    .          .          .          .               debug_assert!(edge_idx <= CAPACITY);
    .          .          .          .               // Rust issue #74834 tries to explain these symmetric rules.
   95 ( 0.00%) .          .          .               match edge_idx {
  216 ( 0.00%) .          .          .                   0..EDGE_IDX_LEFT_OF_CENTER => (KV_IDX_CENTER - 1, LeftOrRight::Left(edge_idx)),
    .          .          .          .                   EDGE_IDX_LEFT_OF_CENTER => (KV_IDX_CENTER, LeftOrRight::Left(edge_idx)),
    .          .          .          .                   EDGE_IDX_RIGHT_OF_CENTER => (KV_IDX_CENTER, LeftOrRight::Right(0)),
   31 ( 0.00%) .          .          .                   _ => (KV_IDX_CENTER + 1, LeftOrRight::Right(edge_idx - (KV_IDX_CENTER + 1 + 1))),
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {
    .          .          .          .               /// Inserts a new key-value pair between the key-value pairs to the right and left of
    .          .          .          .               /// this edge. This method assumes that there is enough space in the node for the new
    .          .          .          .               /// pair to fit.
    .          .          .          .               unsafe fn insert_fit(
    .          .          .          .                   mut self,
    .          .          .          .                   key: K,
    .          .          .          .                   val: V,
    .          .          .          .               ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {
    .          .          .          .                   debug_assert!(self.node.len() < CAPACITY);
  542 ( 0.00%) .          .          .                   let new_len = self.node.len() + 1;
    .          .          .          .           
    .          .          .          .                   unsafe {
    .          .          .          .                       slice_insert(self.node.key_area_mut(..new_len), self.idx, key);
   28 ( 0.00%) .          .          .                       slice_insert(self.node.val_area_mut(..new_len), self.idx, val);
  705 ( 0.00%) .          .          .                       *self.node.len_mut() = new_len as u16;
    .          .          .          .           
    .          .          .          .                       Handle::new_kv(self.node, self.idx)
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {
    .          .          .          .               /// Inserts a new key-value pair between the key-value pairs to the right and left of
-- line 929 ----------------------------------------
-- line 935 ----------------------------------------
    .          .          .          .                   self,
    .          .          .          .                   key: K,
    .          .          .          .                   val: V,
    .          .          .          .                   alloc: A,
    .          .          .          .               ) -> (
    .          .          .          .                   Option<SplitResult<'a, K, V, marker::Leaf>>,
    .          .          .          .                   Handle<NodeRef<marker::DormantMut, K, V, marker::Leaf>, marker::KV>,
    .          .          .          .               ) {
  542 ( 0.00%) .          .          .                   if self.node.len() < CAPACITY {
    .          .          .          .                       // SAFETY: There is enough space in the node for insertion.
1,485 ( 0.00%) .          .          .                       let handle = unsafe { self.insert_fit(key, val) };
    .          .          .          .                       (None, handle.dormant())
    .          .          .          .                   } else {
   47 ( 0.00%) .          .          .                       let (middle_kv_idx, insertion) = splitpoint(self.idx);
   47 ( 0.00%) .          .          .                       let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };
    .          .          .          .                       let mut result = middle.split(alloc);
   18 ( 0.00%) .          .          .                       let insertion_edge = match insertion {
    .          .          .          .                           LeftOrRight::Left(insert_idx) => unsafe {
    .          .          .          .                               Handle::new_edge(result.left.reborrow_mut(), insert_idx)
    .          .          .          .                           },
    .          .          .          .                           LeftOrRight::Right(insert_idx) => unsafe {
    .          .          .          .                               Handle::new_edge(result.right.borrow_mut(), insert_idx)
    .          .          .          .                           },
    .          .          .          .                       };
    .          .          .          .                       // SAFETY: We just split the node, so there is enough space for
-- line 959 ----------------------------------------
-- line 978 ----------------------------------------
    .          .          .          .           
    .          .          .          .           impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {
    .          .          .          .               /// Inserts a new key-value pair and an edge that will go to the right of that new pair
    .          .          .          .               /// between this edge and the key-value pair to the right of this edge. This method assumes
    .          .          .          .               /// that there is enough space in the node for the new pair to fit.
    .          .          .          .               fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {
    .          .          .          .                   debug_assert!(self.node.len() < CAPACITY);
    .          .          .          .                   debug_assert!(edge.height == self.node.height - 1);
   24 ( 0.00%) .          .          .                   let new_len = self.node.len() + 1;
    .          .          .          .           
    .          .          .          .                   unsafe {
    .          .          .          .                       slice_insert(self.node.key_area_mut(..new_len), self.idx, key);
    .          .          .          .                       slice_insert(self.node.val_area_mut(..new_len), self.idx, val);
   26 ( 0.00%) .          .          .                       slice_insert(self.node.edge_area_mut(..new_len + 1), self.idx + 1, edge.node);
   26 ( 0.00%) .          .          .                       *self.node.len_mut() = new_len as u16;
    .          .          .          .           
    .          .          .          .                       self.node.correct_childrens_parent_links(self.idx + 1..new_len + 1);
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Inserts a new key-value pair and an edge that will go to the right of that new pair
    .          .          .          .               /// between this edge and the key-value pair to the right of this edge. This method splits
    .          .          .          .               /// the node if there isn't enough room.
    .          .          .          .               fn insert<A: Allocator + Clone>(
    .          .          .          .                   mut self,
    .          .          .          .                   key: K,
    .          .          .          .                   val: V,
    .          .          .          .                   edge: Root<K, V>,
    .          .          .          .                   alloc: A,
    .          .          .          .               ) -> Option<SplitResult<'a, K, V, marker::Internal>> {
   52 ( 0.00%) .          .          .                   assert!(edge.height == self.node.height - 1);
    .          .          .          .           
   26 ( 0.00%) .          .          .                   if self.node.len() < CAPACITY {
    .          .          .          .                       self.insert_fit(key, val, edge);
    .          .          .          .                       None
    .          .          .          .                   } else {
    .          .          .          .                       let (middle_kv_idx, insertion) = splitpoint(self.idx);
    .          .          .          .                       let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };
    6 ( 0.00%) .          .          .                       let mut result = middle.split(alloc);
  782 ( 0.00%) 4 ( 0.00%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Internal>,alloc::collections::btree::node::marker::KV>::split (2x)
    .          .          .          .                       let mut insertion_edge = match insertion {
    .          .          .          .                           LeftOrRight::Left(insert_idx) => unsafe {
    .          .          .          .                               Handle::new_edge(result.left.reborrow_mut(), insert_idx)
    .          .          .          .                           },
    .          .          .          .                           LeftOrRight::Right(insert_idx) => unsafe {
    .          .          .          .                               Handle::new_edge(result.right.borrow_mut(), insert_idx)
    .          .          .          .                           },
    .          .          .          .                       };
    .          .          .          .                       insertion_edge.insert_fit(key, val, edge);
    2 ( 0.00%) .          .          .                       Some(result)
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {
    .          .          .          .               /// Inserts a new key-value pair between the key-value pairs to the right and left of
    .          .          .          .               /// this edge. This method splits the node if there isn't enough room, and tries to
    .          .          .          .               /// insert the split off portion into the parent node recursively, until the root is reached.
    .          .          .          .               ///
    .          .          .          .               /// If the returned result is some `SplitResult`, the `left` field will be the root node.
    .          .          .          .               /// The returned pointer points to the inserted value, which in the case of `SplitResult`
    .          .          .          .               /// is in the `left` or `right` tree.
4,338 ( 0.00%) .          .          .               pub fn insert_recursing<A: Allocator + Clone>(
    .          .          .          .                   self,
    .          .          .          .                   key: K,
    .          .          .          .                   value: V,
    .          .          .          .                   alloc: A,
    .          .          .          .                   split_root: impl FnOnce(SplitResult<'a, K, V, marker::LeafOrInternal>),
    .          .          .          .               ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {
    .          .          .          .                   let (mut split, handle) = match self.insert(key, value, alloc.clone()) {
    .          .          .          .                       // SAFETY: we have finished splitting and can now re-awaken the
-- line 1047 ----------------------------------------
-- line 1048 ----------------------------------------
    .          .          .          .                       // handle to the inserted element.
    .          .          .          .                       (None, handle) => return unsafe { handle.awaken() },
    .          .          .          .                       (Some(split), handle) => (split.forget_node_type(), handle),
    .          .          .          .                   };
    .          .          .          .           
    .          .          .          .                   loop {
    .          .          .          .                       split = match split.left.ascend() {
    .          .          .          .                           Ok(parent) => {
   18 ( 0.00%) .          .          .                               match parent.insert(split.kv.0, split.kv.1, split.right, alloc.clone()) {
    .          .          .          .                                   // SAFETY: we have finished splitting and can now re-awaken the
    .          .          .          .                                   // handle to the inserted element.
    .          .          .          .                                   None => return unsafe { handle.awaken() },
    .          .          .          .                                   Some(split) => split.forget_node_type(),
    .          .          .          .                               }
    .          .          .          .                           }
    .          .          .          .                           Err(root) => {
   23 ( 0.00%) .          .          .                               split_root(SplitResult { left: root, ..split });
    .          .          .          .                               // SAFETY: we have finished splitting and can now re-awaken the
    .          .          .          .                               // handle to the inserted element.
    .          .          .          .                               return unsafe { handle.awaken() };
    .          .          .          .                           }
    .          .          .          .                       };
    .          .          .          .                   }
4,878 ( 0.00%) .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<BorrowType: marker::BorrowType, K, V>
    .          .          .          .               Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>
    .          .          .          .           {
    .          .          .          .               /// Finds the node pointed to by this edge.
    .          .          .          .               ///
    .          .          .          .               /// The method name assumes you picture trees with the root node on top.
-- line 1079 ----------------------------------------
-- line 1088 ----------------------------------------
    .          .          .          .                   // We need to use raw pointers to nodes because, if BorrowType is
    .          .          .          .                   // marker::ValMut, there might be outstanding mutable references to
    .          .          .          .                   // values that we must not invalidate. There's no worry accessing the
    .          .          .          .                   // height field because that value is copied. Beware that, once the
    .          .          .          .                   // node pointer is dereferenced, we access the edges array with a
    .          .          .          .                   // reference (Rust issue #73987) and invalidate any other references
    .          .          .          .                   // to or inside the array, should any be around.
    .          .          .          .                   let parent_ptr = NodeRef::as_internal_ptr(&self.node);
  231 ( 0.00%) .          .          .                   let node = unsafe { (*parent_ptr).edges.get_unchecked(self.idx).assume_init_read() };
    .          .          .          .                   NodeRef { node, height: self.node.height - 1, _marker: PhantomData }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {
    .          .          .          .               pub fn into_kv(self) -> (&'a K, &'a V) {
    .          .          .          .                   debug_assert!(self.idx < self.node.len());
    .          .          .          .                   let leaf = self.node.into_leaf();
-- line 1104 ----------------------------------------
-- line 1197 ----------------------------------------
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {
    .          .          .          .               /// Helps implementations of `split` for a particular `NodeType`,
    .          .          .          .               /// by taking care of leaf data.
    .          .          .          .               fn split_leaf_data(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V) {
    .          .          .          .                   debug_assert!(self.idx < self.node.len());
    .          .          .          .                   let old_len = self.node.len();
   53 ( 0.00%) .          .          .                   let new_len = old_len - self.idx - 1;
   49 ( 0.00%) .          .          .                   new_node.len = new_len as u16;
    .          .          .          .                   unsafe {
    .          .          .          .                       let k = self.node.key_area_mut(self.idx).assume_init_read();
    .          .          .          .                       let v = self.node.val_area_mut(self.idx).assume_init_read();
    .          .          .          .           
    .          .          .          .                       move_to_slice(
    2 ( 0.00%) .          .          .                           self.node.key_area_mut(self.idx + 1..old_len),
   26 ( 0.00%) .          .          .                           &mut new_node.keys[..new_len],
    .          .          .          .                       );
    .          .          .          .                       move_to_slice(
    .          .          .          .                           self.node.val_area_mut(self.idx + 1..old_len),
   49 ( 0.00%) .          .          .                           &mut new_node.vals[..new_len],
    .          .          .          .                       );
    .          .          .          .           
   49 ( 0.00%) .          .          .                       *self.node.len_mut() = self.idx as u16;
    .          .          .          .                       (k, v)
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {
    .          .          .          .               /// Splits the underlying node into three parts:
    .          .          .          .               ///
-- line 1228 ----------------------------------------
-- line 1232 ----------------------------------------
    .          .          .          .               /// - All the key-value pairs to the right of this handle are put into a newly
    .          .          .          .               ///   allocated node.
    .          .          .          .               pub fn split<A: Allocator + Clone>(mut self, alloc: A) -> SplitResult<'a, K, V, marker::Leaf> {
    .          .          .          .                   let mut new_node = LeafNode::new(alloc);
    .          .          .          .           
    .          .          .          .                   let kv = self.split_leaf_data(&mut new_node);
    .          .          .          .           
    .          .          .          .                   let right = NodeRef::from_new_leaf(new_node);
  258 ( 0.00%) .          .          .                   SplitResult { left: self.node, kv, right }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Removes the key-value pair pointed to by this handle and returns it, along with the edge
    .          .          .          .               /// that the key-value pair collapsed into.
    .          .          .          .               pub fn remove(
    .          .          .          .                   mut self,
    .          .          .          .               ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {
    .          .          .          .                   let old_len = self.node.len();
    .          .          .          .                   unsafe {
  179 ( 0.00%) .          .          .                       let k = slice_remove(self.node.key_area_mut(..old_len), self.idx);
    .          .          .          .                       let v = slice_remove(self.node.val_area_mut(..old_len), self.idx);
  358 ( 0.00%) .          .          .                       *self.node.len_mut() = (old_len - 1) as u16;
  179 ( 0.00%) .          .          .                       ((k, v), self.left_edge())
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {
    .          .          .          .               /// Splits the underlying node into three parts:
    .          .          .          .               ///
    .          .          .          .               /// - The node is truncated to only contain the edges and key-value pairs to the
    .          .          .          .               ///   left of this handle.
    .          .          .          .               /// - The key and value pointed to by this handle are extracted.
    .          .          .          .               /// - All the edges and key-value pairs to the right of this handle are put into
    .          .          .          .               ///   a newly allocated node.
   18 ( 0.00%) .          .          .               pub fn split<A: Allocator + Clone>(
    .          .          .          .                   mut self,
    .          .          .          .                   alloc: A,
    .          .          .          .               ) -> SplitResult<'a, K, V, marker::Internal> {
    .          .          .          .                   let old_len = self.node.len();
    .          .          .          .                   unsafe {
    .          .          .          .                       let mut new_node = InternalNode::new(alloc);
    2 ( 0.00%) .          .          .                       let kv = self.split_leaf_data(&mut new_node.data);
    4 ( 0.00%) .          .          .                       let new_len = usize::from(new_node.data.len);
    .          .          .          .                       move_to_slice(
    .          .          .          .                           self.node.edge_area_mut(self.idx + 1..old_len + 1),
    2 ( 0.00%) .          .          .                           &mut new_node.edges[..new_len + 1],
    .          .          .          .                       );
    .          .          .          .           
    6 ( 0.00%) .          .          .                       let height = self.node.height;
    .          .          .          .                       let right = NodeRef::from_new_internal(new_node, height);
    .          .          .          .           
   16 ( 0.00%) .          .          .                       SplitResult { left: self.node, kv, right }
    .          .          .          .                   }
   16 ( 0.00%) .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Represents a session for evaluating and performing a balancing operation
    .          .          .          .           /// around an internal key-value pair.
    .          .          .          .           pub struct BalancingContext<'a, K, V> {
    .          .          .          .               parent: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV>,
    .          .          .          .               left_child: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,
    .          .          .          .               right_child: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,
-- line 1293 ----------------------------------------
-- line 1357 ----------------------------------------
    .          .          .          .           
    .          .          .          .               pub fn into_right_child(self) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {
    .          .          .          .                   self.right_child
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns whether merging is possible, i.e., whether there is enough room
    .          .          .          .               /// in a node to combine the central KV with both adjacent child nodes.
    .          .          .          .               pub fn can_merge(&self) -> bool {
   93 ( 0.00%) .          .          .                   self.left_child.len() + 1 + self.right_child.len() <= CAPACITY
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {
    .          .          .          .               /// Performs a merge and lets a closure decide what to return.
  168 ( 0.00%) .          .          .               fn do_merge<
    .          .          .          .                   F: FnOnce(
    .          .          .          .                       NodeRef<marker::Mut<'a>, K, V, marker::Internal>,
    .          .          .          .                       NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,
    .          .          .          .                   ) -> R,
    .          .          .          .                   R,
    .          .          .          .                   A: Allocator,
    .          .          .          .               >(
    .          .          .          .                   self,
    .          .          .          .                   result: F,
    .          .          .          .                   alloc: A,
    .          .          .          .               ) -> R {
   24 ( 0.00%) .          .          .                   let Handle { node: mut parent_node, idx: parent_idx, _marker } = self.parent;
    .          .          .          .                   let old_parent_len = parent_node.len();
   24 ( 0.00%) .          .          .                   let mut left_node = self.left_child;
    .          .          .          .                   let old_left_len = left_node.len();
   24 ( 0.00%) .          .          .                   let mut right_node = self.right_child;
    .          .          .          .                   let right_len = right_node.len();
   48 ( 0.00%) .          .          .                   let new_left_len = old_left_len + 1 + right_len;
    .          .          .          .           
   48 ( 0.00%) .          .          .                   assert!(new_left_len <= CAPACITY);
    .          .          .          .           
    .          .          .          .                   unsafe {
   26 ( 0.00%) .          .          .                       *left_node.len_mut() = new_left_len as u16;
    .          .          .          .           
    .          .          .          .                       let parent_key = slice_remove(parent_node.key_area_mut(..old_parent_len), parent_idx);
    .          .          .          .                       left_node.key_area_mut(old_left_len).write(parent_key);
    .          .          .          .                       move_to_slice(
    .          .          .          .                           right_node.key_area_mut(..right_len),
    .          .          .          .                           left_node.key_area_mut(old_left_len + 1..new_left_len),
    .          .          .          .                       );
    .          .          .          .           
    .          .          .          .                       let parent_val = slice_remove(parent_node.val_area_mut(..old_parent_len), parent_idx);
    .          .          .          .                       left_node.val_area_mut(old_left_len).write(parent_val);
    .          .          .          .                       move_to_slice(
    .          .          .          .                           right_node.val_area_mut(..right_len),
    .          .          .          .                           left_node.val_area_mut(old_left_len + 1..new_left_len),
    .          .          .          .                       );
    .          .          .          .           
   26 ( 0.00%) .          .          .                       slice_remove(&mut parent_node.edge_area_mut(..old_parent_len + 1), parent_idx + 1);
    .          .          .          .                       parent_node.correct_childrens_parent_links(parent_idx + 1..old_parent_len);
   54 ( 0.00%) .          .          .                       *parent_node.len_mut() -= 1;
    .          .          .          .           
   78 ( 0.00%) .          .          .                       if parent_node.height > 1 {
    .          .          .          .                           // SAFETY: the height of the nodes being merged is one below the height
    .          .          .          .                           // of the node of this edge, thus above zero, so they are internal.
    .          .          .          .                           let mut left_node = left_node.reborrow_mut().cast_to_internal_unchecked();
    .          .          .          .                           let mut right_node = right_node.cast_to_internal_unchecked();
    .          .          .          .                           move_to_slice(
    2 ( 0.00%) .          .          .                               right_node.edge_area_mut(..right_len + 1),
    .          .          .          .                               left_node.edge_area_mut(old_left_len + 1..new_left_len + 1),
    .          .          .          .                           );
    .          .          .          .           
    .          .          .          .                           left_node.correct_childrens_parent_links(old_left_len + 1..new_left_len + 1);
    .          .          .          .           
    .          .          .          .                           alloc.deallocate(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());
    .          .          .          .                       } else {
    .          .          .          .                           alloc.deallocate(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());
    .          .          .          .                       }
    .          .          .          .                   }
    .          .          .          .                   result(parent_node, left_node)
  240 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Merges the parent's key-value pair and both adjacent child nodes into
    .          .          .          .               /// the left child node and returns the shrunk parent node.
    .          .          .          .               ///
    .          .          .          .               /// Panics unless we `.can_merge()`.
    .          .          .          .               pub fn merge_tracking_parent<A: Allocator + Clone>(
    .          .          .          .                   self,
    .          .          .          .                   alloc: A,
-- line 1440 ----------------------------------------
-- line 1445 ----------------------------------------
    .          .          .          .               /// Merges the parent's key-value pair and both adjacent child nodes into
    .          .          .          .               /// the left child node and returns that child node.
    .          .          .          .               ///
    .          .          .          .               /// Panics unless we `.can_merge()`.
    .          .          .          .               pub fn merge_tracking_child<A: Allocator + Clone>(
    .          .          .          .                   self,
    .          .          .          .                   alloc: A,
    .          .          .          .               ) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {
   72 ( 0.00%) .          .          .                   self.do_merge(|_parent, child| child, alloc)
10,190 ( 0.00%) 46 ( 0.01%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:alloc::collections::btree::node::BalancingContext<K,V>::do_merge (24x)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Merges the parent's key-value pair and both adjacent child nodes into
    .          .          .          .               /// the left child node and returns the edge handle in that child node
    .          .          .          .               /// where the tracked child edge ended up,
    .          .          .          .               ///
    .          .          .          .               /// Panics unless we `.can_merge()`.
    .          .          .          .               pub fn merge_tracking_child_edge<A: Allocator + Clone>(
    .          .          .          .                   self,
    .          .          .          .                   track_edge_idx: LeftOrRight<usize>,
    .          .          .          .                   alloc: A,
    .          .          .          .               ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {
    .          .          .          .                   let old_left_len = self.left_child.len();
    .          .          .          .                   let right_len = self.right_child.len();
   24 ( 0.00%) .          .          .                   assert!(match track_edge_idx {
   24 ( 0.00%) .          .          .                       LeftOrRight::Left(idx) => idx <= old_left_len,
    .          .          .          .                       LeftOrRight::Right(idx) => idx <= right_len,
    .          .          .          .                   });
    .          .          .          .                   let child = self.merge_tracking_child(alloc);
    .          .          .          .                   let new_idx = match track_edge_idx {
    .          .          .          .                       LeftOrRight::Left(idx) => idx,
    .          .          .          .                       LeftOrRight::Right(idx) => old_left_len + 1 + idx,
    .          .          .          .                   };
    .          .          .          .                   unsafe { Handle::new_edge(child, new_idx) }
-- line 1477 ----------------------------------------
-- line 1492 ----------------------------------------
    .          .          .          .               /// Removes a key-value pair from the right child and places it in the key-value storage
    .          .          .          .               /// of the parent, while pushing the old parent key-value pair onto the left child.
    .          .          .          .               /// Returns a handle to the edge in the left child specified by `track_left_edge_idx`,
    .          .          .          .               /// which didn't move.
    .          .          .          .               pub fn steal_right(
    .          .          .          .                   mut self,
    .          .          .          .                   track_left_edge_idx: usize,
    .          .          .          .               ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {
    2 ( 0.00%) .          .          .                   self.bulk_steal_right(1);
  135 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:alloc::collections::btree::node::BalancingContext<K,V>::bulk_steal_right (1x)
    .          .          .          .                   unsafe { Handle::new_edge(self.left_child, track_left_edge_idx) }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// This does stealing similar to `steal_left` but steals multiple elements at once.
    .          .          .          .               pub fn bulk_steal_left(&mut self, count: usize) {
    .          .          .          .                   assert!(count > 0);
    .          .          .          .                   unsafe {
    .          .          .          .                       let left_node = &mut self.left_child;
-- line 1508 ----------------------------------------
-- line 1560 ----------------------------------------
    .          .          .          .                           }
    .          .          .          .                           (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}
    .          .          .          .                           _ => unreachable!(),
    .          .          .          .                       }
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// The symmetric clone of `bulk_steal_left`.
   35 ( 0.00%) .          .          .               pub fn bulk_steal_right(&mut self, count: usize) {
    .          .          .          .                   assert!(count > 0);
    .          .          .          .                   unsafe {
    .          .          .          .                       let left_node = &mut self.left_child;
    .          .          .          .                       let old_left_len = left_node.len();
    .          .          .          .                       let right_node = &mut self.right_child;
    .          .          .          .                       let old_right_len = right_node.len();
    .          .          .          .           
    .          .          .          .                       // Make sure that we may steal safely.
   15 ( 0.00%) .          .          .                       assert!(old_left_len + count <= CAPACITY);
   10 ( 0.00%) .          .          .                       assert!(old_right_len >= count);
    .          .          .          .           
    .          .          .          .                       let new_left_len = old_left_len + count;
    .          .          .          .                       let new_right_len = old_right_len - count;
    5 ( 0.00%) .          .          .                       *left_node.len_mut() = new_left_len as u16;
    5 ( 0.00%) .          .          .                       *right_node.len_mut() = new_right_len as u16;
    .          .          .          .           
    .          .          .          .                       // Move leaf data.
    .          .          .          .                       {
    .          .          .          .                           // Move the rightmost stolen pair to the parent.
    5 ( 0.00%) .          .          .                           let k = right_node.key_area_mut(count - 1).assume_init_read();
    .          .          .          .                           let v = right_node.val_area_mut(count - 1).assume_init_read();
   10 ( 0.00%) .          .          .                           let (k, v) = self.parent.replace_kv(k, v);
    .          .          .          .           
    .          .          .          .                           // Move parent's key-value pair to the left child.
    .          .          .          .                           left_node.key_area_mut(old_left_len).write(k);
    .          .          .          .                           left_node.val_area_mut(old_left_len).write(v);
    .          .          .          .           
    .          .          .          .                           // Move elements from the right child to the left one.
    .          .          .          .                           move_to_slice(
    .          .          .          .                               right_node.key_area_mut(..count - 1),
    5 ( 0.00%) .          .          .                               left_node.key_area_mut(old_left_len + 1..new_left_len),
    .          .          .          .                           );
    .          .          .          .                           move_to_slice(
    .          .          .          .                               right_node.val_area_mut(..count - 1),
    .          .          .          .                               left_node.val_area_mut(old_left_len + 1..new_left_len),
    .          .          .          .                           );
    .          .          .          .           
    .          .          .          .                           // Fill gap where stolen elements used to be.
    .          .          .          .                           slice_shl(right_node.key_area_mut(..old_right_len), count);
    .          .          .          .                           slice_shl(right_node.val_area_mut(..old_right_len), count);
    .          .          .          .                       }
    .          .          .          .           
   10 ( 0.00%) .          .          .                       match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {
    .          .          .          .                           (ForceResult::Internal(mut left), ForceResult::Internal(mut right)) => {
    .          .          .          .                               // Steal edges.
    .          .          .          .                               move_to_slice(
    .          .          .          .                                   right.edge_area_mut(..count),
    .          .          .          .                                   left.edge_area_mut(old_left_len + 1..new_left_len + 1),
    .          .          .          .                               );
    .          .          .          .           
    .          .          .          .                               // Fill gap where stolen edges used to be.
-- line 1619 ----------------------------------------
-- line 1621 ----------------------------------------
    .          .          .          .           
    .          .          .          .                               left.correct_childrens_parent_links(old_left_len + 1..new_left_len + 1);
    .          .          .          .                               right.correct_childrens_parent_links(0..new_right_len + 1);
    .          .          .          .                           }
    .          .          .          .                           (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}
    .          .          .          .                           _ => unreachable!(),
    .          .          .          .                       }
    .          .          .          .                   }
   40 ( 0.00%) .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {
    .          .          .          .               pub fn forget_node_type(
    .          .          .          .                   self,
    .          .          .          .               ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::Edge> {
    .          .          .          .                   unsafe { Handle::new_edge(self.node.forget_type(), self.idx) }
    .          .          .          .               }
-- line 1637 ----------------------------------------
-- line 1796 ----------------------------------------
    .          .          .          .           ///
    .          .          .          .           /// # Safety
    .          .          .          .           /// The slice has more than `idx` elements.
    .          .          .          .           unsafe fn slice_insert<T>(slice: &mut [MaybeUninit<T>], idx: usize, val: T) {
    .          .          .          .               unsafe {
    .          .          .          .                   let len = slice.len();
    .          .          .          .                   debug_assert!(len > idx);
    .          .          .          .                   let slice_ptr = slice.as_mut_ptr();
1,934 ( 0.00%) .          .          .                   if len > idx + 1 {
  393 ( 0.00%) .          .          .                       ptr::copy(slice_ptr.add(idx), slice_ptr.add(idx + 1), len - idx - 1);
    .          .          .          .                   }
    .          .          .          .                   (*slice_ptr.add(idx)).write(val);
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Removes and returns a value from a slice of all initialized elements, leaving behind one
    .          .          .          .           /// trailing uninitialized element.
    .          .          .          .           ///
-- line 1813 ----------------------------------------
-- line 1814 ----------------------------------------
    .          .          .          .           /// # Safety
    .          .          .          .           /// The slice has more than `idx` elements.
    .          .          .          .           unsafe fn slice_remove<T>(slice: &mut [MaybeUninit<T>], idx: usize) -> T {
    .          .          .          .               unsafe {
    .          .          .          .                   let len = slice.len();
    .          .          .          .                   debug_assert!(idx < len);
    .          .          .          .                   let slice_ptr = slice.as_mut_ptr();
    .          .          .          .                   let ret = (*slice_ptr.add(idx)).assume_init_read();
  615 ( 0.00%) .          .          .                   ptr::copy(slice_ptr.add(idx + 1), slice_ptr.add(idx), len - idx - 1);
    .          .          .          .                   ret
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Shifts the elements in a slice `distance` positions to the left.
    .          .          .          .           ///
    .          .          .          .           /// # Safety
    .          .          .          .           /// The slice has at least `distance` elements.
-- line 1830 ----------------------------------------
-- line 1845 ----------------------------------------
    .          .          .          .                   ptr::copy(slice_ptr, slice_ptr.add(distance), slice.len() - distance);
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Moves all values from a slice of initialized elements to a slice
    .          .          .          .           /// of uninitialized elements, leaving behind `src` as all uninitialized.
    .          .          .          .           /// Works like `dst.copy_from_slice(src)` but does not require `T` to be `Copy`.
    .          .          .          .           fn move_to_slice<T>(src: &mut [MaybeUninit<T>], dst: &mut [MaybeUninit<T>]) {
   22 ( 0.00%) .          .          .               assert!(src.len() == dst.len());
    .          .          .          .               unsafe {
    .          .          .          .                   ptr::copy_nonoverlapping(src.as_ptr(), dst.as_mut_ptr(), src.len());
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           #[cfg(test)]
    .          .          .          .           mod tests;

8,935 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 20 ----------------------------------------
     .          .          .          .           
     .          .          .          .           macro non_null {
     .          .          .          .               (mut $place:expr, $t:ident) => {{
     .          .          .          .                   #![allow(unused_unsafe)] // we're sometimes used within an unsafe block
     .          .          .          .                   unsafe { &mut *((&raw mut $place) as *mut NonNull<$t>) }
     .          .          .          .               }},
     .          .          .          .               ($place:expr, $t:ident) => {{
     .          .          .          .                   #![allow(unused_unsafe)] // we're sometimes used within an unsafe block
     1 ( 0.00%) .          .          .                   unsafe { *((&raw const $place) as *const NonNull<$t>) }
     .          .          .          .               }},
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// An iterator that moves out of a vector.
     .          .          .          .           ///
     .          .          .          .           /// This `struct` is created by the `into_iter` method on [`Vec`](super::Vec)
     .          .          .          .           /// (provided by the [`IntoIterator`] trait).
     .          .          .          .           ///
-- line 36 ----------------------------------------
-- line 105 ----------------------------------------
     .          .          .          .               /// Returns a reference to the underlying allocator.
     .          .          .          .               #[unstable(feature = "allocator_api", issue = "32838")]
     .          .          .          .               #[inline]
     .          .          .          .               pub fn allocator(&self) -> &A {
     .          .          .          .                   &self.alloc
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               fn as_raw_mut_slice(&mut self) -> *mut [T] {
    38 ( 0.00%) .          .          .                   ptr::slice_from_raw_parts_mut(self.ptr.as_ptr(), self.len())
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Drops remaining elements and relinquishes the backing allocation.
     .          .          .          .               ///
     .          .          .          .               /// This method guarantees it won't panic before relinquishing the backing
     .          .          .          .               /// allocation.
     .          .          .          .               ///
     .          .          .          .               /// This is roughly equivalent to the following, but more efficient
-- line 121 ----------------------------------------
-- line 210 ----------------------------------------
     .          .          .          .                       if self.ptr.as_ptr() == self.end as *mut T {
     .          .          .          .                           return None;
     .          .          .          .                       }
     .          .          .          .                       // `ptr` has to stay where it is to remain aligned, so we reduce the length by 1 by
     .          .          .          .                       // reducing the `end`.
     .          .          .          .                       self.end = self.end.wrapping_byte_sub(1);
     .          .          .          .                       self.ptr
     .          .          .          .                   } else {
58,431 ( 0.02%) .          .          .                       if self.ptr == non_null!(self.end, T) {
     .          .          .          .                           return None;
     .          .          .          .                       }
     .          .          .          .                       let old = self.ptr;
    42 ( 0.00%) .          .          .                       self.ptr = unsafe { old.add(1) };
     .          .          .          .                       old
     .          .          .          .                   };
     .          .          .          .                   Some(unsafe { ptr.read() })
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               fn size_hint(&self) -> (usize, Option<usize>) {
     .          .          .          .                   let exact = if T::IS_ZST {
-- line 230 ----------------------------------------
-- line 304 ----------------------------------------
     .          .          .          .                           // SAFETY: we just checked that `self.ptr` is in bounds.
     .          .          .          .                           let tmp = unsafe { self.ptr.read() };
     .          .          .          .                           // See `next` for why we subtract from `end` here.
     .          .          .          .                           self.end = self.end.wrapping_byte_sub(1);
     .          .          .          .                           accum = f(accum, tmp);
     .          .          .          .                       }
     .          .          .          .                   } else {
     .          .          .          .                       // SAFETY: `self.end` can only be null if `T` is a ZST.
 1,081 ( 0.00%) .          .          .                       while self.ptr != non_null!(self.end, T) {
     .          .          .          .                           // SAFETY: we just checked that `self.ptr` is in bounds.
     .          .          .          .                           let tmp = unsafe { self.ptr.read() };
     .          .          .          .                           // SAFETY: the maximum this can be is `self.end`.
     .          .          .          .                           // Increment `self.ptr` first to avoid double dropping in the event of a panic.
     .          .          .          .                           self.ptr = unsafe { self.ptr.add(1) };
 1,053 ( 0.00%) .          .          .                           accum = f(accum, tmp);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   accum
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               fn try_fold<B, F, R>(&mut self, mut accum: B, mut f: F) -> R
     .          .          .          .               where
     .          .          .          .                   Self: Sized,
-- line 326 ----------------------------------------
-- line 479 ----------------------------------------
     .          .          .          .               #[cfg(test)]
     .          .          .          .               fn clone(&self) -> Self {
     .          .          .          .                   crate::slice::to_vec(self.as_slice(), self.alloc.deref().clone()).into_iter()
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .           unsafe impl<#[may_dangle] T, A: Allocator> Drop for IntoIter<T, A> {
    12 ( 0.00%) .          .          .               fn drop(&mut self) {
     .          .          .          .                   struct DropGuard<'a, T, A: Allocator>(&'a mut IntoIter<T, A>);
     .          .          .          .           
     .          .          .          .                   impl<T, A: Allocator> Drop for DropGuard<'_, T, A> {
     .          .          .          .                       fn drop(&mut self) {
     .          .          .          .                           unsafe {
     .          .          .          .                               // `IntoIter::alloc` is not used anymore after this and will be dropped by RawVec
     .          .          .          .                               let alloc = ManuallyDrop::take(&mut self.0.alloc);
     .          .          .          .                               // RawVec handles deallocation
    78 ( 0.00%) .          .          .                               let _ = RawVec::from_nonnull_in(self.0.buf, self.0.cap, alloc);
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .           
     .          .          .          .                   let guard = DropGuard(self);
     .          .          .          .                   // destroy the remaining elements
     .          .          .          .                   unsafe {
     .          .          .          .                       ptr::drop_in_place(guard.0.as_raw_mut_slice());
-- line 504 ----------------------------------------

86,580 ( 0.03%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 1498 ----------------------------------------
      .          .          .          .           /// Therefore, implementations must not require the user to uphold
      .          .          .          .           /// any safety invariants.
      .          .          .          .           ///
      .          .          .          .           /// This intrinsic does not have a stable counterpart.
      .          .          .          .           #[unstable(feature = "core_intrinsics", issue = "none")]
      .          .          .          .           #[rustc_nounwind]
      .          .          .          .           #[inline(always)]
      .          .          .          .           pub const fn likely(b: bool) -> bool {
 12,533 ( 0.00%) .          .          .               if b {
      .          .          .          .                   true
      .          .          .          .               } else {
      .          .          .          .                   cold_path();
      .          .          .          .                   false
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Hints to the compiler that branch condition is likely to be false.
-- line 1514 ----------------------------------------
-- line 1521 ----------------------------------------
      .          .          .          .           /// Therefore, implementations must not require the user to uphold
      .          .          .          .           /// any safety invariants.
      .          .          .          .           ///
      .          .          .          .           /// This intrinsic does not have a stable counterpart.
      .          .          .          .           #[unstable(feature = "core_intrinsics", issue = "none")]
      .          .          .          .           #[rustc_nounwind]
      .          .          .          .           #[inline(always)]
      .          .          .          .           pub const fn unlikely(b: bool) -> bool {
502,853 ( 0.15%) .          .          .               if b {
      .          .          .          .                   cold_path();
      .          .          .          .                   true
      .          .          .          .               } else {
      .          .          .          .                   false
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Returns either `true_val` or `false_val` depending on condition `b` with a
-- line 1537 ----------------------------------------
-- line 4382 ----------------------------------------
      .          .          .          .                       ub_checks::maybe_is_aligned_and_not_null(src, align, zero_size)
      .          .          .          .                           && ub_checks::maybe_is_aligned_and_not_null(dst, align, zero_size)
      .          .          .          .                           && ub_checks::maybe_is_nonoverlapping(src, dst, size, count)
      .          .          .          .                   }
      .          .          .          .               );
      .          .          .          .           
      .          .          .          .               // SAFETY: the safety contract for `copy_nonoverlapping` must be
      .          .          .          .               // upheld by the caller.
374,115 ( 0.11%) .          .          .               unsafe { copy_nonoverlapping(src, dst, count) }
    510 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (30x)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source
      .          .          .          .           /// and destination may overlap.
      .          .          .          .           ///
      .          .          .          .           /// If the source and destination will *never* overlap,
      .          .          .          .           /// [`copy_nonoverlapping`] can be used instead.
      .          .          .          .           ///
-- line 4398 ----------------------------------------
-- line 4480 ----------------------------------------
      .          .          .          .                           src: *const () = src as *const (),
      .          .          .          .                           dst: *mut () = dst as *mut (),
      .          .          .          .                           align: usize = align_of::<T>(),
      .          .          .          .                           zero_size: bool = T::IS_ZST || count == 0,
      .          .          .          .                       ) =>
      .          .          .          .                       ub_checks::maybe_is_aligned_and_not_null(src, align, zero_size)
      .          .          .          .                           && ub_checks::maybe_is_aligned_and_not_null(dst, align, zero_size)
      .          .          .          .                   );
 40,621 ( 0.01%) .          .          .                   copy(src, dst, count)
     26 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2x)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to
      .          .          .          .           /// `val`.
      .          .          .          .           ///
      .          .          .          .           /// `write_bytes` is similar to C's [`memset`], but sets `count *
      .          .          .          .           /// size_of::<T>()` bytes to `val`.
-- line 4496 ----------------------------------------
-- line 4560 ----------------------------------------
      .          .          .          .                       check_language_ub,
      .          .          .          .                       "ptr::write_bytes requires that the destination pointer is aligned and non-null",
      .          .          .          .                       (
      .          .          .          .                           addr: *const () = dst as *const (),
      .          .          .          .                           align: usize = align_of::<T>(),
      .          .          .          .                           zero_size: bool = T::IS_ZST || count == 0,
      .          .          .          .                       ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, zero_size)
      .          .          .          .                   );
  1,121 ( 0.00%) .          .          .                   write_bytes(dst, val, count)
    143 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (13x)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Returns the minimum of two `f16` values.
      .          .          .          .           ///
      .          .          .          .           /// Note that, unlike most intrinsics, this is safe to call;
      .          .          .          .           /// it does not require an `unsafe` block.
      .          .          .          .           /// Therefore, implementations must not require the user to uphold
-- line 4576 ----------------------------------------

296,687 ( 0.09%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 756 ----------------------------------------
        .          .          .          .           
        .          .          .          .                   NonZero::new(n - taken).map_or(Ok(()), Err)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {
        .          .          .          .               #[inline]
        .          .          .          .               fn spec_next(&mut self) -> Option<T> {
  444,533 ( 0.13%) .          .          .                   if self.start < self.end {
        .          .          .          .                       let old = self.start;
        .          .          .          .                       // SAFETY: just checked precondition
      290 ( 0.00%) .          .          .                       self.start = unsafe { Step::forward_unchecked(old, 1) };
        .          .          .          .                       Some(old)
        .          .          .          .                   } else {
        .          .          .          .                       None
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn spec_nth(&mut self, n: usize) -> Option<T> {
-- line 775 ----------------------------------------
-- line 798 ----------------------------------------
        .          .          .          .                   // Otherwise 0 is returned which always safe to use.
        .          .          .          .                   self.start = unsafe { Step::forward_unchecked(self.start, taken) };
        .          .          .          .           
        .          .          .          .                   NonZero::new(n - taken).map_or(Ok(()), Err)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn spec_next_back(&mut self) -> Option<T> {
      543 ( 0.00%) .          .          .                   if self.start < self.end {
        .          .          .          .                       // SAFETY: just checked precondition
      290 ( 0.00%) .          .          .                       self.end = unsafe { Step::backward_unchecked(self.end, 1) };
        .          .          .          .                       Some(self.end)
        .          .          .          .                   } else {
        .          .          .          .                       None
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn spec_nth_back(&mut self, n: usize) -> Option<T> {
-- line 816 ----------------------------------------
-- line 846 ----------------------------------------
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn next(&mut self) -> Option<A> {
        .          .          .          .                   self.spec_next()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn size_hint(&self) -> (usize, Option<usize>) {
        4 ( 0.00%) .          .          .                   if self.start < self.end {
        .          .          .          .                       Step::steps_between(&self.start, &self.end)
        .          .          .          .                   } else {
        .          .          .          .                       (0, Some(0))
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn count(self) -> usize {
-- line 862 ----------------------------------------
-- line 1153 ----------------------------------------
        .          .          .          .           
        .          .          .          .           impl<T: TrustedStep> RangeInclusiveIteratorImpl for ops::RangeInclusive<T> {
        .          .          .          .               #[inline]
        .          .          .          .               fn spec_next(&mut self) -> Option<T> {
        .          .          .          .                   if self.is_empty() {
        .          .          .          .                       return None;
        .          .          .          .                   }
        .          .          .          .                   let is_iterating = self.start < self.end;
1,046,174 ( 0.31%) .          .          .                   Some(if is_iterating {
        .          .          .          .                       // SAFETY: just checked precondition
        .          .          .          .                       let n = unsafe { Step::forward_unchecked(self.start, 1) };
        .          .          .          .                       mem::replace(&mut self.start, n)
        .          .          .          .                   } else {
        .          .          .          .                       self.exhausted = true;
        .          .          .          .                       self.start
        .          .          .          .                   })
        .          .          .          .               }
-- line 1169 ----------------------------------------
-- line 1170 ----------------------------------------
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn spec_try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R
        .          .          .          .               where
        .          .          .          .                   Self: Sized,
        .          .          .          .                   F: FnMut(B, T) -> R,
        .          .          .          .                   R: Try<Output = B>,
        .          .          .          .               {
    2,240 ( 0.00%) .          .          .                   if self.is_empty() {
        .          .          .          .                       return try { init };
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   let mut accum = init;
        .          .          .          .           
    1,120 ( 0.00%) .          .          .                   while self.start < self.end {
        .          .          .          .                       // SAFETY: just checked precondition
        .          .          .          .                       let n = unsafe { Step::forward_unchecked(self.start, 1) };
        .          .          .          .                       let n = mem::replace(&mut self.start, n);
        .          .          .          .                       accum = f(accum, n)?;
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   self.exhausted = true;
        .          .          .          .           
-- line 1192 ----------------------------------------

   15,447 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 181 ----------------------------------------
     .          .          .          .               /// **WARNING:** This is only useful for debugging DFAs. Disabling this
     .          .          .          .               /// does not yield any speed advantages. Namely, even when this is
     .          .          .          .               /// disabled, a byte class map is still used while searching. The only
     .          .          .          .               /// difference is that every byte will be forced into its own distinct
     .          .          .          .               /// equivalence class. This is useful for debugging the actual generated
     .          .          .          .               /// transitions because it lets one see the transitions defined on actual
     .          .          .          .               /// bytes instead of the equivalence classes.
     .          .          .          .               pub fn byte_classes(mut self, yes: bool) -> Config {
   162 ( 0.00%) .          .          .                   self.byte_classes = Some(yes);
     .          .          .          .                   self
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set a size limit on the total heap used by a one-pass DFA.
     .          .          .          .               ///
     .          .          .          .               /// This size limit is expressed in bytes and is applied during
     .          .          .          .               /// construction of a one-pass DFA. If the DFA's heap usage exceeds
     .          .          .          .               /// this configured limit, then construction is stopped and an error is
-- line 197 ----------------------------------------
-- line 234 ----------------------------------------
     .          .          .          .               /// `(?-u:\w{20})`. So only use Unicode if you need it!
     .          .          .          .               pub fn size_limit(mut self, limit: Option<usize>) -> Config {
     .          .          .          .                   self.size_limit = Some(limit);
     .          .          .          .                   self
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the match semantics set in this configuration.
     .          .          .          .               pub fn get_match_kind(&self) -> MatchKind {
     1 ( 0.00%) .          .          .                   self.match_kind.unwrap_or(MatchKind::LeftmostFirst)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns whether this configuration has enabled anchored starting states
     .          .          .          .               /// for every pattern in the DFA.
     .          .          .          .               pub fn get_starts_for_each_pattern(&self) -> bool {
    81 ( 0.00%) .          .          .                   self.starts_for_each_pattern.unwrap_or(false)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns whether this configuration has enabled byte classes or not.
     .          .          .          .               /// This is typically a debugging oriented option, as disabling it confers
     .          .          .          .               /// no speed benefit.
     .          .          .          .               pub fn get_byte_classes(&self) -> bool {
     .          .          .          .                   self.byte_classes.unwrap_or(true)
     .          .          .          .               }
-- line 256 ----------------------------------------
-- line 264 ----------------------------------------
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Overwrite the default configuration such that the options in `o` are
     .          .          .          .               /// always used. If an option in `o` is not set, then the corresponding
     .          .          .          .               /// option in `self` is used. If it's not set in `self` either, then it
     .          .          .          .               /// remains not set.
     .          .          .          .               pub(crate) fn overwrite(&self, o: Config) -> Config {
     .          .          .          .                   Config {
   243 ( 0.00%) .          .          .                       match_kind: o.match_kind.or(self.match_kind),
     .          .          .          .                       starts_for_each_pattern: o
     .          .          .          .                           .starts_for_each_pattern
     .          .          .          .                           .or(self.starts_for_each_pattern),
     .          .          .          .                       byte_classes: o.byte_classes.or(self.byte_classes),
     .          .          .          .                       size_limit: o.size_limit.or(self.size_limit),
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           }
-- line 280 ----------------------------------------
-- line 387 ----------------------------------------
     .          .          .          .               ///     .build(r"[a-z0-9]+")?;
     .          .          .          .               /// let re = DFA::builder().build_from_nfa(nfa)?;
     .          .          .          .               /// let (mut cache, mut caps) = (re.create_cache(), re.create_captures());
     .          .          .          .               /// re.captures(&mut cache, "foo123bar", &mut caps);
     .          .          .          .               /// assert_eq!(Some(Match::must(0, 0..9)), caps.get_match());
     .          .          .          .               ///
     .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
     .          .          .          .               /// ```
   729 ( 0.00%) .          .          .               pub fn build_from_nfa(&self, nfa: NFA) -> Result<DFA, BuildError> {
     .          .          .          .                   // Why take ownership if we're just going to pass a reference to the
     .          .          .          .                   // NFA to our internal builder? Well, the first thing to note is that
     .          .          .          .                   // an NFA uses reference counting internally, so either choice is going
     .          .          .          .                   // to be cheap. So there isn't much cost either way.
     .          .          .          .                   //
     .          .          .          .                   // The real reason is that a one-pass DFA, semantically, shares
     .          .          .          .                   // ownership of an NFA. This is unlike other DFAs that don't share
     .          .          .          .                   // ownership of an NFA at all, primarily because they want to be
-- line 403 ----------------------------------------
-- line 405 ----------------------------------------
     .          .          .          .                   //
     .          .          .          .                   // But then why pass a '&nfa' below if we want to share ownership?
     .          .          .          .                   // Well, it turns out that using a '&NFA' in our internal builder
     .          .          .          .                   // separates its lifetime from the DFA we're building, and this turns
     .          .          .          .                   // out to make code a bit more composable. e.g., We can iterate over
     .          .          .          .                   // things inside the NFA while borrowing the builder as mutable because
     .          .          .          .                   // we know the NFA cannot be mutated. So TL;DR --- this weirdness is
     .          .          .          .                   // "because borrow checker."
   567 ( 0.00%) .          .          .                   InternalBuilder::new(self.config.clone(), &nfa).build()
   729 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Apply the given one-pass DFA configuration options to this builder.
     .          .          .          .               pub fn configure(&mut self, config: Config) -> &mut Builder {
   486 ( 0.00%) .          .          .                   self.config = self.config.overwrite(config);
     .          .          .          .                   self
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set the syntax configuration for this builder using
     .          .          .          .               /// [`syntax::Config`](crate::util::syntax::Config).
     .          .          .          .               ///
     .          .          .          .               /// This permits setting things like case insensitivity, Unicode and multi
     .          .          .          .               /// line mode.
-- line 426 ----------------------------------------
-- line 517 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// This is duplicated in dfa.classes.
     .          .          .          .               classes: ByteClasses,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<'a> InternalBuilder<'a> {
     .          .          .          .               /// Create a new builder with an initial empty DFA.
     .          .          .          .               fn new(config: Config, nfa: &'a NFA) -> InternalBuilder<'a> {
   162 ( 0.00%) .          .          .                   let classes = if !config.get_byte_classes() {
     .          .          .          .                       // A one-pass DFA will always use the equivalence class map, but
     .          .          .          .                       // enabling this option is useful for debugging. Namely, this will
     .          .          .          .                       // cause all transitions to be defined over their actual bytes
     .          .          .          .                       // instead of an opaque equivalence class identifier. The former is
     .          .          .          .                       // much easier to grok as a human.
     .          .          .          .                       ByteClasses::singletons()
     .          .          .          .                   } else {
     .          .          .          .                       nfa.byte_classes().clone()
-- line 533 ----------------------------------------
-- line 555 ----------------------------------------
     .          .          .          .                       min_match_id: StateID::MAX,
     .          .          .          .                       classes: classes.clone(),
     .          .          .          .                       alphabet_len,
     .          .          .          .                       stride2,
     .          .          .          .                       pateps_offset: alphabet_len,
     .          .          .          .                       // OK because PatternID::MAX*2 is guaranteed not to overflow.
     .          .          .          .                       explicit_slot_start: nfa.pattern_len().checked_mul(2).unwrap(),
     .          .          .          .                   };
 5,346 ( 0.00%) .          .          .                   InternalBuilder {
     .          .          .          .                       dfa,
     .          .          .          .                       uncompiled_nfa_ids: vec![],
     .          .          .          .                       nfa_to_dfa_id: vec![DEAD; nfa.states().len()],
     .          .          .          .                       stack: vec![],
     .          .          .          .                       seen: SparseSet::new(nfa.states().len()),
     .          .          .          .                       matched: false,
     .          .          .          .                       config,
     .          .          .          .                       nfa,
 3,240 ( 0.00%) .          .          .                       classes,
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Build the DFA from the NFA given to this builder. If the NFA is not
     .          .          .          .               /// one-pass, then return an error. An error may also be returned if a
     .          .          .          .               /// particular limit is exceeded. (Some limits, like the total heap memory
     .          .          .          .               /// used, are configurable. Others, like the total patterns or slots, are
     .          .          .          .               /// hard-coded based on representational limitations.)
-- line 580 ----------------------------------------
-- line 581 ----------------------------------------
     .          .          .          .               fn build(mut self) -> Result<DFA, BuildError> {
     .          .          .          .                   self.nfa.look_set_any().available().map_err(BuildError::word)?;
     .          .          .          .                   for look in self.nfa.look_set_any().iter() {
     .          .          .          .                       // This is a future incompatibility check where if we add any
     .          .          .          .                       // more look-around assertions, then the one-pass DFA either
     .          .          .          .                       // needs to reject them (what we do here) or it needs to have its
     .          .          .          .                       // Transition representation modified to be capable of storing the
     .          .          .          .                       // new assertions.
   244 ( 0.00%) .          .          .                       if look.as_repr() > Look::WordUnicodeNegate.as_repr() {
     .          .          .          .                           return Err(BuildError::unsupported_look(look));
     .          .          .          .                       }
     .          .          .          .                   }
   162 ( 0.00%) .          .          .                   if self.nfa.pattern_len().as_u64() > PatternEpsilons::PATTERN_ID_LIMIT
     .          .          .          .                   {
     .          .          .          .                       return Err(BuildError::too_many_patterns(
     .          .          .          .                           PatternEpsilons::PATTERN_ID_LIMIT,
     .          .          .          .                       ));
     .          .          .          .                   }
   162 ( 0.00%) .          .          .                   if self.nfa.group_info().explicit_slot_len() > Slots::LIMIT {
     .          .          .          .                       return Err(BuildError::not_one_pass(
     .          .          .          .                           "too many explicit capturing groups (max is 16)",
     .          .          .          .                       ));
     .          .          .          .                   }
     .          .          .          .                   assert_eq!(DEAD, self.add_empty_state()?);
     .          .          .          .           
     .          .          .          .                   // This is where the explicit slots start. We care about this because
     .          .          .          .                   // we only need to track explicit slots. The implicit slots---two for
     .          .          .          .                   // each pattern---are tracked as part of the search routine itself.
     .          .          .          .                   let explicit_slot_start = self.nfa.pattern_len() * 2;
    81 ( 0.00%) .          .          .                   self.add_start_state(None, self.nfa.start_anchored())?;
   162 ( 0.00%) .          .          .                   if self.config.get_starts_for_each_pattern() {
   324 ( 0.00%) .          .          .                       for pid in self.nfa.patterns() {
   486 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:regex_automata::nfa::thompson::nfa::NFA::patterns (81x)
     .          .          .          .                           self.add_start_state(
     .          .          .          .                               Some(pid),
   162 ( 0.00%) .          .          .                               self.nfa.start_pattern(pid).unwrap(),
     .          .          .          .                           )?;
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   // NOTE: One wonders what the effects of treating 'uncompiled_nfa_ids'
     .          .          .          .                   // as a stack are. It is really an unordered *set* of NFA state IDs.
     .          .          .          .                   // If it, for example, in practice led to discovering whether a regex
     .          .          .          .                   // was or wasn't one-pass later than if we processed NFA state IDs in
     .          .          .          .                   // ascending order, then that would make this routine more costly in
     .          .          .          .                   // the somewhat common case of a regex that isn't one-pass.
     .          .          .          .                   while let Some(nfa_id) = self.uncompiled_nfa_ids.pop() {
   392 ( 0.00%) .          .          .                       let dfa_id = self.nfa_to_dfa_id[nfa_id];
     .          .          .          .                       // Once we see a match, we keep going, but don't add any new
     .          .          .          .                       // transitions. Normally we'd just stop, but we have to keep
     .          .          .          .                       // going in order to verify that our regex is actually one-pass.
   392 ( 0.00%) .          .          .                       self.matched = false;
     .          .          .          .                       // The NFA states we've already explored for this DFA state.
     .          .          .          .                       self.seen.clear();
     .          .          .          .                       // The NFA states to explore via epsilon transitions. If we ever
     .          .          .          .                       // try to push an NFA state that we've already seen, then the NFA
     .          .          .          .                       // is not one-pass because it implies there are multiple epsilon
     .          .          .          .                       // transition paths that lead to the same NFA state. In other
     .          .          .          .                       // words, there is ambiguity.
 1,176 ( 0.00%) .          .          .                       self.stack_push(nfa_id, Epsilons::empty())?;
35,071 ( 0.01%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push (392x)
     .          .          .          .                       while let Some((id, epsilons)) = self.stack.pop() {
11,990 ( 0.00%) .          .          .                           match *self.nfa.state(id) {
     .          .          .          .                               thompson::State::ByteRange { ref trans } => {
 1,950 ( 0.00%) .          .          .                                   self.compile_transition(dfa_id, trans, epsilons)?;
260,445 ( 0.08%) 245 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::compile_transition (390x)
     .          .          .          .                               }
     .          .          .          .                               thompson::State::Sparse(ref sparse) => {
 1,040 ( 0.00%) .          .          .                                   for trans in sparse.transitions.iter() {
 2,122 ( 0.00%) .          .          .                                       self.compile_transition(dfa_id, trans, epsilons)?;
     .          .          .          .                                   }
     .          .          .          .                               }
     .          .          .          .                               thompson::State::Dense(ref dense) => {
     .          .          .          .                                   for trans in dense.iter() {
     .          .          .          .                                       self.compile_transition(dfa_id, &trans, epsilons)?;
     .          .          .          .                                   }
     .          .          .          .                               }
    66 ( 0.00%) .          .          .                               thompson::State::Look { look, next } => {
     .          .          .          .                                   let looks = epsilons.looks().insert(look);
     .          .          .          .                                   self.stack_push(next, epsilons.set_looks(looks))?;
     .          .          .          .                               }
     .          .          .          .                               thompson::State::Union { ref alternates } => {
 1,720 ( 0.00%) .          .          .                                   for &sid in alternates.iter().rev() {
 3,288 ( 0.00%) .          .          .                                       self.stack_push(sid, epsilons)?;
163,410 ( 0.05%) 258 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push (1,644x)
     .          .          .          .                                   }
     .          .          .          .                               }
   224 ( 0.00%) .          .          .                               thompson::State::BinaryUnion { alt1, alt2 } => {
   560 ( 0.00%) .          .          .                                   self.stack_push(alt2, epsilons)?;
 5,687 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push (112x)
   560 ( 0.00%) .          .          .                                   self.stack_push(alt1, epsilons)?;
 5,692 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::stack_push (112x)
     .          .          .          .                               }
   346 ( 0.00%) .          .          .                               thompson::State::Capture { next, slot, .. } => {
     .          .          .          .                                   let slot = slot.as_usize();
   692 ( 0.00%) .          .          .                                   let epsilons = if slot < explicit_slot_start {
     .          .          .          .                                       // If this is an implicit slot, we don't care
     .          .          .          .                                       // about it, since we handle implicit slots in
     .          .          .          .                                       // the search routine. We can get away with that
     .          .          .          .                                       // because there are 2 implicit slots for every
     .          .          .          .                                       // pattern.
     .          .          .          .                                       epsilons
     .          .          .          .                                   } else {
     .          .          .          .                                       // Offset our explicit slots so that they start
-- line 677 ----------------------------------------
-- line 679 ----------------------------------------
     .          .          .          .                                       let offset = slot - explicit_slot_start;
     .          .          .          .                                       epsilons.set_slots(epsilons.slots().insert(offset))
     .          .          .          .                                   };
     .          .          .          .                                   self.stack_push(next, epsilons)?;
     .          .          .          .                               }
     .          .          .          .                               thompson::State::Fail => {
     .          .          .          .                                   continue;
     .          .          .          .                               }
     1 ( 0.00%) .          .          .                               thompson::State::Match { pattern_id } => {
     .          .          .          .                                   // If we found two different paths to a match state
     .          .          .          .                                   // for the same DFA state, then we have ambiguity.
     .          .          .          .                                   // Thus, it's not one-pass.
     2 ( 0.00%) .          .          .                                   if self.matched {
     .          .          .          .                                       return Err(BuildError::not_one_pass(
     .          .          .          .                                           "multiple epsilon transitions to match state",
     .          .          .          .                                       ));
     .          .          .          .                                   }
     1 ( 0.00%) .          .          .                                   self.matched = true;
     .          .          .          .                                   // Shove the matching pattern ID and the 'epsilons'
     .          .          .          .                                   // into the current DFA state's pattern epsilons. The
     .          .          .          .                                   // 'epsilons' includes the slots we need to capture
     .          .          .          .                                   // before reporting the match and also the conditional
     .          .          .          .                                   // epsilon transitions we need to check before we can
     .          .          .          .                                   // report a match.
     .          .          .          .                                   self.dfa.set_pattern_epsilons(
     .          .          .          .                                       dfa_id,
-- line 704 ----------------------------------------
-- line 712 ----------------------------------------
     .          .          .          .                                   // actually need to keep going in order to verify that
     .          .          .          .                                   // we actually have a one-pass regex. e.g., We might
     .          .          .          .                                   // see more Match states (e.g., for other patterns)
     .          .          .          .                                   // that imply that we don't have a one-pass regex.
     .          .          .          .                                   // So instead, we mark that we've found a match and
     .          .          .          .                                   // continue on. When we go to compile a new DFA state,
     .          .          .          .                                   // we just skip that part. But otherwise check that the
     .          .          .          .                                   // one-pass property is upheld.
     1 ( 0.00%) .          .          .                               }
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   }
     1 ( 0.00%) .          .          .                   self.shuffle_states();
106,698 ( 0.03%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::shuffle_states (1x)
     .          .          .          .                   self.dfa.starts.shrink_to_fit();
     .          .          .          .                   self.dfa.table.shrink_to_fit();
     3 ( 0.00%) .          .          .                   Ok(self.dfa)
    65 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
     2 ( 0.00%) .          .          .               }
   213 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_automata::util::sparse_set::SparseSet> (1x)
     .          .          .          .           
     .          .          .          .               /// Shuffle all match states to the end of the transition table and set
     .          .          .          .               /// 'min_match_id' to the ID of the first such match state.
     .          .          .          .               ///
     .          .          .          .               /// The point of this is to make it extremely cheap to determine whether
     .          .          .          .               /// a state is a match state or not. We need to check on this on every
     .          .          .          .               /// transition during a search, so it being cheap is important. This
     .          .          .          .               /// permits us to check it by simply comparing two state identifiers, as
     .          .          .          .               /// opposed to looking for the pattern ID in the state's `PatternEpsilons`.
     .          .          .          .               /// (Which requires a memory load and some light arithmetic.)
     5 ( 0.00%) .          .          .               fn shuffle_states(&mut self) {
     .          .          .          .                   let mut remapper = Remapper::new(&self.dfa);
     .          .          .          .                   let mut next_dest = self.dfa.last_state_id();
     .          .          .          .                   for i in (0..self.dfa.state_len()).rev() {
     .          .          .          .                       let id = StateID::must(i);
     .          .          .          .                       let is_match =
     .          .          .          .                           self.dfa.pattern_epsilons(id).pattern_id().is_some();
    74 ( 0.00%) .          .          .                       if !is_match {
     .          .          .          .                           continue;
     .          .          .          .                       }
     5 ( 0.00%) .          .          .                       remapper.swap(&mut self.dfa, next_dest, id);
 1,956 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/remapper.rs:regex_automata::dfa::remapper::Remapper::swap (1x)
     1 ( 0.00%) .          .          .                       self.dfa.min_match_id = next_dest;
     .          .          .          .                       next_dest = self.dfa.prev_state_id(next_dest).expect(
     .          .          .          .                           "match states should be a proper subset of all states",
     .          .          .          .                       );
     .          .          .          .                   }
     7 ( 0.00%) .          .          .                   remapper.remap(&mut self.dfa);
103,711 ( 0.03%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/remapper.rs:regex_automata::dfa::remapper::Remapper::remap (1x)
     6 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Compile the given NFA transition into the DFA state given.
     .          .          .          .               ///
     .          .          .          .               /// 'Epsilons' corresponds to any conditional epsilon transitions that need
     .          .          .          .               /// to be satisfied to follow this transition, and any slots that need to
     .          .          .          .               /// be saved if the transition is followed.
     .          .          .          .               ///
     .          .          .          .               /// If this transition indicates that the NFA is not one-pass, then
     .          .          .          .               /// this returns an error. (This occurs, for example, if the DFA state
     .          .          .          .               /// already has a transition defined for the same input symbols as the
     .          .          .          .               /// given transition, *and* the result of the old and new transitions is
     .          .          .          .               /// different.)
 5,460 ( 0.00%) .          .          .               fn compile_transition(
     .          .          .          .                   &mut self,
     .          .          .          .                   dfa_id: StateID,
     .          .          .          .                   trans: &thompson::Transition,
     .          .          .          .                   epsilons: Epsilons,
     .          .          .          .               ) -> Result<(), BuildError> {
 1,841 ( 0.00%) .          .          .                   let next_dfa_id = self.add_dfa_state_for_nfa_state(trans.next)?;
218,899 ( 0.07%) 245 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (390x)
     .          .          .          .                   for byte in self
     .          .          .          .                       .classes
   390 ( 0.00%) .          .          .                       .representatives(trans.start..=trans.end)
     .          .          .          .                       .filter_map(|r| r.as_u8())
     .          .          .          .                   {
     .          .          .          .                       let oldtrans = self.dfa.transition(dfa_id, byte);
     .          .          .          .                       let newtrans =
   778 ( 0.00%) .          .          .                           Transition::new(self.matched, next_dfa_id, epsilons);
     .          .          .          .                       // If the old transition points to the DEAD state, then we know
     .          .          .          .                       // 'byte' has not been mapped to any transition for this DFA state
     .          .          .          .                       // yet. So set it unconditionally. Otherwise, we require that the
     .          .          .          .                       // old and new transitions are equivalent. Otherwise, there is
     .          .          .          .                       // ambiguity and thus the regex is not one-pass.
 1,851 ( 0.00%) .          .          .                       if oldtrans.state_id() == DEAD {
     .          .          .          .                           self.dfa.set_transition(dfa_id, byte, newtrans);
    95 ( 0.00%) .          .          .                       } else if oldtrans != newtrans {
   325 ( 0.00%) .          .          .                           return Err(BuildError::not_one_pass(
     .          .          .          .                               "conflicting transition",
     .          .          .          .                           ));
     .          .          .          .                       }
     .          .          .          .                   }
   325 ( 0.00%) .          .          .                   Ok(())
 3,120 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add a start state to the DFA corresponding to the given NFA starting
     .          .          .          .               /// state ID.
     .          .          .          .               ///
     .          .          .          .               /// If adding a state would blow any limits (configured or hard-coded),
     .          .          .          .               /// then an error is returned.
     .          .          .          .               ///
     .          .          .          .               /// If the starting state is an anchored state for a particular pattern,
-- line 806 ----------------------------------------
-- line 811 ----------------------------------------
     .          .          .          .               fn add_start_state(
     .          .          .          .                   &mut self,
     .          .          .          .                   pid: Option<PatternID>,
     .          .          .          .                   nfa_id: StateID,
     .          .          .          .               ) -> Result<StateID, BuildError> {
     .          .          .          .                   match pid {
     .          .          .          .                       // With no pid, this should be the start state for all patterns
     .          .          .          .                       // and thus be the first one.
   162 ( 0.00%) .          .          .                       None => assert!(self.dfa.starts.is_empty()),
     .          .          .          .                       // With a pid, we want it to be at self.dfa.starts[pid+1].
   162 ( 0.00%) .          .          .                       Some(pid) => assert!(self.dfa.starts.len() == pid.one_more()),
     .          .          .          .                   }
   324 ( 0.00%) .          .          .                   let dfa_id = self.add_dfa_state_for_nfa_state(nfa_id)?;
269,742 ( 0.08%) 250 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs:regex_automata::dfa::onepass::InternalBuilder::add_dfa_state_for_nfa_state (162x)
     .          .          .          .                   self.dfa.starts.push(dfa_id);
     .          .          .          .                   Ok(dfa_id)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add a new DFA state corresponding to the given NFA state. If adding a
     .          .          .          .               /// state would blow any limits (configured or hard-coded), then an error
     .          .          .          .               /// is returned. If a DFA state already exists for the given NFA state,
     .          .          .          .               /// then that DFA state's ID is returned and no new states are added.
     .          .          .          .               ///
     .          .          .          .               /// It is not expected that this routine is called for every NFA state.
     .          .          .          .               /// Instead, an NFA state ID will usually correspond to the "start" state
     .          .          .          .               /// for a sub-graph of the NFA, where all states in the sub-graph are
     .          .          .          .               /// reachable via epsilon transitions (conditional or unconditional). That
     .          .          .          .               /// sub-graph of NFA states is ultimately what produces a single DFA state.
11,291 ( 0.00%) .          .          .               fn add_dfa_state_for_nfa_state(
     .          .          .          .                   &mut self,
     .          .          .          .                   nfa_id: StateID,
     .          .          .          .               ) -> Result<StateID, BuildError> {
     .          .          .          .                   // If we've already built a DFA state for the given NFA state, then
     .          .          .          .                   // just return that. We definitely do not want to have more than one
     .          .          .          .                   // DFA state in existence for the same NFA state, since all but one of
     .          .          .          .                   // them will likely become unreachable. And at least some of them are
     .          .          .          .                   // likely to wind up being incomplete.
 1,613 ( 0.00%) .          .          .                   let existing_dfa_id = self.nfa_to_dfa_id[nfa_id];
 1,613 ( 0.00%) .          .          .                   if existing_dfa_id != DEAD {
   547 ( 0.00%) .          .          .                       return Ok(existing_dfa_id);
     .          .          .          .                   }
     .          .          .          .                   // If we don't have any DFA state yet, add it and then add the given
     .          .          .          .                   // NFA state to the list of states to explore.
     .          .          .          .                   let dfa_id = self.add_empty_state()?;
 1,066 ( 0.00%) .          .          .                   self.nfa_to_dfa_id[nfa_id] = dfa_id;
   154 ( 0.00%) .          .          .                   self.uncompiled_nfa_ids.push(nfa_id);
 2,132 ( 0.00%) .          .          .                   Ok(dfa_id)
12,904 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Unconditionally add a new empty DFA state. If adding it would exceed
     .          .          .          .               /// any limits (configured or hard-coded), then an error is returned. The
     .          .          .          .               /// ID of the new state is returned on success.
     .          .          .          .               ///
     .          .          .          .               /// The added state is *not* a match state.
     .          .          .          .               fn add_empty_state(&mut self) -> Result<StateID, BuildError> {
     .          .          .          .                   let state_limit = Transition::STATE_ID_LIMIT;
-- line 865 ----------------------------------------
-- line 866 ----------------------------------------
     .          .          .          .                   // Note that unlike dense and lazy DFAs, we specifically do NOT
     .          .          .          .                   // premultiply our state IDs here. The reason is that we want to pack
     .          .          .          .                   // our state IDs into 64-bit transitions with other info, so the fewer
     .          .          .          .                   // the bits we use for state IDs the better. If we premultiply, then
     .          .          .          .                   // our state ID space shrinks. We justify this by the assumption that
     .          .          .          .                   // a one-pass DFA is just already doing a fair bit more work than a
     .          .          .          .                   // normal DFA anyway, so an extra multiplication to compute a state
     .          .          .          .                   // transition doesn't seem like a huge deal.
 4,264 ( 0.00%) .          .          .                   let next_id = self.dfa.table.len() >> self.dfa.stride2();
     .          .          .          .                   let id = StateID::new(next_id)
     .          .          .          .                       .map_err(|_| BuildError::too_many_states(state_limit))?;
 2,132 ( 0.00%) .          .          .                   if id.as_u64() > Transition::STATE_ID_LIMIT {
     .          .          .          .                       return Err(BuildError::too_many_states(state_limit));
     .          .          .          .                   }
     .          .          .          .                   self.dfa
     .          .          .          .                       .table
     .          .          .          .                       .extend(core::iter::repeat(Transition(0)).take(self.dfa.stride()));
     .          .          .          .                   // The default empty value for 'PatternEpsilons' is sadly not all
     .          .          .          .                   // zeroes. Instead, a special sentinel is used to indicate that there
     .          .          .          .                   // is no pattern. So we need to explicitly set the pattern epsilons to
     .          .          .          .                   // the correct "empty" PatternEpsilons.
     .          .          .          .                   self.dfa.set_pattern_epsilons(id, PatternEpsilons::empty());
     .          .          .          .                   if let Some(size_limit) = self.config.get_size_limit() {
 2,294 ( 0.00%) .          .          .                       if self.dfa.memory_usage() > size_limit {
     .          .          .          .                           return Err(BuildError::exceeded_size_limit(size_limit));
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   Ok(id)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Push the given NFA state ID and its corresponding epsilons (slots and
     .          .          .          .               /// conditional epsilon transitions) on to a stack for use in a depth first
     .          .          .          .               /// traversal of a sub-graph of the NFA.
     .          .          .          .               ///
     .          .          .          .               /// If the given NFA state ID has already been pushed on to the stack, then
     .          .          .          .               /// it indicates the regex is not one-pass and this correspondingly returns
     .          .          .          .               /// an error.
18,704 ( 0.01%) .          .          .               fn stack_push(
     .          .          .          .                   &mut self,
     .          .          .          .                   nfa_id: StateID,
     .          .          .          .                   epsilons: Epsilons,
     .          .          .          .               ) -> Result<(), BuildError> {
     .          .          .          .                   // If we already have seen a match and we are compiling a leftmost
     .          .          .          .                   // first DFA, then we shouldn't add any more states to look at. This is
     .          .          .          .                   // effectively how preference order and non-greediness is implemented.
     .          .          .          .                   // if !self.config.get_match_kind().continue_past_first_match()
-- line 911 ----------------------------------------
-- line 913 ----------------------------------------
     .          .          .          .                   // {
     .          .          .          .                   // return Ok(());
     .          .          .          .                   // }
     .          .          .          .                   if !self.seen.insert(nfa_id) {
     .          .          .          .                       return Err(BuildError::not_one_pass(
     .          .          .          .                           "multiple epsilon transitions to same state",
     .          .          .          .                       ));
     .          .          .          .                   }
   211 ( 0.00%) .          .          .                   self.stack.push((nfa_id, epsilons));
 5,344 ( 0.00%) .          .          .                   Ok(())
18,704 ( 0.01%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A one-pass DFA for executing a subset of anchored regex searches while
     .          .          .          .           /// resolving capturing groups.
     .          .          .          .           ///
     .          .          .          .           /// A one-pass DFA can be built from an NFA that is one-pass. An NFA is
     .          .          .          .           /// one-pass when there is never any ambiguity about how to continue a search.
     .          .          .          .           /// For example, `a*a` is not one-pass because during a search, it's not
-- line 931 ----------------------------------------
-- line 1440 ----------------------------------------
     .          .          .          .           
     .          .          .          .               /// Returns the total number of states in this one-pass DFA.
     .          .          .          .               ///
     .          .          .          .               /// Note that unlike dense or sparse DFAs, a one-pass DFA does not expose
     .          .          .          .               /// a low level DFA API. Therefore, this routine has little use other than
     .          .          .          .               /// being informational.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn state_len(&self) -> usize {
     6 ( 0.00%) .          .          .                   self.table.len() >> self.stride2()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the total number of elements in the alphabet for this DFA.
     .          .          .          .               ///
     .          .          .          .               /// That is, this returns the total number of transitions that each
     .          .          .          .               /// state in this DFA must have. The maximum alphabet size is 256, which
     .          .          .          .               /// corresponds to each possible byte value.
     .          .          .          .               ///
-- line 1456 ----------------------------------------
-- line 1501 ----------------------------------------
     .          .          .          .               /// than `8`. (Do note that a maximal stride is incredibly rare, as it
     .          .          .          .               /// would imply that there is almost no redundant in the regex pattern.)
     .          .          .          .               ///
     .          .          .          .               /// Note that unlike dense or sparse DFAs, a one-pass DFA does not expose
     .          .          .          .               /// a low level DFA API. Therefore, this routine has little use other than
     .          .          .          .               /// being informational.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn stride2(&self) -> usize {
 5,084 ( 0.00%) .          .          .                   self.stride2
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the total stride for every state in this DFA. This corresponds
     .          .          .          .               /// to the total number of transitions used by each state in this DFA's
     .          .          .          .               /// transition table.
     .          .          .          .               ///
     .          .          .          .               /// Please see [`DFA::stride2`] for more information. In particular, this
     .          .          .          .               /// returns the stride as the number of transitions, where as `stride2`
     .          .          .          .               /// returns it as the exponent of a power of 2.
     .          .          .          .               ///
     .          .          .          .               /// Note that unlike dense or sparse DFAs, a one-pass DFA does not expose
     .          .          .          .               /// a low level DFA API. Therefore, this routine has little use other than
     .          .          .          .               /// being informational.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn stride(&self) -> usize {
 2,294 ( 0.00%) .          .          .                   1 << self.stride2()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the memory usage, in bytes, of this DFA.
     .          .          .          .               ///
     .          .          .          .               /// The memory usage is computed based on the number of bytes used to
     .          .          .          .               /// represent this DFA.
     .          .          .          .               ///
     .          .          .          .               /// This does **not** include the stack size used up by this DFA. To
     .          .          .          .               /// compute that, use `std::mem::size_of::<onepass::DFA>()`.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn memory_usage(&self) -> usize {
     .          .          .          .                   use core::mem::size_of;
     .          .          .          .           
 2,294 ( 0.00%) .          .          .                   self.table.len() * size_of::<Transition>()
     .          .          .          .                       + self.starts.len() * size_of::<StateID>()
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl DFA {
     .          .          .          .               /// Executes an anchored leftmost forward search, and returns true if and
     .          .          .          .               /// only if this one-pass DFA matches the given haystack.
     .          .          .          .               ///
-- line 1547 ----------------------------------------
-- line 1965 ----------------------------------------
     .          .          .          .               /// let slot_start = pid.unwrap().as_usize() * 2;
     .          .          .          .               /// let slot_end = slot_start + 1;
     .          .          .          .               /// assert_eq!(Some(0), slots[slot_start].map(|s| s.get()));
     .          .          .          .               /// assert_eq!(Some(3), slots[slot_end].map(|s| s.get()));
     .          .          .          .               ///
     .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
     .          .          .          .               /// ```
     .          .          .          .               #[inline]
     7 ( 0.00%) .          .          .               pub fn try_search_slots(
     .          .          .          .                   &self,
     .          .          .          .                   cache: &mut Cache,
     .          .          .          .                   input: &Input<'_>,
     .          .          .          .                   slots: &mut [Option<NonMaxUsize>],
     .          .          .          .               ) -> Result<Option<PatternID>, MatchError> {
     2 ( 0.00%) .          .          .                   let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
     .          .          .          .                   if !utf8empty {
     .          .          .          .                       return self.try_search_slots_imp(cache, input, slots);
     .          .          .          .                   }
     .          .          .          .                   // See PikeVM::try_search_slots for why we do this.
     .          .          .          .                   let min = self.get_nfa().group_info().implicit_slot_len();
     .          .          .          .                   if slots.len() >= min {
     .          .          .          .                       return self.try_search_slots_imp(cache, input, slots);
     .          .          .          .                   }
-- line 1987 ----------------------------------------
-- line 1997 ----------------------------------------
     .          .          .          .                   let got = self.try_search_slots_imp(cache, input, &mut enough)?;
     .          .          .          .                   // This is OK because we know `enough_slots` is strictly bigger than
     .          .          .          .                   // `slots`, otherwise this special case isn't reached.
     .          .          .          .                   slots.copy_from_slice(&enough[..slots.len()]);
     .          .          .          .                   Ok(got)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline(never)]
    11 ( 0.00%) .          .          .               fn try_search_slots_imp(
     .          .          .          .                   &self,
     .          .          .          .                   cache: &mut Cache,
     .          .          .          .                   input: &Input<'_>,
     .          .          .          .                   slots: &mut [Option<NonMaxUsize>],
     .          .          .          .               ) -> Result<Option<PatternID>, MatchError> {
     2 ( 0.00%) .          .          .                   let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
     3 ( 0.00%) .          .          .                   match self.search_imp(cache, input, slots)? {
     .          .          .          .                       None => return Ok(None),
     .          .          .          .                       Some(pid) if !utf8empty => return Ok(Some(pid)),
     .          .          .          .                       Some(pid) => {
     .          .          .          .                           // These slot indices are always correct because we know our
     .          .          .          .                           // 'pid' is valid and thus we know that the slot indices for it
     .          .          .          .                           // are valid.
     .          .          .          .                           let slot_start = pid.as_usize().wrapping_mul(2);
     .          .          .          .                           let slot_end = slot_start.wrapping_add(1);
-- line 2020 ----------------------------------------
-- line 2030 ----------------------------------------
     .          .          .          .                           // searches, we don't try to skip ahead to find the next match.
     .          .          .          .                           // We can just quit with nothing.
     .          .          .          .                           if start == end && !input.is_char_boundary(start) {
     .          .          .          .                               return Ok(None);
     .          .          .          .                           }
     .          .          .          .                           Ok(Some(pid))
     .          .          .          .                       }
     .          .          .          .                   }
     9 ( 0.00%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl DFA {
     .          .          .          .               fn search_imp(
     .          .          .          .                   &self,
     .          .          .          .                   cache: &mut Cache,
     .          .          .          .                   input: &Input<'_>,
     .          .          .          .                   slots: &mut [Option<NonMaxUsize>],
-- line 2046 ----------------------------------------
-- line 2077 ----------------------------------------
     .          .          .          .                   // case, maybe an extra function call is OK, but even then, it might be
     .          .          .          .                   // too much of a latency hit. Another idea is to just try and figure
     .          .          .          .                   // out how to reduce the code size of 'find_match'. RE2 has a trick
     .          .          .          .                   // here where the match handling isn't done if we know the next byte of
     .          .          .          .                   // input yields a match too. Maybe we adopt that?
     .          .          .          .                   //
     .          .          .          .                   // This just might be a tricky DFA to optimize.
     .          .          .          .           
     1 ( 0.00%) .          .          .                   if input.is_done() {
     .          .          .          .                       return Ok(None);
     .          .          .          .                   }
     .          .          .          .                   // We unfortunately have a bit of book-keeping to do to set things
     .          .          .          .                   // up. We do have to setup our cache and clear all of our slots. In
     .          .          .          .                   // particular, clearing the slots is necessary for the case where we
     .          .          .          .                   // report a match, but one of the capturing groups didn't participate
     .          .          .          .                   // in the match but had a span set from a previous search. That would
     .          .          .          .                   // be bad. In theory, we could avoid all this slot clearing if we knew
     .          .          .          .                   // that every slot was always activated for every match. Then we would
     .          .          .          .                   // know they would always be overwritten when a match is found.
     .          .          .          .                   let explicit_slots_len = core::cmp::min(
     .          .          .          .                       Slots::LIMIT,
     1 ( 0.00%) .          .          .                       slots.len().saturating_sub(self.explicit_slot_start),
     .          .          .          .                   );
     .          .          .          .                   cache.setup_search(explicit_slots_len);
     .          .          .          .                   for slot in cache.explicit_slots() {
     4 ( 0.00%) .          .          .                       *slot = None;
    19 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
     .          .          .          .                   }
     .          .          .          .                   for slot in slots.iter_mut() {
     4 ( 0.00%) .          .          .                       *slot = None;
    19 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
     .          .          .          .                   }
     .          .          .          .                   // We set the starting slots for every pattern up front. This does
     .          .          .          .                   // increase our latency somewhat, but it avoids having to do it every
     .          .          .          .                   // time we see a match state (which could be many times in a single
     .          .          .          .                   // search if the match state consumes input).
     .          .          .          .                   for pid in self.nfa.patterns() {
     2 ( 0.00%) .          .          .                       let i = pid.as_usize() * 2;
     3 ( 0.00%) .          .          .                       if i >= slots.len() {
     .          .          .          .                           break;
     .          .          .          .                       }
     1 ( 0.00%) .          .          .                       slots[i] = NonMaxUsize::new(input.start());
     .          .          .          .                   }
     .          .          .          .                   let mut pid = None;
     5 ( 0.00%) .          .          .                   let mut next_sid = match input.get_anchored() {
     .          .          .          .                       Anchored::Yes => self.start(),
     .          .          .          .                       Anchored::Pattern(pid) => self.start_pattern(pid)?,
     .          .          .          .                       Anchored::No => {
     .          .          .          .                           // If the regex is itself always anchored, then we're fine,
     .          .          .          .                           // even if the search is configured to be unanchored.
     1 ( 0.00%) .          .          .                           if !self.nfa.is_always_start_anchored() {
     .          .          .          .                               return Err(MatchError::unsupported_anchored(
     .          .          .          .                                   Anchored::No,
     .          .          .          .                               ));
     .          .          .          .                           }
     .          .          .          .                           self.start()
     .          .          .          .                       }
     .          .          .          .                   };
     .          .          .          .                   let leftmost_first =
     .          .          .          .                       matches!(self.config.get_match_kind(), MatchKind::LeftmostFirst);
     .          .          .          .                   for at in input.start()..input.end() {
     .          .          .          .                       let sid = next_sid;
     6 ( 0.00%) .          .          .                       let trans = self.transition(sid, input.haystack()[at]);
     .          .          .          .                       next_sid = trans.state_id();
     .          .          .          .                       let epsilons = trans.epsilons();
     .          .          .          .                       if sid >= self.min_match_id {
     .          .          .          .                           if self.find_match(cache, input, at, sid, slots, &mut pid) {
     .          .          .          .                               if input.get_earliest()
     .          .          .          .                                   || (leftmost_first && trans.match_wins())
     .          .          .          .                               {
     .          .          .          .                                   return Ok(pid);
     .          .          .          .                               }
     .          .          .          .                           }
     .          .          .          .                       }
     2 ( 0.00%) .          .          .                       if sid == DEAD
     3 ( 0.00%) .          .          .                           || (!epsilons.looks().is_empty()
     .          .          .          .                               && !self.nfa.look_matcher().matches_set_inline(
     .          .          .          .                                   epsilons.looks(),
     .          .          .          .                                   input.haystack(),
     .          .          .          .                                   at,
     .          .          .          .                               ))
     .          .          .          .                       {
     .          .          .          .                           return Ok(pid);
     .          .          .          .                       }
-- line 2158 ----------------------------------------
-- line 2252 ----------------------------------------
     .          .          .          .                   Ok(self.starts.get(pid.one_more()).copied().unwrap_or(DEAD))
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the transition from the given state ID and byte of input. The
     .          .          .          .               /// transition includes the next state ID, the slots that should be saved
     .          .          .          .               /// and any conditional epsilon transitions that must be satisfied in order
     .          .          .          .               /// to take this transition.
     .          .          .          .               fn transition(&self, sid: StateID, byte: u8) -> Transition {
 2,631 ( 0.00%) .          .          .                   let offset = sid.as_usize() << self.stride2();
     .          .          .          .                   let class = self.classes.get(byte).as_usize();
 3,706 ( 0.00%) .          .          .                   self.table[offset + class]
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set the transition from the given state ID and byte of input to the
     .          .          .          .               /// transition given.
     .          .          .          .               fn set_transition(&mut self, sid: StateID, byte: u8, to: Transition) {
     .          .          .          .                   let offset = sid.as_usize() << self.stride2();
     .          .          .          .                   let class = self.classes.get(byte).as_usize();
 3,542 ( 0.00%) .          .          .                   self.table[offset + class] = to;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return an iterator of "sparse" transitions for the given state ID.
     .          .          .          .               /// "sparse" in this context means that consecutive transitions that are
     .          .          .          .               /// equivalent are returned as one group, and transitions to the DEAD state
     .          .          .          .               /// are ignored.
     .          .          .          .               ///
     .          .          .          .               /// This winds up being useful for debug printing, since it's much terser
-- line 2278 ----------------------------------------
-- line 2288 ----------------------------------------
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return the pattern epsilons for the given state ID.
     .          .          .          .               ///
     .          .          .          .               /// If the given state ID does not correspond to a match state ID, then the
     .          .          .          .               /// pattern epsilons returned is empty.
     .          .          .          .               fn pattern_epsilons(&self, sid: StateID) -> PatternEpsilons {
   148 ( 0.00%) .          .          .                   let offset = sid.as_usize() << self.stride2();
   148 ( 0.00%) .          .          .                   PatternEpsilons(self.table[offset + self.pateps_offset].0)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set the pattern epsilons for the given state ID.
     .          .          .          .               fn set_pattern_epsilons(&mut self, sid: StateID, pateps: PatternEpsilons) {
 4,069 ( 0.00%) .          .          .                   let offset = sid.as_usize() << self.stride2();
 2,297 ( 0.00%) .          .          .                   self.table[offset + self.pateps_offset] = Transition(pateps.0);
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the state ID prior to the one given. This returns None if the
     .          .          .          .               /// given ID is the first DFA state.
     .          .          .          .               fn prev_state_id(&self, id: StateID) -> Option<StateID> {
     .          .          .          .                   if id == DEAD {
     .          .          .          .                       None
     .          .          .          .                   } else {
-- line 2311 ----------------------------------------
-- line 2329 ----------------------------------------
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Move the transitions from 'id1' to 'id2' and vice versa.
     .          .          .          .               ///
     .          .          .          .               /// WARNING: This does not update the rest of the transition table to have
     .          .          .          .               /// transitions to 'id1' changed to 'id2' and vice versa. This merely moves
     .          .          .          .               /// the states in memory.
     .          .          .          .               pub(super) fn swap_states(&mut self, id1: StateID, id2: StateID) {
     3 ( 0.00%) .          .          .                   let o1 = id1.as_usize() << self.stride2();
     3 ( 0.00%) .          .          .                   let o2 = id2.as_usize() << self.stride2();
     .          .          .          .                   for b in 0..self.stride() {
     .          .          .          .                       self.table.swap(o1 + b, o2 + b);
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Map all state IDs in this DFA (transition table + start states)
     .          .          .          .               /// according to the closure given.
     .          .          .          .               pub(super) fn remap(&mut self, map: impl Fn(StateID) -> StateID) {
     .          .          .          .                   for i in 0..self.state_len() {
   148 ( 0.00%) .          .          .                       let offset = i << self.stride2();
     .          .          .          .                       for b in 0..self.alphabet_len() {
     .          .          .          .                           let next = self.table[offset + b].state_id();
     .          .          .          .                           self.table[offset + b].set_state_id(map(next));
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   for i in 0..self.starts.len() {
     4 ( 0.00%) .          .          .                       self.starts[i] = map(self.starts[i]);
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl core::fmt::Debug for DFA {
     .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
     .          .          .          .                   fn debug_state_transitions(
     .          .          .          .                       f: &mut core::fmt::Formatter,
-- line 2363 ----------------------------------------
-- line 2508 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// A potentially more convenient routine to create a cache is
     .          .          .          .               /// [`DFA::create_cache`], as it does not require also importing the
     .          .          .          .               /// `Cache` type.
     .          .          .          .               ///
     .          .          .          .               /// If you want to reuse the returned `Cache` with some other one-pass DFA,
     .          .          .          .               /// then you must call [`Cache::reset`] with the desired one-pass DFA.
     .          .          .          .               pub fn new(re: &DFA) -> Cache {
     4 ( 0.00%) .          .          .                   let mut cache = Cache { explicit_slots: vec![], explicit_slot_len: 0 };
     .          .          .          .                   cache.reset(re);
     6 ( 0.00%) .          .          .                   cache
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Reset this cache such that it can be used for searching with a
     .          .          .          .               /// different [`onepass::DFA`](DFA).
     .          .          .          .               ///
     .          .          .          .               /// A cache reset permits reusing memory already allocated in this cache
     .          .          .          .               /// with a different one-pass DFA.
     .          .          .          .               ///
-- line 2526 ----------------------------------------
-- line 2556 ----------------------------------------
     .          .          .          .               ///     { re2.captures(&mut cache, "", &mut caps2); caps2.get_match() },
     .          .          .          .               /// );
     .          .          .          .               ///
     .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
     .          .          .          .               /// ```
     .          .          .          .               pub fn reset(&mut self, re: &DFA) {
     .          .          .          .                   let explicit_slot_len = re.get_nfa().group_info().explicit_slot_len();
     .          .          .          .                   self.explicit_slots.resize(explicit_slot_len, None);
     1 ( 0.00%) .          .          .                   self.explicit_slot_len = explicit_slot_len;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the heap memory usage, in bytes, of this cache.
     .          .          .          .               ///
     .          .          .          .               /// This does **not** include the stack size used up by this cache. To
     .          .          .          .               /// compute that, use `std::mem::size_of::<Cache>()`.
     .          .          .          .               pub fn memory_usage(&self) -> usize {
     .          .          .          .                   self.explicit_slots.len() * core::mem::size_of::<Option<NonMaxUsize>>()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               fn explicit_slots(&mut self) -> &mut [Option<NonMaxUsize>] {
     .          .          .          .                   &mut self.explicit_slots[..self.explicit_slot_len]
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               fn setup_search(&mut self, explicit_slot_len: usize) {
     1 ( 0.00%) .          .          .                   self.explicit_slot_len = explicit_slot_len;
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Represents a single transition in a one-pass DFA.
     .          .          .          .           ///
     .          .          .          .           /// The high 21 bits corresponds to the state ID. The bit following corresponds
     .          .          .          .           /// to the special "match wins" flag. The remaining low 42 bits corresponds to
     .          .          .          .           /// the transition epsilons, which contains the slots that should be saved when
     .          .          .          .           /// this transition is followed and the conditional epsilon transitions that
     .          .          .          .           /// must be satisfied in order to follow this transition.
    80 ( 0.00%) .          .          .           #[derive(Clone, Copy, Eq, PartialEq)]
     .          .          .          .           struct Transition(u64);
     .          .          .          .           
     .          .          .          .           impl Transition {
     .          .          .          .               const STATE_ID_BITS: u64 = 21;
     .          .          .          .               const STATE_ID_SHIFT: u64 = 64 - Transition::STATE_ID_BITS;
     .          .          .          .               const STATE_ID_LIMIT: u64 = 1 << Transition::STATE_ID_BITS;
     .          .          .          .               const MATCH_WINS_SHIFT: u64 = 64 - (Transition::STATE_ID_BITS + 1);
     .          .          .          .               const INFO_MASK: u64 = 0x000003FF_FFFFFFFF;
     .          .          .          .           
     .          .          .          .               /// Return a new transition to the given state ID with the given epsilons.
     .          .          .          .               fn new(match_wins: bool, sid: StateID, epsilons: Epsilons) -> Transition {
     .          .          .          .                   let match_wins =
 6,143 ( 0.00%) .          .          .                       if match_wins { 1 << Transition::MATCH_WINS_SHIFT } else { 0 };
 5,994 ( 0.00%) .          .          .                   let sid = sid.as_u64() << Transition::STATE_ID_SHIFT;
13,839 ( 0.00%) .          .          .                   Transition(sid | match_wins | epsilons.0)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if this transition points to the DEAD state.
     .          .          .          .               fn is_dead(self) -> bool {
     .          .          .          .                   self.state_id() == DEAD
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return whether this transition has a "match wins" property.
-- line 2614 ----------------------------------------
-- line 2625 ----------------------------------------
     .          .          .          .           
     .          .          .          .               /// Return the "next" state ID that this transition points to.
     .          .          .          .               fn state_id(&self) -> StateID {
     .          .          .          .                   // OK because a Transition has a valid StateID in its upper bits by
     .          .          .          .                   // construction. The cast to usize is also correct, even on 16-bit
     .          .          .          .                   // targets because, again, we know the upper bits is a valid StateID,
     .          .          .          .                   // which can never overflow usize on any supported target.
     .          .          .          .                   StateID::new_unchecked(
17,982 ( 0.01%) .          .          .                       (self.0 >> Transition::STATE_ID_SHIFT).as_usize(),
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set the "next" state ID in this transition.
     .          .          .          .               fn set_state_id(&mut self, sid: StateID) {
 5,994 ( 0.00%) .          .          .                   *self = Transition::new(self.match_wins(), sid, self.epsilons());
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return the epsilons embedded in this transition.
     .          .          .          .               fn epsilons(&self) -> Epsilons {
     .          .          .          .                   Epsilons(self.0 & Transition::INFO_MASK)
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
-- line 2647 ----------------------------------------
-- line 2701 ----------------------------------------
     .          .          .          .               /// no pattern ID and an empty epsilons.
     .          .          .          .               fn is_empty(self) -> bool {
     .          .          .          .                   self.pattern_id().is_none() && self.epsilons().is_empty()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return the pattern ID in this pattern epsilons if one exists.
     .          .          .          .               fn pattern_id(self) -> Option<PatternID> {
     .          .          .          .                   let pid = self.0 >> PatternEpsilons::PATTERN_ID_SHIFT;
   148 ( 0.00%) .          .          .                   if pid == PatternEpsilons::PATTERN_ID_LIMIT {
     .          .          .          .                       None
     .          .          .          .                   } else {
     .          .          .          .                       Some(PatternID::new_unchecked(pid.as_usize()))
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the pattern ID without checking whether it's valid. If this is
     .          .          .          .               /// called and there is no pattern ID in this `PatternEpsilons`, then this
-- line 2717 ----------------------------------------
-- line 2724 ----------------------------------------
     .          .          .          .                   let pid = self.0 >> PatternEpsilons::PATTERN_ID_SHIFT;
     .          .          .          .                   PatternID::new_unchecked(pid.as_usize())
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return a new pattern epsilons with the given pattern ID, but the same
     .          .          .          .               /// epsilons.
     .          .          .          .               fn set_pattern_id(self, pid: PatternID) -> PatternEpsilons {
     .          .          .          .                   PatternEpsilons(
     1 ( 0.00%) .          .          .                       (pid.as_u64() << PatternEpsilons::PATTERN_ID_SHIFT)
     .          .          .          .                           | (self.0 & PatternEpsilons::EPSILONS_MASK),
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return the epsilons part of this pattern epsilons.
     .          .          .          .               fn epsilons(self) -> Epsilons {
     .          .          .          .                   Epsilons(self.0 & PatternEpsilons::EPSILONS_MASK)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return a new pattern epsilons with the given epsilons, but the same
     .          .          .          .               /// pattern ID.
     .          .          .          .               fn set_epsilons(self, epsilons: Epsilons) -> PatternEpsilons {
     .          .          .          .                   PatternEpsilons(
     1 ( 0.00%) .          .          .                       (self.0 & PatternEpsilons::PATTERN_ID_MASK)
     3 ( 0.00%) .          .          .                           | (u64::from(epsilons.0) & PatternEpsilons::EPSILONS_MASK),
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl core::fmt::Debug for PatternEpsilons {
     .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
     .          .          .          .                   if self.is_empty() {
     .          .          .          .                       return write!(f, "N/A");
-- line 2755 ----------------------------------------
-- line 2799 ----------------------------------------
     .          .          .          .           
     .          .          .          .               /// Returns true if this epsilons contains no slots and no assertions.
     .          .          .          .               fn is_empty(self) -> bool {
     .          .          .          .                   self.0 == 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the slot epsilon transitions.
     .          .          .          .               fn slots(self) -> Slots {
   530 ( 0.00%) .          .          .                   Slots((self.0 >> Epsilons::SLOT_SHIFT).low_u32())
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set the slot epsilon transitions.
     .          .          .          .               fn set_slots(self, slots: Slots) -> Epsilons {
     .          .          .          .                   Epsilons(
   528 ( 0.00%) .          .          .                       (u64::from(slots.0) << Epsilons::SLOT_SHIFT)
   264 ( 0.00%) .          .          .                           | (self.0 & Epsilons::LOOK_MASK),
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return the set of look-around assertions in these epsilon transitions.
     .          .          .          .               fn looks(self) -> LookSet {
     .          .          .          .                   LookSet { bits: (self.0 & Epsilons::LOOK_MASK).low_u32() }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Set the look-around assertions on these epsilon transitions.
     .          .          .          .               fn set_looks(self, look_set: LookSet) -> Epsilons {
     .          .          .          .                   Epsilons(
   198 ( 0.00%) .          .          .                       (self.0 & Epsilons::SLOT_MASK)
    66 ( 0.00%) .          .          .                           | (u64::from(look_set.bits) & Epsilons::LOOK_MASK),
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl core::fmt::Debug for Epsilons {
     .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
     .          .          .          .                   let mut wrote = false;
     .          .          .          .                   if !self.slots().is_empty() {
-- line 2835 ----------------------------------------
-- line 2886 ----------------------------------------
     .          .          .          .           struct Slots(u32);
     .          .          .          .           
     .          .          .          .           impl Slots {
     .          .          .          .               const LIMIT: usize = 32;
     .          .          .          .           
     .          .          .          .               /// Insert the slot at the given bit index.
     .          .          .          .               fn insert(self, slot: usize) -> Slots {
     .          .          .          .                   debug_assert!(slot < Slots::LIMIT);
   264 ( 0.00%) .          .          .                   Slots(self.0 | (1 << slot.as_u32()))
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Remove the slot at the given bit index.
     .          .          .          .               fn remove(self, slot: usize) -> Slots {
     .          .          .          .                   debug_assert!(slot < Slots::LIMIT);
     .          .          .          .                   Slots(self.0 & !(1 << slot.as_u32()))
     .          .          .          .               }
     .          .          .          .           
-- line 2902 ----------------------------------------
-- line 2919 ----------------------------------------
     .          .          .          .               /// The slice *must* correspond only to the explicit slots and the first
     .          .          .          .               /// element of the slice must always correspond to the first explicit slot
     .          .          .          .               /// in the corresponding NFA.
     .          .          .          .               fn apply(
     .          .          .          .                   self,
     .          .          .          .                   at: usize,
     .          .          .          .                   caller_explicit_slots: &mut [Option<NonMaxUsize>],
     .          .          .          .               ) {
     2 ( 0.00%) .          .          .                   if self.is_empty() {
     .          .          .          .                       return;
     .          .          .          .                   }
     .          .          .          .                   let at = NonMaxUsize::new(at);
     .          .          .          .                   for slot in self.iter() {
     .          .          .          .                       if slot >= caller_explicit_slots.len() {
     .          .          .          .                           break;
     .          .          .          .                       }
     .          .          .          .                       caller_explicit_slots[slot] = at;
-- line 2935 ----------------------------------------

26,908 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/onepass.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 82 ----------------------------------------
        .          .          .          .           // them in safe indexing is unnecessary and hurts inlining and debug runtime perf.
        .          .          .          .           // Both the safe and unsafe public methods share these helpers,
        .          .          .          .           // which use intrinsics directly to get *no* extra checks.
        .          .          .          .           
        .          .          .          .           #[inline(always)]
        .          .          .          .           const unsafe fn get_noubcheck<T>(ptr: *const [T], index: usize) -> *const T {
        .          .          .          .               let ptr = ptr as *const T;
        .          .          .          .               // SAFETY: The caller already checked these preconditions
  439,192 ( 0.13%) .          .          .               unsafe { crate::intrinsics::offset(ptr, index) }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[inline(always)]
        .          .          .          .           const unsafe fn get_mut_noubcheck<T>(ptr: *mut [T], index: usize) -> *mut T {
        .          .          .          .               let ptr = ptr as *mut T;
        .          .          .          .               // SAFETY: The caller already checked these preconditions
    4,223 ( 0.00%) .          .          .               unsafe { crate::intrinsics::offset(ptr, index) }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[inline(always)]
        .          .          .          .           const unsafe fn get_offset_len_noubcheck<T>(
        .          .          .          .               ptr: *const [T],
        .          .          .          .               offset: usize,
        .          .          .          .               len: usize,
        .          .          .          .           ) -> *const [T] {
-- line 105 ----------------------------------------
-- line 220 ----------------------------------------
        .          .          .          .           /// The methods `index` and `index_mut` panic if the index is out of bounds.
        .          .          .          .           #[stable(feature = "slice_get_slice_impls", since = "1.15.0")]
        .          .          .          .           unsafe impl<T> SliceIndex<[T]> for usize {
        .          .          .          .               type Output = T;
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn get(self, slice: &[T]) -> Option<&T> {
        .          .          .          .                   // SAFETY: `self` is checked to be in bounds.
    8,851 ( 0.00%) .          .          .                   if self < slice.len() { unsafe { Some(&*get_noubcheck(slice, self)) } } else { None }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {
        .          .          .          .                   if self < slice.len() {
        .          .          .          .                       // SAFETY: `self` is checked to be in bounds.
        .          .          .          .                       unsafe { Some(&mut *get_mut_noubcheck(slice, self)) }
        .          .          .          .                   } else {
-- line 236 ----------------------------------------
-- line 266 ----------------------------------------
        .          .          .          .                   );
        .          .          .          .                   // SAFETY: see comments for `get_unchecked` above.
        .          .          .          .                   unsafe { get_mut_noubcheck(slice, self) }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn index(self, slice: &[T]) -> &T {
        .          .          .          .                   // N.B., use intrinsic indexing
2,607,624 ( 0.78%) .          .          .                   &(*slice)[self]
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn index_mut(self, slice: &mut [T]) -> &mut T {
        .          .          .          .                   // N.B., use intrinsic indexing
1,238,558 ( 0.37%) .          .          .                   &mut (*slice)[self]
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// Because `IndexRange` guarantees `start <= end`, fewer checks are needed here
        .          .          .          .           /// than there are for a general `Range<usize>` (which might be `100..3`).
        .          .          .          .           unsafe impl<T> SliceIndex<[T]> for ops::IndexRange {
        .          .          .          .               type Output = [T];
        .          .          .          .           
-- line 288 ----------------------------------------
-- line 399 ----------------------------------------
        .          .          .          .           
        .          .          .          .                   // SAFETY: the caller guarantees that `slice` is not dangling, so it
        .          .          .          .                   // cannot be longer than `isize::MAX`. They also guarantee that
        .          .          .          .                   // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,
        .          .          .          .                   // so the call to `add` is safe and the length calculation cannot overflow.
        .          .          .          .                   unsafe {
        .          .          .          .                       // Using the intrinsic avoids a superfluous UB check,
        .          .          .          .                       // since the one on this method already checked `end >= start`.
  179,021 ( 0.05%) .          .          .                       let new_len = crate::intrinsics::unchecked_sub(self.end, self.start);
        .          .          .          .                       get_offset_len_noubcheck(slice, self.start, new_len)
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {
        .          .          .          .                   assert_unsafe_precondition!(
        .          .          .          .                       check_library_ub,
-- line 415 ----------------------------------------
-- line 417 ----------------------------------------
        .          .          .          .                       (
        .          .          .          .                           start: usize = self.start,
        .          .          .          .                           end: usize = self.end,
        .          .          .          .                           len: usize = slice.len()
        .          .          .          .                       ) => end >= start && end <= len
        .          .          .          .                   );
        .          .          .          .                   // SAFETY: see comments for `get_unchecked` above.
        .          .          .          .                   unsafe {
       16 ( 0.00%) .          .          .                       let new_len = crate::intrinsics::unchecked_sub(self.end, self.start);
        .          .          .          .                       get_offset_len_mut_noubcheck(slice, self.start, new_len)
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline(always)]
        .          .          .          .               fn index(self, slice: &[T]) -> &[T] {
        .          .          .          .                   // Using checked_sub is a safe way to get `SubUnchecked` in MIR
        .          .          .          .                   let Some(new_len) = usize::checked_sub(self.end, self.start) else {
        .          .          .          .                       slice_index_order_fail(self.start, self.end)
        .          .          .          .                   };
   10,746 ( 0.00%) .          .          .                   if self.end > slice.len() {
        .          .          .          .                       slice_end_index_len_fail(self.end, slice.len());
        .          .          .          .                   }
        .          .          .          .                   // SAFETY: `self` is checked to be valid and in bounds above.
        .          .          .          .                   unsafe { &*get_offset_len_noubcheck(slice, self.start, new_len) }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn index_mut(self, slice: &mut [T]) -> &mut [T] {
        .          .          .          .                   let Some(new_len) = usize::checked_sub(self.end, self.start) else {
        .          .          .          .                       slice_index_order_fail(self.start, self.end)
        .          .          .          .                   };
    6,908 ( 0.00%) .          .          .                   if self.end > slice.len() {
        .          .          .          .                       slice_end_index_len_fail(self.end, slice.len());
        .          .          .          .                   }
        .          .          .          .                   // SAFETY: `self` is checked to be valid and in bounds above.
        .          .          .          .                   unsafe { &mut *get_offset_len_mut_noubcheck(slice, self.start, new_len) }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[unstable(feature = "new_range_api", issue = "125687")]
-- line 456 ----------------------------------------
-- line 552 ----------------------------------------
        .          .          .          .               #[inline]
        .          .          .          .               unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {
        .          .          .          .                   // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.
        .          .          .          .                   unsafe { (self.start..slice.len()).get_unchecked_mut(slice) }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn index(self, slice: &[T]) -> &[T] {
   81,061 ( 0.02%) .          .          .                   if self.start > slice.len() {
        .          .          .          .                       slice_start_index_len_fail(self.start, slice.len());
        .          .          .          .                   }
        .          .          .          .                   // SAFETY: `self` is checked to be valid and in bounds above.
        .          .          .          .                   unsafe { &*self.get_unchecked(slice) }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn index_mut(self, slice: &mut [T]) -> &mut [T] {
   10,107 ( 0.00%) .          .          .                   if self.start > slice.len() {
        .          .          .          .                       slice_start_index_len_fail(self.start, slice.len());
        .          .          .          .                   }
        .          .          .          .                   // SAFETY: `self` is checked to be valid and in bounds above.
        .          .          .          .                   unsafe { &mut *self.get_unchecked_mut(slice) }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[unstable(feature = "new_range_api", issue = "125687")]
-- line 577 ----------------------------------------
-- line 852 ----------------------------------------
        .          .          .          .                   }
        .          .          .          .                   ops::Bound::Excluded(&end) => end,
        .          .          .          .                   ops::Bound::Unbounded => len,
        .          .          .          .               };
        .          .          .          .           
        .          .          .          .               if start > end {
        .          .          .          .                   slice_index_order_fail(start, end);
        .          .          .          .               }
    4,137 ( 0.00%) .          .          .               if end > len {
        .          .          .          .                   slice_end_index_len_fail(end, len);
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               ops::Range { start, end }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// Performs bounds checking of a range without panicking.
        .          .          .          .           ///
-- line 868 ----------------------------------------

  581,032 ( 0.17%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/map.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 120 ----------------------------------------
     .          .          .          .                   assert!(capacity > 0);
     .          .          .          .                   Utf8BoundedMap { version: 0, capacity, map: vec![] }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Clear this map of all entries, but permit the reuse of allocation
     .          .          .          .               /// if possible.
     .          .          .          .               ///
     .          .          .          .               /// This must be called before the map can be used.
   882 ( 0.00%) .          .          .               pub fn clear(&mut self) {
   252 ( 0.00%) .          .          .                   if self.map.is_empty() {
    67 ( 0.00%) .          .          .                       self.map = vec![Utf8BoundedEntry::default(); self.capacity];
     .          .          .          .                   } else {
    59 ( 0.00%) .          .          .                       self.version = self.version.wrapping_add(1);
     .          .          .          .                       // If we loop back to version 0, then we forcefully clear the
     .          .          .          .                       // entire map. Otherwise, it might be possible to incorrectly
     .          .          .          .                       // match entries used to generate other NFAs.
    59 ( 0.00%) .          .          .                       if self.version == 0 {
     .          .          .          .                           self.map = vec![Utf8BoundedEntry::default(); self.capacity];
     .          .          .          .                       }
     .          .          .          .                   }
   882 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return a hash of the given transitions.
     .          .          .          .               pub fn hash(&self, key: &[Transition]) -> usize {
     .          .          .          .                   let mut h = INIT;
     .          .          .          .                   for t in key {
 5,534 ( 0.00%) .          .          .                       h = (h ^ u64::from(t.start)).wrapping_mul(PRIME);
 5,534 ( 0.00%) .          .          .                       h = (h ^ u64::from(t.end)).wrapping_mul(PRIME);
 2,767 ( 0.00%) .          .          .                       h = (h ^ t.next.as_u64()).wrapping_mul(PRIME);
     .          .          .          .                   }
 6,856 ( 0.00%) .          .          .                   (h % self.map.len().as_u64()).as_usize()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Retrieve the cached state ID corresponding to the given key. The hash
     .          .          .          .               /// given must have been computed with `hash` using the same key value.
     .          .          .          .               ///
     .          .          .          .               /// If there is no cached state with the given transitions, then None is
     .          .          .          .               /// returned.
     .          .          .          .               pub fn get(&mut self, key: &[Transition], hash: usize) -> Option<StateID> {
     .          .          .          .                   let entry = &self.map[hash];
 5,142 ( 0.00%) .          .          .                   if entry.version != self.version {
     .          .          .          .                       return None;
     .          .          .          .                   }
     .          .          .          .                   // There may be a hash collision, so we need to confirm real equality.
     .          .          .          .                   if entry.key != key {
     .          .          .          .                       return None;
     .          .          .          .                   }
   941 ( 0.00%) .          .          .                   Some(entry.val)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add a cached state to this map with the given key. Callers should
     .          .          .          .               /// ensure that `state_id` points to a state that contains precisely the
     .          .          .          .               /// NFA transitions given.
     .          .          .          .               ///
     .          .          .          .               /// `hash` must have been computed using the `hash` method with the same
     .          .          .          .               /// key.
     .          .          .          .               pub fn set(
     .          .          .          .                   &mut self,
     .          .          .          .                   key: Vec<Transition>,
     .          .          .          .                   hash: usize,
     .          .          .          .                   state_id: StateID,
     .          .          .          .               ) {
 5,411 ( 0.00%) .          .          .                   self.map[hash] =
   773 ( 0.00%) .          .          .                       Utf8BoundedEntry { version: self.version, key, val: state_id };
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A cache of suffixes used to modestly compress UTF-8 automata for large
     .          .          .          .           /// Unicode character classes.
     .          .          .          .           #[derive(Clone, Debug)]
     .          .          .          .           pub struct Utf8SuffixMap {
     .          .          .          .               /// The current version of this map. Only entries with matching versions
-- line 191 ----------------------------------------
-- line 196 ----------------------------------------
     .          .          .          .               capacity: usize,
     .          .          .          .               /// The actual entries, keyed by hash. Collisions between different states
     .          .          .          .               /// result in the old state being dropped.
     .          .          .          .               map: Vec<Utf8SuffixEntry>,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A key that uniquely identifies an NFA state. It is a triple that represents
     .          .          .          .           /// a transition from one state for a particular byte range.
 3,726 ( 0.00%) .          .          .           #[derive(Clone, Debug, Default, Eq, PartialEq)]
     .          .          .          .           pub struct Utf8SuffixKey {
     .          .          .          .               pub from: StateID,
     .          .          .          .               pub start: u8,
     .          .          .          .               pub end: u8,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// An entry in this map.
     .          .          .          .           #[derive(Clone, Debug, Default)]
-- line 212 ----------------------------------------
-- line 227 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// Note that this does not allocate. Instead, callers must call `clear`
     .          .          .          .               /// before using this map. `clear` will allocate space if necessary.
     .          .          .          .               ///
     .          .          .          .               /// This avoids the need to pay for the allocation of this map when
     .          .          .          .               /// compiling regexes that lack large Unicode character classes.
     .          .          .          .               pub fn new(capacity: usize) -> Utf8SuffixMap {
     .          .          .          .                   assert!(capacity > 0);
 2,965 ( 0.00%) .          .          .                   Utf8SuffixMap { version: 0, capacity, map: vec![] }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Clear this map of all entries, but permit the reuse of allocation
     .          .          .          .               /// if possible.
     .          .          .          .               ///
     .          .          .          .               /// This must be called before the map can be used.
   762 ( 0.00%) .          .          .               pub fn clear(&mut self) {
   254 ( 0.00%) .          .          .                   if self.map.is_empty() {
    68 ( 0.00%) .          .          .                       self.map = vec![Utf8SuffixEntry::default(); self.capacity];
     .          .          .          .                   } else {
    59 ( 0.00%) .          .          .                       self.version = self.version.wrapping_add(1);
    59 ( 0.00%) .          .          .                       if self.version == 0 {
     .          .          .          .                           self.map = vec![Utf8SuffixEntry::default(); self.capacity];
     .          .          .          .                       }
     .          .          .          .                   }
   762 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return a hash of the given transition.
     .          .          .          .               pub fn hash(&self, key: &Utf8SuffixKey) -> usize {
     .          .          .          .                   // Basic FNV-1a hash as described:
     .          .          .          .                   // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
     .          .          .          .                   const PRIME: u64 = 1099511628211;
     .          .          .          .                   const INIT: u64 = 14695981039346656037;
     .          .          .          .           
     .          .          .          .                   let mut h = INIT;
 9,786 ( 0.00%) .          .          .                   h = (h ^ key.from.as_u64()).wrapping_mul(PRIME);
 3,262 ( 0.00%) .          .          .                   h = (h ^ u64::from(key.start)).wrapping_mul(PRIME);
 3,262 ( 0.00%) .          .          .                   h = (h ^ u64::from(key.end)).wrapping_mul(PRIME);
13,048 ( 0.00%) .          .          .                   (h % self.map.len().as_u64()).as_usize()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Retrieve the cached state ID corresponding to the given key. The hash
     .          .          .          .               /// given must have been computed with `hash` using the same key value.
     .          .          .          .               ///
     .          .          .          .               /// If there is no cached state with the given key, then None is returned.
     .          .          .          .               pub fn get(
     .          .          .          .                   &mut self,
     .          .          .          .                   key: &Utf8SuffixKey,
     .          .          .          .                   hash: usize,
     .          .          .          .               ) -> Option<StateID> {
     .          .          .          .                   let entry = &self.map[hash];
 9,786 ( 0.00%) .          .          .                   if entry.version != self.version {
     .          .          .          .                       return None;
     .          .          .          .                   }
   464 ( 0.00%) .          .          .                   if key != &entry.key {
     .          .          .          .                       return None;
     .          .          .          .                   }
   464 ( 0.00%) .          .          .                   Some(entry.val)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Add a cached state to this map with the given key. Callers should
     .          .          .          .               /// ensure that `state_id` points to a state that contains precisely the
     .          .          .          .               /// NFA transition given.
     .          .          .          .               ///
     .          .          .          .               /// `hash` must have been computed using the `hash` method with the same
     .          .          .          .               /// key.
     .          .          .          .               pub fn set(&mut self, key: Utf8SuffixKey, hash: usize, state_id: StateID) {
11,192 ( 0.00%) .          .          .                   self.map[hash] =
 2,798 ( 0.00%) .          .          .                       Utf8SuffixEntry { version: self.version, key, val: state_id };
     .          .          .          .               }
     .          .          .          .           }

17,896 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/map.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 515 ----------------------------------------
        .          .          .          .           ///
        .          .          .          .           /// // Ensure that the last item was dropped.
        .          .          .          .           /// assert!(weak.upgrade().is_none());
        .          .          .          .           /// ```
        .          .          .          .           #[stable(feature = "drop_in_place", since = "1.8.0")]
        .          .          .          .           #[lang = "drop_in_place"]
        .          .          .          .           #[allow(unconditional_recursion)]
        .          .          .          .           #[rustc_diagnostic_item = "ptr_drop_in_place"]
7,197,045 ( 2.16%) .          .          .           pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {
6,013,983 ( 1.81%) 39,114 ( 4.83%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::drop::Drop>::drop (495x)
        .          .          .          .               // Code here does not matter - this is replaced by the
        .          .          .          .               // real drop glue by the compiler.
        .          .          .          .           
        .          .          .          .               // SAFETY: see comment above
        .          .          .          .               unsafe { drop_in_place(to_drop) }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// Creates a null raw pointer.
-- line 531 ----------------------------------------
-- line 1377 ----------------------------------------
        .          .          .          .                       check_language_ub,
        .          .          .          .                       "ptr::read requires that the pointer argument is aligned and non-null",
        .          .          .          .                       (
        .          .          .          .                           addr: *const () = src as *const (),
        .          .          .          .                           align: usize = align_of::<T>(),
        .          .          .          .                           is_zst: bool = T::IS_ZST,
        .          .          .          .                       ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, is_zst)
        .          .          .          .                   );
1,831,086 ( 0.55%) .          .          .                   crate::intrinsics::read_via_copy(src)
  252,326 ( 0.08%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (5,123x)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// Reads the value from `src` without moving it. This leaves the
        .          .          .          .           /// memory in `src` unchanged.
        .          .          .          .           ///
        .          .          .          .           /// Unlike [`read`], `read_unaligned` works with unaligned pointers.
        .          .          .          .           ///
-- line 1393 ----------------------------------------
-- line 1579 ----------------------------------------
        .          .          .          .                       check_language_ub,
        .          .          .          .                       "ptr::write requires that the pointer argument is aligned and non-null",
        .          .          .          .                       (
        .          .          .          .                           addr: *mut () = dst as *mut (),
        .          .          .          .                           align: usize = align_of::<T>(),
        .          .          .          .                           is_zst: bool = T::IS_ZST,
        .          .          .          .                       ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, is_zst)
        .          .          .          .                   );
8,503,517 ( 2.55%) .          .          .                   intrinsics::write_via_move(dst, src)
   65,552 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1x)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// Overwrites a memory location with the given value without reading or
        .          .          .          .           /// dropping the old value.
        .          .          .          .           ///
        .          .          .          .           /// Unlike [`write()`], the pointer may be unaligned.
        .          .          .          .           ///
-- line 1595 ----------------------------------------
-- line 1749 ----------------------------------------
        .          .          .          .                       check_language_ub,
        .          .          .          .                       "ptr::read_volatile requires that the pointer argument is aligned and non-null",
        .          .          .          .                       (
        .          .          .          .                           addr: *const () = src as *const (),
        .          .          .          .                           align: usize = align_of::<T>(),
        .          .          .          .                           is_zst: bool = T::IS_ZST,
        .          .          .          .                       ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, is_zst)
        .          .          .          .                   );
  244,660 ( 0.07%) .          .          .                   intrinsics::volatile_load(src)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// Performs a volatile write of a memory location with the given value without
        .          .          .          .           /// reading or dropping the old value.
        .          .          .          .           ///
        .          .          .          .           /// Volatile operations are intended to act on I/O memory, and are guaranteed
        .          .          .          .           /// to not be elided or reordered by the compiler across other volatile
-- line 1765 ----------------------------------------

  320,712 ( 0.10%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/search.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 49 ----------------------------------------
     .          .          .          .               pub fn search_tree<Q: ?Sized>(
     .          .          .          .                   mut self,
     .          .          .          .                   key: &Q,
     .          .          .          .               ) -> SearchResult<BorrowType, K, V, marker::LeafOrInternal, marker::Leaf>
     .          .          .          .               where
     .          .          .          .                   Q: Ord,
     .          .          .          .                   K: Borrow<Q>,
     .          .          .          .               {
   358 ( 0.00%) .          .          .                   loop {
     .          .          .          .                       self = match self.search_node(key) {
     .          .          .          .                           Found(handle) => return Found(handle),
     .          .          .          .                           GoDown(handle) => match handle.force() {
     .          .          .          .                               Leaf(leaf) => return GoDown(leaf),
     .          .          .          .                               Internal(internal) => internal.descend(),
     .          .          .          .                           },
     .          .          .          .                       }
     .          .          .          .                   }
-- line 65 ----------------------------------------
-- line 98 ----------------------------------------
     .          .          .          .                   K: Borrow<Q>,
     .          .          .          .                   R: RangeBounds<Q>,
     .          .          .          .               {
     .          .          .          .                   // Determine if map or set is being searched
     .          .          .          .                   let is_set = <V as super::set_val::IsSetVal>::is_set_val();
     .          .          .          .           
     .          .          .          .                   // Inlining these variables should be avoided. We assume the bounds reported by `range`
     .          .          .          .                   // remain the same, but an adversarial implementation could change between calls (#81138).
    48 ( 0.00%) .          .          .                   let (start, end) = (range.start_bound(), range.end_bound());
    63 ( 0.00%) .          .          .                   match (start, end) {
     .          .          .          .                       (Bound::Excluded(s), Bound::Excluded(e)) if s == e => {
     .          .          .          .                           if is_set {
     .          .          .          .                               panic!("range start and end are equal and excluded in BTreeSet")
     .          .          .          .                           } else {
     .          .          .          .                               panic!("range start and end are equal and excluded in BTreeMap")
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                       (Bound::Included(s) | Bound::Excluded(s), Bound::Included(e) | Bound::Excluded(e))
     6 ( 0.00%) .          .          .                           if s > e =>
     .          .          .          .                       {
     .          .          .          .                           if is_set {
     .          .          .          .                               panic!("range start is greater than range end in BTreeSet")
     .          .          .          .                           } else {
     .          .          .          .                               panic!("range start is greater than range end in BTreeMap")
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                       _ => {}
     .          .          .          .                   }
     .          .          .          .                   let mut lower_bound = SearchBound::from_range(start);
     .          .          .          .                   let mut upper_bound = SearchBound::from_range(end);
     .          .          .          .                   loop {
     .          .          .          .                       let (lower_edge_idx, lower_child_bound) = self.find_lower_bound_index(lower_bound);
     .          .          .          .                       let (upper_edge_idx, upper_child_bound) =
     .          .          .          .                           unsafe { self.find_upper_bound_index(upper_bound, lower_edge_idx) };
    46 ( 0.00%) .          .          .                       if lower_edge_idx < upper_edge_idx {
     .          .          .          .                           return Ok((
     .          .          .          .                               self,
     .          .          .          .                               lower_edge_idx,
     .          .          .          .                               upper_edge_idx,
     .          .          .          .                               lower_child_bound,
     .          .          .          .                               upper_child_bound,
     .          .          .          .                           ));
     .          .          .          .                       }
-- line 140 ----------------------------------------
-- line 214 ----------------------------------------
     .          .          .          .               unsafe fn find_key_index<Q: ?Sized>(&self, key: &Q, start_index: usize) -> IndexResult
     .          .          .          .               where
     .          .          .          .                   Q: Ord,
     .          .          .          .                   K: Borrow<Q>,
     .          .          .          .               {
     .          .          .          .                   let node = self.reborrow();
     .          .          .          .                   let keys = node.keys();
     .          .          .          .                   debug_assert!(start_index <= keys.len());
 6,972 ( 0.00%) .          .          .                   for (offset, k) in unsafe { keys.get_unchecked(start_index..) }.iter().enumerate() {
50,302 ( 0.02%) .          .          .                       match key.cmp(k.borrow()) {
     .          .          .          .                           Ordering::Greater => {}
     .          .          .          .                           Ordering::Equal => return IndexResult::KV(start_index + offset),
     .          .          .          .                           Ordering::Less => return IndexResult::Edge(start_index + offset),
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   IndexResult::Edge(keys.len())
     .          .          .          .               }
     .          .          .          .           
-- line 231 ----------------------------------------
-- line 237 ----------------------------------------
     .          .          .          .               fn find_lower_bound_index<'r, Q>(
     .          .          .          .                   &self,
     .          .          .          .                   bound: SearchBound<&'r Q>,
     .          .          .          .               ) -> (usize, SearchBound<&'r Q>)
     .          .          .          .               where
     .          .          .          .                   Q: ?Sized + Ord,
     .          .          .          .                   K: Borrow<Q>,
     .          .          .          .               {
    75 ( 0.00%) .          .          .                   match bound {
     8 ( 0.00%) .          .          .                       Included(key) => match unsafe { self.find_key_index(key, 0) } {
     .          .          .          .                           IndexResult::KV(idx) => (idx, AllExcluded),
     .          .          .          .                           IndexResult::Edge(idx) => (idx, bound),
     .          .          .          .                       },
     .          .          .          .                       Excluded(key) => match unsafe { self.find_key_index(key, 0) } {
     .          .          .          .                           IndexResult::KV(idx) => (idx + 1, AllIncluded),
     .          .          .          .                           IndexResult::Edge(idx) => (idx, bound),
     .          .          .          .                       },
     .          .          .          .                       AllIncluded => (0, AllIncluded),
-- line 254 ----------------------------------------
-- line 265 ----------------------------------------
     .          .          .          .                   &self,
     .          .          .          .                   bound: SearchBound<&'r Q>,
     .          .          .          .                   start_index: usize,
     .          .          .          .               ) -> (usize, SearchBound<&'r Q>)
     .          .          .          .               where
     .          .          .          .                   Q: ?Sized + Ord,
     .          .          .          .                   K: Borrow<Q>,
     .          .          .          .               {
    68 ( 0.00%) .          .          .                   match bound {
     .          .          .          .                       Included(key) => match unsafe { self.find_key_index(key, start_index) } {
     .          .          .          .                           IndexResult::KV(idx) => (idx + 1, AllExcluded),
     .          .          .          .                           IndexResult::Edge(idx) => (idx, bound),
     .          .          .          .                       },
     .          .          .          .                       Excluded(key) => match unsafe { self.find_key_index(key, start_index) } {
     .          .          .          .                           IndexResult::KV(idx) => (idx, AllIncluded),
     .          .          .          .                           IndexResult::Edge(idx) => (idx, bound),
     .          .          .          .                       },
-- line 281 ----------------------------------------

 2,686 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/search.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/drain.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 149 ----------------------------------------
      .          .          .          .           unsafe impl<T: Send, A: Send + Allocator> Send for Drain<'_, T, A> {}
      .          .          .          .           
      .          .          .          .           #[stable(feature = "drain", since = "1.6.0")]
      .          .          .          .           impl<T, A: Allocator> Iterator for Drain<'_, T, A> {
      .          .          .          .               type Item = T;
      .          .          .          .           
      .          .          .          .               #[inline]
      .          .          .          .               fn next(&mut self) -> Option<T> {
  2,092 ( 0.00%) .          .          .                   self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn size_hint(&self) -> (usize, Option<usize>) {
      .          .          .          .                   self.iter.size_hint()
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[stable(feature = "drain", since = "1.6.0")]
-- line 165 ----------------------------------------
-- line 167 ----------------------------------------
      .          .          .          .               #[inline]
      .          .          .          .               fn next_back(&mut self) -> Option<T> {
      .          .          .          .                   self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[stable(feature = "drain", since = "1.6.0")]
      .          .          .          .           impl<T, A: Allocator> Drop for Drain<'_, T, A> {
113,420 ( 0.03%) .          .          .               fn drop(&mut self) {
      .          .          .          .                   /// Moves back the un-`Drain`ed elements to restore the original `Vec`.
      .          .          .          .                   struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);
      .          .          .          .           
      .          .          .          .                   impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {
      .          .          .          .                       fn drop(&mut self) {
 63,089 ( 0.02%) .          .          .                           if self.0.tail_len > 0 {
      .          .          .          .                               unsafe {
      .          .          .          .                                   let source_vec = self.0.vec.as_mut();
      .          .          .          .                                   // memmove back untouched tail, update to new length
      .          .          .          .                                   let start = source_vec.len();
      .          .          .          .                                   let tail = self.0.tail_start;
      .          .          .          .                                   if tail != start {
      .          .          .          .                                       let src = source_vec.as_ptr().add(tail);
      .          .          .          .                                       let dst = source_vec.as_mut_ptr().add(start);
-- line 189 ----------------------------------------
-- line 193 ----------------------------------------
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   let iter = mem::take(&mut self.iter);
      .          .          .          .                   let drop_len = iter.len();
      .          .          .          .           
 18,903 ( 0.01%) .          .          .                   let mut vec = self.vec;
      .          .          .          .           
      .          .          .          .                   if T::IS_ZST {
      .          .          .          .                       // ZSTs have no identity, so we don't need to move them around, we only need to drop the correct amount.
      .          .          .          .                       // this can be achieved by manipulating the Vec length instead of moving values out from `iter`.
      .          .          .          .                       unsafe {
      .          .          .          .                           let vec = vec.as_mut();
      .          .          .          .                           let old_len = vec.len();
      .          .          .          .                           vec.set_len(old_len + drop_len + self.tail_len);
-- line 209 ----------------------------------------
-- line 211 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .           
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // ensure elements are moved back into their appropriate places, even when drop_in_place panics
      .          .          .          .                   let _guard = DropGuard(self);
      .          .          .          .           
 46,899 ( 0.01%) .          .          .                   if drop_len == 0 {
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // as_slice() must only be called when iter.len() is > 0 because
      .          .          .          .                   // it also gets touched by vec::Splice which may turn it into a dangling pointer
      .          .          .          .                   // which would make it and the vec pointer point to different allocations which would
      .          .          .          .                   // lead to invalid pointer arithmetic below.
      .          .          .          .                   let drop_ptr = iter.as_slice().as_ptr();
-- line 227 ----------------------------------------
-- line 231 ----------------------------------------
      .          .          .          .                       // a pointer with mutable provenance is necessary. Therefore we must reconstruct
      .          .          .          .                       // it from the original vec but also avoid creating a &mut to the front since that could
      .          .          .          .                       // invalidate raw pointers to it which some unsafe code might rely on.
      .          .          .          .                       let vec_ptr = vec.as_mut().as_mut_ptr();
      .          .          .          .                       let drop_offset = drop_ptr.sub_ptr(vec_ptr);
      .          .          .          .                       let to_drop = ptr::slice_from_raw_parts_mut(vec_ptr.add(drop_offset), drop_len);
      .          .          .          .                       ptr::drop_in_place(to_drop);
      .          .          .          .                   }
113,420 ( 0.03%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[stable(feature = "drain", since = "1.6.0")]
      .          .          .          .           impl<T, A: Allocator> ExactSizeIterator for Drain<'_, T, A> {
      .          .          .          .               fn is_empty(&self) -> bool {
      .          .          .          .                   self.iter.is_empty()
      .          .          .          .               }
      .          .          .          .           }
-- line 247 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/pattern.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 11 ----------------------------------------
    .          .          .          .           ///
    .          .          .          .           /// This collection of patterns is what is passed around to both execute
    .          .          .          .           /// searches and to construct the searchers themselves. Namely, this permits
    .          .          .          .           /// searches to avoid copying all of the patterns, and allows us to keep only
    .          .          .          .           /// one copy throughout all packed searchers.
    .          .          .          .           ///
    .          .          .          .           /// Note that this collection is not a set. The same pattern can appear more
    .          .          .          .           /// than once.
  480 ( 0.00%) .          .          .           #[derive(Clone, Debug)]
397,589 ( 0.12%) 2,727 ( 0.34%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::clone::Clone>::clone (48x)
    .          .          .          .           pub(crate) struct Patterns {
    .          .          .          .               /// The match semantics supported by this collection of patterns.
    .          .          .          .               ///
    .          .          .          .               /// The match semantics determines the order of the iterator over patterns.
    .          .          .          .               /// For leftmost-first, patterns are provided in the same order as were
    .          .          .          .               /// provided by the caller. For leftmost-longest, patterns are provided in
    .          .          .          .               /// descending order of length, with ties broken by the order in which they
    .          .          .          .               /// were provided by the caller.
-- line 27 ----------------------------------------
-- line 62 ----------------------------------------
    .          .          .          .                       minimum_len: usize::MAX,
    .          .          .          .                       total_pattern_bytes: 0,
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Add a pattern to this collection.
    .          .          .          .               ///
    .          .          .          .               /// This panics if the pattern given is empty.
6,970 ( 0.00%) .          .          .               pub(crate) fn add(&mut self, bytes: &[u8]) {
2,788 ( 0.00%) .          .          .                   assert!(!bytes.is_empty());
2,788 ( 0.00%) .          .          .                   assert!(self.by_id.len() <= u16::MAX as usize);
    .          .          .          .           
    .          .          .          .                   let id = PatternID::new(self.by_id.len()).unwrap();
  180 ( 0.00%) .          .          .                   self.order.push(id);
    .          .          .          .                   self.by_id.push(bytes.to_vec());
2,788 ( 0.00%) .          .          .                   self.minimum_len = cmp::min(self.minimum_len, bytes.len());
1,394 ( 0.00%) .          .          .                   self.total_pattern_bytes += bytes.len();
8,364 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Set the match kind semantics for this collection of patterns.
    .          .          .          .               ///
    .          .          .          .               /// If the kind is not set, then the default is leftmost-first.
    .          .          .          .               pub(crate) fn set_match_kind(&mut self, kind: MatchKind) {
   48 ( 0.00%) .          .          .                   self.kind = kind;
   96 ( 0.00%) .          .          .                   match self.kind {
    .          .          .          .                       MatchKind::LeftmostFirst => {
    .          .          .          .                           self.order.sort();
    .          .          .          .                       }
    .          .          .          .                       MatchKind::LeftmostLongest => {
    .          .          .          .                           let (order, by_id) = (&mut self.order, &mut self.by_id);
    .          .          .          .                           order.sort_by(|&id1, &id2| {
    .          .          .          .                               by_id[id1].len().cmp(&by_id[id2].len()).reverse()
    .          .          .          .                           });
-- line 94 ----------------------------------------
-- line 124 ----------------------------------------
    .          .          .          .                   self.order.clear();
    .          .          .          .                   self.minimum_len = usize::MAX;
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the length, in bytes, of the smallest pattern.
    .          .          .          .               ///
    .          .          .          .               /// This is guaranteed to be at least one.
    .          .          .          .               pub(crate) fn minimum_len(&self) -> usize {
1,294 ( 0.00%) .          .          .                   self.minimum_len
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the match semantics used by these patterns.
    .          .          .          .               pub(crate) fn match_kind(&self) -> &MatchKind {
    .          .          .          .                   &self.kind
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Return the pattern with the given identifier. If such a pattern does
    .          .          .          .               /// not exist, then this panics.
    .          .          .          .               pub(crate) fn get(&self, id: PatternID) -> Pattern<'_> {
   96 ( 0.00%) .          .          .                   Pattern(&self.by_id[id])
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Return the pattern with the given identifier without performing bounds
    .          .          .          .               /// checks.
    .          .          .          .               ///
    .          .          .          .               /// # Safety
    .          .          .          .               ///
    .          .          .          .               /// Callers must ensure that a pattern with the given identifier exists
-- line 151 ----------------------------------------
-- line 189 ----------------------------------------
    .          .          .          .               patterns: &'p Patterns,
    .          .          .          .               i: usize,
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'p> Iterator for PatternIter<'p> {
    .          .          .          .               type Item = (PatternID, Pattern<'p>);
    .          .          .          .           
    .          .          .          .               fn next(&mut self) -> Option<(PatternID, Pattern<'p>)> {
5,598 ( 0.00%) .          .          .                   if self.i >= self.patterns.len() {
    .          .          .          .                       return None;
    .          .          .          .                   }
2,478 ( 0.00%) .          .          .                   let id = self.patterns.order[self.i];
    .          .          .          .                   let p = self.patterns.get(id);
    .          .          .          .                   self.i += 1;
    .          .          .          .                   Some((id, p))
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// A pattern that is used in packed searching.
    .          .          .          .           #[derive(Clone)]
-- line 208 ----------------------------------------
-- line 227 ----------------------------------------
    .          .          .          .                   &self.0
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the first `len` low nybbles from this pattern. If this pattern
    .          .          .          .               /// is shorter than `len`, then this panics.
    .          .          .          .               pub(crate) fn low_nybbles(&self, len: usize) -> Box<[u8]> {
    .          .          .          .                   let mut nybs = vec![0; len].into_boxed_slice();
    .          .          .          .                   for (i, byte) in self.bytes().iter().take(len).enumerate() {
3,072 ( 0.00%) .          .          .                       nybs[i] = byte & 0xF;
    .          .          .          .                   }
    .          .          .          .                   nybs
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns true if this pattern is a prefix of the given bytes.
    .          .          .          .               #[inline(always)]
    .          .          .          .               pub(crate) fn is_prefix(&self, bytes: &[u8]) -> bool {
    .          .          .          .                   is_prefix(bytes, self.bytes())
-- line 243 ----------------------------------------
-- line 264 ----------------------------------------
    .          .          .          .               #[inline(always)]
    .          .          .          .               pub(crate) unsafe fn is_prefix_raw(
    .          .          .          .                   &self,
    .          .          .          .                   start: *const u8,
    .          .          .          .                   end: *const u8,
    .          .          .          .               ) -> bool {
    .          .          .          .                   let patlen = self.bytes().len();
    .          .          .          .                   let haylen = end.distance(start);
  100 ( 0.00%) .          .          .                   if patlen > haylen {
    .          .          .          .                       return false;
    .          .          .          .                   }
    .          .          .          .                   // SAFETY: We've checked that the haystack has length at least equal
    .          .          .          .                   // to this pattern. All other safety concerns are the responsibility
    .          .          .          .                   // of the caller.
    .          .          .          .                   is_equal_raw(start, self.bytes().as_ptr(), patlen)
    .          .          .          .               }
    .          .          .          .           }
-- line 280 ----------------------------------------
-- line 365 ----------------------------------------
    .          .          .          .           /// * The distance being in bounds must not rely on "wrapping around" the
    .          .          .          .           /// address space.
    .          .          .          .           #[inline(always)]
    .          .          .          .           unsafe fn is_equal_raw(mut x: *const u8, mut y: *const u8, n: usize) -> bool {
    .          .          .          .               // If we don't have enough bytes to do 4-byte at a time loads, then
    .          .          .          .               // handle each possible length specially. Note that I used to have a
    .          .          .          .               // byte-at-a-time loop here and that turned out to be quite a bit slower
    .          .          .          .               // for the memmem/pathological/defeat-simple-vector-alphabet benchmark.
  100 ( 0.00%) .          .          .               if n < 4 {
  150 ( 0.00%) .          .          .                   return match n {
    .          .          .          .                       0 => true,
    .          .          .          .                       1 => x.read() == y.read(),
    .          .          .          .                       2 => {
    .          .          .          .                           x.cast::<u16>().read_unaligned()
    .          .          .          .                               == y.cast::<u16>().read_unaligned()
    .          .          .          .                       }
    .          .          .          .                       // I also tried copy_nonoverlapping here and it looks like the
    .          .          .          .                       // codegen is the same.
-- line 382 ----------------------------------------

7,108 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/pattern.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 89 ----------------------------------------
      .          .          .          .               /// here must the same one given to `swap` and `remap`.
      .          .          .          .               ///
      .          .          .          .               /// The given stride should be the stride of the transition table expressed
      .          .          .          .               /// as a power of 2. This stride is used to map between state IDs and state
      .          .          .          .               /// indices. If state IDs and state indices are equivalent, then provide
      .          .          .          .               /// a `stride2` of `0`, which acts as an identity.
      .          .          .          .               pub(crate) fn new(r: &impl Remappable, stride2: usize) -> Remapper {
      .          .          .          .                   let idx = IndexMapper { stride2 };
     48 ( 0.00%) .          .          .                   let map = (0..r.state_len()).map(|i| idx.to_state_id(i)).collect();
     96 ( 0.00%) .          .          .                   Remapper { map, idx }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Swap two states. Once this is called, callers must follow through to
      .          .          .          .               /// call `remap`, or else it's possible for the underlying remappable
      .          .          .          .               /// value to be in a corrupt state.
  1,490 ( 0.00%) .          .          .               pub(crate) fn swap(
      .          .          .          .                   &mut self,
      .          .          .          .                   r: &mut impl Remappable,
      .          .          .          .                   id1: StateID,
      .          .          .          .                   id2: StateID,
      .          .          .          .               ) {
  1,490 ( 0.00%) .          .          .                   if id1 == id2 {
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .                   r.swap_states(id1, id2);
  1,446 ( 0.00%) .          .          .                   self.map.swap(self.idx.to_index(id1), self.idx.to_index(id2));
  2,980 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Complete the remapping process by rewriting all state IDs in the
      .          .          .          .               /// remappable value according to the swaps performed.
    384 ( 0.00%) .          .          .               pub(crate) fn remap(mut self, r: &mut impl Remappable) {
      .          .          .          .                   // Update the map to account for states that have been swapped
      .          .          .          .                   // multiple times. For example, if (A, C) and (C, G) are swapped, then
      .          .          .          .                   // transitions previously pointing to A should now point to G. But if
      .          .          .          .                   // we don't update our map, they will erroneously be set to C. All we
      .          .          .          .                   // do is follow the swaps in our map until we see our original state
      .          .          .          .                   // ID.
      .          .          .          .                   //
      .          .          .          .                   // The intuition here is to think about how changes are made to the
-- line 127 ----------------------------------------
-- line 130 ----------------------------------------
      .          .          .          .                   // state by following the swaps represented in the map (which might be
      .          .          .          .                   // 0 swaps).
      .          .          .          .                   //
      .          .          .          .                   // We are also careful to clone the map before starting in order to
      .          .          .          .                   // freeze it. We use the frozen map to find our loops, since we need to
      .          .          .          .                   // update our map as well. Without freezing it, our updates could break
      .          .          .          .                   // the loops referenced above and produce incorrect results.
      .          .          .          .                   let oldmap = self.map.clone();
     48 ( 0.00%) .          .          .                   for i in 0..r.state_len() {
      .          .          .          .                       let cur_id = self.idx.to_state_id(i);
  2,624 ( 0.00%) .          .          .                       let mut new_id = oldmap[i];
  4,596 ( 0.00%) .          .          .                       if cur_id == new_id {
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       loop {
 23,470 ( 0.01%) .          .          .                           let id = oldmap[self.idx.to_index(new_id)];
 23,470 ( 0.01%) .          .          .                           if cur_id == id {
  1,972 ( 0.00%) .          .          .                               self.map[i] = new_id;
      .          .          .          .                               break;
      .          .          .          .                           }
      .          .          .          .                           new_id = id;
      .          .          .          .                       }
      .          .          .          .                   }
134,967 ( 0.04%) .          .          .                   r.remap(|sid| self.map[self.idx.to_index(sid)]);
1,447,351 ( 0.43%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs:<aho_corasick::nfa::noncontiguous::NFA as aho_corasick::util::remapper::Remappable>::remap (48x)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A simple type for mapping between state indices and state IDs.
      .          .          .          .           ///
      .          .          .          .           /// The reason why this exists is because state IDs are "premultiplied" in a
      .          .          .          .           /// DFA. That is, in order to get to the transitions for a particular state,
      .          .          .          .           /// one need only use the state ID as-is, instead of having to multiply it by
-- line 161 ----------------------------------------
-- line 179 ----------------------------------------
      .          .          .          .               /// transition table. 'id >> stride2' de-multiplies an ID while 'index <<
      .          .          .          .               /// stride2' pre-multiplies an index to an ID.
      .          .          .          .               stride2: usize,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl IndexMapper {
      .          .          .          .               /// Convert a state ID to a state index.
      .          .          .          .               fn to_index(&self, id: StateID) -> usize {
162,583 ( 0.05%) .          .          .                   id.as_usize() >> self.stride2
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Convert a state index to a state ID.
      .          .          .          .               fn to_state_id(&self, index: usize) -> StateID {
      .          .          .          .                   // CORRECTNESS: If the given index is not valid, then it is not
      .          .          .          .                   // required for this to panic or return a valid state ID. We'll "just"
      .          .          .          .                   // wind up with panics or silent logic errors at some other point. But
      .          .          .          .                   // this is OK because if Remappable::state_len is correct and so is
      .          .          .          .                   // 'to_index', then all inputs to 'to_state_id' should be valid indices
      .          .          .          .                   // and thus transform into valid state IDs.
  5,440 ( 0.00%) .          .          .                   StateID::new_unchecked(index << self.stride2)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Remappable for noncontiguous::NFA {
      .          .          .          .               fn state_len(&self) -> usize {
      .          .          .          .                   noncontiguous::NFA::states(self).len()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn swap_states(&mut self, id1: StateID, id2: StateID) {
  2,892 ( 0.00%) .          .          .                   noncontiguous::NFA::swap_states(self, id1, id2)
      .          .          .          .               }
      .          .          .          .           
    336 ( 0.00%) .          .          .               fn remap(&mut self, map: impl Fn(StateID) -> StateID) {
      .          .          .          .                   noncontiguous::NFA::remap(self, map)
    384 ( 0.00%) .          .          .               }
      .          .          .          .           }

 32,062 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 311 ----------------------------------------
      .          .          .          .                   // 3. masking by the alignment can remove at most `align - 1`,
      .          .          .          .                   //    which is what we just added, thus the value we return is never
      .          .          .          .                   //    less than the original `size`.
      .          .          .          .                   //
      .          .          .          .                   // (Size 0 Align MAX is already aligned, so stays the same, but things like
      .          .          .          .                   // Size 1 Align MAX or Size isize::MAX Align 2 round up to `isize::MAX + 1`.)
      .          .          .          .                   unsafe {
      .          .          .          .                       let align_m1 = unchecked_sub(align.as_usize(), 1);
114,570 ( 0.03%) .          .          .                       let size_rounded_up = unchecked_add(self.size, align_m1) & !align_m1;
      .          .          .          .                       size_rounded_up
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates a layout by rounding the size of this layout up to a multiple
      .          .          .          .               /// of the layout's alignment.
      .          .          .          .               ///
      .          .          .          .               /// This is equivalent to adding the result of `padding_needed_for`
-- line 327 ----------------------------------------
-- line 368 ----------------------------------------
      .          .          .          .               /// let padding_needed = Layout::from_size_align(6, 4).unwrap();
      .          .          .          .               /// let repeated = padding_needed.repeat(3).unwrap();
      .          .          .          .               /// assert_eq!(repeated, (Layout::from_size_align(24, 4).unwrap(), 8));
      .          .          .          .               /// ```
      .          .          .          .               #[unstable(feature = "alloc_layout_extra", issue = "55724")]
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutError> {
      .          .          .          .                   let padded = self.pad_to_align();
697,325 ( 0.21%) .          .          .                   if let Ok(repeated) = padded.repeat_packed(n) {
      .          .          .          .                       Ok((repeated, padded.size()))
      .          .          .          .                   } else {
      .          .          .          .                       Err(LayoutError)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates a layout describing the record for `self` followed by
      .          .          .          .               /// `next`, including any necessary padding to ensure that `next`
-- line 384 ----------------------------------------
-- line 500 ----------------------------------------
      .          .          .          .                       let Layout { size: element_size, align } = element_layout;
      .          .          .          .           
      .          .          .          .                       // We need to check two things about the size:
      .          .          .          .                       //  - That the total size won't overflow a `usize`, and
      .          .          .          .                       //  - That the total size still fits in an `isize`.
      .          .          .          .                       // By using division we can check them both with a single threshold.
      .          .          .          .                       // That'd usually be a bad idea, but thankfully here the element size
      .          .          .          .                       // and alignment are constants, so the compiler will fold all of it.
  1,760 ( 0.00%) .          .          .                       if element_size != 0 && n > Layout::max_size_for_align(align) / element_size {
      .          .          .          .                           return Err(LayoutError);
      .          .          .          .                       }
      .          .          .          .           
      .          .          .          .                       // SAFETY: We just checked that we won't overflow `usize` when we multiply.
      .          .          .          .                       // This is a useless hint inside this function, but after inlining this helps
      .          .          .          .                       // deduplicate checks for whether the overall capacity is zero (e.g., in RawVec's
      .          .          .          .                       // allocation path) before/after this multiplication.
      .          .          .          .                       let array_size = unsafe { unchecked_mul(element_size, n) };
-- line 516 ----------------------------------------

622,647 ( 0.19%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 461 ----------------------------------------
      .          .          .          .               /// assert!(ascii.is_ascii());
      .          .          .          .               /// assert!(!non_ascii.is_ascii());
      .          .          .          .               /// ```
      .          .          .          .               #[must_use]
      .          .          .          .               #[stable(feature = "ascii_methods_on_intrinsics", since = "1.23.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_u8_is_ascii", since = "1.43.0")]
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn is_ascii(&self) -> bool {
     85 ( 0.00%) .          .          .                   *self <= 127
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// If the value of this byte is within the ASCII range, returns it as an
      .          .          .          .               /// [ASCII character](ascii::Char).  Otherwise, returns `None`.
      .          .          .          .               #[must_use]
      .          .          .          .               #[unstable(feature = "ascii_char", issue = "110998")]
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn as_ascii(&self) -> Option<ascii::Char> {
-- line 477 ----------------------------------------
-- line 520 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// [`make_ascii_lowercase`]: Self::make_ascii_lowercase
      .          .          .          .               #[must_use = "to lowercase the value in-place, use `make_ascii_lowercase()`"]
      .          .          .          .               #[stable(feature = "ascii_methods_on_intrinsics", since = "1.23.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_ascii_methods_on_intrinsics", since = "1.52.0")]
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn to_ascii_lowercase(&self) -> u8 {
      .          .          .          .                   // Set the 6th bit if this is an uppercase letter
      9 ( 0.00%) .          .          .                   *self | (self.is_ascii_uppercase() as u8 * ASCII_CASE_MASK)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Assumes self is ascii
      .          .          .          .               #[inline]
      .          .          .          .               pub(crate) const fn ascii_change_case_unchecked(&self) -> u8 {
      .          .          .          .                   *self ^ ASCII_CASE_MASK
      .          .          .          .               }
      .          .          .          .           
-- line 536 ----------------------------------------
-- line 597 ----------------------------------------
      .          .          .          .               /// assert_eq!(b'a', byte);
      .          .          .          .               /// ```
      .          .          .          .               ///
      .          .          .          .               /// [`to_ascii_lowercase`]: Self::to_ascii_lowercase
      .          .          .          .               #[stable(feature = "ascii_methods_on_intrinsics", since = "1.23.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_make_ascii", since = "1.84.0")]
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn make_ascii_lowercase(&mut self) {
      3 ( 0.00%) .          .          .                   *self = self.to_ascii_lowercase();
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Checks if the value is an ASCII alphabetic character:
      .          .          .          .               ///
      .          .          .          .               /// - U+0041 'A' ..= U+005A 'Z', or
      .          .          .          .               /// - U+0061 'a' ..= U+007A 'z'.
      .          .          .          .               ///
      .          .          .          .               /// # Examples
-- line 613 ----------------------------------------
-- line 633 ----------------------------------------
      .          .          .          .               /// assert!(!lf.is_ascii_alphabetic());
      .          .          .          .               /// assert!(!esc.is_ascii_alphabetic());
      .          .          .          .               /// ```
      .          .          .          .               #[must_use]
      .          .          .          .               #[stable(feature = "ascii_ctype_on_intrinsics", since = "1.24.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_ascii_ctype_on_intrinsics", since = "1.47.0")]
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn is_ascii_alphabetic(&self) -> bool {
     24 ( 0.00%) .          .          .                   matches!(*self, b'A'..=b'Z' | b'a'..=b'z')
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Checks if the value is an ASCII uppercase character:
      .          .          .          .               /// U+0041 'A' ..= U+005A 'Z'.
      .          .          .          .               ///
      .          .          .          .               /// # Examples
      .          .          .          .               ///
      .          .          .          .               /// ```
-- line 649 ----------------------------------------
-- line 667 ----------------------------------------
      .          .          .          .               /// assert!(!lf.is_ascii_uppercase());
      .          .          .          .               /// assert!(!esc.is_ascii_uppercase());
      .          .          .          .               /// ```
      .          .          .          .               #[must_use]
      .          .          .          .               #[stable(feature = "ascii_ctype_on_intrinsics", since = "1.24.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_ascii_ctype_on_intrinsics", since = "1.47.0")]
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn is_ascii_uppercase(&self) -> bool {
      9 ( 0.00%) .          .          .                   matches!(*self, b'A'..=b'Z')
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Checks if the value is an ASCII lowercase character:
      .          .          .          .               /// U+0061 'a' ..= U+007A 'z'.
      .          .          .          .               ///
      .          .          .          .               /// # Examples
      .          .          .          .               ///
      .          .          .          .               /// ```
-- line 683 ----------------------------------------
-- line 772 ----------------------------------------
      .          .          .          .               /// assert!(!lf.is_ascii_digit());
      .          .          .          .               /// assert!(!esc.is_ascii_digit());
      .          .          .          .               /// ```
      .          .          .          .               #[must_use]
      .          .          .          .               #[stable(feature = "ascii_ctype_on_intrinsics", since = "1.24.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_ascii_ctype_on_intrinsics", since = "1.47.0")]
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn is_ascii_digit(&self) -> bool {
    364 ( 0.00%) .          .          .                   matches!(*self, b'0'..=b'9')
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Checks if the value is an ASCII octal digit:
      .          .          .          .               /// U+0030 '0' ..= U+0037 '7'.
      .          .          .          .               ///
      .          .          .          .               /// # Examples
      .          .          .          .               ///
      .          .          .          .               /// ```
-- line 788 ----------------------------------------
-- line 1034 ----------------------------------------
      .          .          .          .               #[inline]
      .          .          .          .               pub fn escape_ascii(self) -> ascii::EscapeDefault {
      .          .          .          .                   ascii::escape_default(self)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline]
      .          .          .          .               pub(crate) const fn is_utf8_char_boundary(self) -> bool {
      .          .          .          .                   // This is bit magic equivalent to: b < 128 || b >= 192
589,183 ( 0.18%) .          .          .                   (self as i8) >= -0x40
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl u16 {
      .          .          .          .               uint_impl! {
      .          .          .          .                   Self = u16,
      .          .          .          .                   ActualT = u16,
      .          .          .          .                   SignedT = i16,
-- line 1050 ----------------------------------------
-- line 1335 ----------------------------------------
      .          .          .          .           /// Determines if a string of text of that length of that radix could be guaranteed to be
      .          .          .          .           /// stored in the given type T.
      .          .          .          .           /// Note that if the radix is known to the compiler, it is just the check of digits.len that
      .          .          .          .           /// is done at runtime.
      .          .          .          .           #[doc(hidden)]
      .          .          .          .           #[inline(always)]
      .          .          .          .           #[unstable(issue = "none", feature = "std_internals")]
      .          .          .          .           pub const fn can_not_overflow<T>(radix: u32, is_signed_ty: bool, digits: &[u8]) -> bool {
      6 ( 0.00%) .          .          .               radix <= 16 && digits.len() <= mem::size_of::<T>() * 2 - is_signed_ty as usize
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[cfg_attr(not(feature = "panic_immediate_abort"), inline(never))]
      .          .          .          .           #[cfg_attr(feature = "panic_immediate_abort", inline)]
      .          .          .          .           #[cold]
      .          .          .          .           #[track_caller]
      .          .          .          .           const fn from_str_radix_panic(radix: u32) -> ! {
      .          .          .          .               const_panic!(
-- line 1351 ----------------------------------------
-- line 1399 ----------------------------------------
      .          .          .          .                       pub const fn from_str_radix(src: &str, radix: u32) -> Result<$int_ty, ParseIntError> {
      .          .          .          .                           use self::IntErrorKind::*;
      .          .          .          .                           use self::ParseIntError as PIE;
      .          .          .          .           
      .          .          .          .                           if 2 > radix || radix > 36 {
      .          .          .          .                               from_str_radix_panic(radix);
      .          .          .          .                           }
      .          .          .          .           
    516 ( 0.00%) .          .          .                           if src.is_empty() {
      .          .          .          .                               return Err(PIE { kind: Empty });
      .          .          .          .                           }
      .          .          .          .           
      .          .          .          .                           #[allow(unused_comparisons)]
      .          .          .          .                           let is_signed_ty = 0 > <$int_ty>::MIN;
      .          .          .          .           
      .          .          .          .                           // all valid digits are ascii, so we will just iterate over the utf8 bytes
      .          .          .          .                           // and cast them to chars. .to_digit() will safely return None for anything
      .          .          .          .                           // other than a valid ascii digit for the given radix, including the first-byte
      .          .          .          .                           // of multi-byte sequences
      .          .          .          .                           let src = src.as_bytes();
      .          .          .          .           
  1,488 ( 0.00%) .          .          .                           let (is_positive, mut digits) = match src {
      .          .          .          .                               [b'+' | b'-'] => {
      .          .          .          .                                   return Err(PIE { kind: InvalidDigit });
      .          .          .          .                               }
      .          .          .          .                               [b'+', rest @ ..] => (true, rest),
      .          .          .          .                               [b'-', rest @ ..] if is_signed_ty => (false, rest),
      .          .          .          .                               _ => (true, src),
      .          .          .          .                           };
      .          .          .          .           
      .          .          .          .                           let mut result = 0;
      .          .          .          .           
      .          .          .          .                           macro_rules! unwrap_or_PIE {
      .          .          .          .                               ($option:expr, $kind:ident) => {
    259 ( 0.00%) .          .          .                                   match $option {
      .          .          .          .                                       Some(value) => value,
      .          .          .          .                                       None => return Err(PIE { kind: $kind }),
      .          .          .          .                                   }
      .          .          .          .                               };
      .          .          .          .                           }
      .          .          .          .           
      6 ( 0.00%) .          .          .                           if can_not_overflow::<$int_ty>(radix, is_signed_ty, digits) {
      .          .          .          .                               // If the len of the str is short compared to the range of the type
      .          .          .          .                               // we are parsing into, then we can be certain that an overflow will not occur.
      .          .          .          .                               // This bound is when `radix.pow(digits.len()) - 1 <= T::MAX` but the condition
      .          .          .          .                               // above is a faster (conservative) approximation of this.
      .          .          .          .                               //
      .          .          .          .                               // Consider radix 16 as it has the highest information density per digit and will thus overflow the earliest:
      .          .          .          .                               // `u8::MAX` is `ff` - any str of len 2 is guaranteed to not overflow.
      .          .          .          .                               // `i8::MAX` is `7f` - only a str of len 1 is guaranteed to not overflow.
      .          .          .          .                               macro_rules! run_unchecked_loop {
      .          .          .          .                                   ($unchecked_additive_op:tt) => {{
    777 ( 0.00%) .          .          .                                       while let [c, rest @ ..] = digits {
    272 ( 0.00%) .          .          .                                           result = result * (radix as $int_ty);
    259 ( 0.00%) .          .          .                                           let x = unwrap_or_PIE!((*c as char).to_digit(radix), InvalidDigit);
    268 ( 0.00%) .          .          .                                           result = result $unchecked_additive_op (x as $int_ty);
      .          .          .          .                                           digits = rest;
      .          .          .          .                                       }
      .          .          .          .                                   }};
      .          .          .          .                               }
      .          .          .          .                               if is_positive {
      .          .          .          .                                   run_unchecked_loop!(+)
      .          .          .          .                               } else {
      .          .          .          .                                   run_unchecked_loop!(-)
-- line 1462 ----------------------------------------

  1,262 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 246 ----------------------------------------
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[inline(always)]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[must_use]
        .          .          .          .               #[rustc_diagnostic_item = "box_new"]
        .          .          .          .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
        .          .          .          .               pub fn new(x: T) -> Self {
        .          .          .          .                   #[rustc_box]
1,855,768 ( 0.56%) .          .          .                   Box::new(x)
   82,590 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Constructs a new box with uninitialized contents.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
        .          .          .          .               /// ```
        .          .          .          .               /// let mut five = Box::<u32>::new_uninit();
-- line 262 ----------------------------------------
-- line 475 ----------------------------------------
        .          .          .          .               // #[unstable(feature = "new_uninit", issue = "63291")]
        .          .          .          .               pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>
        .          .          .          .               where
        .          .          .          .                   A: Allocator,
        .          .          .          .               {
        .          .          .          .                   let layout = Layout::new::<mem::MaybeUninit<T>>();
        .          .          .          .                   // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.
        .          .          .          .                   // That would make code size bigger.
    1,128 ( 0.00%) .          .          .                   match Box::try_new_uninit_in(alloc) {
        .          .          .          .                       Ok(m) => m,
        .          .          .          .                       Err(_) => handle_alloc_error(layout),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Constructs a new box with uninitialized contents in the provided allocator,
        .          .          .          .               /// returning an error if the allocation fails
        .          .          .          .               ///
-- line 491 ----------------------------------------
-- line 1692 ----------------------------------------
        .          .          .          .               #[inline]
        .          .          .          .               fn drop(&mut self) {
        .          .          .          .                   // the T in the Box is dropped by the compiler before the destructor is run
        .          .          .          .           
        .          .          .          .                   let ptr = self.0;
        .          .          .          .           
        .          .          .          .                   unsafe {
        .          .          .          .                       let layout = Layout::for_value_raw(ptr.as_ptr());
   72,575 ( 0.02%) .          .          .                       if layout.size() != 0 {
        .          .          .          .                           self.1.deallocate(From::from(ptr.cast()), layout);
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[cfg(not(no_global_oom_handling))]
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
-- line 1708 ----------------------------------------
-- line 1788 ----------------------------------------
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[cfg(not(no_global_oom_handling))]
        .          .          .          .           #[stable(feature = "box_slice_clone", since = "1.3.0")]
        .          .          .          .           impl<T: Clone, A: Allocator + Clone> Clone for Box<[T], A> {
        .          .          .          .               fn clone(&self) -> Self {
        .          .          .          .                   let alloc = Box::allocator(self).clone();
    3,824 ( 0.00%) .          .          .                   self.to_vec_in(alloc).into_boxed_slice()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Copies `source`'s contents into `self` without creating a new allocation,
        .          .          .          .               /// so long as the two are of the same length.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
        .          .          .          .               /// ```
-- line 1804 ----------------------------------------
-- line 1832 ----------------------------------------
        .          .          .          .                   unsafe { from_boxed_utf8_unchecked(buf) }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           impl<T: ?Sized + PartialEq, A: Allocator> PartialEq for Box<T, A> {
        .          .          .          .               #[inline]
        .          .          .          .               fn eq(&self, other: &Self) -> bool {
      131 ( 0.00%) .          .          .                   PartialEq::eq(&**self, &**other)
    3,548 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:<regex_syntax::hir::Hir as core::cmp::PartialEq>::eq'2 (4x)
        .          .          .          .               }
        .          .          .          .               #[inline]
        .          .          .          .               fn ne(&self, other: &Self) -> bool {
        .          .          .          .                   PartialEq::ne(&**self, &**other)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
-- line 1848 ----------------------------------------
-- line 1999 ----------------------------------------
        .          .          .          .               extern "rust-call" fn call_mut(&mut self, args: Args) -> Self::Output {
        .          .          .          .                   <F as FnMut<Args>>::call_mut(self, args)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[stable(feature = "boxed_closure_impls", since = "1.35.0")]
        .          .          .          .           impl<Args: Tuple, F: Fn<Args> + ?Sized, A: Allocator> Fn<Args> for Box<F, A> {
        .          .          .          .               extern "rust-call" fn call(&self, args: Args) -> Self::Output {
      209 ( 0.00%) .          .          .                   <F as Fn<Args>>::call(self, args)
12,181,404 ( 3.66%) 3,026 ( 0.37%) 7 ( 2.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/regex.rs:regex_automata::meta::regex::Builder::build_many_from_hir::{{closure}} (53x)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[cfg_attr(bootstrap, unstable(feature = "async_closure", issue = "62290"))]
        .          .          .          .           #[cfg_attr(not(bootstrap), stable(feature = "async_closure", since = "1.85.0"))]
        .          .          .          .           impl<Args: Tuple, F: AsyncFnOnce<Args> + ?Sized, A: Allocator> AsyncFnOnce<Args> for Box<F, A> {
        .          .          .          .               type Output = F::Output;
        .          .          .          .               type CallOnceFuture = F::CallOnceFuture;
-- line 2015 ----------------------------------------
-- line 2064 ----------------------------------------
        .          .          .          .               fn borrow_mut(&mut self) -> &mut T {
        .          .          .          .                   &mut **self
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[stable(since = "1.5.0", feature = "smart_ptr_as_ref")]
        .          .          .          .           impl<T: ?Sized, A: Allocator> AsRef<T> for Box<T, A> {
        .          .          .          .               fn as_ref(&self) -> &T {
       24 ( 0.00%) .          .          .                   &**self
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[stable(since = "1.5.0", feature = "smart_ptr_as_ref")]
        .          .          .          .           impl<T: ?Sized, A: Allocator> AsMut<T> for Box<T, A> {
        .          .          .          .               fn as_mut(&mut self) -> &mut T {
        .          .          .          .                   &mut **self
        .          .          .          .               }
-- line 2080 ----------------------------------------

   18,533 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/mod.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 17 ----------------------------------------
    .          .          .          .           /// Returns the length of the run, and a bool that is false when the run
    .          .          .          .           /// is ascending, and true if the run strictly descending.
    .          .          .          .           #[inline(always)]
    .          .          .          .           pub(crate) fn find_existing_run<T, F: FnMut(&T, &T) -> bool>(
    .          .          .          .               v: &[T],
    .          .          .          .               is_less: &mut F,
    .          .          .          .           ) -> (usize, bool) {
    .          .          .          .               let len = v.len();
   86 ( 0.00%) .          .          .               if len < 2 {
    .          .          .          .                   return (len, false);
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               // SAFETY: We checked that len >= 2, so 0 and 1 are valid indices.
    .          .          .          .               // This also means that run_len < len implies run_len and run_len - 1
    .          .          .          .               // are valid indices as well.
    .          .          .          .               unsafe {
    .          .          .          .                   let mut run_len = 2;
   86 ( 0.00%) .          .          .                   let strictly_descending = is_less(v.get_unchecked(1), v.get_unchecked(0));
   43 ( 0.00%) .          .          .                   if strictly_descending {
    .          .          .          .                       while run_len < len && is_less(v.get_unchecked(run_len), v.get_unchecked(run_len - 1)) {
    .          .          .          .                           run_len += 1;
    .          .          .          .                       }
    .          .          .          .                   } else {
9,206 ( 0.00%) .          .          .                       while run_len < len && !is_less(v.get_unchecked(run_len), v.get_unchecked(run_len - 1))
    .          .          .          .                       {
2,269 ( 0.00%) .          .          .                           run_len += 1;
    .          .          .          .                       }
    .          .          .          .                   }
    .          .          .          .                   (run_len, strictly_descending)
    .          .          .          .               }
    .          .          .          .           }

1,408 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 447 ----------------------------------------
      .          .          .          .                       (
      .          .          .          .                           this: *const () = self as *const (),
      .          .          .          .                           count: isize = count,
      .          .          .          .                           size: usize = size_of::<T>(),
      .          .          .          .                       ) => runtime_offset_nowrap(this, count, size)
      .          .          .          .                   );
      .          .          .          .           
      .          .          .          .                   // SAFETY: the caller must uphold the safety contract for `offset`.
     30 ( 0.00%) .          .          .                   unsafe { intrinsics::offset(self, count) }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Adds a signed offset in bytes to a pointer.
      .          .          .          .               ///
      .          .          .          .               /// `count` is in units of **bytes**.
      .          .          .          .               ///
      .          .          .          .               /// This is purely a convenience for casting to a `u8` pointer and
      .          .          .          .               /// using [offset][pointer::offset] on it. See that method for documentation
-- line 463 ----------------------------------------
-- line 681 ----------------------------------------
      .          .          .          .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .          .          .          .               pub const unsafe fn offset_from(self, origin: *const T) -> isize
      .          .          .          .               where
      .          .          .          .                   T: Sized,
      .          .          .          .               {
      .          .          .          .                   let pointee_size = mem::size_of::<T>();
      .          .          .          .                   assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);
      .          .          .          .                   // SAFETY: the caller must uphold the safety contract for `ptr_offset_from`.
     17 ( 0.00%) .          .          .                   unsafe { intrinsics::ptr_offset_from(self, origin) }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Calculates the distance between two pointers within the same allocation. The returned value is in
      .          .          .          .               /// units of **bytes**.
      .          .          .          .               ///
      .          .          .          .               /// This is purely a convenience for casting to a `u8` pointer and
      .          .          .          .               /// using [`offset_from`][pointer::offset_from] on it. See that method for
      .          .          .          .               /// documentation and safety requirements.
-- line 697 ----------------------------------------
-- line 794 ----------------------------------------
      .          .          .          .                           this: *const () = self as *const (),
      .          .          .          .                           origin: *const () = origin as *const (),
      .          .          .          .                       ) => runtime_ptr_ge(this, origin)
      .          .          .          .                   );
      .          .          .          .           
      .          .          .          .                   let pointee_size = mem::size_of::<T>();
      .          .          .          .                   assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);
      .          .          .          .                   // SAFETY: the caller must uphold the safety contract for `ptr_offset_from_unsigned`.
 28,040 ( 0.01%) .          .          .                   unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Calculates the distance between two pointers within the same allocation, *where it's known that
      .          .          .          .               /// `self` is equal to or greater than `origin`*. The returned value is in
      .          .          .          .               /// units of **bytes**.
      .          .          .          .               ///
      .          .          .          .               /// This is purely a convenience for casting to a `u8` pointer and
      .          .          .          .               /// using [`sub_ptr`][pointer::sub_ptr] on it. See that method for
-- line 810 ----------------------------------------
-- line 959 ----------------------------------------
      .          .          .          .                       (
      .          .          .          .                           this: *const () = self as *const (),
      .          .          .          .                           count: usize = count,
      .          .          .          .                           size: usize = size_of::<T>(),
      .          .          .          .                       ) => runtime_add_nowrap(this, count, size)
      .          .          .          .                   );
      .          .          .          .           
      .          .          .          .                   // SAFETY: the caller must uphold the safety contract for `offset`.
408,939 ( 0.12%) .          .          .                   unsafe { intrinsics::offset(self, count) }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Adds an unsigned offset in bytes to a pointer.
      .          .          .          .               ///
      .          .          .          .               /// `count` is in units of bytes.
      .          .          .          .               ///
      .          .          .          .               /// This is purely a convenience for casting to a `u8` pointer and
      .          .          .          .               /// using [add][pointer::add] on it. See that method for documentation
-- line 975 ----------------------------------------

    637 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 85 ----------------------------------------
      .          .          .          .           ///
      .          .          .          .           /// While a `SmallIndex` is meant to guarantee that its value fits into `usize`
      .          .          .          .           /// without using as much space as a `usize` on all targets, callers must
      .          .          .          .           /// not rely on this property for safety. Callers may choose to rely on this
      .          .          .          .           /// property for correctness however. For example, creating a `SmallIndex` with
      .          .          .          .           /// an invalid value can be done in entirely safe code. This may in turn result
      .          .          .          .           /// in panics or silent logical errors.
      .          .          .          .           #[derive(
517,918 ( 0.16%) .          .          .               Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord,
      .          .          .          .           )]
      .          .          .          .           #[repr(transparent)]
      .          .          .          .           pub(crate) struct SmallIndex(u32);
      .          .          .          .           
      .          .          .          .           impl SmallIndex {
      .          .          .          .               /// The maximum index value.
      .          .          .          .               #[cfg(any(target_pointer_width = "32", target_pointer_width = "64"))]
      .          .          .          .               pub const MAX: SmallIndex =
-- line 101 ----------------------------------------
-- line 133 ----------------------------------------
      .          .          .          .               /// invalid index value is likely to cause panics or possibly even silent
      .          .          .          .               /// logical errors.
      .          .          .          .               ///
      .          .          .          .               /// Callers must never rely on a `SmallIndex` to be within a certain range
      .          .          .          .               /// for memory safety.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn new_unchecked(index: usize) -> SmallIndex {
      .          .          .          .                   // FIXME: Use as_u32() once const functions in traits are stable.
  2,768 ( 0.00%) .          .          .                   SmallIndex::from_u32_unchecked(index as u32)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new small index from a `u32` without checking whether the
      .          .          .          .               /// given value exceeds [`SmallIndex::MAX`].
      .          .          .          .               ///
      .          .          .          .               /// Using this routine with an invalid index value will result in
      .          .          .          .               /// unspecified behavior, but *not* undefined behavior. In particular, an
      .          .          .          .               /// invalid index value is likely to cause panics or possibly even silent
-- line 149 ----------------------------------------
-- line 162 ----------------------------------------
      .          .          .          .                   SmallIndex::new(index).expect("invalid small index")
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return this small index as a `usize`. This is guaranteed to never
      .          .          .          .               /// overflow `usize`.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn as_usize(&self) -> usize {
      .          .          .          .                   // FIXME: Use as_usize() once const functions in traits are stable.
328,515 ( 0.10%) .          .          .                   self.0 as usize
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return this small index as a `u64`. This is guaranteed to never
      .          .          .          .               /// overflow.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn as_u64(&self) -> u64 {
      .          .          .          .                   // FIXME: Use u64::from() once const functions in traits are stable.
      .          .          .          .                   self.0 as u64
-- line 178 ----------------------------------------
-- line 318 ----------------------------------------
      .          .          .          .                   Ok(SmallIndex::new_unchecked(index.as_usize()))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl TryFrom<usize> for SmallIndex {
      .          .          .          .               type Error = SmallIndexError;
      .          .          .          .           
      .          .          .          .               fn try_from(index: usize) -> Result<SmallIndex, SmallIndexError> {
148,512 ( 0.04%) .          .          .                   if index > SmallIndex::MAX.as_usize() {
      .          .          .          .                       return Err(SmallIndexError { attempted: index.as_u64() });
      .          .          .          .                   }
      .          .          .          .                   Ok(SmallIndex::new_unchecked(index))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// This error occurs when a small index could not be constructed.
      .          .          .          .           ///
-- line 334 ----------------------------------------
-- line 365 ----------------------------------------
      .          .          .          .           pub(crate) struct SmallIndexIter {
      .          .          .          .               rng: core::ops::Range<usize>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Iterator for SmallIndexIter {
      .          .          .          .               type Item = SmallIndex;
      .          .          .          .           
      .          .          .          .               fn next(&mut self) -> Option<SmallIndex> {
  5,248 ( 0.00%) .          .          .                   if self.rng.start >= self.rng.end {
      .          .          .          .                       return None;
      .          .          .          .                   }
      .          .          .          .                   let next_id = self.rng.start + 1;
      .          .          .          .                   let id = core::mem::replace(&mut self.rng.start, next_id);
      .          .          .          .                   // new_unchecked is OK since we asserted that the number of
      .          .          .          .                   // elements in this iterator will fit in an ID at construction.
      .          .          .          .                   Some(SmallIndex::new_unchecked(id))
      .          .          .          .               }
-- line 381 ----------------------------------------
-- line 637 ----------------------------------------
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   #[derive(Clone, Debug)]
      .          .          .          .                   pub(crate) struct $iter(SmallIndexIter);
      .          .          .          .           
      .          .          .          .                   impl $iter {
      .          .          .          .                       fn new(len: usize) -> $iter {
      .          .          .          .                           assert!(
     96 ( 0.00%) .          .          .                               len <= $name::LIMIT,
      .          .          .          .                               "cannot create iterator for {} when number of \
      .          .          .          .                                elements exceed {:?}",
      .          .          .          .                               stringify!($name),
      .          .          .          .                               $name::LIMIT,
      .          .          .          .                           );
      .          .          .          .                           $iter(SmallIndexIter { rng: 0..len })
      .          .          .          .                       }
      .          .          .          .                   }
-- line 653 ----------------------------------------

 54,637 ( 0.02%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/primitives.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 248 ----------------------------------------
      .          .          .          .                   &self.special
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Swaps the states at `id1` and `id2`.
      .          .          .          .               ///
      .          .          .          .               /// This does not update the transitions of any state to account for the
      .          .          .          .               /// state swap.
      .          .          .          .               pub(crate) fn swap_states(&mut self, id1: StateID, id2: StateID) {
  1,446 ( 0.00%) .          .          .                   self.states.swap(id1.as_usize(), id2.as_usize());
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Re-maps all state IDs in this NFA according to the `map` function
      .          .          .          .               /// given.
      .          .          .          .               pub(crate) fn remap(&mut self, map: impl Fn(StateID) -> StateID) {
      .          .          .          .                   let alphabet_len = self.byte_classes.alphabet_len();
      .          .          .          .                   for state in self.states.iter_mut() {
  5,248 ( 0.00%) .          .          .                       state.fail = map(state.fail);
      .          .          .          .                       let mut link = state.sparse;
 42,682 ( 0.01%) .          .          .                       while link != StateID::ZERO {
      .          .          .          .                           let t = &mut self.sparse[link];
 77,608 ( 0.02%) .          .          .                           t.next = map(t.next);
      .          .          .          .                           link = t.link;
      .          .          .          .                       }
  2,624 ( 0.00%) .          .          .                       if state.dense != StateID::ZERO {
      .          .          .          .                           let start = state.dense.as_usize();
      .          .          .          .                           for next in self.dense[start..][..alphabet_len].iter_mut() {
186,694 ( 0.06%) .          .          .                               *next = map(*next);
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Iterate over all of the transitions for the given state ID.
  3,680 ( 0.00%) .          .          .               pub(crate) fn iter_trans(
      .          .          .          .                   &self,
      .          .          .          .                   sid: StateID,
      .          .          .          .               ) -> impl Iterator<Item = Transition> + '_ {
  6,286 ( 0.00%) .          .          .                   let mut link = self.states[sid].sparse;
      .          .          .          .                   core::iter::from_fn(move || {
 42,786 ( 0.01%) .          .          .                       if link == StateID::ZERO {
      .          .          .          .                           return None;
      .          .          .          .                       }
317,882 ( 0.10%) .          .          .                       let t = self.sparse[link];
      .          .          .          .                       link = t.link;
      .          .          .          .                       Some(t)
      .          .          .          .                   })
  3,680 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Iterate over all of the matches for the given state ID.
      .          .          .          .               pub(crate) fn iter_matches(
      .          .          .          .                   &self,
      .          .          .          .                   sid: StateID,
      .          .          .          .               ) -> impl Iterator<Item = PatternID> + '_ {
  7,411 ( 0.00%) .          .          .                   let mut link = self.states[sid].matches;
      .          .          .          .                   core::iter::from_fn(move || {
  5,505 ( 0.00%) .          .          .                       if link == StateID::ZERO {
      .          .          .          .                           return None;
      .          .          .          .                       }
  3,670 ( 0.00%) .          .          .                       let m = self.matches[link];
      .          .          .          .                       link = m.link;
      .          .          .          .                       Some(m.pid)
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the link following the one given. If the one given is the last
      .          .          .          .               /// link for the given state, then return `None`.
      .          .          .          .               ///
-- line 314 ----------------------------------------
-- line 320 ----------------------------------------
      .          .          .          .               /// the NFA during iteration. Namely, one can access the transition pointed
      .          .          .          .               /// to by the link via `self.sparse[link]`.
      .          .          .          .               fn next_link(
      .          .          .          .                   &self,
      .          .          .          .                   sid: StateID,
      .          .          .          .                   prev: Option<StateID>,
      .          .          .          .               ) -> Option<StateID> {
      .          .          .          .                   let link =
 61,182 ( 0.02%) .          .          .                       prev.map_or(self.states[sid].sparse, |p| self.sparse[p].link);
      .          .          .          .                   if link == StateID::ZERO {
      .          .          .          .                       None
      .          .          .          .                   } else {
      .          .          .          .                       Some(link)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Follow the transition for the given byte in the given state. If no such
-- line 336 ----------------------------------------
-- line 346 ----------------------------------------
      .          .          .          .                   // since we only do this for a small number of states (by default), the
      .          .          .          .                   // memory usage is usually minimal.
      .          .          .          .                   //
      .          .          .          .                   // This has *massive* benefit when executing searches because the
      .          .          .          .                   // unanchored starting state is by far the hottest state and is
      .          .          .          .                   // frequently visited. Moreover, the 'for' loop below that works
      .          .          .          .                   // decently on an actually sparse state is disastrous on a state that
      .          .          .          .                   // is nearly or completely dense.
  4,443 ( 0.00%) .          .          .                   if s.dense == StateID::ZERO {
      .          .          .          .                       self.follow_transition_sparse(sid, byte)
      .          .          .          .                   } else {
      .          .          .          .                       let class = usize::from(self.byte_classes.get(byte));
  1,436 ( 0.00%) .          .          .                       self.dense[s.dense.as_usize() + class]
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Like `follow_transition`, but always uses the sparse representation.
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn follow_transition_sparse(&self, sid: StateID, byte: u8) -> StateID {
  3,680 ( 0.00%) .          .          .                   for t in self.iter_trans(sid) {
 33,120 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::iter_trans (3,680x)
210,436 ( 0.06%) .          .          .                       if byte <= t.byte {
  4,108 ( 0.00%) .          .          .                           if byte == t.byte {
      .          .          .          .                               return t.next;
      .          .          .          .                           }
      .          .          .          .                           break;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   NFA::FAIL
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the transition for the given byte to the state ID given.
      .          .          .          .               ///
      .          .          .          .               /// Note that one should not set transitions to the FAIL state. It is not
      .          .          .          .               /// technically incorrect, but it wastes space. If a transition is not
      .          .          .          .               /// defined, then it is automatically assumed to lead to the FAIL state.
 17,024 ( 0.01%) .          .          .               fn add_transition(
      .          .          .          .                   &mut self,
      .          .          .          .                   prev: StateID,
      .          .          .          .                   byte: u8,
      .          .          .          .                   next: StateID,
      .          .          .          .               ) -> Result<(), BuildError> {
  2,432 ( 0.00%) .          .          .                   if self.states[prev].dense != StateID::ZERO {
      .          .          .          .                       let dense = self.states[prev].dense;
      .          .          .          .                       let class = usize::from(self.byte_classes.get(byte));
      .          .          .          .                       self.dense[dense.as_usize() + class] = next;
      .          .          .          .                   }
      .          .          .          .           
  4,864 ( 0.00%) .          .          .                   let head = self.states[prev].sparse;
  5,076 ( 0.00%) .          .          .                   if head == StateID::ZERO || byte < self.sparse[head].byte {
      .          .          .          .                       let new_link = self.alloc_transition()?;
  4,140 ( 0.00%) .          .          .                       self.sparse[new_link] = Transition { byte, next, link: head };
  1,380 ( 0.00%) .          .          .                       self.states[prev].sparse = new_link;
      .          .          .          .                       return Ok(());
  1,052 ( 0.00%) .          .          .                   } else if byte == self.sparse[head].byte {
      .          .          .          .                       self.sparse[head].next = next;
      .          .          .          .                       return Ok(());
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // We handled the only cases where the beginning of the transition
      .          .          .          .                   // chain needs to change. At this point, we now know that there is
      .          .          .          .                   // at least one entry in the transition chain and the byte for that
      .          .          .          .                   // transition is less than the byte for the transition we're adding.
      .          .          .          .                   let (mut link_prev, mut link_next) = (head, self.sparse[head].link);
124,632 ( 0.04%) .          .          .                   while link_next != StateID::ZERO && byte > self.sparse[link_next].byte
      .          .          .          .                   {
      .          .          .          .                       link_prev = link_next;
      .          .          .          .                       link_next = self.sparse[link_next].link;
      .          .          .          .                   }
    536 ( 0.00%) .          .          .                   if link_next == StateID::ZERO || byte < self.sparse[link_next].byte {
      .          .          .          .                       let link = self.alloc_transition()?;
  1,680 ( 0.00%) .          .          .                       self.sparse[link] = Transition { byte, next, link: link_next };
  1,680 ( 0.00%) .          .          .                       self.sparse[link_prev].link = link;
      .          .          .          .                   } else {
      .          .          .          .                       assert_eq!(byte, self.sparse[link_next].byte);
      .          .          .          .                       self.sparse[link_next].next = next;
      .          .          .          .                   }
      .          .          .          .                   Ok(())
 21,888 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// This sets every possible transition (all 255 of them) for the given
      .          .          .          .               /// state to the name `next` value.
      .          .          .          .               ///
      .          .          .          .               /// This is useful for efficiently initializing start/dead states.
      .          .          .          .               ///
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// This requires that the state has no transitions added to it already.
      .          .          .          .               /// If it has any transitions, then this panics. It will also panic if
      .          .          .          .               /// the state has been densified prior to calling this.
  1,152 ( 0.00%) .          .          .               fn init_full_state(
      .          .          .          .                   &mut self,
      .          .          .          .                   prev: StateID,
      .          .          .          .                   next: StateID,
      .          .          .          .               ) -> Result<(), BuildError> {
    144 ( 0.00%) .          .          .                   assert_eq!(
      .          .          .          .                       StateID::ZERO,
      .          .          .          .                       self.states[prev].dense,
      .          .          .          .                       "state must not be dense yet"
      .          .          .          .                   );
    144 ( 0.00%) .          .          .                   assert_eq!(
      .          .          .          .                       StateID::ZERO,
      .          .          .          .                       self.states[prev].sparse,
      .          .          .          .                       "state must have zero transitions"
      .          .          .          .                   );
      .          .          .          .                   let mut prev_link = StateID::ZERO;
      .          .          .          .                   for byte in 0..=255 {
      .          .          .          .                       let new_link = self.alloc_transition()?;
110,592 ( 0.03%) .          .          .                       self.sparse[new_link] =
      .          .          .          .                           Transition { byte, next, link: StateID::ZERO };
 36,864 ( 0.01%) .          .          .                       if prev_link == StateID::ZERO {
    144 ( 0.00%) .          .          .                           self.states[prev].sparse = new_link;
      .          .          .          .                       } else {
 73,440 ( 0.02%) .          .          .                           self.sparse[prev_link].link = new_link;
      .          .          .          .                       }
      .          .          .          .                       prev_link = new_link;
      .          .          .          .                   }
    144 ( 0.00%) .          .          .                   Ok(())
  1,152 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add a match for the given pattern ID to the state for the given ID.
  9,758 ( 0.00%) .          .          .               fn add_match(
      .          .          .          .                   &mut self,
      .          .          .          .                   sid: StateID,
      .          .          .          .                   pid: PatternID,
      .          .          .          .               ) -> Result<(), BuildError> {
  4,182 ( 0.00%) .          .          .                   let head = self.states[sid].matches;
      .          .          .          .                   let mut link = head;
  1,394 ( 0.00%) .          .          .                   while self.matches[link].link != StateID::ZERO {
      .          .          .          .                       link = self.matches[link].link;
      .          .          .          .                   }
      .          .          .          .                   let new_match_link = self.alloc_match()?;
  1,394 ( 0.00%) .          .          .                   self.matches[new_match_link].pid = pid;
  1,394 ( 0.00%) .          .          .                   if link == StateID::ZERO {
  2,788 ( 0.00%) .          .          .                       self.states[sid].matches = new_match_link;
      .          .          .          .                   } else {
      .          .          .          .                       self.matches[link].link = new_match_link;
      .          .          .          .                   }
  1,394 ( 0.00%) .          .          .                   Ok(())
 12,546 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Copy matches from the `src` state to the `dst` state. This is useful
      .          .          .          .               /// when a match state can be reached via a failure transition. In which
      .          .          .          .               /// case, you'll want to copy the matches (if any) from the state reached
      .          .          .          .               /// by the failure transition to the original state you were at.
  5,768 ( 0.00%) .          .          .               fn copy_matches(
      .          .          .          .                   &mut self,
      .          .          .          .                   src: StateID,
      .          .          .          .                   dst: StateID,
      .          .          .          .               ) -> Result<(), BuildError> {
  2,884 ( 0.00%) .          .          .                   let head_dst = self.states[dst].matches;
      .          .          .          .                   let mut link_dst = head_dst;
    721 ( 0.00%) .          .          .                   while self.matches[link_dst].link != StateID::ZERO {
      .          .          .          .                       link_dst = self.matches[link_dst].link;
      .          .          .          .                   }
    721 ( 0.00%) .          .          .                   let mut link_src = self.states[src].matches;
    721 ( 0.00%) .          .          .                   while link_src != StateID::ZERO {
      .          .          .          .                       let new_match_link =
      .          .          .          .                           StateID::new(self.matches.len()).map_err(|e| {
      .          .          .          .                               BuildError::state_id_overflow(
      .          .          .          .                                   StateID::MAX.as_u64(),
      .          .          .          .                                   e.attempted(),
      .          .          .          .                               )
      .          .          .          .                           })?;
      .          .          .          .                       self.matches.push(Match {
-- line 509 ----------------------------------------
-- line 514 ----------------------------------------
      .          .          .          .                           self.states[dst].matches = new_match_link;
      .          .          .          .                       } else {
      .          .          .          .                           self.matches[link_dst].link = new_match_link;
      .          .          .          .                       }
      .          .          .          .           
      .          .          .          .                       link_dst = new_match_link;
      .          .          .          .                       link_src = self.matches[link_src].link;
      .          .          .          .                   }
    721 ( 0.00%) .          .          .                   Ok(())
  6,489 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new entry in `NFA::trans`, if there's room, and return that
      .          .          .          .               /// entry's ID. If there's no room, then an error is returned.
      .          .          .          .               fn alloc_transition(&mut self) -> Result<StateID, BuildError> {
      .          .          .          .                   let id = StateID::new(self.sparse.len()).map_err(|e| {
      .          .          .          .                       BuildError::state_id_overflow(StateID::MAX.as_u64(), e.attempted())
      .          .          .          .                   })?;
      .          .          .          .                   self.sparse.push(Transition::default());
-- line 531 ----------------------------------------
-- line 560 ----------------------------------------
      .          .          .          .                           .take(self.byte_classes.alphabet_len()),
      .          .          .          .                   );
      .          .          .          .                   Ok(id)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Allocate and add a fresh state to the underlying NFA and return its
      .          .          .          .               /// ID (guaranteed to be one more than the ID of the previously allocated
      .          .          .          .               /// state). If the ID would overflow `StateID`, then this returns an error.
 15,744 ( 0.00%) .          .          .               fn alloc_state(&mut self, depth: usize) -> Result<StateID, BuildError> {
      .          .          .          .                   // This is OK because we error when building the trie if we see a
      .          .          .          .                   // pattern whose length cannot fit into a 'SmallIndex', and the longest
      .          .          .          .                   // possible depth corresponds to the length of the longest pattern.
      .          .          .          .                   let depth = SmallIndex::new(depth)
      .          .          .          .                       .expect("patterns longer than SmallIndex::MAX are not allowed");
      .          .          .          .                   let id = StateID::new(self.states.len()).map_err(|e| {
      .          .          .          .                       BuildError::state_id_overflow(StateID::MAX.as_u64(), e.attempted())
      .          .          .          .                   })?;
      .          .          .          .                   self.states.push(State {
      .          .          .          .                       sparse: StateID::ZERO,
      .          .          .          .                       dense: StateID::ZERO,
      .          .          .          .                       matches: StateID::ZERO,
  2,624 ( 0.00%) .          .          .                       fail: self.special.start_unanchored_id,
      .          .          .          .                       depth,
      .          .          .          .                   });
  5,248 ( 0.00%) .          .          .                   Ok(id)
 20,992 ( 0.01%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           // SAFETY: 'start_state' always returns a valid state ID, 'next_state' always
      .          .          .          .           // returns a valid state ID given a valid state ID. We otherwise claim that
      .          .          .          .           // all other methods are correct as well.
      .          .          .          .           unsafe impl Automaton for NFA {
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn start_state(&self, anchored: Anchored) -> Result<StateID, MatchError> {
-- line 593 ----------------------------------------
-- line 606 ----------------------------------------
      .          .          .          .               ) -> StateID {
      .          .          .          .                   // This terminates since:
      .          .          .          .                   //
      .          .          .          .                   // 1. state.fail never points to the FAIL state.
      .          .          .          .                   // 2. All state.fail values point to a state closer to the start state.
      .          .          .          .                   // 3. The start state has no transitions to the FAIL state.
      .          .          .          .                   loop {
      .          .          .          .                       let next = self.follow_transition(sid, byte);
     90 ( 0.00%) .          .          .                       if next != NFA::FAIL {
      .          .          .          .                           return next;
      .          .          .          .                       }
      .          .          .          .                       // For an anchored search, we never follow failure transitions
      .          .          .          .                       // because failure transitions lead us down a path to matching
      .          .          .          .                       // a *proper* suffix of the path we were on. Thus, it can only
      .          .          .          .                       // produce matches that appear after the beginning of the search.
      .          .          .          .                       if anchored.is_anchored() {
      .          .          .          .                           return NFA::DEAD;
-- line 622 ----------------------------------------
-- line 647 ----------------------------------------
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn is_start(&self, sid: StateID) -> bool {
      .          .          .          .                   sid == self.special.start_unanchored_id
      .          .          .          .                       || sid == self.special.start_anchored_id
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn match_kind(&self) -> MatchKind {
     48 ( 0.00%) .          .          .                   self.match_kind
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn patterns_len(&self) -> usize {
      .          .          .          .                   self.pattern_lens.len()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn pattern_len(&self, pid: PatternID) -> usize {
      .          .          .          .                   self.pattern_lens[pid].as_usize()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn min_pattern_len(&self) -> usize {
     48 ( 0.00%) .          .          .                   self.min_pattern_len
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn max_pattern_len(&self) -> usize {
      .          .          .          .                   self.max_pattern_len
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline(always)]
-- line 678 ----------------------------------------
-- line 750 ----------------------------------------
      .          .          .          .           impl State {
      .          .          .          .               /// Return true if and only if this state is a match state.
      .          .          .          .               pub(crate) fn is_match(&self) -> bool {
      .          .          .          .                   self.matches != StateID::ZERO
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the failure transition for this state.
      .          .          .          .               pub(crate) fn fail(&self) -> StateID {
 12,132 ( 0.00%) .          .          .                   self.fail
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the depth of this state. That is, the number of transitions
      .          .          .          .               /// this state is from the start state of the NFA.
      .          .          .          .               pub(crate) fn depth(&self) -> SmallIndex {
      .          .          .          .                   self.depth
      .          .          .          .               }
      .          .          .          .           }
-- line 766 ----------------------------------------
-- line 777 ----------------------------------------
      .          .          .          .           impl Transition {
      .          .          .          .               /// Return the byte for which this transition is defined.
      .          .          .          .               pub(crate) fn byte(&self) -> u8 {
      .          .          .          .                   self.byte
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the ID of the state that this transition points to.
      .          .          .          .               pub(crate) fn next(&self) -> StateID {
 12,288 ( 0.00%) .          .          .                   self.next
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the ID of the next transition.
      .          .          .          .               fn link(&self) -> StateID {
      .          .          .          .                   self.link
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
-- line 793 ----------------------------------------
-- line 862 ----------------------------------------
      .          .          .          .               pub fn new() -> Builder {
      .          .          .          .                   Builder::default()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Build an Aho-Corasick noncontiguous NFA from the given iterator of
      .          .          .          .               /// patterns.
      .          .          .          .               ///
      .          .          .          .               /// A builder may be reused to create more NFAs.
    576 ( 0.00%) .          .          .               pub fn build<I, P>(&self, patterns: I) -> Result<NFA, BuildError>
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = P>,
      .          .          .          .                   P: AsRef<[u8]>,
      .          .          .          .               {
      .          .          .          .                   debug!("building non-contiguous NFA");
    384 ( 0.00%) .          .          .                   let nfa = Compiler::new(self)?.compile(patterns)?;
 28,425 ( 0.01%) 94 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::new (48x)
  3,696 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x)
      .          .          .          .                   debug!(
      .          .          .          .                       "non-contiguous NFA built, <states: {:?}, size: {:?}>",
      .          .          .          .                       nfa.states.len(),
      .          .          .          .                       nfa.memory_usage()
      .          .          .          .                   );
    240 ( 0.00%) .          .          .                   Ok(nfa)
    480 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the desired match semantics.
      .          .          .          .               ///
      .          .          .          .               /// See
      .          .          .          .               /// [`AhoCorasickBuilder::match_kind`](crate::AhoCorasickBuilder::match_kind)
      .          .          .          .               /// for more documentation and examples.
      .          .          .          .               pub fn match_kind(&mut self, kind: MatchKind) -> &mut Builder {
     66 ( 0.00%) .          .          .                   self.match_kind = kind;
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Enable ASCII-aware case insensitive matching.
      .          .          .          .               ///
      .          .          .          .               /// See
      .          .          .          .               /// [`AhoCorasickBuilder::ascii_case_insensitive`](crate::AhoCorasickBuilder::ascii_case_insensitive)
      .          .          .          .               /// for more documentation and examples.
-- line 899 ----------------------------------------
-- line 932 ----------------------------------------
      .          .          .          .           struct Compiler<'a> {
      .          .          .          .               builder: &'a Builder,
      .          .          .          .               prefilter: prefilter::Builder,
      .          .          .          .               nfa: NFA,
      .          .          .          .               byteset: ByteClassSet,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'a> Compiler<'a> {
    432 ( 0.00%) .          .          .               fn new(builder: &'a Builder) -> Result<Compiler<'a>, BuildError> {
     96 ( 0.00%) .          .          .                   let prefilter = prefilter::Builder::new(builder.match_kind)
     48 ( 0.00%) .          .          .                       .ascii_case_insensitive(builder.ascii_case_insensitive);
  2,352 ( 0.00%) .          .          .                   Ok(Compiler {
  1,728 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (48x)
      .          .          .          .                       builder,
      .          .          .          .                       prefilter,
      .          .          .          .                       nfa: NFA {
      .          .          .          .                           match_kind: builder.match_kind,
      .          .          .          .                           states: vec![],
      .          .          .          .                           sparse: vec![],
      .          .          .          .                           dense: vec![],
      .          .          .          .                           matches: vec![],
-- line 951 ----------------------------------------
-- line 953 ----------------------------------------
      .          .          .          .                           prefilter: None,
      .          .          .          .                           byte_classes: ByteClasses::singletons(),
      .          .          .          .                           min_pattern_len: usize::MAX,
      .          .          .          .                           max_pattern_len: 0,
      .          .          .          .                           special: Special::zero(),
      .          .          .          .                       },
      .          .          .          .                       byteset: ByteClassSet::empty(),
      .          .          .          .                   })
    432 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               fn compile<I, P>(mut self, patterns: I) -> Result<NFA, BuildError>
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = P>,
      .          .          .          .                   P: AsRef<[u8]>,
      .          .          .          .               {
      .          .          .          .                   // Add dummy transition/match links, so that no valid link will point
      .          .          .          .                   // to another link at index 0.
     48 ( 0.00%) .          .          .                   self.nfa.sparse.push(Transition::default());
     48 ( 0.00%) .          .          .                   self.nfa.matches.push(Match::default());
      .          .          .          .                   // Add a dummy dense transition so that no states can have dense==0
      .          .          .          .                   // represent a valid pointer to dense transitions. This permits
      .          .          .          .                   // dense==0 to be a sentinel indicating "no dense transitions."
     48 ( 0.00%) .          .          .                   self.nfa.dense.push(NFA::DEAD);
      .          .          .          .                   // the dead state, only used for leftmost and fixed to id==0
    144 ( 0.00%) .          .          .                   self.nfa.alloc_state(0)?;
  9,384 ( 0.00%) 12 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (48x)
      .          .          .          .                   // the fail state, which is never entered and fixed to id==1
    144 ( 0.00%) .          .          .                   self.nfa.alloc_state(0)?;
  1,584 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (48x)
      .          .          .          .                   // unanchored start state, initially fixed to id==2 but later shuffled
      .          .          .          .                   // to appear after all non-start match states.
    240 ( 0.00%) .          .          .                   self.nfa.special.start_unanchored_id = self.nfa.alloc_state(0)?;
  1,584 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (48x)
      .          .          .          .                   // anchored start state, initially fixed to id==3 but later shuffled
      .          .          .          .                   // to appear after unanchored start state.
    288 ( 0.00%) .          .          .                   self.nfa.special.start_anchored_id = self.nfa.alloc_state(0)?;
  1,584 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (48x)
      .          .          .          .                   // Initialize the unanchored starting state in order to make it dense,
      .          .          .          .                   // and thus make transition lookups on this state faster.
     48 ( 0.00%) .          .          .                   self.init_unanchored_start_state()?;
1,230,214 ( 0.37%) 1,219 ( 0.15%) 1 ( 0.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::init_unanchored_start_state (48x)
      .          .          .          .                   // Set all transitions on the DEAD state to point to itself. This way,
      .          .          .          .                   // the DEAD state can never be escaped. It MUST be used as a sentinel
      .          .          .          .                   // in any correct search.
     48 ( 0.00%) .          .          .                   self.add_dead_state_loop()?;
395,568 ( 0.12%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::add_dead_state_loop (48x)
      .          .          .          .                   // Build the base trie from the given patterns.
    144 ( 0.00%) .          .          .                   self.build_trie(patterns)?;
2,756,235 ( 0.83%) 1,248 ( 0.15%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::build_trie (48x)
      .          .          .          .                   self.nfa.states.shrink_to_fit();
      .          .          .          .                   // Turn our set of bytes into equivalent classes. This NFA
      .          .          .          .                   // implementation uses byte classes only for states that use a dense
      .          .          .          .                   // representation of transitions. (And that's why this comes before
      .          .          .          .                   // `self.densify()`, as the byte classes need to be set first.)
    480 ( 0.00%) .          .          .                   self.nfa.byte_classes = self.byteset.byte_classes();
228,716 ( 0.07%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::byte_classes (48x)
  1,440 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x)
      .          .          .          .                   // Add transitions (and maybe matches) to the anchored starting state.
      .          .          .          .                   // The anchored starting state is used for anchored searches. The only
      .          .          .          .                   // mechanical difference between it and the unanchored start state is
      .          .          .          .                   // that missing transitions map to the DEAD state instead of the FAIL
      .          .          .          .                   // state.
     48 ( 0.00%) .          .          .                   self.set_anchored_start_state()?;
250,272 ( 0.08%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::set_anchored_start_state (48x)
      .          .          .          .                   // Rewrite transitions to the FAIL state on the unanchored start state
      .          .          .          .                   // as self-transitions. This keeps the start state active at all times.
    144 ( 0.00%) .          .          .                   self.add_unanchored_start_state_loop();
158,544 ( 0.05%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::add_unanchored_start_state_loop (48x)
      .          .          .          .                   // Make some (possibly zero) states use a dense representation for
      .          .          .          .                   // transitions. It's important to do this right after the states
      .          .          .          .                   // and non-failure transitions are solidified. That way, subsequent
      .          .          .          .                   // accesses (particularly `fill_failure_transitions`) will benefit from
      .          .          .          .                   // the faster transition lookup in densified states.
     96 ( 0.00%) .          .          .                   self.densify()?;
987,185 ( 0.30%) 863 ( 0.11%) 6 ( 1.99%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::densify (48x)
      .          .          .          .                   // The meat of the Aho-Corasick algorithm: compute and write failure
      .          .          .          .                   // transitions. i.e., the state to move to when a transition isn't
      .          .          .          .                   // defined in the current state. These are epsilon transitions and thus
      .          .          .          .                   // make this formulation an NFA.
     48 ( 0.00%) .          .          .                   self.fill_failure_transitions()?;
564,478 ( 0.17%) 380 ( 0.05%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::fill_failure_transitions (48x)
      .          .          .          .                   // Handle a special case under leftmost semantics when at least one
      .          .          .          .                   // of the patterns is the empty string.
     96 ( 0.00%) .          .          .                   self.close_start_state_loop_for_leftmost();
    864 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::close_start_state_loop_for_leftmost (48x)
      .          .          .          .                   // Shuffle states so that we have DEAD, FAIL, MATCH, ..., START, START,
      .          .          .          .                   // NON-MATCH, ... This permits us to very quickly query the type of
      .          .          .          .                   // the state we're currently in during a search.
    144 ( 0.00%) .          .          .                   self.shuffle();
1,806,737 ( 0.54%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Compiler::shuffle (48x)
    336 ( 0.00%) .          .          .                   self.nfa.prefilter = self.prefilter.build();
298,368 ( 0.09%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/prefilter.rs:aho_corasick::util::prefilter::Builder::build (48x)
      .          .          .          .                   // Store the maximum ID of all *relevant* special states. Start states
      .          .          .          .                   // are only relevant when we have a prefilter, otherwise, there is zero
      .          .          .          .                   // reason to care about whether a state is a start state or not during
      .          .          .          .                   // a search. Indeed, without a prefilter, we are careful to explicitly
      .          .          .          .                   // NOT care about start states, otherwise the search can ping pong
      .          .          .          .                   // between the unrolled loop and the handling of special-status states
      .          .          .          .                   // and destroy perf.
     48 ( 0.00%) .          .          .                   self.nfa.special.max_special_id = if self.nfa.prefilter.is_some() {
      .          .          .          .                       // Why the anchored starting state? Because we always put it
      .          .          .          .                       // after the unanchored starting state and it is therefore the
      .          .          .          .                       // maximum. Why put unanchored followed by anchored? No particular
      .          .          .          .                       // reason, but that's how the states are logically organized in the
      .          .          .          .                       // Thompson NFA implementation found in regex-automata. \_()_/
      .          .          .          .                       self.nfa.special.start_anchored_id
      .          .          .          .                   } else {
      .          .          .          .                       self.nfa.special.max_match_id
      .          .          .          .                   };
      .          .          .          .                   self.nfa.sparse.shrink_to_fit();
      .          .          .          .                   self.nfa.dense.shrink_to_fit();
      .          .          .          .                   self.nfa.matches.shrink_to_fit();
      .          .          .          .                   self.nfa.pattern_lens.shrink_to_fit();
    480 ( 0.00%) .          .          .                   Ok(self.nfa)
  3,588 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x)
     48 ( 0.00%) .          .          .               }
 11,340 ( 0.00%) 92 ( 0.01%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<aho_corasick::util::prefilter::Builder> (48x)
      .          .          .          .           
      .          .          .          .               /// This sets up the initial prefix trie that makes up the Aho-Corasick
      .          .          .          .               /// automaton. Effectively, it creates the basic structure of the
      .          .          .          .               /// automaton, where every pattern given has a path from the start state to
      .          .          .          .               /// the end of the pattern.
    384 ( 0.00%) .          .          .               fn build_trie<I, P>(&mut self, patterns: I) -> Result<(), BuildError>
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = P>,
      .          .          .          .                   P: AsRef<[u8]>,
      .          .          .          .               {
  1,394 ( 0.00%) .          .          .                   'PATTERNS: for (i, pat) in patterns.into_iter().enumerate() {
  1,394 ( 0.00%) .          .          .                       let pid = PatternID::new(i).map_err(|e| {
      .          .          .          .                           BuildError::pattern_id_overflow(
      .          .          .          .                               PatternID::MAX.as_u64(),
      .          .          .          .                               e.attempted(),
      .          .          .          .                           )
      .          .          .          .                       })?;
      .          .          .          .                       let pat = pat.as_ref();
  1,394 ( 0.00%) .          .          .                       let patlen = SmallIndex::new(pat.len())
      .          .          .          .                           .map_err(|_| BuildError::pattern_too_long(pid, pat.len()))?;
  1,394 ( 0.00%) .          .          .                       self.nfa.min_pattern_len =
  1,394 ( 0.00%) .          .          .                           core::cmp::min(self.nfa.min_pattern_len, pat.len());
  1,394 ( 0.00%) .          .          .                       self.nfa.max_pattern_len =
  1,394 ( 0.00%) .          .          .                           core::cmp::max(self.nfa.max_pattern_len, pat.len());
  2,788 ( 0.00%) .          .          .                       assert_eq!(
      .          .          .          .                           i,
      .          .          .          .                           self.nfa.pattern_lens.len(),
      .          .          .          .                           "expected number of patterns to match pattern ID"
      .          .          .          .                       );
      .          .          .          .                       self.nfa.pattern_lens.push(patlen);
      .          .          .          .                       // We add the pattern to the prefilter here because the pattern
      .          .          .          .                       // ID in the prefilter is determined with respect to the patterns
      .          .          .          .                       // added to the prefilter. That is, it isn't the ID we have here,
-- line 1084 ----------------------------------------
-- line 1086 ----------------------------------------
      .          .          .          .                       // To ensure they line up, we add every pattern we see to the
      .          .          .          .                       // prefilter, even if some patterns ultimately are impossible to
      .          .          .          .                       // match (in leftmost-first semantics specifically).
      .          .          .          .                       //
      .          .          .          .                       // Another way of doing this would be to expose an API in the
      .          .          .          .                       // prefilter to permit setting your own pattern IDs. Or to just use
      .          .          .          .                       // our own map and go between them. But this case is sufficiently
      .          .          .          .                       // rare that we don't bother and just make sure they're in sync.
  4,182 ( 0.00%) .          .          .                       if self.builder.prefilter {
      .          .          .          .                           self.prefilter.add(pat);
      .          .          .          .                       }
      .          .          .          .           
  1,394 ( 0.00%) .          .          .                       let mut prev = self.nfa.special.start_unanchored_id;
      .          .          .          .                       let mut saw_match = false;
  3,680 ( 0.00%) .          .          .                       for (depth, &b) in pat.iter().enumerate() {
      .          .          .          .                           // When leftmost-first match semantics are requested, we
      .          .          .          .                           // specifically stop adding patterns when a previously added
      .          .          .          .                           // pattern is a prefix of it. We avoid adding it because
      .          .          .          .                           // leftmost-first semantics imply that the pattern can never
      .          .          .          .                           // match. This is not just an optimization to save space! It
      .          .          .          .                           // is necessary for correctness. In fact, this is the only
      .          .          .          .                           // difference in the automaton between the implementations for
      .          .          .          .                           // leftmost-first and leftmost-longest.
  7,360 ( 0.00%) .          .          .                           saw_match = saw_match || self.nfa.states[prev].is_match();
  3,680 ( 0.00%) .          .          .                           if self.builder.match_kind.is_leftmost_first() && saw_match {
      .          .          .          .                               // Skip to the next pattern immediately. This avoids
      .          .          .          .                               // incorrectly adding a match after this loop terminates.
      .          .          .          .                               continue 'PATTERNS;
      .          .          .          .                           }
      .          .          .          .           
      .          .          .          .                           // Add this byte to our equivalence classes. These don't
      .          .          .          .                           // get used while building the trie, but other Aho-Corasick
      .          .          .          .                           // implementations may use them.
 11,040 ( 0.00%) .          .          .                           self.byteset.set_range(b, b);
125,120 ( 0.04%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/alphabet.rs:aho_corasick::util::alphabet::ByteClassSet::set_range (3,680x)
 11,040 ( 0.00%) .          .          .                           if self.builder.ascii_case_insensitive {
      .          .          .          .                               let b = opposite_ascii_case(b);
      .          .          .          .                               self.byteset.set_range(b, b);
      .          .          .          .                           }
      .          .          .          .           
      .          .          .          .                           // If the transition from prev using the current byte already
      .          .          .          .                           // exists, then just move through it. Otherwise, add a new
      .          .          .          .                           // state. We track the depth here so that we can determine
      .          .          .          .                           // how to represent transitions. States near the start state
      .          .          .          .                           // use a dense representation that uses more memory but is
      .          .          .          .                           // faster. Other states use a sparse representation that uses
      .          .          .          .                           // less memory but is slower.
      .          .          .          .                           let next = self.nfa.follow_transition(prev, b);
  2,232 ( 0.00%) .          .          .                           if next != NFA::FAIL {
      .          .          .          .                               prev = next;
      .          .          .          .                           } else {
 14,592 ( 0.00%) .          .          .                               let next = self.nfa.alloc_state(depth)?;
205,101 ( 0.06%) 639 ( 0.08%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::alloc_state (2,432x)
 14,592 ( 0.00%) .          .          .                               self.nfa.add_transition(prev, b, next)?;
580,438 ( 0.17%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::add_transition (2,432x)
  7,296 ( 0.00%) .          .          .                               if self.builder.ascii_case_insensitive {
      .          .          .          .                                   let b = opposite_ascii_case(b);
      .          .          .          .                                   self.nfa.add_transition(prev, b, next)?;
      .          .          .          .                               }
      .          .          .          .                               prev = next;
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       // Once the pattern has been added, log the match in the final
      .          .          .          .                       // state that it reached.
  6,970 ( 0.00%) .          .          .                       self.nfa.add_match(prev, pid)?;
158,700 ( 0.05%) 300 ( 0.04%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::add_match (1,394x)
      .          .          .          .                   }
     48 ( 0.00%) .          .          .                   Ok(())
    432 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// This routine creates failure transitions according to the standard
      .          .          .          .               /// textbook formulation of the Aho-Corasick algorithm, with a couple small
      .          .          .          .               /// tweaks to support "leftmost" semantics.
      .          .          .          .               ///
      .          .          .          .               /// Building failure transitions is the most interesting part of building
      .          .          .          .               /// the Aho-Corasick automaton, because they are what allow searches to
      .          .          .          .               /// be performed in linear time. Specifically, a failure transition is
-- line 1158 ----------------------------------------
-- line 1267 ----------------------------------------
      .          .          .          .               /// N.B. I came up with this algorithm on my own, and after scouring all of
      .          .          .          .               /// the other AC implementations I know of (Perl, Snort, many on GitHub).
      .          .          .          .               /// I couldn't find any that implement leftmost semantics like this.
      .          .          .          .               /// Perl of course needs leftmost-first semantics, but they implement it
      .          .          .          .               /// with a seeming hack at *search* time instead of encoding it into the
      .          .          .          .               /// automaton. There are also a couple Java libraries that support leftmost
      .          .          .          .               /// longest semantics, but they do it by building a queue of matches at
      .          .          .          .               /// search time, which is even worse than what Perl is doing. ---AG
    432 ( 0.00%) .          .          .               fn fill_failure_transitions(&mut self) -> Result<(), BuildError> {
     48 ( 0.00%) .          .          .                   let is_leftmost = self.builder.match_kind.is_leftmost();
     48 ( 0.00%) .          .          .                   let start_uid = self.nfa.special.start_unanchored_id;
      .          .          .          .                   // Initialize the queue for breadth first search with all transitions
      .          .          .          .                   // out of the start state. We handle the start state specially because
      .          .          .          .                   // we only want to follow non-self transitions. If we followed self
      .          .          .          .                   // transitions, then this would never terminate.
      .          .          .          .                   let mut queue = VecDeque::new();
      .          .          .          .                   let mut seen = self.queued_set();
      .          .          .          .                   let mut prev_link = None;
 12,336 ( 0.00%) .          .          .                   while let Some(link) = self.nfa.next_link(start_uid, prev_link) {
      .          .          .          .                       prev_link = Some(link);
 24,576 ( 0.01%) .          .          .                       let t = self.nfa.sparse[link];
      .          .          .          .           
      .          .          .          .                       // Skip anything we've seen before and any self-transitions on the
      .          .          .          .                       // start state.
 12,288 ( 0.00%) .          .          .                       if start_uid == t.next() || seen.contains(t.next) {
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       queue.push_back(t.next);
      .          .          .          .                       seen.insert(t.next);
      .          .          .          .                       // Under leftmost semantics, if a state immediately following
      .          .          .          .                       // the start state is a match state, then we never want to
      .          .          .          .                       // follow its failure transition since the failure transition
      .          .          .          .                       // necessarily leads back to the start state, which we never
      .          .          .          .                       // want to do for leftmost matching after a match has been
      .          .          .          .                       // found.
      .          .          .          .                       //
      .          .          .          .                       // We apply the same logic to non-start states below as well.
    492 ( 0.00%) .          .          .                       if is_leftmost && self.nfa.states[t.next].is_match() {
    254 ( 0.00%) .          .          .                           self.nfa.states[t.next].fail = NFA::DEAD;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   while let Some(id) = queue.pop_front() {
      .          .          .          .                       let mut prev_link = None;
  3,699 ( 0.00%) .          .          .                       while let Some(link) = self.nfa.next_link(id, prev_link) {
      .          .          .          .                           prev_link = Some(link);
  3,880 ( 0.00%) .          .          .                           let t = self.nfa.sparse[link];
      .          .          .          .           
      .          .          .          .                           if seen.contains(t.next) {
      .          .          .          .                               // The only way to visit a duplicate state in a transition
      .          .          .          .                               // list is when ASCII case insensitivity is enabled. In
      .          .          .          .                               // this case, we want to skip it since it's redundant work.
      .          .          .          .                               // But it would also end up duplicating matches, which
      .          .          .          .                               // results in reporting duplicate matches in some cases.
      .          .          .          .                               // See the 'acasei010' regression test.
-- line 1320 ----------------------------------------
-- line 1339 ----------------------------------------
      .          .          .          .                           // otherwise require passing through a match state.
      .          .          .          .                           //
      .          .          .          .                           // Note that for correctness, the failure transition has to be
      .          .          .          .                           // set to the dead state for ALL states following a match, not
      .          .          .          .                           // just the match state itself. However, by setting the failure
      .          .          .          .                           // transition to the dead state on all match states, the dead
      .          .          .          .                           // state will automatically propagate to all subsequent states
      .          .          .          .                           // via the failure state computation below.
  5,296 ( 0.00%) .          .          .                           if is_leftmost && self.nfa.states[t.next].is_match() {
  1,267 ( 0.00%) .          .          .                               self.nfa.states[t.next].fail = NFA::DEAD;
      .          .          .          .                               continue;
      .          .          .          .                           }
      .          .          .          .                           let mut fail = self.nfa.states[id].fail;
      .          .          .          .                           while self.nfa.follow_transition(fail, t.byte) == NFA::FAIL {
      .          .          .          .                               fail = self.nfa.states[fail].fail;
      .          .          .          .                           }
      .          .          .          .                           fail = self.nfa.follow_transition(fail, t.byte);
  1,346 ( 0.00%) .          .          .                           self.nfa.states[t.next].fail = fail;
  2,692 ( 0.00%) .          .          .                           self.nfa.copy_matches(fail, t.next)?;
 30,958 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::copy_matches (673x)
      .          .          .          .                       }
      .          .          .          .                       // If the start state is a match state, then this automaton can
      .          .          .          .                       // match the empty string. This implies all states are match states
      .          .          .          .                       // since every position matches the empty string, so copy the
      .          .          .          .                       // matches from the start state to every state. Strictly speaking,
      .          .          .          .                       // this is only necessary for overlapping matches since each
      .          .          .          .                       // non-empty non-start match state needs to report empty matches
      .          .          .          .                       // in addition to its own. For the non-overlapping case, such
      .          .          .          .                       // states only report the first match, which is never empty since
      .          .          .          .                       // it isn't a start state.
  2,432 ( 0.00%) .          .          .                       if !is_leftmost {
      .          .          .          .                           self.nfa
      .          .          .          .                               .copy_matches(self.nfa.special.start_unanchored_id, id)?;
      .          .          .          .                       }
      .          .          .          .                   }
     48 ( 0.00%) .          .          .                   Ok(())
    432 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Shuffle the states so that they appear in this sequence:
      .          .          .          .               ///
      .          .          .          .               ///   DEAD, FAIL, MATCH..., START, START, NON-MATCH...
      .          .          .          .               ///
      .          .          .          .               /// The idea here is that if we know how special states are laid out in our
      .          .          .          .               /// transition table, then we can determine what "kind" of state we're in
      .          .          .          .               /// just by comparing our current state ID with a particular value. In this
-- line 1382 ----------------------------------------
-- line 1391 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               ///   DEAD, FAIL, START, START, MATCH... NON-MATCH...
      .          .          .          .               ///
      .          .          .          .               /// Then it's just a simple matter of swapping the two START states with
      .          .          .          .               /// the last two MATCH states.
      .          .          .          .               ///
      .          .          .          .               /// (This is the same technique used for fully compiled DFAs in
      .          .          .          .               /// regex-automata.)
    336 ( 0.00%) .          .          .               fn shuffle(&mut self) {
     48 ( 0.00%) .          .          .                   let old_start_uid = self.nfa.special.start_unanchored_id;
     48 ( 0.00%) .          .          .                   let old_start_aid = self.nfa.special.start_anchored_id;
     48 ( 0.00%) .          .          .                   assert!(old_start_uid < old_start_aid);
     96 ( 0.00%) .          .          .                   assert_eq!(
      .          .          .          .                       3,
      .          .          .          .                       old_start_aid.as_usize(),
      .          .          .          .                       "anchored start state should be at index 3"
      .          .          .          .                   );
      .          .          .          .                   // We implement shuffling by a sequence of pairwise swaps of states.
      .          .          .          .                   // Since we have a number of things referencing states via their
      .          .          .          .                   // IDs and swapping them changes their IDs, we need to record every
      .          .          .          .                   // swap we make so that we can remap IDs. The remapper handles this
-- line 1411 ----------------------------------------
-- line 1416 ----------------------------------------
      .          .          .          .                   // START-UNANCHORED, START-ANCHORED, MATCH, ..., NON-MATCH, ...
      .          .          .          .                   //
      .          .          .          .                   // To do that, we proceed forward through all states after
      .          .          .          .                   // START-ANCHORED and swap match states so that they appear before all
      .          .          .          .                   // non-match states.
      .          .          .          .                   let mut next_avail = StateID::from(4u8);
      .          .          .          .                   for i in next_avail.as_usize()..self.nfa.states.len() {
      .          .          .          .                       let sid = StateID::new(i).unwrap();
  7,296 ( 0.00%) .          .          .                       if !self.nfa.states[sid].is_match() {
      .          .          .          .                           continue;
      .          .          .          .                       }
  5,576 ( 0.00%) .          .          .                       remapper.swap(&mut self.nfa, sid, next_avail);
 56,920 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::swap (1,394x)
      .          .          .          .                       // The key invariant here is that only non-match states exist
      .          .          .          .                       // between 'next_avail' and 'sid' (with them being potentially
      .          .          .          .                       // equivalent). Thus, incrementing 'next_avail' by 1 is guaranteed
      .          .          .          .                       // to land on the leftmost non-match state. (Unless 'next_avail'
      .          .          .          .                       // and 'sid' are equivalent, in which case, a swap will occur but
      .          .          .          .                       // it is a no-op.)
      .          .          .          .                       next_avail = StateID::new(next_avail.one_more()).unwrap();
      .          .          .          .                   }
-- line 1435 ----------------------------------------
-- line 1457 ----------------------------------------
      .          .          .          .                   // transition logic. This in turn stalls the CPU by killing branch
      .          .          .          .                   // prediction.
      .          .          .          .                   //
      .          .          .          .                   // So essentially, we really want to be able to "forget" that start
      .          .          .          .                   // states even exist and this is why we put them at the end.
      .          .          .          .                   let new_start_aid =
      .          .          .          .                       StateID::new(next_avail.as_usize().checked_sub(1).unwrap())
      .          .          .          .                           .unwrap();
    144 ( 0.00%) .          .          .                   remapper.swap(&mut self.nfa, old_start_aid, new_start_aid);
  2,016 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::swap (48x)
      .          .          .          .                   let new_start_uid =
     48 ( 0.00%) .          .          .                       StateID::new(next_avail.as_usize().checked_sub(2).unwrap())
      .          .          .          .                           .unwrap();
    144 ( 0.00%) .          .          .                   remapper.swap(&mut self.nfa, old_start_uid, new_start_uid);
  2,016 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::swap (48x)
      .          .          .          .                   let new_max_match_id =
     48 ( 0.00%) .          .          .                       StateID::new(next_avail.as_usize().checked_sub(3).unwrap())
      .          .          .          .                           .unwrap();
     48 ( 0.00%) .          .          .                   self.nfa.special.max_match_id = new_max_match_id;
     48 ( 0.00%) .          .          .                   self.nfa.special.start_unanchored_id = new_start_uid;
     48 ( 0.00%) .          .          .                   self.nfa.special.start_anchored_id = new_start_aid;
      .          .          .          .                   // If one start state is a match state, then they both are.
     48 ( 0.00%) .          .          .                   if self.nfa.states[self.nfa.special.start_anchored_id].is_match() {
      .          .          .          .                       self.nfa.special.max_match_id = self.nfa.special.start_anchored_id;
      .          .          .          .                   }
    336 ( 0.00%) .          .          .                   remapper.remap(&mut self.nfa);
1,686,475 ( 0.51%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/remapper.rs:aho_corasick::util::remapper::Remapper::remap (48x)
    384 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Attempts to convert the transition representation of a subset of states
      .          .          .          .               /// in this NFA from sparse to dense. This can greatly improve search
      .          .          .          .               /// performance since states with a higher number of transitions tend to
      .          .          .          .               /// correlate with very active states.
      .          .          .          .               ///
      .          .          .          .               /// We generally only densify states that are close to the start state.
      .          .          .          .               /// These tend to be the most active states and thus benefit from a dense
-- line 1489 ----------------------------------------
-- line 1492 ----------------------------------------
      .          .          .          .               /// This tends to best balance between memory usage and performance. In
      .          .          .          .               /// particular, the *vast majority* of all states in a typical Aho-Corasick
      .          .          .          .               /// automaton have only 1 transition and are usually farther from the start
      .          .          .          .               /// state and thus don't get densified.
      .          .          .          .               ///
      .          .          .          .               /// Note that this doesn't remove the sparse representation of transitions
      .          .          .          .               /// for states that are densified. It could be done, but actually removing
      .          .          .          .               /// entries from `NFA::sparse` is likely more expensive than it's worth.
    336 ( 0.00%) .          .          .               fn densify(&mut self) -> Result<(), BuildError> {
      .          .          .          .                   for i in 0..self.nfa.states.len() {
      .          .          .          .                       let sid = StateID::new(i).unwrap();
      .          .          .          .                       // Don't bother densifying states that are only used as sentinels.
  5,248 ( 0.00%) .          .          .                       if sid == NFA::DEAD || sid == NFA::FAIL {
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       // Only densify states that are "close enough" to the start state.
  5,056 ( 0.00%) .          .          .                       if self.nfa.states[sid].depth.as_usize()
      .          .          .          .                           >= self.builder.dense_depth
      .          .          .          .                       {
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       let dense = self.nfa.alloc_dense_state()?;
      .          .          .          .                       let mut prev_link = None;
 28,921 ( 0.01%) .          .          .                       while let Some(link) = self.nfa.next_link(sid, prev_link) {
      .          .          .          .                           prev_link = Some(link);
 79,521 ( 0.02%) .          .          .                           let t = self.nfa.sparse[link];
      .          .          .          .           
      .          .          .          .                           let class = usize::from(self.nfa.byte_classes.get(t.byte));
 26,507 ( 0.01%) .          .          .                           let index = dense.as_usize() + class;
 26,507 ( 0.01%) .          .          .                           self.nfa.dense[index] = t.next;
      .          .          .          .                       }
  2,414 ( 0.00%) .          .          .                       self.nfa.states[sid].dense = dense;
      .          .          .          .                   }
     48 ( 0.00%) .          .          .                   Ok(())
    432 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a set that tracked queued states.
      .          .          .          .               ///
      .          .          .          .               /// This is only necessary when ASCII case insensitivity is enabled, since
      .          .          .          .               /// it is the only way to visit the same state twice. Otherwise, this
      .          .          .          .               /// returns an inert set that nevers adds anything and always reports
      .          .          .          .               /// `false` for every member test.
      .          .          .          .               fn queued_set(&self) -> QueuedSet {
     96 ( 0.00%) .          .          .                   if self.builder.ascii_case_insensitive {
      .          .          .          .                       QueuedSet::active()
      .          .          .          .                   } else {
      .          .          .          .                       QueuedSet::inert()
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Initializes the unanchored start state by making it dense. This is
      .          .          .          .               /// achieved by explicitly setting every transition to the FAIL state.
      .          .          .          .               /// This isn't necessary for correctness, since any missing transition is
      .          .          .          .               /// automatically assumed to be mapped to the FAIL state. We do this to
      .          .          .          .               /// make the unanchored starting state dense, and thus in turn make
      .          .          .          .               /// transition lookups on it faster. (Which is worth doing because it's
      .          .          .          .               /// the most active state.)
    240 ( 0.00%) .          .          .               fn init_unanchored_start_state(&mut self) -> Result<(), BuildError> {
     96 ( 0.00%) .          .          .                   let start_uid = self.nfa.special.start_unanchored_id;
     48 ( 0.00%) .          .          .                   let start_aid = self.nfa.special.start_anchored_id;
    144 ( 0.00%) .          .          .                   self.nfa.init_full_state(start_uid, NFA::FAIL)?;
790,512 ( 0.24%) 1,125 ( 0.14%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state (48x)
    192 ( 0.00%) .          .          .                   self.nfa.init_full_state(start_aid, NFA::FAIL)?;
438,310 ( 0.13%) 94 ( 0.01%) 1 ( 0.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state (48x)
     48 ( 0.00%) .          .          .                   Ok(())
    336 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Setup the anchored start state by copying all of the transitions and
      .          .          .          .               /// matches from the unanchored starting state with one change: the failure
      .          .          .          .               /// transition is changed to the DEAD state, so that for any undefined
      .          .          .          .               /// transitions, the search will stop.
    288 ( 0.00%) .          .          .               fn set_anchored_start_state(&mut self) -> Result<(), BuildError> {
     48 ( 0.00%) .          .          .                   let start_uid = self.nfa.special.start_unanchored_id;
      .          .          .          .                   let start_aid = self.nfa.special.start_anchored_id;
      .          .          .          .                   let (mut uprev_link, mut aprev_link) = (None, None);
      .          .          .          .                   loop {
      .          .          .          .                       let unext = self.nfa.next_link(start_uid, uprev_link);
      .          .          .          .                       let anext = self.nfa.next_link(start_aid, aprev_link);
 24,720 ( 0.01%) .          .          .                       let (ulink, alink) = match (unext, anext) {
      .          .          .          .                           (Some(ulink), Some(alink)) => (ulink, alink),
      .          .          .          .                           (None, None) => break,
      .          .          .          .                           _ => unreachable!(),
      .          .          .          .                       };
      .          .          .          .                       uprev_link = Some(ulink);
      .          .          .          .                       aprev_link = Some(alink);
 49,152 ( 0.01%) .          .          .                       self.nfa.sparse[alink].next = self.nfa.sparse[ulink].next;
      .          .          .          .                   }
     96 ( 0.00%) .          .          .                   self.nfa.copy_matches(start_uid, start_aid)?;
  2,208 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::copy_matches (48x)
      .          .          .          .                   // This is the main difference between the unanchored and anchored
      .          .          .          .                   // starting states. If a lookup on an anchored starting state fails,
      .          .          .          .                   // then the search should stop.
      .          .          .          .                   //
      .          .          .          .                   // N.B. This assumes that the loop on the unanchored starting state
      .          .          .          .                   // hasn't been created yet.
     48 ( 0.00%) .          .          .                   self.nfa.states[start_aid].fail = NFA::DEAD;
     48 ( 0.00%) .          .          .                   Ok(())
    384 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the failure transitions on the start state to loop back to the
      .          .          .          .               /// start state. This effectively permits the Aho-Corasick automaton to
      .          .          .          .               /// match at any position. This is also required for finding the next
      .          .          .          .               /// state to terminate, namely, finding the next state should never return
      .          .          .          .               /// a fail_id.
      .          .          .          .               ///
      .          .          .          .               /// This must be done after building the initial trie, since trie
      .          .          .          .               /// construction depends on transitions to `fail_id` to determine whether a
      .          .          .          .               /// state already exists or not.
     96 ( 0.00%) .          .          .               fn add_unanchored_start_state_loop(&mut self) {
     48 ( 0.00%) .          .          .                   let start_uid = self.nfa.special.start_unanchored_id;
      .          .          .          .                   let mut prev_link = None;
 12,336 ( 0.00%) .          .          .                   while let Some(link) = self.nfa.next_link(start_uid, prev_link) {
      .          .          .          .                       prev_link = Some(link);
 24,084 ( 0.01%) .          .          .                       if self.nfa.sparse[link].next() == NFA::FAIL {
 11,796 ( 0.00%) .          .          .                           self.nfa.sparse[link].next = start_uid;
      .          .          .          .                       }
      .          .          .          .                   }
     96 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Remove the start state loop by rewriting any transitions on the start
      .          .          .          .               /// state back to the start state with transitions to the dead state.
      .          .          .          .               ///
      .          .          .          .               /// The loop is only closed when two conditions are met: the start state
      .          .          .          .               /// is a match state and the match kind is leftmost-first or
      .          .          .          .               /// leftmost-longest.
      .          .          .          .               ///
      .          .          .          .               /// The reason for this is that under leftmost semantics, a start state
      .          .          .          .               /// that is also a match implies that we should never restart the search
      .          .          .          .               /// process. We allow normal transitions out of the start state, but if
      .          .          .          .               /// none exist, we transition to the dead state, which signals that
      .          .          .          .               /// searching should stop.
     96 ( 0.00%) .          .          .               fn close_start_state_loop_for_leftmost(&mut self) {
     48 ( 0.00%) .          .          .                   let start_uid = self.nfa.special.start_unanchored_id;
      .          .          .          .                   let start = &mut self.nfa.states[start_uid];
      .          .          .          .                   let dense = start.dense;
     96 ( 0.00%) .          .          .                   if self.builder.match_kind.is_leftmost() && start.is_match() {
      .          .          .          .                       let mut prev_link = None;
      .          .          .          .                       while let Some(link) = self.nfa.next_link(start_uid, prev_link) {
      .          .          .          .                           prev_link = Some(link);
      .          .          .          .                           if self.nfa.sparse[link].next() == start_uid {
      .          .          .          .                               self.nfa.sparse[link].next = NFA::DEAD;
      .          .          .          .                               if dense != StateID::ZERO {
      .          .          .          .                                   let b = self.nfa.sparse[link].byte;
      .          .          .          .                                   let class = usize::from(self.nfa.byte_classes.get(b));
      .          .          .          .                                   self.nfa.dense[dense.as_usize() + class] = NFA::DEAD;
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
     96 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets all transitions on the dead state to point back to the dead state.
      .          .          .          .               /// Normally, missing transitions map back to the failure state, but the
      .          .          .          .               /// point of the dead state is to act as a sink that can never be escaped.
    144 ( 0.00%) .          .          .               fn add_dead_state_loop(&mut self) -> Result<(), BuildError> {
    192 ( 0.00%) .          .          .                   self.nfa.init_full_state(NFA::DEAD, NFA::DEAD)?;
394,848 ( 0.12%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::NFA::init_full_state (48x)
     48 ( 0.00%) .          .          .                   Ok(())
    192 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A set of state identifiers used to avoid revisiting the same state multiple
      .          .          .          .           /// times when filling in failure transitions.
      .          .          .          .           ///
      .          .          .          .           /// This set has an "inert" and an "active" mode. When inert, the set never
      .          .          .          .           /// stores anything and always returns `false` for every member test. This is
      .          .          .          .           /// useful to avoid the performance and memory overhead of maintaining this
-- line 1654 ----------------------------------------
-- line 1668 ----------------------------------------
      .          .          .          .               /// Return an active set that tracks state ID membership.
      .          .          .          .               fn active() -> QueuedSet {
      .          .          .          .                   QueuedSet { set: Some(BTreeSet::new()) }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Inserts the given state ID into this set. (If the set is inert, then
      .          .          .          .               /// this is a no-op.)
      .          .          .          .               fn insert(&mut self, state_id: StateID) {
  4,864 ( 0.00%) .          .          .                   if let Some(ref mut set) = self.set {
      .          .          .          .                       set.insert(state_id);
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if the given state ID is in this set. If the
      .          .          .          .               /// set is inert, this always returns false.
      .          .          .          .               fn contains(&self, state_id: StateID) -> bool {
  4,864 ( 0.00%) .          .          .                   match self.set {
      .          .          .          .                       None => false,
      .          .          .          .                       Some(ref set) => set.contains(&state_id),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl core::fmt::Debug for NFA {
      .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-- line 1692 ----------------------------------------

431,772 ( 0.13%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 439 ----------------------------------------
     .          .          .          .               /// let s = String::new();
     .          .          .          .               /// ```
     .          .          .          .               #[inline]
     .          .          .          .               #[rustc_const_stable(feature = "const_string_new", since = "1.39.0")]
     .          .          .          .               #[cfg_attr(not(test), rustc_diagnostic_item = "string_new")]
     .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .               #[must_use]
     .          .          .          .               pub const fn new() -> String {
 5,604 ( 0.00%) .          .          .                   String { vec: Vec::new() }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Creates a new empty `String` with at least the specified capacity.
     .          .          .          .               ///
     .          .          .          .               /// `String`s have an internal buffer to hold their data. The capacity is
     .          .          .          .               /// the length of that buffer, and can be queried with the [`capacity`]
     .          .          .          .               /// method. This method creates an empty `String`, but one with an initial
     .          .          .          .               /// buffer that can hold at least `capacity` bytes. This is useful when you
-- line 455 ----------------------------------------
-- line 1036 ----------------------------------------
     .          .          .          .               /// };
     .          .          .          .               ///
     .          .          .          .               /// assert_eq!("", sparkle_heart);
     .          .          .          .               /// ```
     .          .          .          .               #[inline]
     .          .          .          .               #[must_use]
     .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .               pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {
    34 ( 0.00%) .          .          .                   String { vec: bytes }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Converts a `String` into a byte vector.
     .          .          .          .               ///
     .          .          .          .               /// This consumes the `String`, so we do not need to copy its contents.
     .          .          .          .               ///
     .          .          .          .               /// # Examples
     .          .          .          .               ///
-- line 1052 ----------------------------------------
-- line 1832 ----------------------------------------
     .          .          .          .               /// v.push('a');
     .          .          .          .               /// assert!(!v.is_empty());
     .          .          .          .               /// ```
     .          .          .          .               #[inline]
     .          .          .          .               #[must_use]
     .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .               #[rustc_const_unstable(feature = "const_vec_string_slice", issue = "129041")]
     .          .          .          .               pub const fn is_empty(&self) -> bool {
     1 ( 0.00%) .          .          .                   self.len() == 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Splits the string into two at the given byte index.
     .          .          .          .               ///
     .          .          .          .               /// Returns a newly allocated `String`. `self` contains bytes `[0, at)`, and
     .          .          .          .               /// the returned `String` contains bytes `[at, len)`. `at` must be on the
     .          .          .          .               /// boundary of a UTF-8 code point.
     .          .          .          .               ///
-- line 1848 ----------------------------------------
-- line 2498 ----------------------------------------
     .          .          .          .                   fmt::Display::fmt(&**self, f)
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .           impl fmt::Debug for String {
     .          .          .          .               #[inline]
     .          .          .          .               fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
     2 ( 0.00%) .          .          .                   fmt::Debug::fmt(&**self, f)
   438 ( 0.00%) .          .          .           => /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/mod.rs:<str as core::fmt::Debug>::fmt (2x)
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .           impl hash::Hash for String {
     .          .          .          .               #[inline]
     .          .          .          .               fn hash<H: hash::Hasher>(&self, hasher: &mut H) {
     .          .          .          .                   (**self).hash(hasher)
-- line 2514 ----------------------------------------
-- line 2693 ----------------------------------------
     .          .          .          .               // See <https://github.com/rust-lang/rust/pull/74852>, the last attempt
     .          .          .          .               // to try to remove it.
     .          .          .          .               #[inline]
     .          .          .          .               default fn spec_to_string(&self) -> String {
     .          .          .          .                   let mut buf = String::new();
     .          .          .          .                   let mut formatter =
     .          .          .          .                       core::fmt::Formatter::new(&mut buf, core::fmt::FormattingOptions::new());
     .          .          .          .                   // Bypass format_args!() to avoid write_str with zero-length strs
     5 ( 0.00%) .          .          .                   fmt::Display::fmt(self, &mut formatter)
 1,273 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/chrono-0.4.42/src/offset/fixed.rs:<chrono::offset::fixed::FixedOffset as core::fmt::Display>::fmt (1x)
   434 ( 0.00%) .          .          .           => /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/num.rs:core::fmt::num::imp::<impl core::fmt::Display for u64>::fmt (1x)
     .          .          .          .                       .expect("a Display implementation returned an error unexpectedly");
 8,106 ( 0.00%) .          .          .                   buf
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[cfg(not(no_global_oom_handling))]
     .          .          .          .           impl SpecToString for core::ascii::Char {
     .          .          .          .               #[inline]
     .          .          .          .               fn spec_to_string(&self) -> String {
     .          .          .          .                   self.as_str().to_owned()
-- line 2711 ----------------------------------------
-- line 3073 ----------------------------------------
     .          .          .          .                   string.into_bytes()
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[cfg(not(no_global_oom_handling))]
     .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .           impl fmt::Write for String {
     .          .          .          .               #[inline]
13,097 ( 0.00%) .          .          .               fn write_str(&mut self, s: &str) -> fmt::Result {
     .          .          .          .                   self.push_str(s);
     .          .          .          .                   Ok(())
13,097 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
    36 ( 0.00%) .          .          .               fn write_char(&mut self, c: char) -> fmt::Result {
     .          .          .          .                   self.push(c);
     .          .          .          .                   Ok(())
    42 ( 0.00%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A draining iterator for `String`.
     .          .          .          .           ///
     .          .          .          .           /// This struct is created by the [`drain`] method on [`String`]. See its
     .          .          .          .           /// documentation for more.
     .          .          .          .           ///
     .          .          .          .           /// [`drain`]: String::drain
-- line 3098 ----------------------------------------

    11 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 180 ----------------------------------------
    .          .          .          .               /// `ManuallyDrop` to control drop order (needs to be dropped after all the nodes).
    .          .          .          .               pub(super) alloc: ManuallyDrop<A>,
    .          .          .          .               // For dropck; the `Box` avoids making the `Unpin` impl more strict than before
    .          .          .          .               _marker: PhantomData<crate::boxed::Box<(K, V), A>>,
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           #[stable(feature = "btree_drop", since = "1.7.0")]
    .          .          .          .           unsafe impl<#[may_dangle] K, #[may_dangle] V, A: Allocator + Clone> Drop for BTreeMap<K, V, A> {
   97 ( 0.00%) .          .          .               fn drop(&mut self) {
    .          .          .          .                   drop(unsafe { ptr::read(self) }.into_iter())
   16 ( 0.00%) .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           // FIXME: This implementation is "wrong", but changing it would be a breaking change.
    .          .          .          .           // (The bounds of the automatic `UnwindSafe` implementation have been like this since Rust 1.50.)
    .          .          .          .           // Maybe we can fix it nonetheless with a crater run, or if the `UnwindSafe`
    .          .          .          .           // traits are deprecated, or disarmed (no longer causing hard errors) in the future.
    .          .          .          .           #[stable(feature = "btree_unwindsafe", since = "1.64.0")]
    .          .          .          .           impl<K, V, A: Allocator + Clone> core::panic::UnwindSafe for BTreeMap<K, V, A>
-- line 198 ----------------------------------------
-- line 621 ----------------------------------------
    .          .          .          .               /// // entries can now be inserted into the empty map
    .          .          .          .               /// map.insert(1, "a");
    .          .          .          .               /// ```
    .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .               #[rustc_const_stable(feature = "const_btree_new", since = "1.66.0")]
    .          .          .          .               #[inline]
    .          .          .          .               #[must_use]
    .          .          .          .               pub const fn new() -> BTreeMap<K, V> {
  134 ( 0.00%) .          .          .                   BTreeMap { root: None, length: 0, alloc: ManuallyDrop::new(Global), _marker: PhantomData }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {
    .          .          .          .               /// Clears the map, removing all elements.
    .          .          .          .               ///
    .          .          .          .               /// # Examples
    .          .          .          .               ///
-- line 637 ----------------------------------------
-- line 694 ----------------------------------------
    .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .               pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>
    .          .          .          .               where
    .          .          .          .                   K: Borrow<Q> + Ord,
    .          .          .          .                   Q: Ord,
    .          .          .          .               {
    .          .          .          .                   let root_node = self.root.as_ref()?.reborrow();
    .          .          .          .                   match root_node.search_tree(key) {
   15 ( 0.00%) .          .          .                       Found(handle) => Some(handle.into_kv().1),
    .          .          .          .                       GoDown(_) => None,
    .          .          .          .                   }
    9 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the key-value pair corresponding to the supplied key. This is
    .          .          .          .               /// potentially useful:
    .          .          .          .               /// - for key types where non-identical keys can be considered equal;
    .          .          .          .               /// - for getting the `&K` stored key value from a borrowed `&Q` lookup key; or
    .          .          .          .               /// - for getting a reference to a key with the same lifetime as the collection.
    .          .          .          .               ///
    .          .          .          .               /// The supplied key may be any borrowed form of the map's key type, but the ordering
-- line 713 ----------------------------------------
-- line 954 ----------------------------------------
    .          .          .          .               /// ```
    .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .               #[cfg_attr(not(test), rustc_diagnostic_item = "btreemap_contains_key")]
    .          .          .          .               pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool
    .          .          .          .               where
    .          .          .          .                   K: Borrow<Q> + Ord,
    .          .          .          .                   Q: Ord,
    .          .          .          .               {
    6 ( 0.00%) .          .          .                   self.get(key).is_some()
   77 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::get (2x)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns a mutable reference to the value corresponding to the key.
    .          .          .          .               ///
    .          .          .          .               /// The key may be any borrowed form of the map's key type, but the ordering
    .          .          .          .               /// on the borrowed form *must* match the ordering on the key type.
    .          .          .          .               ///
    .          .          .          .               /// # Examples
-- line 970 ----------------------------------------
-- line 983 ----------------------------------------
    .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .               pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>
    .          .          .          .               where
    .          .          .          .                   K: Borrow<Q> + Ord,
    .          .          .          .                   Q: Ord,
    .          .          .          .               {
    .          .          .          .                   let root_node = self.root.as_mut()?.borrow_mut();
    .          .          .          .                   match root_node.search_tree(key) {
   10 ( 0.00%) .          .          .                       Found(handle) => Some(handle.into_val_mut()),
    .          .          .          .                       GoDown(_) => None,
    .          .          .          .                   }
    5 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Inserts a key-value pair into the map.
    .          .          .          .               ///
    .          .          .          .               /// If the map did not have this key present, `None` is returned.
    .          .          .          .               ///
    .          .          .          .               /// If the map did have this key present, the value is updated, and the old
    .          .          .          .               /// value is returned. The key is not updated, though; this matters for
    .          .          .          .               /// types that can be `==` without being identical. See the [module-level
-- line 1002 ----------------------------------------
-- line 1015 ----------------------------------------
    .          .          .          .               ///
    .          .          .          .               /// map.insert(37, "b");
    .          .          .          .               /// assert_eq!(map.insert(37, "c"), Some("b"));
    .          .          .          .               /// assert_eq!(map[&37], "c");
    .          .          .          .               /// ```
    .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .               #[rustc_confusables("push", "put", "set")]
    .          .          .          .               #[cfg_attr(not(test), rustc_diagnostic_item = "btreemap_insert")]
5,336 ( 0.00%) .          .          .               pub fn insert(&mut self, key: K, value: V) -> Option<V>
    .          .          .          .               where
    .          .          .          .                   K: Ord,
    .          .          .          .               {
    .          .          .          .                   match self.entry(key) {
    .          .          .          .                       Occupied(mut entry) => Some(entry.insert(value)),
3,844 ( 0.00%) .          .          .                       Vacant(entry) => {
    .          .          .          .                           entry.insert(value);
    4 ( 0.00%) .          .          .                           None
    .          .          .          .                       }
    .          .          .          .                   }
4,314 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Tries to insert a key-value pair into the map, and returns
    .          .          .          .               /// a mutable reference to the value in the entry.
    .          .          .          .               ///
    .          .          .          .               /// If the map already had this key present, nothing is updated, and
    .          .          .          .               /// an error containing the occupied entry and the value is returned.
    .          .          .          .               ///
    .          .          .          .               /// # Examples
-- line 1042 ----------------------------------------
-- line 1078 ----------------------------------------
    .          .          .          .               ///
    .          .          .          .               /// let mut map = BTreeMap::new();
    .          .          .          .               /// map.insert(1, "a");
    .          .          .          .               /// assert_eq!(map.remove(&1), Some("a"));
    .          .          .          .               /// assert_eq!(map.remove(&1), None);
    .          .          .          .               /// ```
    .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .               #[rustc_confusables("delete", "take")]
    9 ( 0.00%) .          .          .               pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>
    .          .          .          .               where
    .          .          .          .                   K: Borrow<Q> + Ord,
    .          .          .          .                   Q: Ord,
    .          .          .          .               {
   42 ( 0.00%) .          .          .                   self.remove_entry(key).map(|(_, v)| v)
   13 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Removes a key from the map, returning the stored key and value if the key
    .          .          .          .               /// was previously in the map.
    .          .          .          .               ///
    .          .          .          .               /// The key may be any borrowed form of the map's key type, but the ordering
    .          .          .          .               /// on the borrowed form *must* match the ordering on the key type.
    .          .          .          .               ///
    .          .          .          .               /// # Examples
-- line 1100 ----------------------------------------
-- line 1111 ----------------------------------------
    .          .          .          .               pub fn remove_entry<Q: ?Sized>(&mut self, key: &Q) -> Option<(K, V)>
    .          .          .          .               where
    .          .          .          .                   K: Borrow<Q> + Ord,
    .          .          .          .                   Q: Ord,
    .          .          .          .               {
    .          .          .          .                   let (map, dormant_map) = DormantMutRef::new(self);
    .          .          .          .                   let root_node = map.root.as_mut()?.borrow_mut();
    .          .          .          .                   match root_node.search_tree(key) {
   17 ( 0.00%) .          .          .                       Found(handle) => Some(
   12 ( 0.00%) .          .          .                           OccupiedEntry {
    .          .          .          .                               handle,
    .          .          .          .                               dormant_map,
    .          .          .          .                               alloc: (*map.alloc).clone(),
    .          .          .          .                               _marker: PhantomData,
    .          .          .          .                           }
    .          .          .          .                           .remove_entry(),
    .          .          .          .                       ),
    .          .          .          .                       GoDown(_) => None,
-- line 1128 ----------------------------------------
-- line 1146 ----------------------------------------
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               #[stable(feature = "btree_retain", since = "1.53.0")]
    .          .          .          .               pub fn retain<F>(&mut self, mut f: F)
    .          .          .          .               where
    .          .          .          .                   K: Ord,
    .          .          .          .                   F: FnMut(&K, &mut V) -> bool,
    .          .          .          .               {
  175 ( 0.00%) .          .          .                   self.extract_if(|k, v| !f(k, v)).for_each(drop);
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Moves all elements from `other` into `self`, leaving `other` empty.
    .          .          .          .               ///
    .          .          .          .               /// If a key from `other` is already present in `self`, the respective
    .          .          .          .               /// value from `self` will be overwritten with the respective value from `other`.
    .          .          .          .               ///
    .          .          .          .               /// # Examples
-- line 1162 ----------------------------------------
-- line 1242 ----------------------------------------
    .          .          .          .               /// ```
    .          .          .          .               #[stable(feature = "btree_range", since = "1.17.0")]
    .          .          .          .               pub fn range<T: ?Sized, R>(&self, range: R) -> Range<'_, K, V>
    .          .          .          .               where
    .          .          .          .                   T: Ord,
    .          .          .          .                   K: Borrow<T> + Ord,
    .          .          .          .                   R: RangeBounds<T>,
    .          .          .          .               {
  108 ( 0.00%) .          .          .                   if let Some(root) = &self.root {
   94 ( 0.00%) .          .          .                       Range { inner: root.reborrow().range_search(range) }
    .          .          .          .                   } else {
    .          .          .          .                       Range { inner: LeafRange::none() }
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Constructs a mutable double-ended iterator over a sub-range of elements in the map.
    .          .          .          .               /// The simplest way is to use the range syntax `min..max`, thus `range(min..max)` will
    .          .          .          .               /// yield elements from min (inclusive) to max (exclusive).
-- line 1259 ----------------------------------------
-- line 1313 ----------------------------------------
    .          .          .          .               /// assert_eq!(count["c"], 1);
    .          .          .          .               /// ```
    .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .               pub fn entry(&mut self, key: K) -> Entry<'_, K, V, A>
    .          .          .          .               where
    .          .          .          .                   K: Ord,
    .          .          .          .               {
    .          .          .          .                   let (map, dormant_map) = DormantMutRef::new(self);
2,251 ( 0.00%) .          .          .                   match map.root {
    .          .          .          .                       None => Vacant(VacantEntry {
    .          .          .          .                           key,
    .          .          .          .                           handle: None,
    .          .          .          .                           dormant_map,
    .          .          .          .                           alloc: (*map.alloc).clone(),
    .          .          .          .                           _marker: PhantomData,
    .          .          .          .                       }),
    .          .          .          .                       Some(ref mut root) => match root.borrow_mut().search_tree(&key) {
-- line 1329 ----------------------------------------
-- line 1428 ----------------------------------------
    .          .          .          .               /// ```
    .          .          .          .               #[unstable(feature = "btree_extract_if", issue = "70530")]
    .          .          .          .               pub fn extract_if<F>(&mut self, pred: F) -> ExtractIf<'_, K, V, F, A>
    .          .          .          .               where
    .          .          .          .                   K: Ord,
    .          .          .          .                   F: FnMut(&K, &mut V) -> bool,
    .          .          .          .               {
    .          .          .          .                   let (inner, alloc) = self.extract_if_inner();
    9 ( 0.00%) .          .          .                   ExtractIf { pred, inner, alloc }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(super) fn extract_if_inner(&mut self) -> (ExtractIfInner<'_, K, V>, A)
    .          .          .          .               where
    .          .          .          .                   K: Ord,
    .          .          .          .               {
    .          .          .          .                   if let Some(root) = self.root.as_mut() {
    .          .          .          .                       let (root, dormant_root) = DormantMutRef::new(root);
    .          .          .          .                       let front = root.borrow_mut().first_leaf_edge();
    4 ( 0.00%) .          .          .                       (
    .          .          .          .                           ExtractIfInner {
    .          .          .          .                               length: &mut self.length,
    .          .          .          .                               dormant_root: Some(dormant_root),
    .          .          .          .                               cur_leaf_edge: Some(front),
    .          .          .          .                           },
    .          .          .          .                           (*self.alloc).clone(),
    .          .          .          .                       )
    .          .          .          .                   } else {
-- line 1454 ----------------------------------------
-- line 1529 ----------------------------------------
    .          .          .          .                   self.iter()
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .           impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {
    .          .          .          .               type Item = (&'a K, &'a V);
    .          .          .          .           
    9 ( 0.00%) .          .          .               fn next(&mut self) -> Option<(&'a K, &'a V)> {
2,922 ( 0.00%) .          .          .                   if self.length == 0 {
    .          .          .          .                       None
    .          .          .          .                   } else {
   18 ( 0.00%) .          .          .                       self.length -= 1;
    .          .          .          .                       Some(unsafe { self.range.next_unchecked() })
    .          .          .          .                   }
   18 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               fn size_hint(&self) -> (usize, Option<usize>) {
    .          .          .          .                   (self.length, Some(self.length))
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               fn last(mut self) -> Option<(&'a K, &'a V)> {
    .          .          .          .                   self.next_back()
    .          .          .          .               }
-- line 1552 ----------------------------------------
-- line 1604 ----------------------------------------
    .          .          .          .                   self.iter_mut()
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .           impl<'a, K, V> Iterator for IterMut<'a, K, V> {
    .          .          .          .               type Item = (&'a K, &'a mut V);
    .          .          .          .           
    3 ( 0.00%) .          .          .               fn next(&mut self) -> Option<(&'a K, &'a mut V)> {
   15 ( 0.00%) .          .          .                   if self.length == 0 {
    .          .          .          .                       None
    .          .          .          .                   } else {
    6 ( 0.00%) .          .          .                       self.length -= 1;
    .          .          .          .                       Some(unsafe { self.range.next_unchecked() })
    .          .          .          .                   }
    6 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               fn size_hint(&self) -> (usize, Option<usize>) {
    .          .          .          .                   (self.length, Some(self.length))
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               fn last(mut self) -> Option<(&'a K, &'a mut V)> {
    .          .          .          .                   self.next_back()
    .          .          .          .               }
-- line 1627 ----------------------------------------
-- line 1674 ----------------------------------------
    .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .           impl<K, V, A: Allocator + Clone> IntoIterator for BTreeMap<K, V, A> {
    .          .          .          .               type Item = (K, V);
    .          .          .          .               type IntoIter = IntoIter<K, V, A>;
    .          .          .          .           
    .          .          .          .               /// Gets an owning iterator over the entries of the map, sorted by key.
    .          .          .          .               fn into_iter(self) -> IntoIter<K, V, A> {
    .          .          .          .                   let mut me = ManuallyDrop::new(self);
  144 ( 0.00%) .          .          .                   if let Some(root) = me.root.take() {
    .          .          .          .                       let full_range = root.into_dying().full_range();
    .          .          .          .           
   14 ( 0.00%) .          .          .                       IntoIter {
    .          .          .          .                           range: full_range,
    .          .          .          .                           length: me.length,
    .          .          .          .                           alloc: unsafe { ManuallyDrop::take(&mut me.alloc) },
    .          .          .          .                       }
    .          .          .          .                   } else {
    .          .          .          .                       IntoIter {
    .          .          .          .                           range: LazyLeafRange::none(),
    .          .          .          .                           length: 0,
-- line 1693 ----------------------------------------
-- line 1708 ----------------------------------------
    .          .          .          .                           // don't have to care about panics this time (they'll abort).
    .          .          .          .                           while let Some(kv) = self.0.dying_next() {
    .          .          .          .                               // SAFETY: we consume the dying handle immediately.
    .          .          .          .                               unsafe { kv.drop_key_val() };
    .          .          .          .                           }
    .          .          .          .                       }
    .          .          .          .                   }
    .          .          .          .           
   10 ( 0.00%) .          .          .                   while let Some(kv) = self.dying_next() {
   52 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:alloc::collections::btree::map::IntoIter<K,V,A>::dying_next (2x)
    .          .          .          .                       let guard = DropGuard(self);
    .          .          .          .                       // SAFETY: we don't touch the tree before consuming the dying handle.
    .          .          .          .                       unsafe { kv.drop_key_val() };
    .          .          .          .                       mem::forget(guard);
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<K, V, A: Allocator + Clone> IntoIter<K, V, A> {
    .          .          .          .               /// Core of a `next` method returning a dying KV handle,
    .          .          .          .               /// invalidated by further calls to this function and some others.
   48 ( 0.00%) .          .          .               fn dying_next(
    .          .          .          .                   &mut self,
    .          .          .          .               ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>> {
  584 ( 0.00%) .          .          .                   if self.length == 0 {
    .          .          .          .                       self.range.deallocating_end(self.alloc.clone());
    4 ( 0.00%) .          .          .                       None
    .          .          .          .                   } else {
    4 ( 0.00%) .          .          .                       self.length -= 1;
    .          .          .          .                       Some(unsafe { self.range.deallocating_next_unchecked(self.alloc.clone()) })
    .          .          .          .                   }
   48 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Core of a `next_back` method returning a dying KV handle,
    .          .          .          .               /// invalidated by further calls to this function and some others.
    .          .          .          .               fn dying_next_back(
    .          .          .          .                   &mut self,
    .          .          .          .               ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>> {
    .          .          .          .                   if self.length == 0 {
    .          .          .          .                       self.range.deallocating_end(self.alloc.clone());
-- line 1746 ----------------------------------------
-- line 1753 ----------------------------------------
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .           impl<K, V, A: Allocator + Clone> Iterator for IntoIter<K, V, A> {
    .          .          .          .               type Item = (K, V);
    .          .          .          .           
    .          .          .          .               fn next(&mut self) -> Option<(K, V)> {
    .          .          .          .                   // SAFETY: we consume the dying handle immediately.
    4 ( 0.00%) .          .          .                   self.dying_next().map(unsafe { |kv| kv.into_key_val() })
  394 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:alloc::collections::btree::map::IntoIter<K,V,A>::dying_next (4x)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               fn size_hint(&self) -> (usize, Option<usize>) {
    .          .          .          .                   (self.length, Some(self.length))
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
-- line 1769 ----------------------------------------
-- line 1953 ----------------------------------------
    .          .          .          .           
    .          .          .          .           #[unstable(feature = "btree_extract_if", issue = "70530")]
    .          .          .          .           impl<K, V, F, A: Allocator + Clone> Iterator for ExtractIf<'_, K, V, F, A>
    .          .          .          .           where
    .          .          .          .               F: FnMut(&K, &mut V) -> bool,
    .          .          .          .           {
    .          .          .          .               type Item = (K, V);
    .          .          .          .           
  350 ( 0.00%) .          .          .               fn next(&mut self) -> Option<(K, V)> {
  175 ( 0.00%) .          .          .                   self.inner.next(&mut self.pred, self.alloc.clone())
  175 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               fn size_hint(&self) -> (usize, Option<usize>) {
    .          .          .          .                   self.inner.size_hint()
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl<'a, K, V> ExtractIfInner<'a, K, V> {
    .          .          .          .               /// Allow Debug implementations to predict the next element.
-- line 1971 ----------------------------------------
-- line 1976 ----------------------------------------
    .          .          .          .           
    .          .          .          .               /// Implementation of a typical `ExtractIf::next` method, given the predicate.
    .          .          .          .               pub(super) fn next<F, A: Allocator + Clone>(&mut self, pred: &mut F, alloc: A) -> Option<(K, V)>
    .          .          .          .               where
    .          .          .          .                   F: FnMut(&K, &mut V) -> bool,
    .          .          .          .               {
    .          .          .          .                   while let Ok(mut kv) = self.cur_leaf_edge.take()?.next_kv() {
    .          .          .          .                       let (k, v) = kv.kv_mut();
  175 ( 0.00%) .          .          .                       if pred(k, v) {
  348 ( 0.00%) .          .          .                           *self.length -= 1;
1,566 ( 0.00%) .          .          .                           let (kv, pos) = kv.remove_kv_tracking(
31,902 ( 0.01%) 54 ( 0.01%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/remove.rs:alloc::collections::btree::remove::<impl alloc::collections::btree::node::Handle<alloc::collections::btree::node::NodeRef<alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::LeafOrInternal>,alloc::collections::btree::node::marker::KV>>::remove_kv_tracking (174x)
  174 ( 0.00%) .          .          .                               || {
    .          .          .          .                                   // SAFETY: we will touch the root in a way that will not
    .          .          .          .                                   // invalidate the position returned.
    .          .          .          .                                   let root = unsafe { self.dormant_root.take().unwrap().awaken() };
    .          .          .          .                                   root.pop_internal_level(alloc.clone());
    .          .          .          .                                   self.dormant_root = Some(DormantMutRef::new(root).1);
    .          .          .          .                               },
    .          .          .          .                               alloc.clone(),
    .          .          .          .                           );
  348 ( 0.00%) .          .          .                           self.cur_leaf_edge = Some(pos);
  348 ( 0.00%) .          .          .                           return Some(kv);
    .          .          .          .                       }
    1 ( 0.00%) .          .          .                       self.cur_leaf_edge = Some(kv.next_leaf_edge());
    .          .          .          .                   }
    .          .          .          .                   None
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Implementation of a typical `ExtractIf::size_hint` method.
    .          .          .          .               pub(super) fn size_hint(&self) -> (usize, Option<usize>) {
    .          .          .          .                   // In most of the btree iterators, `self.length` is the number of elements
    .          .          .          .                   // yet to be visited. Here, it includes elements that were visited and that
-- line 2007 ----------------------------------------
-- line 2306 ----------------------------------------
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .           impl<K: Ord, V, A: Allocator + Clone> Extend<(K, V)> for BTreeMap<K, V, A> {
    .          .          .          .               #[inline]
    .          .          .          .               fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {
    .          .          .          .                   iter.into_iter().for_each(move |(k, v)| {
    8 ( 0.00%) .          .          .                       self.insert(k, v);
  172 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert (2x)
    .          .          .          .                   });
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               #[inline]
    .          .          .          .               fn extend_one(&mut self, (k, v): (K, V)) {
    .          .          .          .                   self.insert(k, v);
    .          .          .          .               }
    .          .          .          .           }
-- line 2322 ----------------------------------------
-- line 2447 ----------------------------------------
    .          .          .          .               ///     println!("{key}: {value}");
    .          .          .          .               /// }
    .          .          .          .               ///
    .          .          .          .               /// let (first_key, first_value) = map.iter().next().unwrap();
    .          .          .          .               /// assert_eq!((*first_key, *first_value), (1, "a"));
    .          .          .          .               /// ```
    .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .               pub fn iter(&self) -> Iter<'_, K, V> {
  114 ( 0.00%) .          .          .                   if let Some(root) = &self.root {
    .          .          .          .                       let full_range = root.reborrow().full_range();
    .          .          .          .           
   67 ( 0.00%) .          .          .                       Iter { range: full_range, length: self.length }
    .          .          .          .                   } else {
    .          .          .          .                       Iter { range: LazyLeafRange::none(), length: 0 }
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Gets a mutable iterator over the entries of the map, sorted by key.
    .          .          .          .               ///
    .          .          .          .               /// # Examples
-- line 2466 ----------------------------------------
-- line 2478 ----------------------------------------
    .          .          .          .               /// for (key, value) in map.iter_mut() {
    .          .          .          .               ///     if key != &"a" {
    .          .          .          .               ///         *value += 10;
    .          .          .          .               ///     }
    .          .          .          .               /// }
    .          .          .          .               /// ```
    .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .               pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {
    9 ( 0.00%) .          .          .                   if let Some(root) = &mut self.root {
    .          .          .          .                       let full_range = root.borrow_valmut().full_range();
    .          .          .          .           
   24 ( 0.00%) .          .          .                       IterMut { range: full_range, length: self.length, _marker: PhantomData }
    .          .          .          .                   } else {
    .          .          .          .                       IterMut { range: LazyLeafRange::none(), length: 0, _marker: PhantomData }
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Gets an iterator over the keys of the map, in sorted order.
    .          .          .          .               ///
    .          .          .          .               /// # Examples
-- line 2497 ----------------------------------------
-- line 2570 ----------------------------------------
    .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
    .          .          .          .               #[rustc_const_unstable(
    .          .          .          .                   feature = "const_btree_len",
    .          .          .          .                   issue = "71835",
    .          .          .          .                   implied_by = "const_btree_new"
    .          .          .          .               )]
    .          .          .          .               #[rustc_confusables("length", "size")]
    .          .          .          .               pub const fn len(&self) -> usize {
   25 ( 0.00%) .          .          .                   self.length
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns `true` if the map contains no elements.
    .          .          .          .               ///
    .          .          .          .               /// # Examples
    .          .          .          .               ///
    .          .          .          .               /// ```
    .          .          .          .               /// use std::collections::BTreeMap;
-- line 2586 ----------------------------------------

5,095 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/remapper.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 85 ----------------------------------------
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl Remapper {
     .          .          .          .               /// Create a new remapper from the given remappable implementation. The
     .          .          .          .               /// remapper can then be used to swap states. The remappable value given
     .          .          .          .               /// here must the same one given to `swap` and `remap`.
     .          .          .          .               pub(super) fn new(r: &impl Remappable) -> Remapper {
     .          .          .          .                   let idxmap = IndexMapper { stride2: r.stride2() };
     2 ( 0.00%) .          .          .                   let map = (0..r.state_len()).map(|i| idxmap.to_state_id(i)).collect();
     1 ( 0.00%) .          .          .                   Remapper { map, idxmap }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Swap two states. Once this is called, callers must follow through to
     .          .          .          .               /// call `remap`, or else it's possible for the underlying remappable
     .          .          .          .               /// value to be in a corrupt state.
     3 ( 0.00%) .          .          .               pub(super) fn swap(
     .          .          .          .                   &mut self,
     .          .          .          .                   r: &mut impl Remappable,
     .          .          .          .                   id1: StateID,
     .          .          .          .                   id2: StateID,
     .          .          .          .               ) {
     1 ( 0.00%) .          .          .                   if id1 == id2 {
     .          .          .          .                       return;
     .          .          .          .                   }
     .          .          .          .                   r.swap_states(id1, id2);
     1 ( 0.00%) .          .          .                   self.map.swap(self.idxmap.to_index(id1), self.idxmap.to_index(id2));
     4 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Complete the remapping process by rewriting all state IDs in the
     .          .          .          .               /// remappable value according to the swaps performed.
     8 ( 0.00%) .          .          .               pub(super) fn remap(mut self, r: &mut impl Remappable) {
     .          .          .          .                   // Update the map to account for states that have been swapped
     .          .          .          .                   // multiple times. For example, if (A, C) and (C, G) are swapped, then
     .          .          .          .                   // transitions previously pointing to A should now point to G. But if
     .          .          .          .                   // we don't update our map, they will erroneously be set to C. All we
     .          .          .          .                   // do is follow the swaps in our map until we see our original state
     .          .          .          .                   // ID.
     .          .          .          .                   //
     .          .          .          .                   // The intuition here is to think about how changes are made to the
-- line 123 ----------------------------------------
-- line 126 ----------------------------------------
     .          .          .          .                   // state by following the swaps represented in the map (which might be
     .          .          .          .                   // 0 swaps).
     .          .          .          .                   //
     .          .          .          .                   // We are also careful to clone the map before starting in order to
     .          .          .          .                   // freeze it. We use the frozen map to find our loops, since we need to
     .          .          .          .                   // update our map as well. Without freezing it, our updates could break
     .          .          .          .                   // the loops referenced above and produce incorrect results.
     .          .          .          .                   let oldmap = self.map.clone();
     2 ( 0.00%) .          .          .                   for i in 0..r.state_len() {
     .          .          .          .                       let cur_id = self.idxmap.to_state_id(i);
    74 ( 0.00%) .          .          .                       let mut new_id = oldmap[i];
    76 ( 0.00%) .          .          .                       if cur_id == new_id {
     .          .          .          .                           continue;
     .          .          .          .                       }
     .          .          .          .                       loop {
     4 ( 0.00%) .          .          .                           let id = oldmap[self.idxmap.to_index(new_id)];
     4 ( 0.00%) .          .          .                           if cur_id == id {
     2 ( 0.00%) .          .          .                               self.map[i] = new_id;
     .          .          .          .                               break;
     .          .          .          .                           }
     .          .          .          .                           new_id = id;
     .          .          .          .                       }
     .          .          .          .                   }
     6 ( 0.00%) .          .          .                   r.remap(|next| self.map[self.idxmap.to_index(next)]);
102,562 ( 0.03%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/remapper.rs:regex_automata::dfa::remapper::onepass::<impl regex_automata::dfa::remapper::Remappable for regex_automata::dfa::onepass::DFA>::remap (1x)
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// A simple type for mapping between state indices and state IDs.
     .          .          .          .           ///
     .          .          .          .           /// The reason why this exists is because state IDs are "premultiplied." That
     .          .          .          .           /// is, in order to get to the transitions for a particular state, one need
     .          .          .          .           /// only use the state ID as-is, instead of having to multiple it by transition
-- line 157 ----------------------------------------
-- line 171 ----------------------------------------
     .          .          .          .               /// transition table. 'id >> stride2' de-multiplies an ID while 'index <<
     .          .          .          .               /// stride2' pre-multiplies an index to an ID.
     .          .          .          .               stride2: usize,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl IndexMapper {
     .          .          .          .               /// Convert a state ID to a state index.
     .          .          .          .               fn to_index(&self, id: StateID) -> usize {
11,995 ( 0.00%) .          .          .                   id.as_usize() >> self.stride2
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Convert a state index to a state ID.
     .          .          .          .               fn to_state_id(&self, index: usize) -> StateID {
     .          .          .          .                   // CORRECTNESS: If the given index is not valid, then it is not
     .          .          .          .                   // required for this to panic or return a valid state ID. We'll "just"
     .          .          .          .                   // wind up with panics or silent logic errors at some other point.
   148 ( 0.00%) .          .          .                   StateID::new_unchecked(index << self.stride2)
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[cfg(feature = "dfa-build")]
     .          .          .          .           mod dense {
     .          .          .          .               use crate::{dfa::dense::OwnedDFA, util::primitives::StateID};
     .          .          .          .           
     .          .          .          .               use super::Remappable;
-- line 195 ----------------------------------------
-- line 230 ----------------------------------------
     .          .          .          .                       // equivalent.
     .          .          .          .                       0
     .          .          .          .                   }
     .          .          .          .           
     .          .          .          .                   fn swap_states(&mut self, id1: StateID, id2: StateID) {
     .          .          .          .                       DFA::swap_states(self, id1, id2)
     .          .          .          .                   }
     .          .          .          .           
     9 ( 0.00%) .          .          .                   fn remap(&mut self, map: impl Fn(StateID) -> StateID) {
     .          .          .          .                       DFA::remap(self, map)
     8 ( 0.00%) .          .          .                   }
     .          .          .          .               }
     .          .          .          .           }

    81 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/dfa/remapper.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/sip.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 66 ----------------------------------------
     .          .          .          .               // the compiler can pick up on just a few simd optimizations by itself.
     .          .          .          .               v0: u64,
     .          .          .          .               v2: u64,
     .          .          .          .               v1: u64,
     .          .          .          .               v3: u64,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           macro_rules! compress {
     5 ( 0.00%) .          .          .               ($state:expr) => {{ compress!($state.v0, $state.v1, $state.v2, $state.v3) }};
     .          .          .          .               ($v0:expr, $v1:expr, $v2:expr, $v3:expr) => {{
     .          .          .          .                   $v0 = $v0.wrapping_add($v1);
     .          .          .          .                   $v2 = $v2.wrapping_add($v3);
     .          .          .          .                   $v1 = $v1.rotate_left(13);
14,282 ( 0.00%) .          .          .                   $v1 ^= $v0;
     .          .          .          .                   $v3 = $v3.rotate_left(16);
14,282 ( 0.00%) .          .          .                   $v3 ^= $v2;
     .          .          .          .                   $v0 = $v0.rotate_left(32);
     .          .          .          .           
     .          .          .          .                   $v2 = $v2.wrapping_add($v1);
     .          .          .          .                   $v0 = $v0.wrapping_add($v3);
     .          .          .          .                   $v1 = $v1.rotate_left(17);
11,406 ( 0.00%) .          .          .                   $v1 ^= $v2;
     .          .          .          .                   $v3 = $v3.rotate_left(21);
11,371 ( 0.00%) .          .          .                   $v3 ^= $v0;
     5 ( 0.00%) .          .          .                   $v2 = $v2.rotate_left(32);
     .          .          .          .               }};
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Loads an integer of the desired type from a byte stream, in LE order. Uses
     .          .          .          .           /// `copy_nonoverlapping` to let the compiler generate the most efficient way
     .          .          .          .           /// to load it from a possibly unaligned address.
     .          .          .          .           ///
     .          .          .          .           /// Safety: this performs unchecked indexing of `$buf` at
-- line 98 ----------------------------------------
-- line 116 ----------------------------------------
     .          .          .          .           ///
     .          .          .          .           /// Safety: this performs unchecked indexing of `buf` at `start..start+len`, so
     .          .          .          .           /// that must be in-bounds.
     .          .          .          .           #[inline]
     .          .          .          .           unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {
     .          .          .          .               debug_assert!(len < 8);
     .          .          .          .               let mut i = 0; // current byte index (from LSB) in the output u64
     .          .          .          .               let mut out = 0;
11,394 ( 0.00%) .          .          .               if i + 3 < len {
     .          .          .          .                   // SAFETY: `i` cannot be greater than `len`, and the caller must guarantee
     .          .          .          .                   // that the index start..start+len is in bounds.
     .          .          .          .                   out = unsafe { load_int_le!(buf, start + i, u32) } as u64;
     .          .          .          .                   i += 4;
     .          .          .          .               }
23,653 ( 0.01%) .          .          .               if i + 1 < len {
     .          .          .          .                   // SAFETY: same as above.
 3,975 ( 0.00%) .          .          .                   out |= (unsafe { load_int_le!(buf, start + i, u16) } as u64) << (i * 8);
 1,325 ( 0.00%) .          .          .                   i += 2
     .          .          .          .               }
11,394 ( 0.00%) .          .          .               if i < len {
     .          .          .          .                   // SAFETY: same as above.
15,565 ( 0.00%) .          .          .                   out |= (unsafe { *buf.get_unchecked(start + i) } as u64) << (i * 8);
     .          .          .          .                   i += 1;
     .          .          .          .               }
     .          .          .          .               //FIXME(fee1-dead): use debug_assert_eq
     .          .          .          .               debug_assert!(i == len);
     .          .          .          .               out
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl SipHasher {
-- line 145 ----------------------------------------
-- line 194 ----------------------------------------
     .          .          .          .                   };
     .          .          .          .                   state.reset();
     .          .          .          .                   state
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               const fn reset(&mut self) {
     .          .          .          .                   self.length = 0;
 5,729 ( 0.00%) .          .          .                   self.state.v0 = self.k0 ^ 0x736f6d6570736575;
 5,729 ( 0.00%) .          .          .                   self.state.v1 = self.k1 ^ 0x646f72616e646f6d;
    36 ( 0.00%) .          .          .                   self.state.v2 = self.k0 ^ 0x6c7967656e657261;
     .          .          .          .                   self.state.v3 = self.k1 ^ 0x7465646279746573;
     .          .          .          .                   self.ntail = 0;
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .           impl super::Hasher for SipHasher {
     .          .          .          .               #[inline]
-- line 212 ----------------------------------------
-- line 224 ----------------------------------------
     .          .          .          .                   self.0.hasher.finish()
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[unstable(feature = "hashmap_internals", issue = "none")]
     .          .          .          .           impl super::Hasher for SipHasher13 {
     .          .          .          .               #[inline]
     .          .          .          .               fn write(&mut self, msg: &[u8]) {
 8,463 ( 0.00%) .          .          .                   self.hasher.write(msg)
145,357 ( 0.04%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/sip.rs:<core::hash::sip::Hasher<S> as core::hash::Hasher>::write (2,418x)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               fn write_str(&mut self, s: &str) {
     .          .          .          .                   self.hasher.write_str(s);
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
-- line 240 ----------------------------------------
-- line 247 ----------------------------------------
     .          .          .          .               // Note: no integer hashing methods (`write_u*`, `write_i*`) are defined
     .          .          .          .               // for this type. We could add them, copy the `short_write` implementation
     .          .          .          .               // in librustc_data_structures/sip128.rs, and add `write_u*`/`write_i*`
     .          .          .          .               // methods to `SipHasher`, `SipHasher13`, and `DefaultHasher`. This would
     .          .          .          .               // greatly speed up integer hashing by those hashers, at the cost of
     .          .          .          .               // slightly slowing down compile speeds on some benchmarks. See #69152 for
     .          .          .          .               // details.
     .          .          .          .               #[inline]
 5,692 ( 0.00%) .          .          .               fn write(&mut self, msg: &[u8]) {
     .          .          .          .                   let length = msg.len();
 5,692 ( 0.00%) .          .          .                   self.length += length;
     .          .          .          .           
     .          .          .          .                   let mut needed = 0;
     .          .          .          .           
17,076 ( 0.01%) .          .          .                   if self.ntail != 0 {
 1,637 ( 0.00%) .          .          .                       needed = 8 - self.ntail;
     .          .          .          .                       // SAFETY: `cmp::min(length, needed)` is guaranteed to not be over `length`
 6,548 ( 0.00%) .          .          .                       self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << (8 * self.ntail);
 3,274 ( 0.00%) .          .          .                       if length < needed {
 1,632 ( 0.00%) .          .          .                           self.ntail += length;
     .          .          .          .                           return;
     .          .          .          .                       } else {
     5 ( 0.00%) .          .          .                           self.state.v3 ^= self.tail;
     .          .          .          .                           S::c_rounds(&mut self.state);
    10 ( 0.00%) .          .          .                           self.state.v0 ^= self.tail;
     .          .          .          .                           self.ntail = 0;
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .           
     .          .          .          .                   // Buffered tail is now flushed, process new input.
 4,060 ( 0.00%) .          .          .                   let len = length - needed;
 8,120 ( 0.00%) .          .          .                   let left = len & 0x7; // len % 8
     .          .          .          .           
     .          .          .          .                   let mut i = needed;
13,556 ( 0.00%) .          .          .                   while i < len - left {
     .          .          .          .                       // SAFETY: because `len - left` is the biggest multiple of 8 under
     .          .          .          .                       // `len`, and because `i` starts at `needed` where `len` is `length - needed`,
     .          .          .          .                       // `i + 8` is guaranteed to be less than or equal to `length`.
     .          .          .          .                       let mi = unsafe { load_int_le!(msg, i, u64) };
     .          .          .          .           
 2,789 ( 0.00%) .          .          .                       self.state.v3 ^= mi;
     .          .          .          .                       S::c_rounds(&mut self.state);
 2,778 ( 0.00%) .          .          .                       self.state.v0 ^= mi;
     .          .          .          .           
 2,718 ( 0.00%) .          .          .                       i += 8;
     .          .          .          .                   }
     .          .          .          .           
     .          .          .          .                   // SAFETY: `i` is now `needed + len.div_euclid(8) * 8`,
     .          .          .          .                   // so `i + left` = `needed + len` = `length`, which is by
     .          .          .          .                   // definition equal to `msg.len()`.
 4,060 ( 0.00%) .          .          .                   self.tail = unsafe { u8to64_le(msg, i, left) };
     .          .          .          .                   self.ntail = left;
11,384 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               fn write_str(&mut self, s: &str) {
     .          .          .          .                   // This hasher works byte-wise, and `0xFF` cannot show up in a `str`,
     .          .          .          .                   // so just hashing the one extra byte is enough to be prefix-free.
 4,341 ( 0.00%) .          .          .                   self.write(s.as_bytes());
57,651 ( 0.02%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/sip.rs:<core::hash::sip::Hasher<S> as core::hash::Hasher>::write (1,637x)
     .          .          .          .                   self.write_u8(0xFF);
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               fn finish(&self) -> u64 {
 2,846 ( 0.00%) .          .          .                   let mut state = self.state;
     .          .          .          .           
 8,538 ( 0.00%) .          .          .                   let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;
     .          .          .          .           
 2,916 ( 0.00%) .          .          .                   state.v3 ^= b;
     .          .          .          .                   S::c_rounds(&mut state);
 2,881 ( 0.00%) .          .          .                   state.v0 ^= b;
     .          .          .          .           
 2,881 ( 0.00%) .          .          .                   state.v2 ^= 0xff;
     .          .          .          .                   S::d_rounds(&mut state);
     .          .          .          .           
 8,643 ( 0.00%) .          .          .                   state.v0 ^ state.v1 ^ state.v2 ^ state.v3
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<S: Sip> Clone for Hasher<S> {
     .          .          .          .               #[inline]
     .          .          .          .               fn clone(&self) -> Hasher<S> {
     .          .          .          .                   Hasher {
     .          .          .          .                       k0: self.k0,
-- line 330 ----------------------------------------

56,942 ( 0.02%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/sip.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/smallsort.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 539 ----------------------------------------
    .          .          .          .           ///
    .          .          .          .           /// # Safety
    .          .          .          .           /// begin < tail and p must be valid and initialized for all begin <= p <= tail.
    .          .          .          .           unsafe fn insert_tail<T, F: FnMut(&T, &T) -> bool>(begin: *mut T, tail: *mut T, is_less: &mut F) {
    .          .          .          .               // SAFETY: see individual comments.
    .          .          .          .               unsafe {
    .          .          .          .                   // SAFETY: in-bounds as tail > begin.
    .          .          .          .                   let mut sift = tail.sub(1);
6,600 ( 0.00%) .          .          .                   if !is_less(&*tail, &*sift) {
    .          .          .          .                       return;
    .          .          .          .                   }
    .          .          .          .           
    .          .          .          .                   // SAFETY: after this read tail is never read from again, as we only ever
    .          .          .          .                   // read from sift, sift < tail and we only ever decrease sift. Thus this is
    .          .          .          .                   // effectively a move, not a copy. Should a panic occur, or we have found
    .          .          .          .                   // the correct insertion position, gap_guard ensures the element is moved
    .          .          .          .                   // back into the array.
-- line 555 ----------------------------------------
-- line 558 ----------------------------------------
    .          .          .          .           
    .          .          .          .                   loop {
    .          .          .          .                       // SAFETY: we move sift into the gap (which is valid), and point the
    .          .          .          .                       // gap guard destination at sift, ensuring that if a panic occurs the
    .          .          .          .                       // gap is once again filled.
    .          .          .          .                       ptr::copy_nonoverlapping(sift, gap_guard.dst, 1);
    .          .          .          .                       gap_guard.dst = sift;
    .          .          .          .           
  600 ( 0.00%) .          .          .                       if sift == begin {
    .          .          .          .                           break;
    .          .          .          .                       }
    .          .          .          .           
    .          .          .          .                       // SAFETY: we checked that sift != begin, thus this is in-bounds.
    .          .          .          .                       sift = sift.sub(1);
1,036 ( 0.00%) .          .          .                       if !is_less(&tmp, &*sift) {
    .          .          .          .                           break;
    .          .          .          .                       }
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Sort `v` assuming `v[..offset]` is already sorted.
    .          .          .          .           pub fn insertion_sort_shift_left<T, F: FnMut(&T, &T) -> bool>(
    .          .          .          .               v: &mut [T],
    .          .          .          .               offset: usize,
    .          .          .          .               is_less: &mut F,
    .          .          .          .           ) {
    .          .          .          .               let len = v.len();
3,954 ( 0.00%) .          .          .               if offset == 0 || offset > len {
    .          .          .          .                   intrinsics::abort();
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               // SAFETY: see individual comments.
    .          .          .          .               unsafe {
    .          .          .          .                   // We write this basic loop directly using pointers, as when we use a
    .          .          .          .                   // for loop LLVM likes to unroll this loop which we do not want.
    .          .          .          .                   // SAFETY: v_end is the one-past-end pointer, and we checked that
    .          .          .          .                   // offset <= len, thus tail is also in-bounds.
    .          .          .          .                   let v_base = v.as_mut_ptr();
    .          .          .          .                   let v_end = v_base.add(len);
    .          .          .          .                   let mut tail = v_base.add(offset);
7,424 ( 0.00%) .          .          .                   while tail != v_end {
    .          .          .          .                       // SAFETY: v_base and tail are both valid pointers to elements, and
    .          .          .          .                       // v_base < tail since we checked offset != 0.
    .          .          .          .                       insert_tail(v_base, tail, is_less);
    .          .          .          .           
    .          .          .          .                       // SAFETY: we checked that tail is not yet the one-past-end pointer.
    .          .          .          .                       tail = tail.add(1);
    .          .          .          .                   }
    .          .          .          .               }
1,318 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           /// SAFETY: The caller MUST guarantee that `v_base` is valid for 4 reads and
    .          .          .          .           /// `dst` is valid for 4 writes. The result will be stored in `dst[0..4]`.
    .          .          .          .           pub unsafe fn sort4_stable<T, F: FnMut(&T, &T) -> bool>(
    .          .          .          .               v_base: *const T,
    .          .          .          .               dst: *mut T,
    .          .          .          .               is_less: &mut F,
    .          .          .          .           ) {
-- line 616 ----------------------------------------

  609 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/smallsort.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 388 ----------------------------------------
      .          .          .          .                             without modifying the original"]
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn to_digit(self, radix: u32) -> Option<u32> {
      .          .          .          .                   assert!(
      .          .          .          .                       radix >= 2 && radix <= 36,
      .          .          .          .                       "to_digit: invalid radix -- radix must be in the range 2 to 36 inclusive"
      .          .          .          .                   );
      .          .          .          .                   // check radix to remove letter handling code when radix is a known constant
    250 ( 0.00%) .          .          .                   let value = if self > '9' && radix > 10 {
      .          .          .          .                       // mask to convert ASCII letters to uppercase
      .          .          .          .                       const TO_UPPERCASE_MASK: u32 = !0b0010_0000;
      .          .          .          .                       // Converts an ASCII letter to its corresponding integer value:
      .          .          .          .                       // A-Z => 10-35, a-z => 10-35. Other characters produce values >= 36.
      .          .          .          .                       //
      .          .          .          .                       // Add Overflow Safety:
      .          .          .          .                       // By applying the mask after the subtraction, the first addendum is
      .          .          .          .                       // constrained such that it never exceeds u32::MAX - 0x20.
      .          .          .          .                       ((self as u32).wrapping_sub('A' as u32) & TO_UPPERCASE_MASK) + 10
      .          .          .          .                   } else {
      .          .          .          .                       // convert digit to value, non-digits wrap to values > 36
      .          .          .          .                       (self as u32).wrapping_sub('0' as u32)
      .          .          .          .                   };
      .          .          .          .                   // FIXME(const-hack): once then_some is const fn, use it here
    259 ( 0.00%) .          .          .                   if value < radix { Some(value) } else { None }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns an iterator that yields the hexadecimal Unicode escape of a
      .          .          .          .               /// character as `char`s.
      .          .          .          .               ///
      .          .          .          .               /// This will escape characters with the Rust syntax of the form
      .          .          .          .               /// `\u{NNNNNN}` where `NNNNNN` is a hexadecimal representation.
      .          .          .          .               ///
-- line 419 ----------------------------------------
-- line 760 ----------------------------------------
      .          .          .          .               /// // love is many things, but it is not alphabetic
      .          .          .          .               /// assert!(!c.is_alphabetic());
      .          .          .          .               /// ```
      .          .          .          .               #[must_use]
      .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_alphabetic(self) -> bool {
      .          .          .          .                   match self {
 14,175 ( 0.00%) .          .          .                       'a'..='z' | 'A'..='Z' => true,
      .          .          .          .                       c => c > '\x7f' && unicode::Alphabetic(c),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns `true` if this `char` has the `Lowercase` property.
      .          .          .          .               ///
      .          .          .          .               /// `Lowercase` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and
      .          .          .          .               /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].
-- line 776 ----------------------------------------
-- line 874 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// assert!(!''.is_whitespace());
      .          .          .          .               /// ```
      .          .          .          .               #[must_use]
      .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .               #[rustc_const_unstable(feature = "const_char_classify", issue = "132241")]
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn is_whitespace(self) -> bool {
  2,806 ( 0.00%) .          .          .                   match self {
     51 ( 0.00%) .          .          .                       ' ' | '\x09'..='\x0d' => true,
  1,150 ( 0.00%) .          .          .                       c => c > '\x7f' && unicode::White_Space(c),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns `true` if this `char` satisfies either [`is_alphabetic()`] or [`is_numeric()`].
      .          .          .          .               ///
      .          .          .          .               /// [`is_alphabetic()`]: #method.is_alphabetic
      .          .          .          .               /// [`is_numeric()`]: #method.is_numeric
      .          .          .          .               ///
-- line 892 ----------------------------------------
-- line 1165 ----------------------------------------
      .          .          .          .               /// assert!(ascii.is_ascii());
      .          .          .          .               /// assert!(!non_ascii.is_ascii());
      .          .          .          .               /// ```
      .          .          .          .               #[must_use]
      .          .          .          .               #[stable(feature = "ascii_methods_on_intrinsics", since = "1.23.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_char_is_ascii", since = "1.32.0")]
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn is_ascii(&self) -> bool {
      1 ( 0.00%) .          .          .                   *self as u32 <= 0x7F
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns `Some` if the value is within the ASCII range,
      .          .          .          .               /// or `None` if it's not.
      .          .          .          .               ///
      .          .          .          .               /// This is preferred to [`Self::is_ascii`] when you're passing the value
      .          .          .          .               /// along to something else that can take [`ascii::Char`] rather than
      .          .          .          .               /// needing to check again for itself whether the value is in ASCII.
-- line 1181 ----------------------------------------
-- line 1759 ----------------------------------------
      .          .          .          .                   escape_double_quote: true,
      .          .          .          .               };
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[inline]
      .          .          .          .           #[must_use]
      .          .          .          .           const fn len_utf8(code: u32) -> usize {
      .          .          .          .               match code {
452,916 ( 0.14%) .          .          .                   ..MAX_ONE_B => 1,
  6,047 ( 0.00%) .          .          .                   ..MAX_TWO_B => 2,
  5,235 ( 0.00%) .          .          .                   ..MAX_THREE_B => 3,
      .          .          .          .                   _ => 4,
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[inline]
      .          .          .          .           #[must_use]
      .          .          .          .           const fn len_utf16(code: u32) -> usize {
      .          .          .          .               if (code & 0xFFFF) == code { 1 } else { 2 }
-- line 1777 ----------------------------------------
-- line 1792 ----------------------------------------
      .          .          .          .           /// A buffer of length four is large enough to encode any `char`.
      .          .          .          .           #[unstable(feature = "char_internals", reason = "exposed only for libstd", issue = "none")]
      .          .          .          .           #[doc(hidden)]
      .          .          .          .           #[inline]
      .          .          .          .           pub const fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> &mut [u8] {
      .          .          .          .               let len = len_utf8(code);
      .          .          .          .               match (len, &mut *dst) {
      .          .          .          .                   (1, [a, ..]) => {
100,849 ( 0.03%) .          .          .                       *a = code as u8;
      .          .          .          .                   }
      .          .          .          .                   (2, [a, b, ..]) => {
  6,186 ( 0.00%) .          .          .                       *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;
    579 ( 0.00%) .          .          .                       *b = (code & 0x3F) as u8 | TAG_CONT;
      .          .          .          .                   }
      .          .          .          .                   (3, [a, b, c, ..]) => {
  3,614 ( 0.00%) .          .          .                       *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;
  5,422 ( 0.00%) .          .          .                       *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;
  4,520 ( 0.00%) .          .          .                       *c = (code & 0x3F) as u8 | TAG_CONT;
  1,613 ( 0.00%) .          .          .                   }
      .          .          .          .                   (4, [a, b, c, d, ..]) => {
  2,836 ( 0.00%) .          .          .                       *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;
  4,254 ( 0.00%) .          .          .                       *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;
  5,672 ( 0.00%) .          .          .                       *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;
  2,836 ( 0.00%) .          .          .                       *d = (code & 0x3F) as u8 | TAG_CONT;
      .          .          .          .                   }
      .          .          .          .                   _ => {
      .          .          .          .                       const_panic!(
      .          .          .          .                           "encode_utf8: buffer does not have enough bytes to encode code point",
      .          .          .          .                           "encode_utf8: need {len} bytes to encode U+{code:04X} but buffer has just {dst_len}",
      .          .          .          .                           code: u32 = code,
      .          .          .          .                           len: usize = len,
      .          .          .          .                           dst_len: usize = dst.len(),
-- line 1823 ----------------------------------------

 66,570 ( 0.02%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/manually_drop.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 173 ----------------------------------------
     .          .          .          .               /// # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.
     .          .          .          .               /// # let _ = ManuallyDrop::into_inner(x);
     .          .          .          .               /// ```
     .          .          .          .               #[must_use = "if you don't need the wrapper, you can use `mem::forget` instead"]
     .          .          .          .               #[stable(feature = "manually_drop", since = "1.20.0")]
     .          .          .          .               #[rustc_const_stable(feature = "const_manually_drop", since = "1.32.0")]
     .          .          .          .               #[inline(always)]
     .          .          .          .               pub const fn new(value: T) -> ManuallyDrop<T> {
66,102 ( 0.02%) .          .          .                   ManuallyDrop { value }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Extracts the value from the `ManuallyDrop` container.
     .          .          .          .               ///
     .          .          .          .               /// This allows the value to be dropped again.
     .          .          .          .               ///
     .          .          .          .               /// # Examples
     .          .          .          .               ///
-- line 189 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 538 ----------------------------------------
        .          .          .          .               /// let mut r = 3..=5;
        .          .          .          .               /// for _ in r.by_ref() {}
        .          .          .          .               /// // Precise field values are unspecified here
        .          .          .          .               /// assert!(r.is_empty());
        .          .          .          .               /// ```
        .          .          .          .               #[stable(feature = "range_is_empty", since = "1.47.0")]
        .          .          .          .               #[inline]
        .          .          .          .               pub fn is_empty(&self) -> bool {
1,651,055 ( 0.50%) .          .          .                   self.exhausted || !(self.start <= self.end)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           /// A range only bounded inclusively above (`..=end`).
        .          .          .          .           ///
        .          .          .          .           /// The `RangeToInclusive` `..=end` contains all values with `x <= end`.
        .          .          .          .           /// It cannot serve as an [`Iterator`] because it doesn't have a starting point.
        .          .          .          .           ///
-- line 554 ----------------------------------------
-- line 814 ----------------------------------------
        .          .          .          .               /// assert!(!(f32::NAN..1.0).contains(&0.5));
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "range_contains", since = "1.35.0")]
        .          .          .          .               fn contains<U>(&self, item: &U) -> bool
        .          .          .          .               where
        .          .          .          .                   T: PartialOrd<U>,
        .          .          .          .                   U: ?Sized + PartialOrd<T>,
        .          .          .          .               {
      101 ( 0.00%) .          .          .                   (match self.start_bound() {
        .          .          .          .                       Included(start) => start <= item,
        .          .          .          .                       Excluded(start) => start < item,
        .          .          .          .                       Unbounded => true,
        .          .          .          .                   }) && (match self.end_bound() {
        .          .          .          .                       Included(end) => item <= end,
        .          .          .          .                       Excluded(end) => item < end,
        .          .          .          .                       Unbounded => true,
        .          .          .          .                   })
-- line 830 ----------------------------------------
-- line 897 ----------------------------------------
        .          .          .          .               fn end_bound(&self) -> Bound<&T> {
        .          .          .          .                   Included(&self.end)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[stable(feature = "collections_range", since = "1.28.0")]
        .          .          .          .           impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {
        .          .          .          .               fn start_bound(&self) -> Bound<&T> {
       25 ( 0.00%) .          .          .                   match *self {
        .          .          .          .                       (Included(ref start), _) => Included(start),
        .          .          .          .                       (Excluded(ref start), _) => Excluded(start),
        .          .          .          .                       (Unbounded, _) => Unbounded,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn end_bound(&self) -> Bound<&T> {
       20 ( 0.00%) .          .          .                   match *self {
        .          .          .          .                       (_, Included(ref end)) => Included(end),
        .          .          .          .                       (_, Excluded(ref end)) => Excluded(end),
        .          .          .          .                       (_, Unbounded) => Unbounded,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[stable(feature = "collections_range", since = "1.28.0")]
-- line 921 ----------------------------------------

1,054,006 ( 0.32%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 403 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn patterns(&self) -> PatternIter<'_> {
      .          .          .          .                   PatternIter {
      .          .          .          .                       it: PatternID::iter(self.pattern_len()),
      .          .          .          .                       _marker: core::marker::PhantomData,
      .          .          .          .                   }
    162 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the total number of regex patterns in this NFA.
      .          .          .          .               ///
      .          .          .          .               /// This may return zero if the NFA was constructed with no patterns. In
      .          .          .          .               /// this case, the NFA can never produce a match for any input.
      .          .          .          .               ///
      .          .          .          .               /// This is guaranteed to be no bigger than [`PatternID::LIMIT`] because
      .          .          .          .               /// NFA construction will fail if too many patterns are added.
-- line 419 ----------------------------------------
-- line 466 ----------------------------------------
      .          .          .          .               ///     }
      .          .          .          .               ///     _ => unreachable!("unexpected state"),
      .          .          .          .               /// }
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn start_anchored(&self) -> StateID {
      8 ( 0.00%) .          .          .                   self.0.start_anchored
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the state identifier of the initial unanchored state of this
      .          .          .          .               /// NFA.
      .          .          .          .               ///
      .          .          .          .               /// This is equivalent to the identifier returned by
      .          .          .          .               /// [`NFA::start_anchored`] when the NFA has no unanchored starting state.
      .          .          .          .               ///
-- line 482 ----------------------------------------
-- line 901 ----------------------------------------
      .          .          .          .               /// how the state machine is constructed, and thus needs to be altered
      .          .          .          .               /// based on the direction of the search.
      .          .          .          .               ///
      .          .          .          .               /// This is automatically set when using a [`Compiler`] with a configuration
      .          .          .          .               /// where [`Config::reverse`] is enabled. If you're building your own NFA
      .          .          .          .               /// by hand via a [`Builder`]
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_reverse(&self) -> bool {
    259 ( 0.00%) .          .          .                   self.0.reverse
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if all starting states for this NFA correspond
      .          .          .          .               /// to the beginning of an anchored search.
      .          .          .          .               ///
      .          .          .          .               /// Typically, an NFA will have both an anchored and an unanchored starting
      .          .          .          .               /// state. Namely, because it tends to be useful to have both and the cost
      .          .          .          .               /// of having an unanchored starting state is almost zero (for an NFA).
-- line 917 ----------------------------------------
-- line 1052 ----------------------------------------
      .          .          .          .               /// assert!(nfa.look_set_any().contains_word());
      .          .          .          .               /// assert!(!nfa.look_set_any().contains_word_unicode());
      .          .          .          .               /// assert!(nfa.look_set_any().contains_word_ascii());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn look_set_any(&self) -> LookSet {
    677 ( 0.00%) .          .          .                   self.0.look_set_any
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the union of all prefix look-around assertions for every
      .          .          .          .               /// pattern in this NFA. When the returned set is empty, it implies none of
      .          .          .          .               /// the patterns require moving through a conditional epsilon transition
      .          .          .          .               /// before inspecting the first byte in the haystack.
      .          .          .          .               ///
      .          .          .          .               /// This can be useful for determining what kinds of assertions need to be
-- line 1068 ----------------------------------------
-- line 1092 ----------------------------------------
      .          .          .          .               /// let nfa = NFA::new_many(&["a", "b", "^ab$", "c"])?;
      .          .          .          .               /// assert!(nfa.look_set_prefix_any().contains(Look::Start));
      .          .          .          .               /// assert!(!nfa.look_set_prefix_any().contains(Look::End));
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn look_set_prefix_any(&self) -> LookSet {
      2 ( 0.00%) .          .          .                   self.0.look_set_prefix_any
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               // FIXME: The `look_set_prefix_all` computation was not correct, and it
      .          .          .          .               // seemed a little tricky to fix it. Since I wasn't actually using it for
      .          .          .          .               // anything, I just decided to remove it in the run up to the regex 1.9
      .          .          .          .               // release. If you need this, please file an issue.
      .          .          .          .               /*
      .          .          .          .               /// Returns the intersection of all prefix look-around assertions for every
-- line 1108 ----------------------------------------
-- line 1186 ----------------------------------------
      .          .          .          .           /// The "inner" part of the NFA. We split this part out so that we can easily
      .          .          .          .           /// wrap it in an `Arc` above in the definition of `NFA`.
      .          .          .          .           ///
      .          .          .          .           /// See builder.rs for the code that actually builds this type. This module
      .          .          .          .           /// does provide (internal) mutable methods for adding things to this
      .          .          .          .           /// NFA before finalizing it, but the high level construction process is
      .          .          .          .           /// controlled by the builder abstraction. (Which is complicated enough to
      .          .          .          .           /// get its own module.)
  2,100 ( 0.00%) .          .          .           #[derive(Default)]
      .          .          .          .           pub(super) struct Inner {
      .          .          .          .               /// The state sequence. This sequence is guaranteed to be indexable by all
      .          .          .          .               /// starting state IDs, and it is also guaranteed to contain at most one
      .          .          .          .               /// `Match` state for each pattern compiled into this NFA. (A pattern may
      .          .          .          .               /// not have a corresponding `Match` state if a `Match` state is impossible
      .          .          .          .               /// to reach.)
      .          .          .          .               states: Vec<State>,
      .          .          .          .               /// The anchored starting state of this NFA.
-- line 1202 ----------------------------------------
-- line 1264 ----------------------------------------
      .          .          .          .               /// various capturing group representations above). Since each state
      .          .          .          .               /// might use a different amount of heap, we need to keep track of this
      .          .          .          .               /// incrementally.
      .          .          .          .               memory_extra: usize,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Inner {
      .          .          .          .               /// Runs any last finalization bits and turns this into a full NFA.
  1,400 ( 0.00%) .          .          .               pub(super) fn into_nfa(mut self) -> NFA {
    875 ( 0.00%) .          .          .                   self.byte_classes = self.byte_class_set.byte_classes();
  5,250 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x)
      .          .          .          .                   // Do epsilon closure from the start state of every pattern in order
      .          .          .          .                   // to compute various properties such as look-around assertions and
      .          .          .          .                   // whether the empty string can be matched.
      .          .          .          .                   let mut stack = vec![];
      .          .          .          .                   let mut seen = SparseSet::new(self.states.len());
    175 ( 0.00%) .          .          .                   for &start_id in self.start_pattern.iter() {
      .          .          .          .                       stack.push(start_id);
      .          .          .          .                       seen.clear();
      .          .          .          .                       // let mut prefix_all = LookSet::full();
      .          .          .          .                       let mut prefix_any = LookSet::empty();
      .          .          .          .                       while let Some(sid) = stack.pop() {
      .          .          .          .                           if !seen.insert(sid) {
      .          .          .          .                               continue;
      .          .          .          .                           }
  8,452 ( 0.00%) .          .          .                           match self.states[sid] {
      .          .          .          .                               State::ByteRange { .. }
      .          .          .          .                               | State::Dense { .. }
      .          .          .          .                               | State::Fail => continue,
      .          .          .          .                               State::Sparse(_) => {
      .          .          .          .                                   // This snippet below will rewrite this sparse state
      .          .          .          .                                   // as a dense state. By doing it here, we apply this
      .          .          .          .                                   // optimization to all hot "sparse" states since these
      .          .          .          .                                   // are the states that are reachable from the start
-- line 1296 ----------------------------------------
-- line 1309 ----------------------------------------
      .          .          .          .                                   // is a large re-design and will require API breaking
      .          .          .          .                                   // changes.
      .          .          .          .                                   // self.memory_extra -= self.states[sid].memory_usage();
      .          .          .          .                                   // let trans = DenseTransitions::from_sparse(sparse);
      .          .          .          .                                   // self.states[sid] = State::Dense(trans);
      .          .          .          .                                   // self.memory_extra += self.states[sid].memory_usage();
      .          .          .          .                                   continue;
      .          .          .          .                               }
      4 ( 0.00%) .          .          .                               State::Match { .. } => self.has_empty = true,
    123 ( 0.00%) .          .          .                               State::Look { look, next } => {
      .          .          .          .                                   prefix_any = prefix_any.insert(look);
      .          .          .          .                                   stack.push(next);
      .          .          .          .                               }
      .          .          .          .                               State::Union { ref alternates } => {
      .          .          .          .                                   // Order doesn't matter here, since we're just dealing
      .          .          .          .                                   // with look-around sets. But if we do richer analysis
      .          .          .          .                                   // here that needs to care about preference order, then
      .          .          .          .                                   // this should be done in reverse.
    192 ( 0.00%) .          .          .                                   stack.extend(alternates.iter());
     96 ( 0.00%) .          .          .                               }
    237 ( 0.00%) .          .          .                               State::BinaryUnion { alt1, alt2 } => {
      .          .          .          .                                   stack.push(alt2);
      .          .          .          .                                   stack.push(alt1);
    335 ( 0.00%) .          .          .                               }
    133 ( 0.00%) .          .          .                               State::Capture { next, .. } => {
      .          .          .          .                                   stack.push(next);
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                       }
    175 ( 0.00%) .          .          .                       self.look_set_prefix_any =
      .          .          .          .                           self.look_set_prefix_any.union(prefix_any);
      .          .          .          .                   }
      .          .          .          .                   self.states.shrink_to_fit();
      .          .          .          .                   self.start_pattern.shrink_to_fit();
      .          .          .          .                   NFA(Arc::new(self))
  1,575 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the capturing group info for this NFA.
      .          .          .          .               pub(super) fn group_info(&self) -> &GroupInfo {
     86 ( 0.00%) .          .          .                   &self.group_info
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add the given state to this NFA after allocating a fresh identifier for
      .          .          .          .               /// it.
      .          .          .          .               ///
      .          .          .          .               /// This panics if too many states are added such that a fresh identifier
      .          .          .          .               /// could not be created. (Currently, the only caller of this routine is
      .          .          .          .               /// a `Builder`, and it upholds this invariant.)
515,312 ( 0.15%) .          .          .               pub(super) fn add(&mut self, state: State) -> StateID {
322,070 ( 0.10%) .          .          .                   match state {
      .          .          .          .                       State::ByteRange { ref trans } => {
136,332 ( 0.04%) .          .          .                           self.byte_class_set.set_range(trans.start, trans.end);
      .          .          .          .                       }
      .          .          .          .                       State::Sparse(ref sparse) => {
 10,394 ( 0.00%) .          .          .                           for trans in sparse.transitions.iter() {
 77,028 ( 0.02%) .          .          .                               self.byte_class_set.set_range(trans.start, trans.end);
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       State::Dense { .. } => unreachable!(),
    245 ( 0.00%) .          .          .                       State::Look { look, .. } => {
    735 ( 0.00%) .          .          .                           self.look_matcher
  3,920 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/look.rs:regex_automata::util::look::LookMatcher::add_to_byteset (245x)
    245 ( 0.00%) .          .          .                               .add_to_byteset(look, &mut self.byte_class_set);
    245 ( 0.00%) .          .          .                           self.look_set_any = self.look_set_any.insert(look);
      .          .          .          .                       }
      .          .          .          .                       State::Capture { .. } => {
  1,548 ( 0.00%) .          .          .                           self.has_capture = true;
      .          .          .          .                       }
      .          .          .          .                       State::Union { .. }
      .          .          .          .                       | State::BinaryUnion { .. }
      .          .          .          .                       | State::Fail
      .          .          .          .                       | State::Match { .. } => {}
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   let id = StateID::new(self.states.len()).unwrap();
 64,414 ( 0.02%) .          .          .                   self.memory_extra += state.memory_usage();
  1,275 ( 0.00%) .          .          .                   self.states.push(state);
      .          .          .          .                   id
515,312 ( 0.15%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the starting state identifiers for this NFA.
      .          .          .          .               ///
      .          .          .          .               /// `start_anchored` and `start_unanchored` may be equivalent. When they
      .          .          .          .               /// are, then the NFA can only execute anchored searches. This might
      .          .          .          .               /// occur, for example, for patterns that are unconditionally anchored.
      .          .          .          .               /// e.g., `^foo`.
      .          .          .          .               pub(super) fn set_starts(
      .          .          .          .                   &mut self,
      .          .          .          .                   start_anchored: StateID,
      .          .          .          .                   start_unanchored: StateID,
      .          .          .          .                   start_pattern: &[StateID],
      .          .          .          .               ) {
    175 ( 0.00%) .          .          .                   self.start_anchored = start_anchored;
    175 ( 0.00%) .          .          .                   self.start_unanchored = start_unanchored;
    525 ( 0.00%) .          .          .                   self.start_pattern = start_pattern.to_vec();
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets the UTF-8 mode of this NFA.
      .          .          .          .               pub(super) fn set_utf8(&mut self, yes: bool) {
    175 ( 0.00%) .          .          .                   self.utf8 = yes;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets the reverse mode of this NFA.
      .          .          .          .               pub(super) fn set_reverse(&mut self, yes: bool) {
    175 ( 0.00%) .          .          .                   self.reverse = yes;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets the look-around assertion matcher for this NFA.
      .          .          .          .               pub(super) fn set_look_matcher(&mut self, m: LookMatcher) {
    175 ( 0.00%) .          .          .                   self.look_matcher = m;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the capturing groups for this NFA.
      .          .          .          .               ///
      .          .          .          .               /// The given slice should contain the capturing groups for each pattern,
      .          .          .          .               /// The capturing groups in turn should correspond to the total number of
      .          .          .          .               /// capturing groups in the pattern, including the anonymous first capture
      .          .          .          .               /// group for each pattern. If a capturing group does have a name, then it
-- line 1425 ----------------------------------------
-- line 1426 ----------------------------------------
      .          .          .          .               /// should be provided as a Arc<str>.
      .          .          .          .               ///
      .          .          .          .               /// This returns an error if a corresponding `GroupInfo` could not be
      .          .          .          .               /// built.
      .          .          .          .               pub(super) fn set_captures(
      .          .          .          .                   &mut self,
      .          .          .          .                   captures: &[Vec<Option<Arc<str>>>],
      .          .          .          .               ) -> Result<(), GroupInfoError> {
    350 ( 0.00%) .          .          .                   self.group_info = GroupInfo::new(
917,383 ( 0.28%) 3,114 ( 0.38%) 2 ( 0.66%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/captures.rs:regex_automata::util::captures::GroupInfo::new (175x)
      .          .          .          .                       captures.iter().map(|x| x.iter().map(|y| y.as_ref())),
      .          .          .          .                   )?;
      .          .          .          .                   Ok(())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Remap the transitions in every state of this NFA using the given map.
      .          .          .          .               /// The given map should be indexed according to state ID namespace used by
      .          .          .          .               /// the transitions of the states currently in this NFA.
      .          .          .          .               ///
      .          .          .          .               /// This is particularly useful to the NFA builder, since it is convenient
      .          .          .          .               /// to add NFA states in order to produce their final IDs. Then, after all
      .          .          .          .               /// of the intermediate "empty" states (unconditional epsilon transitions)
      .          .          .          .               /// have been removed from the builder's representation, we can re-map all
      .          .          .          .               /// of the transitions in the states already added to their final IDs.
    175 ( 0.00%) .          .          .               pub(super) fn remap(&mut self, old_to_new: &[StateID]) {
      .          .          .          .                   for state in &mut self.states {
      .          .          .          .                       state.remap(old_to_new);
      .          .          .          .                   }
    525 ( 0.00%) .          .          .                   self.start_anchored = old_to_new[self.start_anchored];
    525 ( 0.00%) .          .          .                   self.start_unanchored = old_to_new[self.start_unanchored];
      .          .          .          .                   for id in self.start_pattern.iter_mut() {
    525 ( 0.00%) .          .          .                       *id = old_to_new[*id];
      .          .          .          .                   }
    350 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl fmt::Debug for Inner {
      .          .          .          .               fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      .          .          .          .                   writeln!(f, "thompson::NFA(")?;
      .          .          .          .                   for (sid, state) in self.states.iter().with_state_ids() {
      .          .          .          .                       let status = if sid == self.start_anchored {
      .          .          .          .                           '^'
-- line 1466 ----------------------------------------
-- line 1650 ----------------------------------------
      .          .          .          .               ///     trans: Transition { start: b'a', end: b'z', next: StateID::ZERO },
      .          .          .          .               /// };
      .          .          .          .               /// assert!(!state.is_epsilon());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn is_epsilon(&self) -> bool {
    940 ( 0.00%) .          .          .                   match *self {
      .          .          .          .                       State::ByteRange { .. }
      .          .          .          .                       | State::Sparse { .. }
      .          .          .          .                       | State::Dense { .. }
      .          .          .          .                       | State::Fail
      .          .          .          .                       | State::Match { .. } => false,
      .          .          .          .                       State::Look { .. }
      .          .          .          .                       | State::Union { .. }
      .          .          .          .                       | State::BinaryUnion { .. }
      .          .          .          .                       | State::Capture { .. } => true,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the heap memory usage of this NFA state in bytes.
      .          .          .          .               fn memory_usage(&self) -> usize {
 85,885 ( 0.03%) .          .          .                   match *self {
      .          .          .          .                       State::ByteRange { .. }
      .          .          .          .                       | State::Look { .. }
      .          .          .          .                       | State::BinaryUnion { .. }
      .          .          .          .                       | State::Capture { .. }
      .          .          .          .                       | State::Match { .. }
      .          .          .          .                       | State::Fail => 0,
      .          .          .          .                       State::Sparse(SparseTransitions { ref transitions }) => {
 20,788 ( 0.01%) .          .          .                           transitions.len() * mem::size_of::<Transition>()
 10,394 ( 0.00%) .          .          .                       }
      .          .          .          .                       State::Dense { .. } => 256 * mem::size_of::<StateID>(),
      .          .          .          .                       State::Union { ref alternates } => {
  4,380 ( 0.00%) .          .          .                           alternates.len() * mem::size_of::<StateID>()
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Remap the transitions in this state using the given map. Namely, the
      .          .          .          .               /// given map should be indexed according to the transitions currently
      .          .          .          .               /// in this state.
      .          .          .          .               ///
      .          .          .          .               /// This is used during the final phase of the NFA compiler, which turns
      .          .          .          .               /// its intermediate NFA into the final NFA.
      .          .          .          .               fn remap(&mut self, remap: &[StateID]) {
257,656 ( 0.08%) .          .          .                   match *self {
      .          .          .          .                       State::ByteRange { ref mut trans } => {
 45,444 ( 0.01%) .          .          .                           trans.next = remap[trans.next]
      .          .          .          .                       }
      .          .          .          .                       State::Sparse(SparseTransitions { ref mut transitions }) => {
 10,394 ( 0.00%) .          .          .                           for t in transitions.iter_mut() {
115,542 ( 0.03%) .          .          .                               t.next = remap[t.next];
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       State::Dense(DenseTransitions { ref mut transitions }) => {
      .          .          .          .                           for sid in transitions.iter_mut() {
      .          .          .          .                               *sid = remap[*sid];
      .          .          .          .                           }
      .          .          .          .                       }
    245 ( 0.00%) .          .          .                       State::Look { ref mut next, .. } => *next = remap[*next],
      .          .          .          .                       State::Union { ref mut alternates } => {
  1,460 ( 0.00%) .          .          .                           for alt in alternates.iter_mut() {
 31,392 ( 0.01%) .          .          .                               *alt = remap[*alt];
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       State::BinaryUnion { ref mut alt1, ref mut alt2 } => {
 15,444 ( 0.00%) .          .          .                           *alt1 = remap[*alt1];
 20,592 ( 0.01%) .          .          .                           *alt2 = remap[*alt2];
      .          .          .          .                       }
  1,548 ( 0.00%) .          .          .                       State::Capture { ref mut next, .. } => *next = remap[*next],
      .          .          .          .                       State::Fail => {}
      .          .          .          .                       State::Match { .. } => {}
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl fmt::Debug for State {
      .          .          .          .               fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-- line 1729 ----------------------------------------
-- line 1802 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// The matching transition is found by looking for a matching byte
      .          .          .          .               /// range (there is at most one) corresponding to the position `at` in
      .          .          .          .               /// `haystack`.
      .          .          .          .               ///
      .          .          .          .               /// If `at >= haystack.len()`, then this returns `None`.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn matches(&self, haystack: &[u8], at: usize) -> Option<StateID> {
    150 ( 0.00%) .          .          .                   haystack.get(at).and_then(|&b| self.matches_byte(b))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// This follows the matching transition for any member of the alphabet.
      .          .          .          .               ///
      .          .          .          .               /// The matching transition is found by looking for a matching byte
      .          .          .          .               /// range (there is at most one) corresponding to the position `at` in
      .          .          .          .               /// `haystack`. If the given alphabet unit is [`EOI`](alphabet::Unit::eoi),
      .          .          .          .               /// then this always returns `None`.
      .          .          .          .               #[inline]
      .          .          .          .               pub(crate) fn matches_unit(
      .          .          .          .                   &self,
      .          .          .          .                   unit: alphabet::Unit,
      .          .          .          .               ) -> Option<StateID> {
    292 ( 0.00%) .          .          .                   unit.as_u8().and_then(|byte| self.matches_byte(byte))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// This follows the matching transition for a particular byte.
      .          .          .          .               ///
      .          .          .          .               /// The matching transition is found by looking for a matching byte range
      .          .          .          .               /// (there is at most one) corresponding to the byte given.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn matches_byte(&self, byte: u8) -> Option<StateID> {
    488 ( 0.00%) .          .          .                   for t in self.transitions.iter() {
  1,064 ( 0.00%) .          .          .                       if t.start > byte {
      .          .          .          .                           break;
  1,391 ( 0.00%) .          .          .                       } else if t.matches_byte(byte) {
     40 ( 0.00%) .          .          .                           return Some(t.next);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   None
      .          .          .          .           
      .          .          .          .                   /*
      .          .          .          .                   // This is an alternative implementation that uses binary search. In
      .          .          .          .                   // some ad hoc experiments, like
      .          .          .          .                   //
-- line 1845 ----------------------------------------
-- line 1959 ----------------------------------------
      .          .          .          .           
      .          .          .          .           /// A single transition to another state.
      .          .          .          .           ///
      .          .          .          .           /// This transition may only be followed if the current byte in the haystack
      .          .          .          .           /// falls in the inclusive range of bytes specified.
      .          .          .          .           #[derive(Clone, Copy, Eq, Hash, PartialEq)]
      .          .          .          .           pub struct Transition {
      .          .          .          .               /// The inclusive start of the byte range.
  2,841 ( 0.00%) .          .          .               pub start: u8,
      .          .          .          .               /// The inclusive end of the byte range.
  2,838 ( 0.00%) .          .          .               pub end: u8,
      .          .          .          .               /// The identifier of the state to transition to.
      .          .          .          .               pub next: StateID,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Transition {
      .          .          .          .               /// Returns true if the position `at` in `haystack` falls in this
      .          .          .          .               /// transition's range of bytes.
      .          .          .          .               ///
-- line 1977 ----------------------------------------
-- line 1985 ----------------------------------------
      .          .          .          .               /// this returns `false`.
      .          .          .          .               pub fn matches_unit(&self, unit: alphabet::Unit) -> bool {
      .          .          .          .                   unit.as_u8().map_or(false, |byte| self.matches_byte(byte))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if the given byte falls in this transition's range of
      .          .          .          .               /// bytes.
      .          .          .          .               pub fn matches_byte(&self, byte: u8) -> bool {
  1,750 ( 0.00%) .          .          .                   self.start <= byte && byte <= self.end
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl fmt::Debug for Transition {
      .          .          .          .               fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      .          .          .          .                   use crate::util::escape::DebugByte;
      .          .          .          .           
      .          .          .          .                   let Transition { start, end, next } = *self;
-- line 2001 ----------------------------------------

174,695 ( 0.05%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 197 ----------------------------------------
     .          .          .          .                   unsafe {
     .          .          .          .                       ptr::slice_from_raw_parts_mut(self.ptr().add(range.start), range.end - range.start)
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns `true` if the buffer is at full capacity.
     .          .          .          .               #[inline]
     .          .          .          .               fn is_full(&self) -> bool {
 4,864 ( 0.00%) .          .          .                   self.len == self.capacity()
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the index in the underlying buffer for a given logical element
     .          .          .          .               /// index + addend.
     .          .          .          .               #[inline]
     .          .          .          .               fn wrap_add(&self, idx: usize, addend: usize) -> usize {
     .          .          .          .                   wrap_index(idx.wrapping_add(addend), self.capacity())
     .          .          .          .               }
-- line 213 ----------------------------------------
-- line 510 ----------------------------------------
     .          .          .          .                   //          H             L
     .          .          .          .                   // B [. . . o o o o o o o o . . . . . ]
     .          .          .          .                   //              L H
     .          .          .          .                   //   [o o o o o o o o ]
     .          .          .          .                   //              L                 H
     .          .          .          .                   // C [o o o o o o . . . . . . . . o o ]
     .          .          .          .           
     .          .          .          .                   // can't use is_contiguous() because the capacity is already updated.
 1,080 ( 0.00%) .          .          .                   if self.head <= old_capacity - self.len {
     .          .          .          .                       // A
     .          .          .          .                       // Nop
     .          .          .          .                   } else {
   138 ( 0.00%) .          .          .                       let head_len = old_capacity - self.head;
    69 ( 0.00%) .          .          .                       let tail_len = self.len - head_len;
   552 ( 0.00%) .          .          .                       if head_len > tail_len && new_capacity - old_capacity >= tail_len {
     .          .          .          .                           // B
     .          .          .          .                           unsafe {
    47 ( 0.00%) .          .          .                               self.copy_nonoverlapping(0, old_capacity, tail_len);
     .          .          .          .                           }
     .          .          .          .                       } else {
     .          .          .          .                           // C
    22 ( 0.00%) .          .          .                           let new_head = new_capacity - head_len;
     .          .          .          .                           unsafe {
     .          .          .          .                               // can't use copy_nonoverlapping here, because if e.g. head_len = 2
     .          .          .          .                               // and new_capacity = old_capacity + 1, then the heads overlap.
    22 ( 0.00%) .          .          .                               self.copy(self.head, new_head, head_len);
     .          .          .          .                           }
    22 ( 0.00%) .          .          .                           self.head = new_head;
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   debug_assert!(self.head < self.capacity() || self.capacity() == 0);
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<T> VecDeque<T> {
     .          .          .          .               /// Creates an empty deque.
-- line 545 ----------------------------------------
-- line 552 ----------------------------------------
     .          .          .          .               /// let deque: VecDeque<u32> = VecDeque::new();
     .          .          .          .               /// ```
     .          .          .          .               #[inline]
     .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .               #[rustc_const_stable(feature = "const_vec_deque_new", since = "1.68.0")]
     .          .          .          .               #[must_use]
     .          .          .          .               pub const fn new() -> VecDeque<T> {
     .          .          .          .                   // FIXME(const-hack): This should just be `VecDeque::new_in(Global)` once that hits stable.
   192 ( 0.00%) .          .          .                   VecDeque { head: 0, len: 0, buf: RawVec::new() }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Creates an empty deque with space for at least `capacity` elements.
     .          .          .          .               ///
     .          .          .          .               /// # Examples
     .          .          .          .               ///
     .          .          .          .               /// ```
     .          .          .          .               /// use std::collections::VecDeque;
-- line 568 ----------------------------------------
-- line 1334 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// let mut deque = VecDeque::new();
     .          .          .          .               /// assert!(deque.is_empty());
     .          .          .          .               /// deque.push_front(1);
     .          .          .          .               /// assert!(!deque.is_empty());
     .          .          .          .               /// ```
     .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .               pub fn is_empty(&self) -> bool {
 2,480 ( 0.00%) .          .          .                   self.len == 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Given a range into the logical buffer of the deque, this function
     .          .          .          .               /// return two ranges into the physical buffer that correspond to
     .          .          .          .               /// the given range. The `len` parameter should usually just be `self.len`;
     .          .          .          .               /// the reason it's passed explicitly is that if the deque is wrapped in
     .          .          .          .               /// a `Drain`, then `self.len` is not actually the length of the deque.
     .          .          .          .               ///
-- line 1350 ----------------------------------------
-- line 1690 ----------------------------------------
     .          .          .          .               /// d.push_back(2);
     .          .          .          .               ///
     .          .          .          .               /// assert_eq!(d.pop_front(), Some(1));
     .          .          .          .               /// assert_eq!(d.pop_front(), Some(2));
     .          .          .          .               /// assert_eq!(d.pop_front(), None);
     .          .          .          .               /// ```
     .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .               pub fn pop_front(&mut self) -> Option<T> {
 5,056 ( 0.00%) .          .          .                   if self.is_empty() {
     .          .          .          .                       None
     .          .          .          .                   } else {
 2,432 ( 0.00%) .          .          .                       let old_head = self.head;
 2,432 ( 0.00%) .          .          .                       self.head = self.to_physical_idx(1);
 4,864 ( 0.00%) .          .          .                       self.len -= 1;
     .          .          .          .                       unsafe {
     .          .          .          .                           core::hint::assert_unchecked(self.len < self.capacity());
     .          .          .          .                           Some(self.buffer_read(old_head))
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Removes the last element from the deque and returns it, or `None` if
-- line 1711 ----------------------------------------
-- line 1773 ----------------------------------------
     .          .          .          .               /// buf.push_back(1);
     .          .          .          .               /// buf.push_back(3);
     .          .          .          .               /// assert_eq!(3, *buf.back().unwrap());
     .          .          .          .               /// ```
     .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .               #[rustc_confusables("push", "put", "append")]
     .          .          .          .               #[track_caller]
     .          .          .          .               pub fn push_back(&mut self, value: T) {
 2,432 ( 0.00%) .          .          .                   if self.is_full() {
   610 ( 0.00%) .          .          .                       self.grow();
80,096 ( 0.02%) 314 ( 0.04%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:alloc::collections::vec_deque::VecDeque<T,A>::grow (180x)
     .          .          .          .                   }
     .          .          .          .           
   180 ( 0.00%) .          .          .                   unsafe { self.buffer_write(self.to_physical_idx(self.len), value) }
 2,432 ( 0.00%) .          .          .                   self.len += 1;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               fn is_contiguous(&self) -> bool {
     .          .          .          .                   // Do the calculation like this to avoid overflowing if len + head > usize::MAX
     .          .          .          .                   self.head <= self.capacity() - self.len
     .          .          .          .               }
     .          .          .          .           
-- line 1794 ----------------------------------------
-- line 2179 ----------------------------------------
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               // Double the buffer size. This method is inline(never), so we expect it to only
     .          .          .          .               // be called in cold paths.
     .          .          .          .               // This may panic or abort
     .          .          .          .               #[inline(never)]
     .          .          .          .               #[track_caller]
   720 ( 0.00%) .          .          .               fn grow(&mut self) {
     .          .          .          .                   // Extend or possibly remove this assertion when valid use-cases for growing the
     .          .          .          .                   // buffer without it being full emerge
     .          .          .          .                   debug_assert!(self.is_full());
     .          .          .          .                   let old_cap = self.capacity();
   180 ( 0.00%) .          .          .                   self.buf.grow_one();
75,120 ( 0.02%) 314 ( 0.04%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (180x)
     .          .          .          .                   unsafe {
     .          .          .          .                       self.handle_capacity_increase(old_cap);
     .          .          .          .                   }
     .          .          .          .                   debug_assert!(!self.is_full());
   532 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Modifies the deque in-place so that `len()` is equal to `new_len`,
     .          .          .          .               /// either by removing excess elements from the back or by appending
     .          .          .          .               /// elements generated by calling `generator` to the back.
     .          .          .          .               ///
     .          .          .          .               /// # Examples
     .          .          .          .               ///
     .          .          .          .               /// ```
-- line 2205 ----------------------------------------
-- line 2783 ----------------------------------------
     .          .          .          .           /// Returns the index in the underlying buffer for a given logical element index.
     .          .          .          .           #[inline]
     .          .          .          .           fn wrap_index(logical_index: usize, capacity: usize) -> usize {
     .          .          .          .               debug_assert!(
     .          .          .          .                   (logical_index == 0 && capacity == 0)
     .          .          .          .                       || logical_index < capacity
     .          .          .          .                       || (logical_index - capacity) < capacity
     .          .          .          .               );
23,828 ( 0.01%) .          .          .               if logical_index >= capacity { logical_index - capacity } else { logical_index }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .           impl<T: PartialEq, A: Allocator> PartialEq for VecDeque<T, A> {
     .          .          .          .               fn eq(&self, other: &Self) -> bool {
     .          .          .          .                   if self.len != other.len() {
     .          .          .          .                       return false;
     .          .          .          .                   }
-- line 2799 ----------------------------------------

   261 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 157 ----------------------------------------
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           // Tiny Vecs are dumb. Skip to:
        .          .          .          .           // - 8 if the element size is 1, because any heap allocators is likely
        .          .          .          .           //   to round up a request of less than 8 bytes to at least 8 bytes.
        .          .          .          .           // - 4 if elements are moderate-sized (<= 1 KiB).
        .          .          .          .           // - 1 otherwise, to avoid wasting too much space for very short Vecs.
        .          .          .          .           const fn min_non_zero_cap(size: usize) -> usize {
  160,398 ( 0.05%) .          .          .               if size == 1 {
        .          .          .          .                   8
        .          .          .          .               } else if size <= 1024 {
        .          .          .          .                   4
        .          .          .          .               } else {
        .          .          .          .                   1
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
-- line 173 ----------------------------------------
-- line 333 ----------------------------------------
        .          .          .          .                   self.inner.reserve(len, additional, T::LAYOUT)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// A specialized version of `self.reserve(len, 1)` which requires the
        .          .          .          .               /// caller to ensure `len == self.capacity()`.
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[inline(never)]
        .          .          .          .               #[track_caller]
  888,320 ( 0.27%) .          .          .               pub fn grow_one(&mut self) {
        .          .          .          .                   self.inner.grow_one(T::LAYOUT)
  888,320 ( 0.27%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// The same as `reserve`, but returns on errors instead of panicking or aborting.
        .          .          .          .               pub fn try_reserve(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {
        .          .          .          .                   self.inner.try_reserve(len, additional, T::LAYOUT)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Ensures that the buffer contains at least enough space to hold `len +
        .          .          .          .               /// additional` elements. If it doesn't already, will reallocate the
-- line 351 ----------------------------------------
-- line 388 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// # Aborts
        .          .          .          .               ///
        .          .          .          .               /// Aborts on OOM.
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[track_caller]
        .          .          .          .               #[inline]
        .          .          .          .               pub fn shrink_to_fit(&mut self, cap: usize) {
    2,244 ( 0.00%) .          .          .                   self.inner.shrink_to_fit(cap, T::LAYOUT)
      607 ( 0.00%) 4 ( 0.00%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::shrink_to_fit (2x)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           unsafe impl<#[may_dangle] T, A: Allocator> Drop for RawVec<T, A> {
        .          .          .          .               /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.
        .          .          .          .               fn drop(&mut self) {
        .          .          .          .                   // SAFETY: We are in a Drop impl, self.inner will not be used again.
1,020,714 ( 0.31%) .          .          .                   unsafe { self.inner.deallocate(T::LAYOUT) }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<A: Allocator> RawVecInner<A> {
        .          .          .          .               #[inline]
        .          .          .          .               const fn new_in(alloc: A, align: usize) -> Self {
        .          .          .          .                   let ptr = unsafe { core::mem::transmute(align) };
        .          .          .          .                   // `cap: 0` means "unallocated". zero-sized types are ignored.
-- line 412 ----------------------------------------
-- line 457 ----------------------------------------
        .          .          .          .                   // We avoid `unwrap_or_else` here because it bloats the amount of
        .          .          .          .                   // LLVM IR generated.
        .          .          .          .                   let layout = match layout_array(capacity, elem_layout) {
        .          .          .          .                       Ok(layout) => layout,
        .          .          .          .                       Err(_) => return Err(CapacityOverflow.into()),
        .          .          .          .                   };
        .          .          .          .           
        .          .          .          .                   // Don't allocate here because `Drop` will not deallocate when `capacity` is 0.
   58,469 ( 0.02%) .          .          .                   if layout.size() == 0 {
        .          .          .          .                       return Ok(Self::new_in(alloc, elem_layout.align()));
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   if let Err(err) = alloc_guard(layout.size()) {
        .          .          .          .                       return Err(err);
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   let result = match init {
        .          .          .          .                       AllocInit::Uninitialized => alloc.allocate(layout),
        .          .          .          .                       #[cfg(not(no_global_oom_handling))]
        .          .          .          .                       AllocInit::Zeroed => alloc.allocate_zeroed(layout),
        .          .          .          .                   };
  138,892 ( 0.04%) .          .          .                   let ptr = match result {
        .          .          .          .                       Ok(ptr) => ptr,
        .          .          .          .                       Err(_) => return Err(AllocError { layout, non_exhaustive: () }.into()),
        .          .          .          .                   };
        .          .          .          .           
        .          .          .          .                   // Allocators currently return a `NonNull<[u8]>` whose length
        .          .          .          .                   // matches the size requested. If that ever changes, the capacity
        .          .          .          .                   // here should change to `ptr.len() / mem::size_of::<T>()`.
        .          .          .          .                   Ok(Self { ptr: Unique::from(ptr.cast()), cap: unsafe { Cap(capacity) }, alloc })
-- line 486 ----------------------------------------
-- line 498 ----------------------------------------
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               const fn ptr<T>(&self) -> *mut T {
        .          .          .          .                   self.non_null::<T>().as_ptr()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               const fn non_null<T>(&self) -> NonNull<T> {
2,107,012 ( 0.63%) .          .          .                   self.ptr.cast().as_non_null_ptr()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               const fn capacity(&self, elem_size: usize) -> usize {
  189,194 ( 0.06%) .          .          .                   if elem_size == 0 { usize::MAX } else { self.cap.0 }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn allocator(&self) -> &A {
        .          .          .          .                   &self.alloc
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn current_memory(&self, elem_layout: Layout) -> Option<(NonNull<u8>, Layout)> {
1,276,018 ( 0.38%) .          .          .                   if elem_layout.size() == 0 || self.cap.0 == 0 {
        .          .          .          .                       None
        .          .          .          .                   } else {
        .          .          .          .                       // We could use Layout::array here which ensures the absence of isize and usize overflows
        .          .          .          .                       // and could hypothetically handle differences between stride and size, but this memory
        .          .          .          .                       // has already been allocated so we know it can't overflow and currently Rust does not
        .          .          .          .                       // support such types. So we can do better by skipping some checks and avoid an unwrap.
        .          .          .          .                       unsafe {
        .          .          .          .                           let alloc_size = elem_layout.size().unchecked_mul(self.cap.0);
        .          .          .          .                           let layout = Layout::from_size_align_unchecked(alloc_size, elem_layout.align());
  132,072 ( 0.04%) .          .          .                           Some((self.ptr.into(), layout))
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
        .          .          .          .               fn reserve(&mut self, len: usize, additional: usize, elem_layout: Layout) {
        .          .          .          .                   // Callers expect this function to be very cheap when there is already sufficient capacity.
        .          .          .          .                   // Therefore, we move all the resizing and error-handling logic from grow_amortized and
        .          .          .          .                   // handle_reserve behind a call, while making sure that this function is likely to be
        .          .          .          .                   // inlined as just a comparison and a call if the comparison fails.
        .          .          .          .                   #[cold]
   68,742 ( 0.02%) .          .          .                   fn do_reserve_and_handle<A: Allocator>(
        .          .          .          .                       slf: &mut RawVecInner<A>,
        .          .          .          .                       len: usize,
        .          .          .          .                       additional: usize,
        .          .          .          .                       elem_layout: Layout,
        .          .          .          .                   ) {
        .          .          .          .                       if let Err(err) = slf.grow_amortized(len, additional, elem_layout) {
        .          .          .          .                           handle_error(err);
        .          .          .          .                       }
   91,656 ( 0.03%) .          .          .                   }
        .          .          .          .           
   76,143 ( 0.02%) .          .          .                   if self.needs_to_grow(len, additional, elem_layout) {
  127,413 ( 0.04%) .          .          .                       do_reserve_and_handle(self, len, additional, elem_layout);
      251 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::reserve::do_reserve_and_handle (1x)
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
        .          .          .          .               fn grow_one(&mut self, elem_layout: Layout) {
  177,664 ( 0.05%) .          .          .                   if let Err(err) = self.grow_amortized(self.cap.0, 1, elem_layout) {
        .          .          .          .                       handle_error(err);
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn try_reserve(
        .          .          .          .                   &mut self,
        .          .          .          .                   len: usize,
        .          .          .          .                   additional: usize,
-- line 573 ----------------------------------------
-- line 605 ----------------------------------------
        .          .          .          .                       hint::assert_unchecked(!self.needs_to_grow(len, additional, elem_layout));
        .          .          .          .                   }
        .          .          .          .                   Ok(())
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
    3,192 ( 0.00%) .          .          .               fn shrink_to_fit(&mut self, cap: usize, elem_layout: Layout) {
        .          .          .          .                   if let Err(err) = self.shrink(cap, elem_layout) {
        .          .          .          .                       handle_error(err);
        .          .          .          .                   }
    3,192 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn needs_to_grow(&self, len: usize, additional: usize, elem_layout: Layout) -> bool {
   85,034 ( 0.03%) .          .          .                   additional > self.capacity(elem_layout.size()).wrapping_sub(len)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               unsafe fn set_ptr_and_cap(&mut self, ptr: NonNull<[u8]>, cap: usize) {
        .          .          .          .                   // Allocators currently return a `NonNull<[u8]>` whose length matches
        .          .          .          .                   // the size requested. If that ever changes, the capacity here should
        .          .          .          .                   // change to `ptr.len() / mem::size_of::<T>()`.
  200,578 ( 0.06%) .          .          .                   self.ptr = Unique::from(ptr.cast());
  200,578 ( 0.06%) .          .          .                   self.cap = unsafe { Cap(cap) };
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn grow_amortized(
        .          .          .          .                   &mut self,
        .          .          .          .                   len: usize,
        .          .          .          .                   additional: usize,
        .          .          .          .                   elem_layout: Layout,
        .          .          .          .               ) -> Result<(), TryReserveError> {
        .          .          .          .                   // This is ensured by the calling contexts.
        .          .          .          .                   debug_assert!(additional > 0);
        .          .          .          .           
   45,828 ( 0.01%) .          .          .                   if elem_layout.size() == 0 {
        .          .          .          .                       // Since we return a capacity of `usize::MAX` when `elem_size` is
        .          .          .          .                       // 0, getting to here necessarily means the `RawVec` is overfull.
        .          .          .          .                       return Err(CapacityOverflow.into());
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   // Nothing we can really do about these checks, sadly.
        .          .          .          .                   let required_cap = len.checked_add(additional).ok_or(CapacityOverflow)?;
        .          .          .          .           
        .          .          .          .                   // This guarantees exponential growth. The doubling cannot overflow
        .          .          .          .                   // because `cap <= isize::MAX` and the type of `cap` is `usize`.
  223,492 ( 0.07%) .          .          .                   let cap = cmp::max(self.cap.0 * 2, required_cap);
        .          .          .          .                   let cap = cmp::max(min_non_zero_cap(elem_layout.size()), cap);
        .          .          .          .           
        .          .          .          .                   let new_layout = layout_array(cap, elem_layout)?;
        .          .          .          .           
  536,496 ( 0.16%) .          .          .                   let ptr = finish_grow(new_layout, self.current_memory(elem_layout), &mut self.alloc)?;
47,667,734 (14.31%) 223,224 (27.57%) 67 (22.26%) .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::finish_grow (177,664x)
        .          .          .          .                   // SAFETY: finish_grow would have resulted in a capacity overflow if we tried to allocate more than `isize::MAX` items
        .          .          .          .           
        .          .          .          .                   unsafe { self.set_ptr_and_cap(ptr, cap) };
        .          .          .          .                   Ok(())
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               fn grow_exact(
        .          .          .          .                   &mut self,
-- line 666 ----------------------------------------
-- line 683 ----------------------------------------
        .          .          .          .                       self.set_ptr_and_cap(ptr, cap);
        .          .          .          .                   }
        .          .          .          .                   Ok(())
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[inline]
        .          .          .          .               fn shrink(&mut self, cap: usize, elem_layout: Layout) -> Result<(), TryReserveError> {
      912 ( 0.00%) .          .          .                   assert!(cap <= self.capacity(elem_layout.size()), "Tried to shrink to a larger capacity");
        .          .          .          .                   // SAFETY: Just checked this isn't trying to grow
        .          .          .          .                   unsafe { self.shrink_unchecked(cap, elem_layout) }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// `shrink`, but without the capacity check.
        .          .          .          .               ///
        .          .          .          .               /// This is split out so that `shrink` can inline the check, since it
        .          .          .          .               /// optimizes out in things like `shrink_to_fit`, without needing to
-- line 699 ----------------------------------------
-- line 705 ----------------------------------------
        .          .          .          .               /// `cap <= self.capacity()`
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               unsafe fn shrink_unchecked(
        .          .          .          .                   &mut self,
        .          .          .          .                   cap: usize,
        .          .          .          .                   elem_layout: Layout,
        .          .          .          .               ) -> Result<(), TryReserveError> {
        .          .          .          .                   let (ptr, layout) =
      628 ( 0.00%) .          .          .                       if let Some(mem) = self.current_memory(elem_layout) { mem } else { return Ok(()) };
        .          .          .          .           
        .          .          .          .                   // If shrinking to 0, deallocate the buffer. We don't reach this point
        .          .          .          .                   // for the T::IS_ZST case since current_memory() will have returned
        .          .          .          .                   // None.
   17,623 ( 0.01%) .          .          .                   if cap == 0 {
        .          .          .          .                       unsafe { self.alloc.deallocate(ptr, layout) };
        .          .          .          .                       self.ptr =
        .          .          .          .                           unsafe { Unique::new_unchecked(ptr::without_provenance_mut(elem_layout.align())) };
        .          .          .          .                       self.cap = Cap::ZERO;
        .          .          .          .                   } else {
        .          .          .          .                       let ptr = unsafe {
        .          .          .          .                           // Layout cannot overflow here because it would have
        .          .          .          .                           // overflowed earlier when capacity was larger.
-- line 726 ----------------------------------------
-- line 752 ----------------------------------------
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           // not marked inline(never) since we want optimizers to be able to observe the specifics of this
        .          .          .          .           // function, see tests/codegen/vec-reserve-extend.rs.
        .          .          .          .           #[cold]
1,203,468 ( 0.36%) .          .          .           fn finish_grow<A>(
        .          .          .          .               new_layout: Layout,
        .          .          .          .               current_memory: Option<(NonNull<u8>, Layout)>,
        .          .          .          .               alloc: &mut A,
        .          .          .          .           ) -> Result<NonNull<[u8]>, TryReserveError>
        .          .          .          .           where
        .          .          .          .               A: Allocator,
        .          .          .          .           {
        .          .          .          .               alloc_guard(new_layout.size())?;
        .          .          .          .           
  445,180 ( 0.13%) .          .          .               let memory = if let Some((ptr, old_layout)) = current_memory {
        .          .          .          .                   debug_assert_eq!(old_layout.align(), new_layout.align());
        .          .          .          .                   unsafe {
        .          .          .          .                       // The allocator checks for alignment equality
        .          .          .          .                       hint::assert_unchecked(old_layout.align() == new_layout.align());
        .          .          .          .                       alloc.grow(ptr, old_layout, new_layout)
        .          .          .          .                   }
        .          .          .          .               } else {
        .          .          .          .                   alloc.allocate(new_layout)
        .          .          .          .               };
        .          .          .          .           
        .          .          .          .               memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () }.into())
  802,312 ( 0.24%) .          .          .           }
        .          .          .          .           
        .          .          .          .           // Central function for reserve error handling.
        .          .          .          .           #[cfg(not(no_global_oom_handling))]
        .          .          .          .           #[cold]
        .          .          .          .           #[optimize(size)]
        .          .          .          .           #[track_caller]
        .          .          .          .           fn handle_error(e: TryReserveError) -> ! {
        .          .          .          .               match e.kind() {
-- line 790 ----------------------------------------

3,284,372 ( 0.99%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/lib.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 253 ----------------------------------------
    .          .          .          .           ///
    .          .          .          .           /// assert!(!is_meta_character('%'));
    .          .          .          .           /// assert!(!is_meta_character('/'));
    .          .          .          .           /// assert!(!is_meta_character('!'));
    .          .          .          .           /// assert!(!is_meta_character('"'));
    .          .          .          .           /// assert!(!is_meta_character('e'));
    .          .          .          .           /// ```
    .          .          .          .           pub fn is_meta_character(c: char) -> bool {
9,648 ( 0.00%) .          .          .               match c {
    .          .          .          .                   '\\' | '.' | '+' | '*' | '?' | '(' | ')' | '|' | '[' | ']' | '{'
    .          .          .          .                   | '}' | '^' | '$' | '#' | '&' | '-' | '~' => true,
    .          .          .          .                   _ => false,
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Returns true if the given character can be escaped in a regex.
    .          .          .          .           ///
-- line 269 ----------------------------------------
-- line 302 ----------------------------------------
    .          .          .          .           /// ```
    .          .          .          .           pub fn is_escapeable_character(c: char) -> bool {
    .          .          .          .               // Certainly escapeable if it's a meta character.
    .          .          .          .               if is_meta_character(c) {
    .          .          .          .                   return true;
    .          .          .          .               }
    .          .          .          .               // Any character that isn't ASCII is definitely not escapeable. There's
    .          .          .          .               // no real need to allow things like \ right?
    1 ( 0.00%) .          .          .               if !c.is_ascii() {
    .          .          .          .                   return false;
    .          .          .          .               }
    .          .          .          .               // Otherwise, we basically say that everything is escapeable unless it's a
    .          .          .          .               // letter or digit. Things like \3 are either octal (when enabled) or an
    .          .          .          .               // error, and we should keep it that way. Otherwise, letters are reserved
    .          .          .          .               // for adding new syntax in a backwards compatible way.
    .          .          .          .               match c {
   12 ( 0.00%) .          .          .                   '0'..='9' | 'A'..='Z' | 'a'..='z' => false,
    .          .          .          .                   // While not currently supported, we keep these as not escapeable to
    .          .          .          .                   // give us some flexibility with respect to supporting the \< and
    .          .          .          .                   // \> word boundary assertions in the future. By rejecting them as
    .          .          .          .                   // escapeable, \< and \> will result in a parse error. Thus, we can
    .          .          .          .                   // turn them into something else in the future without it being a
    .          .          .          .                   // backwards incompatible change.
    .          .          .          .                   //
    .          .          .          .                   // OK, now we support \< and \>, and we need to retain them as *not*
    .          .          .          .                   // escapeable here since the escape sequence is significant.
    .          .          .          .                   '<' | '>' => false,
    .          .          .          .                   _ => true,
    .          .          .          .               }
    1 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Returns true if and only if the given character is a Unicode word
    .          .          .          .           /// character.
    .          .          .          .           ///
    .          .          .          .           /// A Unicode word character is defined by
    .          .          .          .           /// [UTS#18 Annex C](https://unicode.org/reports/tr18/#Compatibility_Properties).
    .          .          .          .           /// In particular, a character
    .          .          .          .           /// is considered a word character if it is in either of the `Alphabetic` or
-- line 339 ----------------------------------------

2,610 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/lib.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 129 ----------------------------------------
      .          .          .          .               /// let b: &[i32] = &[];
      .          .          .          .               /// assert!(b.is_empty());
      .          .          .          .               /// ```
      .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_slice_is_empty", since = "1.39.0")]
      .          .          .          .               #[inline]
      .          .          .          .               #[must_use]
      .          .          .          .               pub const fn is_empty(&self) -> bool {
  1,401 ( 0.00%) .          .          .                   self.len() == 0
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the first element of the slice, or `None` if it is empty.
      .          .          .          .               ///
      .          .          .          .               /// # Examples
      .          .          .          .               ///
      .          .          .          .               /// ```
      .          .          .          .               /// let v = [10, 40, 30];
-- line 145 ----------------------------------------
-- line 148 ----------------------------------------
      .          .          .          .               /// let w: &[i32] = &[];
      .          .          .          .               /// assert_eq!(None, w.first());
      .          .          .          .               /// ```
      .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_slice_first_last_not_mut", since = "1.56.0")]
      .          .          .          .               #[inline]
      .          .          .          .               #[must_use]
      .          .          .          .               pub const fn first(&self) -> Option<&T> {
     13 ( 0.00%) .          .          .                   if let [first, ..] = self { Some(first) } else { None }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a mutable reference to the first element of the slice, or `None` if it is empty.
      .          .          .          .               ///
      .          .          .          .               /// # Examples
      .          .          .          .               ///
      .          .          .          .               /// ```
      .          .          .          .               /// let x = &mut [0, 1, 2];
-- line 164 ----------------------------------------
-- line 191 ----------------------------------------
      .          .          .          .               ///     assert_eq!(elements, &[1, 2]);
      .          .          .          .               /// }
      .          .          .          .               /// ```
      .          .          .          .               #[stable(feature = "slice_splits", since = "1.5.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_slice_first_last_not_mut", since = "1.56.0")]
      .          .          .          .               #[inline]
      .          .          .          .               #[must_use]
      .          .          .          .               pub const fn split_first(&self) -> Option<(&T, &[T])> {
    150 ( 0.00%) .          .          .                   if let [first, tail @ ..] = self { Some((first, tail)) } else { None }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.
      .          .          .          .               ///
      .          .          .          .               /// # Examples
      .          .          .          .               ///
      .          .          .          .               /// ```
      .          .          .          .               /// let x = &mut [0, 1, 2];
-- line 207 ----------------------------------------
-- line 255 ----------------------------------------
      .          .          .          .               /// }
      .          .          .          .               /// assert_eq!(x, &[4, 5, 3]);
      .          .          .          .               /// ```
      .          .          .          .               #[stable(feature = "slice_splits", since = "1.5.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_slice_first_last", since = "1.83.0")]
      .          .          .          .               #[inline]
      .          .          .          .               #[must_use]
      .          .          .          .               pub const fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {
  1,567 ( 0.00%) .          .          .                   if let [init @ .., last] = self { Some((last, init)) } else { None }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the last element of the slice, or `None` if it is empty.
      .          .          .          .               ///
      .          .          .          .               /// # Examples
      .          .          .          .               ///
      .          .          .          .               /// ```
      .          .          .          .               /// let v = [10, 40, 30];
-- line 271 ----------------------------------------
-- line 274 ----------------------------------------
      .          .          .          .               /// let w: &[i32] = &[];
      .          .          .          .               /// assert_eq!(None, w.last());
      .          .          .          .               /// ```
      .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_slice_first_last_not_mut", since = "1.56.0")]
      .          .          .          .               #[inline]
      .          .          .          .               #[must_use]
      .          .          .          .               pub const fn last(&self) -> Option<&T> {
513,023 ( 0.15%) .          .          .                   if let [.., last] = self { Some(last) } else { None }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a mutable reference to the last item in the slice, or `None` if it is empty.
      .          .          .          .               ///
      .          .          .          .               /// # Examples
      .          .          .          .               ///
      .          .          .          .               /// ```
      .          .          .          .               /// let x = &mut [0, 1, 2];
-- line 290 ----------------------------------------
-- line 297 ----------------------------------------
      .          .          .          .               /// let y: &mut [i32] = &mut [];
      .          .          .          .               /// assert_eq!(None, y.last_mut());
      .          .          .          .               /// ```
      .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_slice_first_last", since = "1.83.0")]
      .          .          .          .               #[inline]
      .          .          .          .               #[must_use]
      .          .          .          .               pub const fn last_mut(&mut self) -> Option<&mut T> {
257,443 ( 0.08%) .          .          .                   if let [.., last] = self { Some(last) } else { None }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns an array reference to the first `N` items in the slice.
      .          .          .          .               ///
      .          .          .          .               /// If the slice is not at least `N` in length, this will return `None`.
      .          .          .          .               ///
      .          .          .          .               /// # Examples
      .          .          .          .               ///
-- line 313 ----------------------------------------
-- line 914 ----------------------------------------
      .          .          .          .               /// ```
      .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .               #[rustc_const_stable(feature = "const_swap", since = "1.85.0")]
      .          .          .          .               #[inline]
      .          .          .          .               #[track_caller]
      .          .          .          .               pub const fn swap(&mut self, a: usize, b: usize) {
      .          .          .          .                   // FIXME: use swap_unchecked here (https://github.com/rust-lang/rust/pull/88540#issuecomment-944344343)
      .          .          .          .                   // Can't take two mutable loans from one vector, so instead use raw pointers.
  7,488 ( 0.00%) .          .          .                   let pa = &raw mut self[a];
  7,488 ( 0.00%) .          .          .                   let pb = &raw mut self[b];
      .          .          .          .                   // SAFETY: `pa` and `pb` have been created from safe mutable references and refer
      .          .          .          .                   // to elements in the slice and therefore are guaranteed to be valid and aligned.
      .          .          .          .                   // Note that accessing the elements behind `a` and `b` is checked and will
      .          .          .          .                   // panic when out of bounds.
      .          .          .          .                   unsafe {
      .          .          .          .                       ptr::swap(pa, pb);
      .          .          .          .                   }
      .          .          .          .               }
-- line 931 ----------------------------------------
-- line 1017 ----------------------------------------
      .          .          .          .           
      .          .          .          .                       // Because this function is first compiled in isolation,
      .          .          .          .                       // this check tells LLVM that the indexing below is
      .          .          .          .                       // in-bounds. Then after inlining -- once the actual
      .          .          .          .                       // lengths of the slices are known -- it's removed.
      .          .          .          .                       let (a, b) = (&mut a[..n], &mut b[..n]);
      .          .          .          .           
      .          .          .          .                       let mut i = 0;
 76,380 ( 0.02%) .          .          .                       while i < n {
 14,622 ( 0.00%) .          .          .                           mem::swap(&mut a[i], &mut b[n - 1 - i]);
      .          .          .          .                           i += 1;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns an iterator over the slice.
      .          .          .          .               ///
      .          .          .          .               /// The iterator yields all items from start to end.
-- line 1034 ----------------------------------------
-- line 1223 ----------------------------------------
      .          .          .          .               /// ```
      .          .          .          .               ///
      .          .          .          .               /// [`chunks`]: slice::chunks
      .          .          .          .               /// [`rchunks_exact`]: slice::rchunks_exact
      .          .          .          .               #[stable(feature = "chunks_exact", since = "1.31.0")]
      .          .          .          .               #[inline]
      .          .          .          .               #[track_caller]
      .          .          .          .               pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<'_, T> {
      5 ( 0.00%) .          .          .                   assert!(chunk_size != 0, "chunk size must be non-zero");
      .          .          .          .                   ChunksExact::new(self, chunk_size)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the
      .          .          .          .               /// beginning of the slice.
      .          .          .          .               ///
      .          .          .          .               /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the
      .          .          .          .               /// length of the slice, then the last up to `chunk_size-1` elements will be omitted and can be
-- line 1239 ----------------------------------------
-- line 2573 ----------------------------------------
      .          .          .          .               /// ```
      .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .               #[must_use]
      .          .          .          .               pub fn starts_with(&self, needle: &[T]) -> bool
      .          .          .          .               where
      .          .          .          .                   T: PartialEq,
      .          .          .          .               {
      .          .          .          .                   let n = needle.len();
  9,247 ( 0.00%) .          .          .                   self.len() >= n && needle == &self[..n]
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns `true` if `needle` is a suffix of the slice or equal to the slice.
      .          .          .          .               ///
      .          .          .          .               /// # Examples
      .          .          .          .               ///
      .          .          .          .               /// ```
      .          .          .          .               /// let v = [10, 40, 30];
-- line 2589 ----------------------------------------
-- line 2638 ----------------------------------------
      .          .          .          .               #[stable(feature = "slice_strip", since = "1.51.0")]
      .          .          .          .               pub fn strip_prefix<P: SlicePattern<Item = T> + ?Sized>(&self, prefix: &P) -> Option<&[T]>
      .          .          .          .               where
      .          .          .          .                   T: PartialEq,
      .          .          .          .               {
      .          .          .          .                   // This function will need rewriting if and when SlicePattern becomes more sophisticated.
      .          .          .          .                   let prefix = prefix.as_slice();
      .          .          .          .                   let n = prefix.len();
     20 ( 0.00%) .          .          .                   if n <= self.len() {
      .          .          .          .                       let (head, tail) = self.split_at(n);
      .          .          .          .                       if head == prefix {
      .          .          .          .                           return Some(tail);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   None
      .          .          .          .               }
      .          .          .          .           
-- line 2654 ----------------------------------------
-- line 2809 ----------------------------------------
      .          .          .          .               /// ```
      .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .               #[inline]
      .          .          .          .               pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>
      .          .          .          .               where
      .          .          .          .                   F: FnMut(&'a T) -> Ordering,
      .          .          .          .               {
      .          .          .          .                   let mut size = self.len();
454,915 ( 0.14%) .          .          .                   if size == 0 {
      .          .          .          .                       return Err(0);
      .          .          .          .                   }
      .          .          .          .                   let mut base = 0usize;
      .          .          .          .           
      .          .          .          .                   // This loop intentionally doesn't have an early exit if the comparison
      .          .          .          .                   // returns Equal. We want the number of loop iterations to depend *only*
      .          .          .          .                   // on the size of the input slice so that the CPU can reliably predict
      .          .          .          .                   // the loop count.
464,818 ( 0.14%) .          .          .                   while size > 1 {
464,818 ( 0.14%) .          .          .                       let half = size / 2;
245,499 ( 0.07%) .          .          .                       let mid = base + half;
      .          .          .          .           
      .          .          .          .                       // SAFETY: the call is made safe by the following inconstants:
      .          .          .          .                       // - `mid >= 0`: by definition
      .          .          .          .                       // - `mid < size`: `mid = size / 2 + size / 4 + size / 8 ...`
  1,896 ( 0.00%) .          .          .                       let cmp = f(unsafe { self.get_unchecked(mid) });
      .          .          .          .           
      .          .          .          .                       // Binary search interacts poorly with branch prediction, so force
      .          .          .          .                       // the compiler to use conditional moves if supported by the target
      .          .          .          .                       // architecture.
246,689 ( 0.07%) .          .          .                       base = select_unpredictable(cmp == Greater, base, mid);
      .          .          .          .           
      .          .          .          .                       // This is imprecise in the case where `size` is odd and the
      .          .          .          .                       // comparison returns Greater: the mid element still gets included
      .          .          .          .                       // by `size` even though it's known to be larger than the element
      .          .          .          .                       // being searched for.
      .          .          .          .                       //
      .          .          .          .                       // This is fine though: we gain more performance by keeping the
      .          .          .          .                       // loop iteration count invariant (and thus predictable) than we
      .          .          .          .                       // lose from considering one additional element.
232,409 ( 0.07%) .          .          .                       size -= half;
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // SAFETY: base is always in [0, size) because base <= mid.
  3,320 ( 0.00%) .          .          .                   let cmp = f(unsafe { self.get_unchecked(base) });
 97,891 ( 0.03%) .          .          .                   if cmp == Equal {
      .          .          .          .                       // SAFETY: same as the `get_unchecked` above.
      .          .          .          .                       unsafe { hint::assert_unchecked(base < self.len()) };
      .          .          .          .                       Ok(base)
      .          .          .          .                   } else {
 73,722 ( 0.02%) .          .          .                       let result = base + (cmp == Less) as usize;
      .          .          .          .                       // SAFETY: same as the `get_unchecked` above.
      .          .          .          .                       // Note that this is `<=`, unlike the assume in the `Ok` path.
      .          .          .          .                       unsafe { hint::assert_unchecked(result <= self.len()) };
      .          .          .          .                       Err(result)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Binary searches this slice with a key extraction function.
-- line 2866 ----------------------------------------
-- line 3717 ----------------------------------------
      .          .          .          .                       const_panic!(
      .          .          .          .                           "copy_from_slice: source slice length does not match destination slice length",
      .          .          .          .                           "copy_from_slice: source slice length ({src_len}) does not match destination slice length ({dst_len})",
      .          .          .          .                           src_len: usize,
      .          .          .          .                           dst_len: usize,
      .          .          .          .                       )
      .          .          .          .                   }
      .          .          .          .           
     50 ( 0.00%) .          .          .                   if self.len() != src.len() {
      .          .          .          .                       len_mismatch_fail(self.len(), src.len());
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was
      .          .          .          .                   // checked to have the same length. The slices cannot overlap because
      .          .          .          .                   // mutable references are exclusive.
      .          .          .          .                   unsafe {
      .          .          .          .                       ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.len());
-- line 3733 ----------------------------------------

573,695 ( 0.17%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 309 ----------------------------------------
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Span represents the position information of a single AST item.
      .          .          .          .           ///
      .          .          .          .           /// All span positions are absolute byte offsets that can be used on the
      .          .          .          .           /// original regular expression that was parsed.
  4,688 ( 0.00%) .          .          .           #[derive(Clone, Copy, Eq, PartialEq)]
      .          .          .          .           #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
      .          .          .          .           pub struct Span {
      .          .          .          .               /// The start byte offset.
      .          .          .          .               pub start: Position,
      .          .          .          .               /// The end byte offset.
      .          .          .          .               pub end: Position,
      .          .          .          .           }
      .          .          .          .           
-- line 325 ----------------------------------------
-- line 340 ----------------------------------------
      .          .          .          .                   Some(self.cmp(other))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A single position in a regular expression.
      .          .          .          .           ///
      .          .          .          .           /// A position encodes one half of a span, and include the byte offset, line
      .          .          .          .           /// number and column number.
  6,260 ( 0.00%) .          .          .           #[derive(Clone, Copy, Eq, PartialEq)]
      .          .          .          .           #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
      .          .          .          .           pub struct Position {
      .          .          .          .               /// The absolute offset of this position, starting at `0` from the
      .          .          .          .               /// beginning of the regular expression pattern string.
      .          .          .          .               pub offset: usize,
      .          .          .          .               /// The line number, starting at `1`.
      .          .          .          .               pub line: usize,
      .          .          .          .               /// The approximate column number, starting at `1`.
-- line 356 ----------------------------------------
-- line 377 ----------------------------------------
      .          .          .          .               fn partial_cmp(&self, other: &Position) -> Option<Ordering> {
      .          .          .          .                   Some(self.cmp(other))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Span {
      .          .          .          .               /// Create a new span with the given positions.
      .          .          .          .               pub fn new(start: Position, end: Position) -> Span {
121,377 ( 0.04%) .          .          .                   Span { start, end }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new span using the given position as the start and end.
      .          .          .          .               pub fn splat(pos: Position) -> Span {
      .          .          .          .                   Span::new(pos, pos)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a new span by replacing the starting the position with the one
-- line 393 ----------------------------------------
-- line 492 ----------------------------------------
      .          .          .          .               /// An alternation of regular expressions.
      .          .          .          .               Alternation(Box<Alternation>),
      .          .          .          .               /// A concatenation of regular expressions.
      .          .          .          .               Concat(Box<Concat>),
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Ast {
      .          .          .          .               /// Create an "empty" AST item.
    214 ( 0.00%) .          .          .               pub fn empty(span: Span) -> Ast {
      .          .          .          .                   Ast::Empty(Box::new(span))
    321 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a "flags" AST item.
      .          .          .          .               pub fn flags(e: SetFlags) -> Ast {
      .          .          .          .                   Ast::Flags(Box::new(e))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a "literal" AST item.
      .          .          .          .               pub fn literal(e: Literal) -> Ast {
-- line 510 ----------------------------------------
-- line 532 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a "bracketed class" AST item.
      .          .          .          .               pub fn class_bracketed(e: ClassBracketed) -> Ast {
      .          .          .          .                   Ast::ClassBracketed(Box::new(e))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a "repetition" AST item.
    344 ( 0.00%) .          .          .               pub fn repetition(e: Repetition) -> Ast {
      .          .          .          .                   Ast::Repetition(Box::new(e))
    516 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a "group" AST item.
      .          .          .          .               pub fn group(e: Group) -> Ast {
      .          .          .          .                   Ast::Group(Box::new(e))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Create a "alternation" AST item.
      .          .          .          .               pub fn alternation(e: Alternation) -> Ast {
-- line 550 ----------------------------------------
-- line 553 ----------------------------------------
      .          .          .          .           
      .          .          .          .               /// Create a "concat" AST item.
      .          .          .          .               pub fn concat(e: Concat) -> Ast {
      .          .          .          .                   Ast::Concat(Box::new(e))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the span of this abstract syntax tree.
      .          .          .          .               pub fn span(&self) -> &Span {
 13,195 ( 0.00%) .          .          .                   match *self {
      .          .          .          .                       Ast::Empty(ref span) => span,
      .          .          .          .                       Ast::Flags(ref x) => &x.span,
      .          .          .          .                       Ast::Literal(ref x) => &x.span,
      .          .          .          .                       Ast::Dot(ref span) => span,
      .          .          .          .                       Ast::Assertion(ref x) => &x.span,
      .          .          .          .                       Ast::ClassUnicode(ref x) => &x.span,
      .          .          .          .                       Ast::ClassPerl(ref x) => &x.span,
      .          .          .          .                       Ast::ClassBracketed(ref x) => &x.span,
      .          .          .          .                       Ast::Repetition(ref x) => &x.span,
      2 ( 0.00%) .          .          .                       Ast::Group(ref x) => &x.span,
      .          .          .          .                       Ast::Alternation(ref x) => &x.span,
      .          .          .          .                       Ast::Concat(ref x) => &x.span,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return true if and only if this Ast is empty.
      .          .          .          .               pub fn is_empty(&self) -> bool {
      .          .          .          .                   match *self {
-- line 579 ----------------------------------------
-- line 580 ----------------------------------------
      .          .          .          .                       Ast::Empty(_) => true,
      .          .          .          .                       _ => false,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this AST has any (including possibly empty)
      .          .          .          .               /// subexpressions.
      .          .          .          .               fn has_subexprs(&self) -> bool {
  5,156 ( 0.00%) .          .          .                   match *self {
      .          .          .          .                       Ast::Empty(_)
      .          .          .          .                       | Ast::Flags(_)
      .          .          .          .                       | Ast::Literal(_)
      .          .          .          .                       | Ast::Dot(_)
      .          .          .          .                       | Ast::Assertion(_)
      .          .          .          .                       | Ast::ClassUnicode(_)
      .          .          .          .                       | Ast::ClassPerl(_) => false,
      .          .          .          .                       Ast::ClassBracketed(_)
-- line 596 ----------------------------------------
-- line 628 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Alternation {
      .          .          .          .               /// Return this alternation as an AST.
      .          .          .          .               ///
      .          .          .          .               /// If this alternation contains zero ASTs, then `Ast::empty` is returned.
      .          .          .          .               /// If this alternation contains exactly 1 AST, then the corresponding AST
      .          .          .          .               /// is returned. Otherwise, `Ast::alternation` is returned.
  2,048 ( 0.00%) .          .          .               pub fn into_ast(mut self) -> Ast {
  2,048 ( 0.00%) .          .          .                   match self.asts.len() {
      .          .          .          .                       0 => Ast::empty(self.span),
      .          .          .          .                       1 => self.asts.pop().unwrap(),
      .          .          .          .                       _ => Ast::alternation(self),
      .          .          .          .                   }
  3,072 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A concatenation of regular expressions.
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
      .          .          .          .           pub struct Concat {
      .          .          .          .               /// The span of this concatenation.
      .          .          .          .               pub span: Span,
-- line 650 ----------------------------------------
-- line 653 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Concat {
      .          .          .          .               /// Return this concatenation as an AST.
      .          .          .          .               ///
      .          .          .          .               /// If this alternation contains zero ASTs, then `Ast::empty` is returned.
      .          .          .          .               /// If this alternation contains exactly 1 AST, then the corresponding AST
      .          .          .          .               /// is returned. Otherwise, `Ast::concat` is returned.
 66,812 ( 0.02%) .          .          .               pub fn into_ast(mut self) -> Ast {
 66,812 ( 0.02%) .          .          .                   match self.asts.len() {
      .          .          .          .                       0 => Ast::empty(self.span),
      .          .          .          .                       1 => self.asts.pop().unwrap(),
      .          .          .          .                       _ => Ast::concat(self),
      .          .          .          .                   }
100,218 ( 0.03%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A single literal expression.
      .          .          .          .           ///
      .          .          .          .           /// A literal corresponds to a single Unicode scalar value. Literals may be
      .          .          .          .           /// represented in their literal form, e.g., `a` or in their escaped form,
      .          .          .          .           /// e.g., `\x61`.
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
-- line 675 ----------------------------------------
-- line 857 ----------------------------------------
      .          .          .          .               /// The name given should correspond to the lowercase version of the
      .          .          .          .               /// variant name. e.g., `cntrl` is the name for `ClassAsciiKind::Cntrl`.
      .          .          .          .               ///
      .          .          .          .               /// If no variant with the corresponding name exists, then `None` is
      .          .          .          .               /// returned.
      .          .          .          .               pub fn from_name(name: &str) -> Option<ClassAsciiKind> {
      .          .          .          .                   use self::ClassAsciiKind::*;
      .          .          .          .                   match name {
    769 ( 0.00%) .          .          .                       "alnum" => Some(Alnum),
    759 ( 0.00%) .          .          .                       "alpha" => Some(Alpha),
    747 ( 0.00%) .          .          .                       "ascii" => Some(Ascii),
    747 ( 0.00%) .          .          .                       "blank" => Some(Blank),
    513 ( 0.00%) .          .          .                       "cntrl" => Some(Cntrl),
    513 ( 0.00%) .          .          .                       "digit" => Some(Digit),
      .          .          .          .                       "graph" => Some(Graph),
      .          .          .          .                       "lower" => Some(Lower),
      .          .          .          .                       "print" => Some(Print),
      .          .          .          .                       "punct" => Some(Punct),
      .          .          .          .                       "space" => Some(Space),
      .          .          .          .                       "upper" => Some(Upper),
      2 ( 0.00%) .          .          .                       "word" => Some(Word),
      .          .          .          .                       "xdigit" => Some(Xdigit),
      .          .          .          .                       _ => None,
      .          .          .          .                   }
    770 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A Unicode character class.
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
      .          .          .          .           pub struct ClassUnicode {
      .          .          .          .               /// The span of this class.
      .          .          .          .               pub span: Span,
-- line 889 ----------------------------------------
-- line 1147 ----------------------------------------
      .          .          .          .                   match *self {
      .          .          .          .                       ClassSet::Item(ref x) => x.span(),
      .          .          .          .                       ClassSet::BinaryOp(ref x) => &x.span,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return true if and only if this class set is empty.
      .          .          .          .               fn is_empty(&self) -> bool {
    353 ( 0.00%) .          .          .                   match *self {
      .          .          .          .                       ClassSet::Item(ClassSetItem::Empty(_)) => true,
      .          .          .          .                       _ => false,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A single component of a character class set.
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
-- line 1163 ----------------------------------------
-- line 1185 ----------------------------------------
      .          .          .          .               Bracketed(Box<ClassBracketed>),
      .          .          .          .               /// A union of items.
      .          .          .          .               Union(ClassSetUnion),
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl ClassSetItem {
      .          .          .          .               /// Return the span of this character class set item.
      .          .          .          .               pub fn span(&self) -> &Span {
 51,346 ( 0.02%) .          .          .                   match *self {
      .          .          .          .                       ClassSetItem::Empty(ref span) => span,
      .          .          .          .                       ClassSetItem::Literal(ref x) => &x.span,
      .          .          .          .                       ClassSetItem::Range(ref x) => &x.span,
      .          .          .          .                       ClassSetItem::Ascii(ref x) => &x.span,
      .          .          .          .                       ClassSetItem::Perl(ref x) => &x.span,
      .          .          .          .                       ClassSetItem::Unicode(ref x) => &x.span,
      .          .          .          .                       ClassSetItem::Bracketed(ref x) => &x.span,
      .          .          .          .                       ClassSetItem::Union(ref x) => &x.span,
-- line 1201 ----------------------------------------
-- line 1243 ----------------------------------------
      .          .          .          .               /// position of the span of the item given. If the union is empty, then
      .          .          .          .               /// the starting position of this union is set to the starting position
      .          .          .          .               /// of this item.
      .          .          .          .               ///
      .          .          .          .               /// In other words, if you only use this method to add items to a union
      .          .          .          .               /// and you set the spans on each item correctly, then you should never
      .          .          .          .               /// need to adjust the span of the union directly.
      .          .          .          .               pub fn push(&mut self, item: ClassSetItem) {
  8,782 ( 0.00%) .          .          .                   if self.items.is_empty() {
 14,049 ( 0.00%) .          .          .                       self.span.start = item.span().start;
      .          .          .          .                   }
 21,882 ( 0.01%) .          .          .                   self.span.end = item.span().end;
      .          .          .          .                   self.items.push(item);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return this union as a character class set item.
      .          .          .          .               ///
      .          .          .          .               /// If this union contains zero items, then an empty union is
      .          .          .          .               /// returned. If this concatenation contains exactly 1 item, then the
      .          .          .          .               /// corresponding item is returned. Otherwise, ClassSetItem::Union is
      .          .          .          .               /// returned.
      .          .          .          .               pub fn into_item(mut self) -> ClassSetItem {
 11,296 ( 0.00%) .          .          .                   match self.items.len() {
      .          .          .          .                       0 => ClassSetItem::Empty(self.span),
      .          .          .          .                       1 => self.items.pop().unwrap(),
  5,775 ( 0.00%) .          .          .                       _ => ClassSetItem::Union(self),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A Unicode character class set operation.
      .          .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
      .          .          .          .           pub struct ClassSetBinaryOp {
-- line 1276 ----------------------------------------
-- line 1394 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl RepetitionRange {
      .          .          .          .               /// Returns true if and only if this repetition range is valid.
      .          .          .          .               ///
      .          .          .          .               /// The only case where a repetition range is invalid is if it is bounded
      .          .          .          .               /// and its start is greater than its end.
      .          .          .          .               pub fn is_valid(&self) -> bool {
    688 ( 0.00%) .          .          .                   match *self {
      .          .          .          .                       RepetitionRange::Bounded(s, e) if s > e => false,
      .          .          .          .                       _ => true,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A grouped regular expression.
      .          .          .          .           ///
-- line 1410 ----------------------------------------
-- line 1422 ----------------------------------------
      .          .          .          .               /// The regular expression in this group.
      .          .          .          .               pub ast: Box<Ast>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Group {
      .          .          .          .               /// If this group is non-capturing, then this returns the (possibly empty)
      .          .          .          .               /// set of flags. Otherwise, `None` is returned.
      .          .          .          .               pub fn flags(&self) -> Option<&Flags> {
  4,851 ( 0.00%) .          .          .                   match self.kind {
      .          .          .          .                       GroupKind::NonCapturing(ref flags) => Some(flags),
      .          .          .          .                       _ => None,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if this group is capturing.
      .          .          .          .               pub fn is_capturing(&self) -> bool {
      .          .          .          .                   match self.kind {
-- line 1438 ----------------------------------------
-- line 1469 ----------------------------------------
      .          .          .          .               /// `(?:a)` and `(?i:a)`
      .          .          .          .               NonCapturing(Flags),
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A capture name.
      .          .          .          .           ///
      .          .          .          .           /// This corresponds to the name itself between the angle brackets in, e.g.,
      .          .          .          .           /// `(?P<foo>expr)`.
  1,758 ( 0.00%) .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
 72,094 ( 0.02%) 67 ( 0.01%) .          .           => /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/string.rs:<alloc::string::String as core::clone::Clone>::clone (586x)
      .          .          .          .           pub struct CaptureName {
      .          .          .          .               /// The span of this capture name.
      .          .          .          .               pub span: Span,
      .          .          .          .               /// The capture name.
      .          .          .          .               pub name: String,
      .          .          .          .               /// The capture index.
      .          .          .          .               pub index: u32,
      .          .          .          .           }
-- line 1485 ----------------------------------------
-- line 1559 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// If the given flag is in the set and is not negated, then `Some(true)`
      .          .          .          .               /// is returned.
      .          .          .          .               ///
      .          .          .          .               /// Otherwise, `None` is returned.
      .          .          .          .               pub fn flag_state(&self, flag: Flag) -> Option<bool> {
      .          .          .          .                   let mut negated = false;
      .          .          .          .                   for x in &self.items {
    240 ( 0.00%) .          .          .                       match x.kind {
      .          .          .          .                           FlagsItemKind::Negation => {
      .          .          .          .                               negated = true;
      .          .          .          .                           }
      .          .          .          .                           FlagsItemKind::Flag(ref xflag) if xflag == &flag => {
      .          .          .          .                               return Some(!negated);
      .          .          .          .                           }
      .          .          .          .                           _ => {}
      .          .          .          .                       }
-- line 1575 ----------------------------------------
-- line 1584 ----------------------------------------
      .          .          .          .           pub struct FlagsItem {
      .          .          .          .               /// The span of this item.
      .          .          .          .               pub span: Span,
      .          .          .          .               /// The kind of this item.
      .          .          .          .               pub kind: FlagsItemKind,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// The kind of an item in a group of flags.
     50 ( 0.00%) .          .          .           #[derive(Clone, Debug, Eq, PartialEq)]
      .          .          .          .           #[cfg_attr(feature = "arbitrary", derive(arbitrary::Arbitrary))]
      .          .          .          .           pub enum FlagsItemKind {
      .          .          .          .               /// A negation operator applied to all subsequent flags in the enclosing
      .          .          .          .               /// group.
      .          .          .          .               Negation,
      .          .          .          .               /// A single flag in a group.
      .          .          .          .               Flag(Flag),
      .          .          .          .           }
-- line 1600 ----------------------------------------
-- line 1627 ----------------------------------------
      .          .          .          .               CRLF,
      .          .          .          .               /// `x`
      .          .          .          .               IgnoreWhitespace,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A custom `Drop` impl is used for `Ast` such that it uses constant stack
      .          .          .          .           /// space but heap space proportional to the depth of the `Ast`.
      .          .          .          .           impl Drop for Ast {
522,256 ( 0.16%) .          .          .               fn drop(&mut self) {
      .          .          .          .                   use core::mem;
      .          .          .          .           
318,609 ( 0.10%) .          .          .                   match *self {
      .          .          .          .                       Ast::Empty(_)
      .          .          .          .                       | Ast::Flags(_)
      .          .          .          .                       | Ast::Literal(_)
      .          .          .          .                       | Ast::Dot(_)
      .          .          .          .                       | Ast::Assertion(_)
      .          .          .          .                       | Ast::ClassUnicode(_)
      .          .          .          .                       | Ast::ClassPerl(_)
      .          .          .          .                       // Bracketed classes are recursive, they get their own Drop impl.
      .          .          .          .                       | Ast::ClassBracketed(_) => return,
  3,770 ( 0.00%) .          .          .                       Ast::Repetition(ref x) if !x.ast.has_subexprs() => return,
  1,386 ( 0.00%) .          .          .                       Ast::Group(ref x) if !x.ast.has_subexprs() => return,
      .          .          .          .                       Ast::Alternation(ref x) if x.asts.is_empty() => return,
      .          .          .          .                       Ast::Concat(ref x) if x.asts.is_empty() => return,
      .          .          .          .                       _ => {}
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   let empty_span = || Span::splat(Position::new(0, 0, 0));
      .          .          .          .                   let empty_ast = || Ast::empty(empty_span());
    243 ( 0.00%) .          .          .                   let mut stack = vec![mem::replace(self, empty_ast())];
142,512 ( 0.04%) .          .          .                   while let Some(mut ast) = stack.pop() {
218,016 ( 0.07%) .          .          .                       match ast {
      .          .          .          .                           Ast::Empty(_)
      .          .          .          .                           | Ast::Flags(_)
      .          .          .          .                           | Ast::Literal(_)
      .          .          .          .                           | Ast::Dot(_)
      .          .          .          .                           | Ast::Assertion(_)
      .          .          .          .                           | Ast::ClassUnicode(_)
      .          .          .          .                           | Ast::ClassPerl(_)
      .          .          .          .                           // Bracketed classes are recursive, so they get their own Drop
      .          .          .          .                           // impl.
      .          .          .          .                           | Ast::ClassBracketed(_) => {}
      .          .          .          .                           Ast::Repetition(ref mut x) => {
  1,885 ( 0.00%) .          .          .                               stack.push(mem::replace(&mut x.ast, empty_ast()));
      .          .          .          .                           }
      .          .          .          .                           Ast::Group(ref mut x) => {
    693 ( 0.00%) .          .          .                               stack.push(mem::replace(&mut x.ast, empty_ast()));
      .          .          .          .                           }
      .          .          .          .                           Ast::Alternation(ref mut x) => {
      .          .          .          .                               stack.extend(x.asts.drain(..));
    512 ( 0.00%) .          .          .                           }
      .          .          .          .                           Ast::Concat(ref mut x) => {
      .          .          .          .                               stack.extend(x.asts.drain(..));
      .          .          .          .                           }
      .          .          .          .                       }
142,512 ( 0.04%) .          .          .                   }
16,810,488 ( 5.05%) 99,702 (12.31%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<regex_syntax::ast::Ast>'2 (71,256x)
596,864 ( 0.18%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A custom `Drop` impl is used for `ClassSet` such that it uses constant
      .          .          .          .           /// stack space but heap space proportional to the depth of the `ClassSet`.
      .          .          .          .           impl Drop for ClassSet {
 67,248 ( 0.02%) .          .          .               fn drop(&mut self) {
      .          .          .          .                   use core::mem;
      .          .          .          .           
 25,218 ( 0.01%) .          .          .                   match *self {
 54,451 ( 0.02%) .          .          .                       ClassSet::Item(ref item) => match *item {
      .          .          .          .                           ClassSetItem::Empty(_)
      .          .          .          .                           | ClassSetItem::Literal(_)
      .          .          .          .                           | ClassSetItem::Range(_)
      .          .          .          .                           | ClassSetItem::Ascii(_)
      .          .          .          .                           | ClassSetItem::Unicode(_)
      .          .          .          .                           | ClassSetItem::Perl(_) => return,
      .          .          .          .                           ClassSetItem::Bracketed(ref x) => {
    141 ( 0.00%) .          .          .                               if x.kind.is_empty() {
      .          .          .          .                                   return;
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                           ClassSetItem::Union(ref x) => {
  7,748 ( 0.00%) .          .          .                               if x.items.is_empty() {
      .          .          .          .                                   return;
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                       },
      .          .          .          .                       ClassSet::BinaryOp(ref op) => {
      .          .          .          .                           if op.lhs.is_empty() && op.rhs.is_empty() {
      .          .          .          .                               return;
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   let empty_span = || Span::splat(Position::new(0, 0, 0));
      .          .          .          .                   let empty_set = || ClassSet::Item(ClassSetItem::Empty(empty_span()));
      .          .          .          .                   let mut stack = vec![mem::replace(self, empty_set())];
 24,822 ( 0.01%) .          .          .                   while let Some(mut set) = stack.pop() {
 82,740 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,758x)
  5,516 ( 0.00%) .          .          .                       match set {
 17,144 ( 0.01%) .          .          .                           ClassSet::Item(ref mut item) => match *item {
      .          .          .          .                               ClassSetItem::Empty(_)
      .          .          .          .                               | ClassSetItem::Literal(_)
      .          .          .          .                               | ClassSetItem::Range(_)
      .          .          .          .                               | ClassSetItem::Ascii(_)
      .          .          .          .                               | ClassSetItem::Unicode(_)
      .          .          .          .                               | ClassSetItem::Perl(_) => {}
      .          .          .          .                               ClassSetItem::Bracketed(ref mut x) => {
     71 ( 0.00%) .          .          .                                   stack.push(mem::replace(&mut x.kind, empty_set()));
      .          .          .          .                               }
      .          .          .          .                               ClassSetItem::Union(ref mut x) => {
      .          .          .          .                                   stack.extend(x.items.drain(..).map(ClassSet::Item));
      .          .          .          .                               }
      .          .          .          .                           },
      .          .          .          .                           ClassSet::BinaryOp(ref mut op) => {
      .          .          .          .                               stack.push(mem::replace(&mut op.lhs, empty_set()));
      .          .          .          .                               stack.push(mem::replace(&mut op.rhs, empty_set()));
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
 67,248 ( 0.02%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[cfg(test)]
      .          .          .          .           mod tests {
      .          .          .          .               use super::*;
      .          .          .          .           
      .          .          .          .               // We use a thread with an explicit stack size to test that our destructor
      .          .          .          .               // for Ast can handle arbitrarily sized expressions in constant stack
-- line 1752 ----------------------------------------

 74,845 ( 0.02%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 536 ----------------------------------------
        .          .          .          .               /// let five = c.get();
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[rustc_const_unstable(feature = "const_cell", issue = "131283")]
        .          .          .          .               pub const fn get(&self) -> T {
        .          .          .          .                   // SAFETY: This can cause data races if called from a separate thread,
        .          .          .          .                   // but `Cell` is `!Sync` so this won't happen.
1,521,200 ( 0.46%) .          .          .                   unsafe { *self.value.get() }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Updates the contained value using a function and returns the new value.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
        .          .          .          .               /// ```
        .          .          .          .               /// #![feature(cell_update)]
-- line 552 ----------------------------------------
-- line 826 ----------------------------------------
        .          .          .          .           
        .          .          .          .           #[inline(always)]
        .          .          .          .           fn is_writing(x: BorrowFlag) -> bool {
        .          .          .          .               x < UNUSED
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[inline(always)]
        .          .          .          .           fn is_reading(x: BorrowFlag) -> bool {
    7,269 ( 0.00%) .          .          .               x > UNUSED
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<T> RefCell<T> {
        .          .          .          .               /// Creates a new `RefCell` containing `value`.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
        .          .          .          .               /// ```
-- line 842 ----------------------------------------
-- line 1408 ----------------------------------------
        .          .          .          .           struct BorrowRef<'b> {
        .          .          .          .               borrow: &'b Cell<BorrowFlag>,
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'b> BorrowRef<'b> {
        .          .          .          .               #[inline]
        .          .          .          .               fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRef<'b>> {
        .          .          .          .                   let b = borrow.get().wrapping_add(1);
    3,675 ( 0.00%) .          .          .                   if !is_reading(b) {
        .          .          .          .                       // Incrementing borrow can result in a non-reading value (<= 0) in these cases:
        .          .          .          .                       // 1. It was < 0, i.e. there are writing borrows, so we can't allow a read borrow
        .          .          .          .                       //    due to Rust's reference aliasing rules
        .          .          .          .                       // 2. It was isize::MAX (the max amount of reading borrows) and it overflowed
        .          .          .          .                       //    into isize::MIN (the max amount of writing borrows) so we can't allow
        .          .          .          .                       //    an additional read borrow because isize can't represent so many read borrows
        .          .          .          .                       //    (this can only happen if you mem::forget more than a small constant amount of
        .          .          .          .                       //    `Ref`s, which is not good practice)
-- line 1424 ----------------------------------------
-- line 1804 ----------------------------------------
        .          .          .          .               borrow: &'b Cell<BorrowFlag>,
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl Drop for BorrowRefMut<'_> {
        .          .          .          .               #[inline]
        .          .          .          .               fn drop(&mut self) {
        .          .          .          .                   let borrow = self.borrow.get();
        .          .          .          .                   debug_assert!(is_writing(borrow));
   67,375 ( 0.02%) .          .          .                   self.borrow.set(borrow + 1);
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<'b> BorrowRefMut<'b> {
        .          .          .          .               #[inline]
        .          .          .          .               fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRefMut<'b>> {
        .          .          .          .                   // NOTE: Unlike BorrowRefMut::clone, new is called to create the initial
        .          .          .          .                   // mutable reference, and so there must currently be no existing
        .          .          .          .                   // references. Thus, while clone increments the mutable refcount, here
        .          .          .          .                   // we explicitly only allow going from UNUSED to UNUSED - 1.
  684,303 ( 0.21%) .          .          .                   match borrow.get() {
        .          .          .          .                       UNUSED => {
        .          .          .          .                           borrow.set(UNUSED - 1);
        .          .          .          .                           Some(BorrowRefMut { borrow })
        .          .          .          .                       }
        .          .          .          .                       _ => None,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
-- line 1831 ----------------------------------------
-- line 2162 ----------------------------------------
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[rustc_const_stable(feature = "const_unsafecell_get", since = "1.32.0")]
        .          .          .          .               #[rustc_as_ptr]
        .          .          .          .               #[rustc_never_returns_null_ptr]
        .          .          .          .               pub const fn get(&self) -> *mut T {
        .          .          .          .                   // We can just cast the pointer from `UnsafeCell<T>` to `T` because of
        .          .          .          .                   // #[repr(transparent)]. This exploits std's special status, there is
        .          .          .          .                   // no guarantee for user code that this will work in future versions of the compiler!
   57,468 ( 0.02%) .          .          .                   self as *const UnsafeCell<T> as *const T as *mut T
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns a mutable reference to the underlying data.
        .          .          .          .               ///
        .          .          .          .               /// This call borrows the `UnsafeCell` mutably (at compile-time) which
        .          .          .          .               /// guarantees that we possess the only reference.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
-- line 2178 ----------------------------------------

  293,313 ( 0.09%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/visitor.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 110 ----------------------------------------
      .          .          .          .           /// analysis over an `Ast` without using a stack size proportional to the depth
      .          .          .          .           /// of the `Ast`. Namely, this method will instead use constant stack size, but
      .          .          .          .           /// will use heap space proportional to the size of the `Ast`. This may be
      .          .          .          .           /// desirable in cases where the size of `Ast` is proportional to end user
      .          .          .          .           /// input.
      .          .          .          .           ///
      .          .          .          .           /// If the visitor returns an error at any point, then visiting is stopped and
      .          .          .          .           /// the error is returned.
  1,539 ( 0.00%) .          .          .           pub fn visit<V: Visitor>(ast: &Ast, visitor: V) -> Result<V::Output, V::Err> {
      .          .          .          .               HeapVisitor::new().visit(ast, visitor)
  1,296 ( 0.00%) .          .          .           }
      .          .          .          .           
      .          .          .          .           /// HeapVisitor visits every item in an `Ast` recursively using constant stack
      .          .          .          .           /// size and a heap size proportional to the size of the `Ast`.
      .          .          .          .           struct HeapVisitor<'a> {
      .          .          .          .               /// A stack of `Ast` nodes. This is roughly analogous to the call stack
      .          .          .          .               /// used in a typical recursive visitor.
      .          .          .          .               stack: Vec<(&'a Ast, Frame<'a>)>,
      .          .          .          .               /// Similar to the `Ast` stack above, but is used only for character
-- line 128 ----------------------------------------
-- line 194 ----------------------------------------
      .          .          .          .           /// syntax, which is not possible.)
      .          .          .          .           enum ClassInduct<'a> {
      .          .          .          .               Item(&'a ast::ClassSetItem),
      .          .          .          .               BinaryOp(&'a ast::ClassSetBinaryOp),
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'a> HeapVisitor<'a> {
      .          .          .          .               fn new() -> HeapVisitor<'a> {
    486 ( 0.00%) .          .          .                   HeapVisitor { stack: vec![], stack_class: vec![] }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn visit<V: Visitor>(
      .          .          .          .                   &mut self,
      .          .          .          .                   mut ast: &'a Ast,
      .          .          .          .                   mut visitor: V,
      .          .          .          .               ) -> Result<V::Output, V::Err> {
      .          .          .          .                   self.stack.clear();
      .          .          .          .                   self.stack_class.clear();
      .          .          .          .           
      .          .          .          .                   visitor.start();
      .          .          .          .                   loop {
285,024 ( 0.09%) .          .          .                       visitor.visit_pre(ast)?;
2,619,293 ( 0.79%) 1,256 ( 0.16%) 3 ( 1.00%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_pre (71,256x)
185,770 ( 0.06%) .          .          .                       if let Some(x) = self.induct(ast, &mut visitor)? {
      .          .          .          .                           let child = x.child();
      .          .          .          .                           self.stack.push((ast, x));
      .          .          .          .                           ast = child;
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       // No induction means we have a base case, so we can post visit
      .          .          .          .                       // it now.
209,520 ( 0.06%) .          .          .                       visitor.visit_post(ast)?;
      .          .          .          .           
      .          .          .          .                       // At this point, we now try to pop our call stack until it is
      .          .          .          .                       // either empty or we hit another inductive case.
      .          .          .          .                       loop {
494,220 ( 0.15%) .          .          .                           let (post_ast, frame) = match self.stack.pop() {
    567 ( 0.00%) .          .          .                               None => return visitor.finish(),
  6,399 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::finish (81x)
      .          .          .          .                               Some((post_ast, frame)) => (post_ast, frame),
      .          .          .          .                           };
      .          .          .          .                           // If this is a concat/alternate, then we might have additional
      .          .          .          .                           // inductive steps to process.
      .          .          .          .                           if let Some(x) = self.pop(frame) {
      .          .          .          .                               match x {
      .          .          .          .                                   Frame::Alternation { .. } => {
      .          .          .          .                                       visitor.visit_alternation_in()?;
-- line 238 ----------------------------------------
-- line 243 ----------------------------------------
      .          .          .          .                                   _ => {}
      .          .          .          .                               }
      .          .          .          .                               ast = x.child();
      .          .          .          .                               self.stack.push((post_ast, x));
      .          .          .          .                               break;
      .          .          .          .                           }
      .          .          .          .                           // Otherwise, we've finished visiting all the child nodes for
      .          .          .          .                           // this AST, so we can post visit it now.
 56,628 ( 0.02%) .          .          .                           visitor.visit_post(post_ast)?;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Build a stack frame for the given AST if one is needed (which occurs if
      .          .          .          .               /// and only if there are child nodes in the AST). Otherwise, return None.
      .          .          .          .               ///
      .          .          .          .               /// If this visits a class, then the underlying visitor implementation may
      .          .          .          .               /// return an error which will be passed on here.
      .          .          .          .               fn induct<V: Visitor>(
      .          .          .          .                   &mut self,
      .          .          .          .                   ast: &'a Ast,
      .          .          .          .                   visitor: &mut V,
      .          .          .          .               ) -> Result<Option<Frame<'a>>, V::Err> {
557,310 ( 0.17%) .          .          .                   Ok(match *ast {
      .          .          .          .                       Ast::ClassBracketed(ref x) => {
      .          .          .          .                           self.visit_class(x, visitor)?;
      .          .          .          .                           None
      .          .          .          .                       }
      .          .          .          .                       Ast::Repetition(ref x) => Some(Frame::Repetition(x)),
      .          .          .          .                       Ast::Group(ref x) => Some(Frame::Group(x)),
 63,144 ( 0.02%) .          .          .                       Ast::Concat(ref x) if x.asts.is_empty() => None,
      .          .          .          .                       Ast::Concat(ref x) => {
      .          .          .          .                           Some(Frame::Concat { head: &x.asts[0], tail: &x.asts[1..] })
      .          .          .          .                       }
  2,048 ( 0.00%) .          .          .                       Ast::Alternation(ref x) if x.asts.is_empty() => None,
      .          .          .          .                       Ast::Alternation(ref x) => Some(Frame::Alternation {
      .          .          .          .                           head: &x.asts[0],
      .          .          .          .                           tail: &x.asts[1..],
      .          .          .          .                       }),
      .          .          .          .                       _ => None,
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Pops the given frame. If the frame has an additional inductive step,
      .          .          .          .               /// then return it, otherwise return `None`.
      .          .          .          .               fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {
353,297 ( 0.11%) .          .          .                   match induct {
      .          .          .          .                       Frame::Repetition(_) => None,
      .          .          .          .                       Frame::Group(_) => None,
      .          .          .          .                       Frame::Concat { tail, .. } => {
140,682 ( 0.04%) .          .          .                           if tail.is_empty() {
      .          .          .          .                               None
      .          .          .          .                           } else {
      .          .          .          .                               Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       Frame::Alternation { tail, .. } => {
 32,882 ( 0.01%) .          .          .                           if tail.is_empty() {
      .          .          .          .                               None
      .          .          .          .                           } else {
      .          .          .          .                               Some(Frame::Alternation {
      .          .          .          .                                   head: &tail[0],
      .          .          .          .                                   tail: &tail[1..],
      .          .          .          .                               })
      .          .          .          .                           }
      .          .          .          .                       }
-- line 308 ----------------------------------------
-- line 310 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn visit_class<V: Visitor>(
      .          .          .          .                   &mut self,
      .          .          .          .                   ast: &'a ast::ClassBracketed,
      .          .          .          .                   visitor: &mut V,
      .          .          .          .               ) -> Result<(), V::Err> {
      .          .          .          .                   let mut ast = ClassInduct::from_bracketed(ast);
  1,567 ( 0.00%) .          .          .                   loop {
      .          .          .          .                       self.visit_class_pre(&ast, visitor)?;
      .          .          .          .                       if let Some(x) = self.induct_class(&ast) {
      .          .          .          .                           let child = x.child();
      .          .          .          .                           self.stack_class.push((ast, x));
      .          .          .          .                           ast = child;
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       self.visit_class_post(&ast, visitor)?;
-- line 326 ----------------------------------------
-- line 350 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Call the appropriate `Visitor` methods given an inductive step.
      .          .          .          .               fn visit_class_pre<V: Visitor>(
      .          .          .          .                   &self,
      .          .          .          .                   ast: &ClassInduct<'a>,
      .          .          .          .                   visitor: &mut V,
      .          .          .          .               ) -> Result<(), V::Err> {
 27,333 ( 0.01%) .          .          .                   match *ast {
      .          .          .          .                       ClassInduct::Item(item) => {
  9,832 ( 0.00%) .          .          .                           visitor.visit_class_set_item_pre(item)?;
 80,556 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_pre (4,916x)
      .          .          .          .                       }
      .          .          .          .                       ClassInduct::BinaryOp(op) => {
  4,916 ( 0.00%) .          .          .                           visitor.visit_class_set_binary_op_pre(op)?;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Ok(())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Call the appropriate `Visitor` methods given an inductive step.
      .          .          .          .               fn visit_class_post<V: Visitor>(
      .          .          .          .                   &self,
      .          .          .          .                   ast: &ClassInduct<'a>,
      .          .          .          .                   visitor: &mut V,
      .          .          .          .               ) -> Result<(), V::Err> {
  2,384 ( 0.00%) .          .          .                   match *ast {
      .          .          .          .                       ClassInduct::Item(item) => {
 18,472 ( 0.01%) .          .          .                           visitor.visit_class_set_item_post(item)?;
1,716,692 ( 0.52%) 1,526 ( 0.19%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/translate.rs:<regex_syntax::hir::translate::TranslatorI as regex_syntax::ast::visitor::Visitor>::visit_class_set_item_post (4,916x)
      .          .          .          .                       }
      .          .          .          .                       ClassInduct::BinaryOp(op) => {
    596 ( 0.00%) .          .          .                           visitor.visit_class_set_binary_op_post(op)?;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Ok(())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Build a stack frame for the given class node if one is needed (which
      .          .          .          .               /// occurs if and only if there are child nodes). Otherwise, return None.
      .          .          .          .               fn induct_class(&self, ast: &ClassInduct<'a>) -> Option<ClassFrame<'a>> {
 43,932 ( 0.01%) .          .          .                   match *ast {
      .          .          .          .                       ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) => {
    568 ( 0.00%) .          .          .                           match x.kind {
      .          .          .          .                               ast::ClassSet::Item(ref item) => {
      .          .          .          .                                   Some(ClassFrame::Union { head: item, tail: &[] })
      .          .          .          .                               }
      .          .          .          .                               ast::ClassSet::BinaryOp(ref op) => {
      .          .          .          .                                   Some(ClassFrame::Binary { op })
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) => {
  2,100 ( 0.00%) .          .          .                           if x.items.is_empty() {
      .          .          .          .                               None
      .          .          .          .                           } else {
      .          .          .          .                               Some(ClassFrame::Union {
      .          .          .          .                                   head: &x.items[0],
      .          .          .          .                                   tail: &x.items[1..],
      .          .          .          .                               })
      .          .          .          .                           }
      .          .          .          .                       }
-- line 409 ----------------------------------------
-- line 412 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .                       _ => None,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Pops the given frame. If the frame has an additional inductive step,
      .          .          .          .               /// then return it, otherwise return `None`.
      .          .          .          .               fn pop_class(&self, induct: ClassFrame<'a>) -> Option<ClassFrame<'a>> {
 23,788 ( 0.01%) .          .          .                   match induct {
      .          .          .          .                       ClassFrame::Union { tail, .. } => {
  8,652 ( 0.00%) .          .          .                           if tail.is_empty() {
      .          .          .          .                               None
      .          .          .          .                           } else {
      .          .          .          .                               Some(ClassFrame::Union {
      .          .          .          .                                   head: &tail[0],
      .          .          .          .                                   tail: &tail[1..],
      .          .          .          .                               })
      .          .          .          .                           }
      .          .          .          .                       }
-- line 430 ----------------------------------------
-- line 437 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'a> Frame<'a> {
      .          .          .          .               /// Perform the next inductive step on this frame and return the next
      .          .          .          .               /// child AST node to visit.
      .          .          .          .               fn child(&self) -> &'a Ast {
      .          .          .          .                   match *self {
  7,540 ( 0.00%) .          .          .                       Frame::Repetition(rep) => &rep.ast,
  3,465 ( 0.00%) .          .          .                       Frame::Group(group) => &group.ast,
      .          .          .          .                       Frame::Concat { head, .. } => head,
      .          .          .          .                       Frame::Alternation { head, .. } => head,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'a> ClassFrame<'a> {
      .          .          .          .               /// Perform the next inductive step on this frame and return the next
-- line 454 ----------------------------------------
-- line 468 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'a> ClassInduct<'a> {
      .          .          .          .               fn from_bracketed(ast: &'a ast::ClassBracketed) -> ClassInduct<'a> {
      .          .          .          .                   ClassInduct::from_set(&ast.kind)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn from_set(ast: &'a ast::ClassSet) -> ClassInduct<'a> {
 16,518 ( 0.00%) .          .          .                   match *ast {
      .          .          .          .                       ast::ClassSet::Item(ref item) => ClassInduct::Item(item),
      .          .          .          .                       ast::ClassSet::BinaryOp(ref op) => ClassInduct::BinaryOp(op),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'a> core::fmt::Debug for ClassFrame<'a> {
      .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
-- line 484 ----------------------------------------

759,406 ( 0.23%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/ast/visitor.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 220 ----------------------------------------
      .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .               fn count(self) -> usize
      .          .          .          .               where
      .          .          .          .                   Self: Sized,
      .          .          .          .               {
      .          .          .          .                   self.fold(
      .          .          .          .                       0,
      .          .          .          .                       #[rustc_inherit_overflow_checks]
    903 ( 0.00%) .          .          .                       |count, _| count + 1,
      .          .          .          .                   )
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Consumes the iterator, returning the last element.
      .          .          .          .               ///
      .          .          .          .               /// This method will evaluate the iterator until it returns [`None`]. While
      .          .          .          .               /// doing so, it keeps track of the current element. After [`None`] is
      .          .          .          .               /// returned, `last()` will then return the last element it saw.
-- line 236 ----------------------------------------
-- line 789 ----------------------------------------
      .          .          .          .               #[stable(feature = "iterator_for_each", since = "1.21.0")]
      .          .          .          .               fn for_each<F>(self, f: F)
      .          .          .          .               where
      .          .          .          .                   Self: Sized,
      .          .          .          .                   F: FnMut(Self::Item),
      .          .          .          .               {
      .          .          .          .                   #[inline]
      .          .          .          .                   fn call<T>(mut f: impl FnMut(T)) -> impl FnMut((), T) {
    405 ( 0.00%) .          .          .                       move |(), item| f(item)
      .          .          .          .                   }
      .          .          .          .           
     83 ( 0.00%) .          .          .                   self.fold((), call(f));
    135 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::fold (1x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates an iterator which uses a closure to determine if an element
      .          .          .          .               /// should be yielded.
      .          .          .          .               ///
      .          .          .          .               /// Given an element the closure must return `true` or `false`. The returned
      .          .          .          .               /// iterator will yield only the elements for which the closure returns
      .          .          .          .               /// `true`.
-- line 808 ----------------------------------------
-- line 1963 ----------------------------------------
      .          .          .          .               #[inline]
      .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .               #[must_use = "if you really need to exhaust the iterator, consider `.for_each(drop)` instead"]
      .          .          .          .               #[cfg_attr(not(test), rustc_diagnostic_item = "iterator_collect_fn")]
      .          .          .          .               fn collect<B: FromIterator<Self::Item>>(self) -> B
      .          .          .          .               where
      .          .          .          .                   Self: Sized,
      .          .          .          .               {
      2 ( 0.00%) .          .          .                   FromIterator::from_iter(self)
    274 ( 0.00%) 2 ( 0.00%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed/iter.rs:alloc::boxed::iter::<impl core::iter::traits::collect::FromIterator<I> for alloc::boxed::Box<[I]>>::from_iter (1x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Fallibly transforms an iterator into a collection, short circuiting if
      .          .          .          .               /// a failure is encountered.
      .          .          .          .               ///
      .          .          .          .               /// `try_collect()` is a variation of [`collect()`][`collect`] that allows fallible
      .          .          .          .               /// conversions during collection. Its main use case is simplifying conversions from
      .          .          .          .               /// iterators yielding [`Option<T>`][`Option`] into `Option<Collection<T>>`, or similarly for other [`Try`]
-- line 1979 ----------------------------------------
-- line 2361 ----------------------------------------
      .          .          .          .               #[stable(feature = "iterator_try_fold", since = "1.27.0")]
      .          .          .          .               fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R
      .          .          .          .               where
      .          .          .          .                   Self: Sized,
      .          .          .          .                   F: FnMut(B, Self::Item) -> R,
      .          .          .          .                   R: Try<Output = B>,
      .          .          .          .               {
      .          .          .          .                   let mut accum = init;
 39,034 ( 0.01%) .          .          .                   while let Some(x) = self.next() {
 10,900 ( 0.00%) .          .          .                       accum = f(accum, x)?;
      .          .          .          .                   }
      .          .          .          .                   try { accum }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// An iterator method that applies a fallible function to each item in the
      .          .          .          .               /// iterator, stopping at the first error and returning that error.
      .          .          .          .               ///
      .          .          .          .               /// This can also be thought of as the fallible form of [`for_each()`]
-- line 2378 ----------------------------------------
-- line 2537 ----------------------------------------
      .          .          .          .               #[inline]
      .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .               fn fold<B, F>(mut self, init: B, mut f: F) -> B
      .          .          .          .               where
      .          .          .          .                   Self: Sized,
      .          .          .          .                   F: FnMut(B, Self::Item) -> B,
      .          .          .          .               {
      .          .          .          .                   let mut accum = init;
274,732 ( 0.08%) .          .          .                   while let Some(x) = self.next() {
 40,645 ( 0.01%) 54 ( 0.01%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:<alloc::collections::btree::map::ExtractIf<K,V,F,A> as core::iter::traits::iterator::Iterator>::next (175x)
    175 ( 0.00%) .          .          .                       accum = f(accum, x);
      .          .          .          .                   }
      .          .          .          .                   accum
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Reduces the elements to a single one, by repeatedly applying a reducing
      .          .          .          .               /// operation.
      .          .          .          .               ///
      .          .          .          .               /// If the iterator is empty, returns [`None`]; otherwise, returns the
-- line 2554 ----------------------------------------
-- line 2573 ----------------------------------------
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               #[stable(feature = "iterator_fold_self", since = "1.51.0")]
      .          .          .          .               fn reduce<F>(mut self, f: F) -> Option<Self::Item>
      .          .          .          .               where
      .          .          .          .                   Self: Sized,
      .          .          .          .                   F: FnMut(Self::Item, Self::Item) -> Self::Item,
      .          .          .          .               {
      6 ( 0.00%) .          .          .                   let first = self.next()?;
    132 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:<alloc::collections::btree::map::IterMut<K,V> as core::iter::traits::iterator::Iterator>::next (3x)
      3 ( 0.00%) .          .          .                   Some(self.fold(first, f))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Reduces the elements to a single one by repeatedly applying a reducing operation. If the
      .          .          .          .               /// closure returns a failure, the failure is propagated back to the caller immediately.
      .          .          .          .               ///
      .          .          .          .               /// The return type of this method depends on the return type of the closure. If the closure
      .          .          .          .               /// returns `Result<Self::Item, E>`, then this function will return `Result<Option<Self::Item>,
      .          .          .          .               /// E>`. If the closure returns `Option<Self::Item>`, then this function will return
-- line 2590 ----------------------------------------
-- line 2821 ----------------------------------------
      .          .          .          .               fn find<P>(&mut self, predicate: P) -> Option<Self::Item>
      .          .          .          .               where
      .          .          .          .                   Self: Sized,
      .          .          .          .                   P: FnMut(&Self::Item) -> bool,
      .          .          .          .               {
      .          .          .          .                   #[inline]
      .          .          .          .                   fn check<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut((), T) -> ControlFlow<T> {
      .          .          .          .                       move |(), x| {
      6 ( 0.00%) .          .          .                           if predicate(&x) { ControlFlow::Break(x) } else { ControlFlow::Continue(()) }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   self.try_fold((), check(predicate)).break_value()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Applies function to the elements of iterator and returns
      .          .          .          .               /// the first non-none result.
-- line 2837 ----------------------------------------

 42,285 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 531 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// If `write` is a reference to a formatter, it is recommended to use
     .          .          .          .               /// [`Formatter::with_options`] instead as this can borrow the underlying
     .          .          .          .               /// `write`, thereby bypassing one layer of indirection.
     .          .          .          .               ///
     .          .          .          .               /// You may alternatively use [`FormattingOptions::create_formatter()`].
     .          .          .          .               #[unstable(feature = "formatting_options", issue = "118117")]
     .          .          .          .               pub fn new(write: &'a mut (dyn Write + 'a), options: FormattingOptions) -> Self {
14,942 ( 0.00%) .          .          .                   Formatter { options, buf: write }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Creates a new formatter based on this one with given [`FormattingOptions`].
     .          .          .          .               #[unstable(feature = "formatting_options", issue = "118117")]
     .          .          .          .               pub fn with_options<'b>(&'b mut self, options: FormattingOptions) -> Formatter<'b> {
     .          .          .          .                   Formatter { options, buf: self.buf }
     .          .          .          .               }
     .          .          .          .           }
-- line 547 ----------------------------------------
-- line 596 ----------------------------------------
     .          .          .          .               /// When using the format_args!() macro, this function is used to generate the
     .          .          .          .               /// Arguments structure.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn new_v1<const P: usize, const A: usize>(
     .          .          .          .                   pieces: &'a [&'static str; P],
     .          .          .          .                   args: &'a [rt::Argument<'a>; A],
     .          .          .          .               ) -> Arguments<'a> {
     .          .          .          .                   const { assert!(P >= A && P <= A + 1, "invalid args") }
    14 ( 0.00%) .          .          .                   Arguments { pieces, fmt: None, args }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Specifies nonstandard formatting parameters.
     .          .          .          .               ///
     .          .          .          .               /// An `rt::UnsafeArg` is required because the following invariants must be held
     .          .          .          .               /// in order for this function to be safe:
     .          .          .          .               /// 1. The `pieces` slice must be at least as long as `fmt`.
     .          .          .          .               /// 2. Every `rt::Placeholder::position` value within `fmt` must be a valid index of `args`.
-- line 612 ----------------------------------------
-- line 613 ----------------------------------------
     .          .          .          .               /// 3. Every `rt::Count::Param` within `fmt` must contain a valid index of `args`.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn new_v1_formatted(
     .          .          .          .                   pieces: &'a [&'static str],
     .          .          .          .                   args: &'a [rt::Argument<'a>],
     .          .          .          .                   fmt: &'a [rt::Placeholder],
     .          .          .          .                   _unsafe_arg: rt::UnsafeArg,
     .          .          .          .               ) -> Arguments<'a> {
    18 ( 0.00%) .          .          .                   Arguments { pieces, fmt: Some(fmt), args }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Estimates the length of the formatted text.
     .          .          .          .               ///
     .          .          .          .               /// This is intended to be used for setting initial `String` capacity
     .          .          .          .               /// when using `format!`. Note: this is neither the lower nor upper bound.
     .          .          .          .               #[inline]
     .          .          .          .               pub fn estimated_capacity(&self) -> usize {
-- line 629 ----------------------------------------
-- line 1904 ----------------------------------------
     .          .          .          .               /// assert_eq!(format!("{:0>8}", Foo(2)), "Foo 2");
     .          .          .          .               /// ```
     .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .               #[inline]
     .          .          .          .               pub fn write_fmt(&mut self, fmt: Arguments<'_>) -> Result {
     .          .          .          .                   if let Some(s) = fmt.as_statically_known_str() {
     .          .          .          .                       self.buf.write_str(s)
     .          .          .          .                   } else {
     2 ( 0.00%) .          .          .                       write(self.buf, fmt)
 2,114 ( 0.00%) 2 ( 0.00%) .          .           => /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/mod.rs:core::fmt::write (2x)
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns flags for formatting.
     .          .          .          .               #[must_use]
     .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .               #[deprecated(
     .          .          .          .                   since = "1.24.0",
-- line 1920 ----------------------------------------
-- line 2635 ----------------------------------------
     .          .          .          .           
     .          .          .          .           // Implementations of the core formatting traits
     .          .          .          .           
     .          .          .          .           macro_rules! fmt_refs {
     .          .          .          .               ($($tr:ident),*) => {
     .          .          .          .                   $(
     .          .          .          .                   #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .                   impl<T: ?Sized + $tr> $tr for &T {
     4 ( 0.00%) .          .          .                       fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }
     .          .          .          .                   }
     .          .          .          .                   #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .                   impl<T: ?Sized + $tr> $tr for &mut T {
 2,681 ( 0.00%) .          .          .                       fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }
   440 ( 0.00%) .          .          .           => /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/mod.rs:<str as core::fmt::Display>::fmt (2x)
     .          .          .          .                   }
     .          .          .          .                   )*
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }
     .          .          .          .           
     .          .          .          .           #[unstable(feature = "never_type", issue = "35121")]
-- line 2655 ----------------------------------------

 2,912 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 557 ----------------------------------------
        .          .          .          .               /// let x: Result<i32, &str> = Err("Some error message");
        .          .          .          .               /// assert_eq!(x.is_ok(), false);
        .          .          .          .               /// ```
        .          .          .          .               #[must_use = "if you intended to assert that this is ok, consider `.unwrap()` instead"]
        .          .          .          .               #[rustc_const_stable(feature = "const_result_basics", since = "1.48.0")]
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub const fn is_ok(&self) -> bool {
   34,870 ( 0.01%) .          .          .                   matches!(*self, Ok(_))
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns `true` if the result is [`Ok`] and the value inside of it matches a predicate.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
        .          .          .          .               /// ```
        .          .          .          .               /// let x: Result<u32, &str> = Ok(2);
-- line 573 ----------------------------------------
-- line 651 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// let x: Result<u32, &str> = Err("Nothing here");
        .          .          .          .               /// assert_eq!(x.ok(), None);
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[cfg_attr(not(test), rustc_diagnostic_item = "result_ok_method")]
        .          .          .          .               pub fn ok(self) -> Option<T> {
      162 ( 0.00%) .          .          .                   match self {
      183 ( 0.00%) .          .          .                       Ok(x) => Some(x),
    3,003 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (39x)
        .          .          .          .                       Err(_) => None,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Converts from `Result<T, E>` to [`Option<E>`].
        .          .          .          .               ///
        .          .          .          .               /// Converts `self` into an [`Option<E>`], consuming `self`,
        .          .          .          .               /// and discarding the success value, if any.
-- line 668 ----------------------------------------
-- line 764 ----------------------------------------
        .          .          .          .               ///         Ok(n) => println!("{n}"),
        .          .          .          .               ///         Err(..) => {}
        .          .          .          .               ///     }
        .          .          .          .               /// }
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U, E> {
      412 ( 0.00%) .          .          .                   match self {
    8,913 ( 0.00%) .          .          .                       Ok(t) => Ok(op(t)),
       30 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
        .          .          .          .                       Err(e) => Err(e),
        .          .          .          .                   }
        1 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the provided default (if [`Err`]), or
        .          .          .          .               /// applies a function to the contained value (if [`Ok`]).
        .          .          .          .               ///
        .          .          .          .               /// Arguments passed to `map_or` are eagerly evaluated; if you are passing
        .          .          .          .               /// the result of a function call, it is recommended to use [`map_or_else`],
        .          .          .          .               /// which is lazily evaluated.
        .          .          .          .               ///
-- line 784 ----------------------------------------
-- line 846 ----------------------------------------
        .          .          .          .               /// assert_eq!(x.map_err(stringify), Ok(2));
        .          .          .          .               ///
        .          .          .          .               /// let x: Result<u32, u32> = Err(13);
        .          .          .          .               /// assert_eq!(x.map_err(stringify), Err("error code: 13".to_string()));
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T, F> {
  843,785 ( 0.25%) .          .          .                   match self {
      818 ( 0.00%) .          .          .                       Ok(t) => Ok(t),
      445 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (5x)
        .          .          .          .                       Err(e) => Err(op(e)),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Calls a function with a reference to the contained value if [`Ok`].
        .          .          .          .               ///
        .          .          .          .               /// Returns the original result.
        .          .          .          .               ///
-- line 863 ----------------------------------------
-- line 1051 ----------------------------------------
        .          .          .          .               /// [`std::error`](../../std/error/index.html) module docs.
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
        .          .          .          .               #[stable(feature = "result_expect", since = "1.4.0")]
        .          .          .          .               pub fn expect(self, msg: &str) -> T
        .          .          .          .               where
        .          .          .          .                   E: fmt::Debug,
        .          .          .          .               {
    3,752 ( 0.00%) .          .          .                   match self {
       31 ( 0.00%) .          .          .                       Ok(t) => t,
        .          .          .          .                       Err(e) => unwrap_failed(msg, &e),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the contained [`Ok`] value, consuming the `self` value.
        .          .          .          .               ///
        .          .          .          .               /// Because this function may panic, its use is generally discouraged.
        .          .          .          .               /// Panics are meant for unrecoverable errors, and
-- line 1068 ----------------------------------------
-- line 1099 ----------------------------------------
        .          .          .          .               /// ```
        .          .          .          .               #[inline(always)]
        .          .          .          .               #[track_caller]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub fn unwrap(self) -> T
        .          .          .          .               where
        .          .          .          .                   E: fmt::Debug,
        .          .          .          .               {
   20,572 ( 0.01%) .          .          .                   match self {
      759 ( 0.00%) .          .          .                       Ok(t) => t,
    2,445 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (57x)
        .          .          .          .                       Err(e) => unwrap_failed("called `Result::unwrap()` on an `Err` value", &e),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the contained [`Ok`] value or a default
        .          .          .          .               ///
        .          .          .          .               /// Consumes the `self` argument then, if [`Ok`], returns the contained
        .          .          .          .               /// value, otherwise if [`Err`], returns the default value for that
-- line 1116 ----------------------------------------
-- line 1432 ----------------------------------------
        .          .          .          .               /// assert_eq!(x.unwrap_or(default), 9);
        .          .          .          .               ///
        .          .          .          .               /// let x: Result<u32, &str> = Err("error");
        .          .          .          .               /// assert_eq!(x.unwrap_or(default), default);
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub fn unwrap_or(self, default: T) -> T {
       79 ( 0.00%) .          .          .                   match self {
        .          .          .          .                       Ok(t) => t,
        .          .          .          .                       Err(_) => default,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the contained [`Ok`] value or computes it from a closure.
        .          .          .          .               ///
        .          .          .          .               ///
-- line 1448 ----------------------------------------
-- line 1453 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// assert_eq!(Ok(2).unwrap_or_else(count), 2);
        .          .          .          .               /// assert_eq!(Err("foo").unwrap_or_else(count), 3);
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {
    3,547 ( 0.00%) .          .          .                   match self {
       37 ( 0.00%) .          .          .                       Ok(t) => t,
        .          .          .          .                       Err(e) => op(e),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the contained [`Ok`] value, consuming the `self` value,
        .          .          .          .               /// without checking that the value is not an [`Err`].
        .          .          .          .               ///
        .          .          .          .               /// # Safety
-- line 1470 ----------------------------------------
-- line 1546 ----------------------------------------
        .          .          .          .               #[rustc_allow_const_fn_unstable(const_precise_live_drops)]
        .          .          .          .               pub const fn copied(self) -> Result<T, E>
        .          .          .          .               where
        .          .          .          .                   T: Copy,
        .          .          .          .               {
        .          .          .          .                   // FIXME(const-hack): this implementation, which sidesteps using `Result::map` since it's not const
        .          .          .          .                   // ready yet, should be reverted when possible to avoid code repetition
        .          .          .          .                   match self {
    1,156 ( 0.00%) .          .          .                       Ok(&v) => Ok(v),
        .          .          .          .                       Err(e) => Err(e),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Maps a `Result<&T, E>` to a `Result<T, E>` by cloning the contents of the
        .          .          .          .               /// `Ok` part.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
-- line 1562 ----------------------------------------
-- line 1993 ----------------------------------------
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn from_output(output: Self::Output) -> Self {
        .          .          .          .                   Ok(output)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
1,876,536 ( 0.56%) .          .          .                   match self {
1,406,754 ( 0.42%) .          .          .                       Ok(v) => ControlFlow::Continue(v),
   82,590 ( 0.02%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2,753x)
    1,345 ( 0.00%) .          .          .                       Err(e) => ControlFlow::Break(Err(e)),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[unstable(feature = "try_trait_v2", issue = "84277")]
        .          .          .          .           impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>> for Result<T, F> {
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
        .          .          .          .               fn from_residual(residual: Result<convert::Infallible, E>) -> Self {
        .          .          .          .                   match residual {
       80 ( 0.00%) .          .          .                       Err(e) => Err(From::from(e)),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           #[diagnostic::do_not_recommend]
        .          .          .          .           #[unstable(feature = "try_trait_v2_yeet", issue = "96374")]
        .          .          .          .           impl<T, E, F: From<E>> ops::FromResidual<ops::Yeet<E>> for Result<T, F> {
        .          .          .          .               #[inline]
        .          .          .          .               fn from_residual(ops::Yeet(e): ops::Yeet<E>) -> Self {
-- line 2022 ----------------------------------------

1,206,185 ( 0.36%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/id.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 159 ----------------------------------------
     .          .          .          .           /// assert_eq!(mat.offset(), 7);
     .          .          .          .           /// let mat = find_leftmost_first(&dfa, &mut cache, &haystack[10..])?.unwrap();
     .          .          .          .           /// assert_eq!(mat.pattern().as_usize(), 1);
     .          .          .          .           /// assert_eq!(mat.offset(), 5);
     .          .          .          .           ///
     .          .          .          .           /// # Ok::<(), Box<dyn std::error::Error>>(())
     .          .          .          .           /// ```
     .          .          .          .           #[derive(
   234 ( 0.00%) .          .          .               Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord,
     .          .          .          .           )]
     .          .          .          .           pub struct LazyStateID(u32);
     .          .          .          .           
     .          .          .          .           impl LazyStateID {
     .          .          .          .               #[cfg(any(target_pointer_width = "32", target_pointer_width = "64"))]
     .          .          .          .               const MAX_BIT: usize = 31;
     .          .          .          .           
     .          .          .          .               #[cfg(target_pointer_width = "16")]
-- line 175 ----------------------------------------
-- line 183 ----------------------------------------
     .          .          .          .               const MAX: usize = LazyStateID::MASK_MATCH - 1;
     .          .          .          .           
     .          .          .          .               /// Create a new lazy state ID.
     .          .          .          .               ///
     .          .          .          .               /// If the given identifier exceeds [`LazyStateID::MAX`], then this returns
     .          .          .          .               /// an error.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn new(id: usize) -> Result<LazyStateID, LazyStateIDError> {
 1,600 ( 0.00%) .          .          .                   if id > LazyStateID::MAX {
     .          .          .          .                       let attempted = u64::try_from(id).unwrap();
     .          .          .          .                       return Err(LazyStateIDError { attempted });
     .          .          .          .                   }
     .          .          .          .                   Ok(LazyStateID::new_unchecked(id))
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Create a new lazy state ID without checking whether the given value
     .          .          .          .               /// exceeds [`LazyStateID::MAX`].
-- line 199 ----------------------------------------
-- line 208 ----------------------------------------
     .          .          .          .           
     .          .          .          .               /// Return this lazy state ID as an untagged `usize`.
     .          .          .          .               ///
     .          .          .          .               /// If this lazy state ID is tagged, then the usize returned is the state
     .          .          .          .               /// ID without the tag. If the ID was not tagged, then the usize returned
     .          .          .          .               /// is equivalent to the state ID.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) fn as_usize_untagged(&self) -> usize {
68,638 ( 0.02%) .          .          .                   self.as_usize_unchecked() & LazyStateID::MAX
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return this lazy state ID as its raw internal `usize` value, which may
     .          .          .          .               /// be tagged (and thus greater than LazyStateID::MAX).
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) const fn as_usize_unchecked(&self) -> usize {
     .          .          .          .                   // FIXME: Use as_usize() once const functions in traits are stable.
   440 ( 0.00%) .          .          .                   self.0 as usize
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) const fn to_unknown(&self) -> LazyStateID {
     .          .          .          .                   LazyStateID::new_unchecked(
     .          .          .          .                       self.as_usize_unchecked() | LazyStateID::MASK_UNKNOWN,
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) const fn to_dead(&self) -> LazyStateID {
     .          .          .          .                   LazyStateID::new_unchecked(
   117 ( 0.00%) .          .          .                       self.as_usize_unchecked() | LazyStateID::MASK_DEAD,
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) const fn to_quit(&self) -> LazyStateID {
     .          .          .          .                   LazyStateID::new_unchecked(
   117 ( 0.00%) .          .          .                       self.as_usize_unchecked() | LazyStateID::MASK_QUIT,
     .          .          .          .                   )
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return this lazy state ID as a state ID that is tagged as a start
     .          .          .          .               /// state.
     .          .          .          .               #[inline]
     .          .          .          .               pub(crate) const fn to_start(&self) -> LazyStateID {
     .          .          .          .                   LazyStateID::new_unchecked(
-- line 252 ----------------------------------------
-- line 264 ----------------------------------------
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return true if and only if this lazy state ID is tagged.
     .          .          .          .               ///
     .          .          .          .               /// When a lazy state ID is tagged, then one can conclude that it is one
     .          .          .          .               /// of a match, start, dead, quit or unknown state.
     .          .          .          .               #[inline]
     .          .          .          .               pub const fn is_tagged(&self) -> bool {
   699 ( 0.00%) .          .          .                   self.as_usize_unchecked() > LazyStateID::MAX
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return true if and only if this represents a lazy state ID that is
     .          .          .          .               /// "unknown." That is, the state has not yet been created. When a caller
     .          .          .          .               /// sees this state ID, it generally means that a state has to be computed
     .          .          .          .               /// in order to proceed.
     .          .          .          .               #[inline]
     .          .          .          .               pub const fn is_unknown(&self) -> bool {
   682 ( 0.00%) .          .          .                   self.as_usize_unchecked() & LazyStateID::MASK_UNKNOWN > 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return true if and only if this represents a dead state. A dead state
     .          .          .          .               /// is a state that can never transition to any other state except the
     .          .          .          .               /// dead state. When a dead state is seen, it generally indicates that a
     .          .          .          .               /// search should stop.
     .          .          .          .               #[inline]
     .          .          .          .               pub const fn is_dead(&self) -> bool {
    43 ( 0.00%) .          .          .                   self.as_usize_unchecked() & LazyStateID::MASK_DEAD > 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return true if and only if this represents a quit state. A quit state
     .          .          .          .               /// is a state that is representationally equivalent to a dead state,
     .          .          .          .               /// except it indicates the automaton has reached a point at which it can
     .          .          .          .               /// no longer determine whether a match exists or not. In general, this
     .          .          .          .               /// indicates an error during search and the caller must either pass this
     .          .          .          .               /// error up or use a different search technique.
-- line 298 ----------------------------------------
-- line 305 ----------------------------------------
     .          .          .          .               /// start state.
     .          .          .          .               ///
     .          .          .          .               /// Note that if
     .          .          .          .               /// [`Config::specialize_start_states`](crate::hybrid::dfa::Config) is
     .          .          .          .               /// disabled (which is the default), then this will always return false
     .          .          .          .               /// since start states won't be tagged.
     .          .          .          .               #[inline]
     .          .          .          .               pub const fn is_start(&self) -> bool {
     1 ( 0.00%) .          .          .                   self.as_usize_unchecked() & LazyStateID::MASK_START > 0
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Return true if and only if this lazy state ID has been tagged as a
     .          .          .          .               /// match state.
     .          .          .          .               #[inline]
     .          .          .          .               pub const fn is_match(&self) -> bool {
    48 ( 0.00%) .          .          .                   self.as_usize_unchecked() & LazyStateID::MASK_MATCH > 0
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// This error occurs when a lazy state ID could not be constructed.
     .          .          .          .           ///
     .          .          .          .           /// This occurs when given an integer exceeding the maximum lazy state ID
     .          .          .          .           /// value.
     .          .          .          .           ///
-- line 328 ----------------------------------------

 1,197 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/id.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 381 ----------------------------------------
        .          .          .          .               #[stable(feature = "nonnull", since = "1.25.0")]
        .          .          .          .               #[rustc_const_stable(feature = "const_nonnull_as_ref", since = "1.73.0")]
        .          .          .          .               #[must_use]
        .          .          .          .               #[inline(always)]
        .          .          .          .               pub const unsafe fn as_ref<'a>(&self) -> &'a T {
        .          .          .          .                   // SAFETY: the caller must guarantee that `self` meets all the
        .          .          .          .                   // requirements for a reference.
        .          .          .          .                   // `cast_const` avoids a mutable raw pointer deref.
    6,757 ( 0.00%) .          .          .                   unsafe { &*self.as_ptr().cast_const() }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns a unique reference to the value. If the value may be uninitialized, [`as_uninit_mut`]
        .          .          .          .               /// must be used instead.
        .          .          .          .               ///
        .          .          .          .               /// For the shared counterpart see [`as_ref`].
        .          .          .          .               ///
        .          .          .          .               /// [`as_uninit_mut`]: NonNull::as_uninit_mut
-- line 397 ----------------------------------------
-- line 493 ----------------------------------------
        .          .          .          .               pub const unsafe fn offset(self, count: isize) -> Self
        .          .          .          .               where
        .          .          .          .                   T: Sized,
        .          .          .          .               {
        .          .          .          .                   // SAFETY: the caller must uphold the safety contract for `offset`.
        .          .          .          .                   // Additionally safety contract of `offset` guarantees that the resulting pointer is
        .          .          .          .                   // pointing to an allocation, there can't be an allocation at null, thus it's safe to
        .          .          .          .                   // construct `NonNull`.
   42,135 ( 0.01%) .          .          .                   unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Calculates the offset from a pointer in bytes.
        .          .          .          .               ///
        .          .          .          .               /// `count` is in units of **bytes**.
        .          .          .          .               ///
        .          .          .          .               /// This is purely a convenience for casting to a `u8` pointer and
        .          .          .          .               /// using [offset][pointer::offset] on it. See that method for documentation
-- line 509 ----------------------------------------
-- line 569 ----------------------------------------
        .          .          .          .               pub const unsafe fn add(self, count: usize) -> Self
        .          .          .          .               where
        .          .          .          .                   T: Sized,
        .          .          .          .               {
        .          .          .          .                   // SAFETY: the caller must uphold the safety contract for `offset`.
        .          .          .          .                   // Additionally safety contract of `offset` guarantees that the resulting pointer is
        .          .          .          .                   // pointing to an allocation, there can't be an allocation at null, thus it's safe to
        .          .          .          .                   // construct `NonNull`.
  132,904 ( 0.04%) .          .          .                   unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Calculates the offset from a pointer in bytes (convenience for `.byte_offset(count as isize)`).
        .          .          .          .               ///
        .          .          .          .               /// `count` is in units of bytes.
        .          .          .          .               ///
        .          .          .          .               /// This is purely a convenience for casting to a `u8` pointer and
        .          .          .          .               /// using [`add`][NonNull::add] on it. See that method for documentation
-- line 585 ----------------------------------------
-- line 1576 ----------------------------------------
        .          .          .          .           #[stable(feature = "nonnull", since = "1.25.0")]
        .          .          .          .           impl<T: ?Sized> Eq for NonNull<T> {}
        .          .          .          .           
        .          .          .          .           #[stable(feature = "nonnull", since = "1.25.0")]
        .          .          .          .           impl<T: ?Sized> PartialEq for NonNull<T> {
        .          .          .          .               #[inline]
        .          .          .          .               #[allow(ambiguous_wide_pointer_comparisons)]
        .          .          .          .               fn eq(&self, other: &Self) -> bool {
2,512,684 ( 0.75%) .          .          .                   self.as_ptr() == other.as_ptr()
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[stable(feature = "nonnull", since = "1.25.0")]
        .          .          .          .           impl<T: ?Sized> Ord for NonNull<T> {
        .          .          .          .               #[inline]
        .          .          .          .               #[allow(ambiguous_wide_pointer_comparisons)]
        .          .          .          .               fn cmp(&self, other: &Self) -> Ordering {
-- line 1592 ----------------------------------------

  140,824 ( 0.04%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 128 ----------------------------------------
      .          .          .          .                   /// ```
      .          .          .          .                   #[doc = concat!("[`ilog2`]: ", stringify!($SelfT), "::ilog2")]
      .          .          .          .                   #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
      .          .          .          .                   #[must_use = "this returns the result of the operation, \
      .          .          .          .                                 without modifying the original"]
      .          .          .          .                   #[inline(always)]
      .          .          .          .                   pub const fn leading_zeros(self) -> u32 {
    192 ( 0.00%) .          .          .                       return intrinsics::ctlz(self as $ActualT);
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Returns the number of trailing zeros in the binary representation
      .          .          .          .                   /// of `self`.
      .          .          .          .                   ///
      .          .          .          .                   /// # Examples
      .          .          .          .                   ///
      .          .          .          .                   /// Basic usage:
-- line 144 ----------------------------------------
-- line 154 ----------------------------------------
      .          .          .          .                   #[doc = concat!("assert_eq!(max.trailing_zeros(), 0);")]
      .          .          .          .                   /// ```
      .          .          .          .                   #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
      .          .          .          .                   #[must_use = "this returns the result of the operation, \
      .          .          .          .                                 without modifying the original"]
      .          .          .          .                   #[inline(always)]
      .          .          .          .                   pub const fn trailing_zeros(self) -> u32 {
    121 ( 0.00%) .          .          .                       return intrinsics::cttz(self);
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Returns the number of leading ones in the binary representation of `self`.
      .          .          .          .                   ///
      .          .          .          .                   /// # Examples
      .          .          .          .                   ///
      .          .          .          .                   /// Basic usage:
      .          .          .          .                   ///
-- line 170 ----------------------------------------
-- line 253 ----------------------------------------
      .          .          .          .                   #[doc = concat!("assert_eq!(n.rotate_left(", $rot, "), m);")]
      .          .          .          .                   /// ```
      .          .          .          .                   #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
      .          .          .          .                   #[must_use = "this returns the result of the operation, \
      .          .          .          .                                 without modifying the original"]
      .          .          .          .                   #[inline(always)]
      .          .          .          .                   pub const fn rotate_left(self, n: u32) -> Self {
 85,705 ( 0.03%) .          .          .                       return intrinsics::rotate_left(self, n);
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Shifts the bits to the right by a specified amount, `n`,
      .          .          .          .                   /// wrapping the truncated bits to the beginning of the resulting
      .          .          .          .                   /// integer.
      .          .          .          .                   ///
      .          .          .          .                   /// Please note this isn't the same operation as the `>>` shifting operator!
      .          .          .          .                   ///
-- line 269 ----------------------------------------
-- line 486 ----------------------------------------
      .          .          .          .                   pub const fn checked_add(self, rhs: Self) -> Option<Self> {
      .          .          .          .                       // This used to use `overflowing_add`, but that means it ends up being
      .          .          .          .                       // a `wrapping_add`, losing some optimization opportunities. Notably,
      .          .          .          .                       // phrasing it this way helps `.checked_add(1)` optimize to a check
      .          .          .          .                       // against `MAX` and a `add nuw`.
      .          .          .          .                       // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,
      .          .          .          .                       // LLVM is happy to re-form the intrinsic later if useful.
      .          .          .          .           
453,707 ( 0.14%) .          .          .                       if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {
      .          .          .          .                           None
      .          .          .          .                       } else {
      .          .          .          .                           // SAFETY: Just checked it doesn't overflow
473,297 ( 0.14%) .          .          .                           Some(unsafe { intrinsics::unchecked_add(self, rhs) })
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Strict integer addition. Computes `self + rhs`, panicking
      .          .          .          .                   /// if overflow occurred.
      .          .          .          .                   ///
      .          .          .          .                   /// # Panics
      .          .          .          .                   ///
-- line 506 ----------------------------------------
-- line 564 ----------------------------------------
      .          .          .          .                           (
      .          .          .          .                               lhs: $SelfT = self,
      .          .          .          .                               rhs: $SelfT = rhs,
      .          .          .          .                           ) => !lhs.overflowing_add(rhs).1,
      .          .          .          .                       );
      .          .          .          .           
      .          .          .          .                       // SAFETY: this is guaranteed to be safe by the caller.
      .          .          .          .                       unsafe {
 19,300 ( 0.01%) .          .          .                           intrinsics::unchecked_add(self, rhs)
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Checked addition with a signed integer. Computes `self + rhs`,
      .          .          .          .                   /// returning `None` if overflow occurred.
      .          .          .          .                   ///
      .          .          .          .                   /// # Examples
      .          .          .          .                   ///
-- line 580 ----------------------------------------
-- line 651 ----------------------------------------
      .          .          .          .                                 without modifying the original"]
      .          .          .          .                   #[inline]
      .          .          .          .                   pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
      .          .          .          .                       // Per PR#103299, there's no advantage to the `overflowing` intrinsic
      .          .          .          .                       // for *unsigned* subtraction and we just emit the manual check anyway.
      .          .          .          .                       // Thus, rather than using `overflowing_sub` that produces a wrapping
      .          .          .          .                       // subtraction, check it ourself so we can use an unchecked one.
      .          .          .          .           
 64,154 ( 0.02%) .          .          .                       if self < rhs {
      .          .          .          .                           None
      .          .          .          .                       } else {
      .          .          .          .                           // SAFETY: just checked this can't overflow
 21,833 ( 0.01%) .          .          .                           Some(unsafe { intrinsics::unchecked_sub(self, rhs) })
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Strict integer subtraction. Computes `self - rhs`, panicking if
      .          .          .          .                   /// overflow occurred.
      .          .          .          .                   ///
      .          .          .          .                   /// # Panics
      .          .          .          .                   ///
-- line 671 ----------------------------------------
-- line 754 ----------------------------------------
      .          .          .          .                           (
      .          .          .          .                               lhs: $SelfT = self,
      .          .          .          .                               rhs: $SelfT = rhs,
      .          .          .          .                           ) => !lhs.overflowing_sub(rhs).1,
      .          .          .          .                       );
      .          .          .          .           
      .          .          .          .                       // SAFETY: this is guaranteed to be safe by the caller.
      .          .          .          .                       unsafe {
    408 ( 0.00%) .          .          .                           intrinsics::unchecked_sub(self, rhs)
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Checked subtraction with a signed integer. Computes `self - rhs`,
      .          .          .          .                   /// returning `None` if overflow occurred.
      .          .          .          .                   ///
      .          .          .          .                   /// # Examples
      .          .          .          .                   ///
-- line 770 ----------------------------------------
-- line 937 ----------------------------------------
      .          .          .          .                           (
      .          .          .          .                               lhs: $SelfT = self,
      .          .          .          .                               rhs: $SelfT = rhs,
      .          .          .          .                           ) => !lhs.overflowing_mul(rhs).1,
      .          .          .          .                       );
      .          .          .          .           
      .          .          .          .                       // SAFETY: this is guaranteed to be safe by the caller.
      .          .          .          .                       unsafe {
243,875 ( 0.07%) .          .          .                           intrinsics::unchecked_mul(self, rhs)
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Checked integer division. Computes `self / rhs`, returning `None`
      .          .          .          .                   /// if `rhs == 0`.
      .          .          .          .                   ///
      .          .          .          .                   /// # Examples
      .          .          .          .                   ///
-- line 953 ----------------------------------------
-- line 1434 ----------------------------------------
      .          .          .          .                   /// ```
      .          .          .          .                   #[stable(feature = "wrapping", since = "1.7.0")]
      .          .          .          .                   #[rustc_const_stable(feature = "const_checked_int_methods", since = "1.47.0")]
      .          .          .          .                   #[must_use = "this returns the result of the operation, \
      .          .          .          .                                 without modifying the original"]
      .          .          .          .                   #[inline]
      .          .          .          .                   pub const fn checked_shl(self, rhs: u32) -> Option<Self> {
      .          .          .          .                       // Not using overflowing_shl as that's a wrapping shift
    144 ( 0.00%) .          .          .                       if rhs < Self::BITS {
      .          .          .          .                           // SAFETY: just checked the RHS is in-range
      .          .          .          .                           Some(unsafe { self.unchecked_shl(rhs) })
      .          .          .          .                       } else {
      .          .          .          .                           None
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger
-- line 1450 ----------------------------------------
-- line 1506 ----------------------------------------
      .          .          .          .                           concat!(stringify!($SelfT), "::unchecked_shl cannot overflow"),
      .          .          .          .                           (
      .          .          .          .                               rhs: u32 = rhs,
      .          .          .          .                           ) => rhs < <$ActualT>::BITS,
      .          .          .          .                       );
      .          .          .          .           
      .          .          .          .                       // SAFETY: this is guaranteed to be safe by the caller.
      .          .          .          .                       unsafe {
     56 ( 0.00%) .          .          .                           intrinsics::unchecked_shl(self, rhs)
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.
      .          .          .          .                   ///
      .          .          .          .                   /// If `rhs` is larger or equal to the number of bits in `self`,
      .          .          .          .                   /// the entire value is shifted out, and `0` is returned.
      .          .          .          .                   ///
-- line 1522 ----------------------------------------
-- line 1760 ----------------------------------------
      .          .          .          .                   #[doc = concat!("assert_eq!(", stringify!($SelfT), "::MAX.saturating_add(127), ", stringify!($SelfT), "::MAX);")]
      .          .          .          .                   /// ```
      .          .          .          .                   #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .                   #[must_use = "this returns the result of the operation, \
      .          .          .          .                                 without modifying the original"]
      .          .          .          .                   #[rustc_const_stable(feature = "const_saturating_int_methods", since = "1.47.0")]
      .          .          .          .                   #[inline(always)]
      .          .          .          .                   pub const fn saturating_add(self, rhs: Self) -> Self {
 91,368 ( 0.03%) .          .          .                       intrinsics::saturating_add(self, rhs)
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Saturating addition with a signed integer. Computes `self + rhs`,
      .          .          .          .                   /// saturating at the numeric bounds instead of overflowing.
      .          .          .          .                   ///
      .          .          .          .                   /// # Examples
      .          .          .          .                   ///
      .          .          .          .                   /// Basic usage:
-- line 1776 ----------------------------------------
-- line 1808 ----------------------------------------
      .          .          .          .                   #[doc = concat!("assert_eq!(13", stringify!($SelfT), ".saturating_sub(127), 0);")]
      .          .          .          .                   /// ```
      .          .          .          .                   #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .                   #[must_use = "this returns the result of the operation, \
      .          .          .          .                                 without modifying the original"]
      .          .          .          .                   #[rustc_const_stable(feature = "const_saturating_int_methods", since = "1.47.0")]
      .          .          .          .                   #[inline(always)]
      .          .          .          .                   pub const fn saturating_sub(self, rhs: Self) -> Self {
    203 ( 0.00%) .          .          .                       intrinsics::saturating_sub(self, rhs)
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at
      .          .          .          .                   /// the numeric bounds instead of overflowing.
      .          .          .          .                   ///
      .          .          .          .                   /// # Examples
      .          .          .          .                   ///
      .          .          .          .                   /// Basic usage:
-- line 1824 ----------------------------------------
-- line 1929 ----------------------------------------
      .          .          .          .                   #[doc = concat!("assert_eq!(200", stringify!($SelfT), ".wrapping_add(", stringify!($SelfT), "::MAX), 199);")]
      .          .          .          .                   /// ```
      .          .          .          .                   #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
      .          .          .          .                   #[must_use = "this returns the result of the operation, \
      .          .          .          .                                 without modifying the original"]
      .          .          .          .                   #[inline(always)]
      .          .          .          .                   pub const fn wrapping_add(self, rhs: Self) -> Self {
 62,637 ( 0.02%) .          .          .                       intrinsics::wrapping_add(self, rhs)
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Wrapping (modular) addition with a signed integer. Computes
      .          .          .          .                   /// `self + rhs`, wrapping around at the boundary of the type.
      .          .          .          .                   ///
      .          .          .          .                   /// # Examples
      .          .          .          .                   ///
      .          .          .          .                   /// Basic usage:
-- line 1945 ----------------------------------------
-- line 1970 ----------------------------------------
      .          .          .          .                   #[doc = concat!("assert_eq!(100", stringify!($SelfT), ".wrapping_sub(", stringify!($SelfT), "::MAX), 101);")]
      .          .          .          .                   /// ```
      .          .          .          .                   #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
      .          .          .          .                   #[must_use = "this returns the result of the operation, \
      .          .          .          .                                 without modifying the original"]
      .          .          .          .                   #[inline(always)]
      .          .          .          .                   pub const fn wrapping_sub(self, rhs: Self) -> Self {
 71,121 ( 0.02%) .          .          .                       intrinsics::wrapping_sub(self, rhs)
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Wrapping (modular) subtraction with a signed integer. Computes
      .          .          .          .                   /// `self - rhs`, wrapping around at the boundary of the type.
      .          .          .          .                   ///
      .          .          .          .                   /// # Examples
      .          .          .          .                   ///
      .          .          .          .                   /// Basic usage:
-- line 1986 ----------------------------------------
-- line 2014 ----------------------------------------
      .          .          .          .                   /// assert_eq!(25u8.wrapping_mul(12), 44);
      .          .          .          .                   /// ```
      .          .          .          .                   #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
      .          .          .          .                   #[must_use = "this returns the result of the operation, \
      .          .          .          .                                 without modifying the original"]
      .          .          .          .                   #[inline(always)]
      .          .          .          .                   pub const fn wrapping_mul(self, rhs: Self) -> Self {
 18,093 ( 0.01%) .          .          .                       intrinsics::wrapping_mul(self, rhs)
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Wrapping (modular) division. Computes `self / rhs`.
      .          .          .          .                   ///
      .          .          .          .                   /// Wrapped division on unsigned types is just normal division. There's
      .          .          .          .                   /// no way wrapping could ever happen. This function exists so that all
      .          .          .          .                   /// operations are accounted for in the wrapping operations.
      .          .          .          .                   ///
-- line 2030 ----------------------------------------
-- line 2521 ----------------------------------------
      .          .          .          .                   /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));
      .          .          .          .                   /// ```
      .          .          .          .                   #[stable(feature = "wrapping", since = "1.7.0")]
      .          .          .          .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
      .          .          .          .                   #[must_use = "this returns the result of the operation, \
      .          .          .          .                                     without modifying the original"]
      .          .          .          .                   #[inline(always)]
      .          .          .          .                   pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
299,398 ( 0.09%) .          .          .                       let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
      .          .          .          .                       (a as Self, b)
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Calculates the complete product `self * rhs` without the possibility to overflow.
      .          .          .          .                   ///
      .          .          .          .                   /// This returns the low-order (wrapping) bits and the high-order (overflow) bits
      .          .          .          .                   /// of the result as two separate values, in that order.
      .          .          .          .                   ///
-- line 2537 ----------------------------------------
-- line 3237 ----------------------------------------
      .          .          .          .                   // 8u8.one_less_than_next_power_of_two() == 7
      .          .          .          .                   // 6u8.one_less_than_next_power_of_two() == 7
      .          .          .          .                   //
      .          .          .          .                   // This method cannot overflow, as in the `next_power_of_two`
      .          .          .          .                   // overflow cases it instead ends up returning the maximum value
      .          .          .          .                   // of the type, and can return 0 for 0.
      .          .          .          .                   #[inline]
      .          .          .          .                   const fn one_less_than_next_power_of_two(self) -> Self {
    200 ( 0.00%) .          .          .                       if self <= 1 { return 0; }
      .          .          .          .           
     57 ( 0.00%) .          .          .                       let p = self - 1;
      .          .          .          .                       // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.
      .          .          .          .                       // That means the shift is always in-bounds, and some processors
      .          .          .          .                       // (such as intel pre-haswell) have more efficient ctlz
      .          .          .          .                       // intrinsics when the argument is non-zero.
    569 ( 0.00%) .          .          .                       let z = unsafe { intrinsics::ctlz_nonzero(p) };
    171 ( 0.00%) .          .          .                       <$SelfT>::MAX >> z
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Returns the smallest power of two greater than or equal to `self`.
      .          .          .          .                   ///
      .          .          .          .                   /// When return value overflows (i.e., `self > (1 << (N-1))` for type
      .          .          .          .                   /// `uN`), it panics in debug mode and the return value is wrapped to 0 in
      .          .          .          .                   /// release mode (the only situation in which this method can return 0).
      .          .          .          .                   ///
-- line 3261 ----------------------------------------
-- line 3270 ----------------------------------------
      .          .          .          .                   /// ```
      .          .          .          .                   #[stable(feature = "rust1", since = "1.0.0")]
      .          .          .          .                   #[rustc_const_stable(feature = "const_int_pow", since = "1.50.0")]
      .          .          .          .                   #[must_use = "this returns the result of the operation, \
      .          .          .          .                                 without modifying the original"]
      .          .          .          .                   #[inline]
      .          .          .          .                   #[rustc_inherit_overflow_checks]
      .          .          .          .                   pub const fn next_power_of_two(self) -> Self {
     56 ( 0.00%) .          .          .                       self.one_less_than_next_power_of_two() + 1
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Returns the smallest power of two greater than or equal to `self`. If
      .          .          .          .                   /// the next power of two is greater than the type's maximum value,
      .          .          .          .                   /// `None` is returned, otherwise the power of two is wrapped in `Some`.
      .          .          .          .                   ///
      .          .          .          .                   /// # Examples
      .          .          .          .                   ///
-- line 3286 ----------------------------------------
-- line 3394 ----------------------------------------
      .          .          .          .                   #[must_use = "this returns the result of the operation, \
      .          .          .          .                                 without modifying the original"]
      .          .          .          .                   // SAFETY: const sound because integers are plain old datatypes so we can always
      .          .          .          .                   // transmute them to arrays of bytes
      .          .          .          .                   #[inline]
      .          .          .          .                   pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
      .          .          .          .                       // SAFETY: integers are plain old datatypes so we can always transmute them to
      .          .          .          .                       // arrays of bytes
  1,532 ( 0.00%) .          .          .                       unsafe { mem::transmute(self) }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   /// Creates a native endian integer value from its representation
      .          .          .          .                   /// as a byte array in big endian.
      .          .          .          .                   ///
      .          .          .          .                   #[doc = $from_xe_bytes_doc]
      .          .          .          .                   ///
      .          .          .          .                   /// # Examples
-- line 3410 ----------------------------------------

161,102 ( 0.05%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/unicode.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 116 ----------------------------------------
     .          .          .          .               /// no entry in the underlying case folding table), then this returns an
     .          .          .          .               /// empty slice.
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
     .          .          .          .               /// This panics when called with a `c` that is less than or equal to the
     .          .          .          .               /// previous call. In other words, callers need to use this method with
     .          .          .          .               /// strictly increasing values of `c`.
 2,240 ( 0.00%) .          .          .               pub fn mapping(&mut self, c: char) -> &'static [char] {
 5,600 ( 0.00%) .          .          .                   if let Some(last) = self.last {
     .          .          .          .                       assert!(
     .          .          .          .                           last < c,
     .          .          .          .                           "got codepoint U+{:X} which occurs before \
     .          .          .          .                            last codepoint U+{:X}",
     .          .          .          .                           u32::from(c),
     .          .          .          .                           u32::from(last),
     .          .          .          .                       );
     .          .          .          .                   }
 1,120 ( 0.00%) .          .          .                   self.last = Some(c);
 5,600 ( 0.00%) .          .          .                   if self.next >= self.table.len() {
     .          .          .          .                       return &[];
     .          .          .          .                   }
 2,480 ( 0.00%) .          .          .                   let (k, v) = self.table[self.next];
 2,240 ( 0.00%) .          .          .                   if k == c {
   160 ( 0.00%) .          .          .                       self.next += 1;
     .          .          .          .                       return v;
     .          .          .          .                   }
     .          .          .          .                   match self.get(c) {
     .          .          .          .                       Err(i) => {
     .          .          .          .                           self.next = i;
     .          .          .          .                           &[]
     .          .          .          .                       }
     .          .          .          .                       Ok(i) => {
     .          .          .          .                           // Since we require lookups to proceed
     .          .          .          .                           // in order, anything we find should be
     .          .          .          .                           // after whatever we thought might be
     .          .          .          .                           // next. Otherwise, the caller is either
     .          .          .          .                           // going out of order or we would have
     .          .          .          .                           // found our next key at 'self.next'.
 2,080 ( 0.00%) .          .          .                           assert!(i > self.next);
 2,080 ( 0.00%) .          .          .                           self.next = i + 1;
 2,080 ( 0.00%) .          .          .                           self.table[i].1
     .          .          .          .                       }
     .          .          .          .                   }
 3,360 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns true if and only if the given range overlaps with any region
     .          .          .          .               /// of the underlying case folding table. That is, when true, there exists
     .          .          .          .               /// at least one codepoint in the inclusive range `[start, end]` that has
     .          .          .          .               /// a non-trivial equivalence class of case folded codepoints. Conversely,
     .          .          .          .               /// when this returns false, all codepoints in the range `[start, end]`
     .          .          .          .               /// correspond to the trivial equivalence class of case folded codepoints,
     .          .          .          .               /// i.e., itself.
-- line 168 ----------------------------------------
-- line 170 ----------------------------------------
     .          .          .          .               /// This is useful to call before iterating over the codepoints in the
     .          .          .          .               /// range and looking up the mapping for each. If you know none of the
     .          .          .          .               /// mappings will return anything, then you might be able to skip doing it
     .          .          .          .               /// altogether.
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
     .          .          .          .               /// This panics when `end < start`.
 1,120 ( 0.00%) .          .          .               pub fn overlaps(&self, start: char, end: char) -> bool {
     .          .          .          .                   use core::cmp::Ordering;
     .          .          .          .           
 4,620 ( 0.00%) .          .          .                   assert!(start <= end);
 1,120 ( 0.00%) .          .          .                   self.table
     .          .          .          .                       .binary_search_by(|&(c, _)| {
 7,000 ( 0.00%) .          .          .                           if start <= c && c <= end {
     .          .          .          .                               Ordering::Equal
     .          .          .          .                           } else if c > end {
     .          .          .          .                               Ordering::Greater
     .          .          .          .                           } else {
     .          .          .          .                               Ordering::Less
     .          .          .          .                           }
     .          .          .          .                       })
     .          .          .          .                       .is_ok()
 2,240 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the index at which `c` occurs in the simple case fold table. If
     .          .          .          .               /// `c` does not occur, then this returns an `i` such that `table[i-1].0 <
     .          .          .          .               /// c` and `table[i].0 > c`.
     .          .          .          .               fn get(&self, c: char) -> Result<usize, usize> {
     .          .          .          .                   self.table.binary_search_by_key(&c, |&(c1, _)| c1)
     .          .          .          .               }
     .          .          .          .           }
-- line 201 ----------------------------------------
-- line 422 ----------------------------------------
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               imp()
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Returns a Unicode aware class for \d.
     .          .          .          .           ///
     .          .          .          .           /// This returns an error if the data is not available for \d.
    15 ( 0.00%) .          .          .           pub fn perl_digit() -> Result<hir::ClassUnicode, Error> {
     .          .          .          .               #[cfg(not(any(feature = "unicode-perl", feature = "unicode-gencat")))]
     .          .          .          .               fn imp() -> Result<hir::ClassUnicode, Error> {
     .          .          .          .                   Err(Error::PerlClassNotFound)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[cfg(all(feature = "unicode-perl", not(feature = "unicode-gencat")))]
     .          .          .          .               fn imp() -> Result<hir::ClassUnicode, Error> {
     .          .          .          .                   use crate::unicode_tables::perl_decimal::DECIMAL_NUMBER;
-- line 438 ----------------------------------------
-- line 441 ----------------------------------------
     .          .          .          .           
     .          .          .          .               #[cfg(feature = "unicode-gencat")]
     .          .          .          .               fn imp() -> Result<hir::ClassUnicode, Error> {
     .          .          .          .                   use crate::unicode_tables::general_category::DECIMAL_NUMBER;
     .          .          .          .                   Ok(hir_class(DECIMAL_NUMBER))
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               imp()
    20 ( 0.00%) .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Build a Unicode HIR class from a sequence of Unicode scalar value ranges.
     .          .          .          .           pub fn hir_class(ranges: &[(char, char)]) -> hir::ClassUnicode {
     .          .          .          .               let hir_ranges: Vec<hir::ClassUnicodeRange> = ranges
     .          .          .          .                   .iter()
     .          .          .          .                   .map(|&(s, e)| hir::ClassUnicodeRange::new(s, e))
     .          .          .          .                   .collect();
     .          .          .          .               hir::ClassUnicode::new(hir_ranges)
-- line 457 ----------------------------------------

10,360 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/unicode.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 25 ----------------------------------------
     .          .          .          .               fn from_iter(iter: I) -> Self;
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<T, I> SpecFromIter<T, I> for Vec<T>
     .          .          .          .           where
     .          .          .          .               I: Iterator<Item = T>,
     .          .          .          .           {
     .          .          .          .               #[track_caller]
 7,053 ( 0.00%) .          .          .               default fn from_iter(iterator: I) -> Self {
    48 ( 0.00%) .          .          .                   SpecFromIterNested::from_iter(iterator)
   640 ( 0.00%) 2 ( 0.00%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter_nested.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<T,I>>::from_iter (1x)
 7,038 ( 0.00%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<T> SpecFromIter<T, IntoIter<T>> for Vec<T> {
     .          .          .          .               #[track_caller]
35,883 ( 0.01%) .          .          .               fn from_iter(iterator: IntoIter<T>) -> Self {
     .          .          .          .                   // A common case is passing a vector into a function which immediately
     .          .          .          .                   // re-collects into a vector. We can short circuit this if the IntoIter
     .          .          .          .                   // has not been advanced at all.
     .          .          .          .                   // When it has been advanced We can also reuse the memory and move the data to the front.
     .          .          .          .                   // But we only do so when the resulting Vec wouldn't have more unused capacity
     .          .          .          .                   // than creating it through the generic FromIterator implementation would. That limitation
     .          .          .          .                   // is not strictly necessary as Vec's allocation behavior is intentionally unspecified.
     .          .          .          .                   // But it is a conservative choice.
     .          .          .          .                   let has_advanced = iterator.buf != iterator.ptr;
 3,987 ( 0.00%) .          .          .                   if !has_advanced || iterator.len() >= iterator.cap / 2 {
     .          .          .          .                       unsafe {
 7,974 ( 0.00%) .          .          .                           let it = ManuallyDrop::new(iterator);
     .          .          .          .                           if has_advanced {
     .          .          .          .                               ptr::copy(it.ptr.as_ptr(), it.buf.as_ptr(), it.len());
     .          .          .          .                           }
     .          .          .          .                           return Vec::from_parts(it.buf, it.len(), it.cap);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .           
     .          .          .          .                   let mut vec = Vec::new();
     .          .          .          .                   // must delegate to spec_extend() since extend() itself delegates
     .          .          .          .                   // to spec_from for empty Vecs
     .          .          .          .                   vec.spec_extend(iterator);
     .          .          .          .                   vec
35,883 ( 0.01%) .          .          .               }
     .          .          .          .           }

     5 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 84 ----------------------------------------
    .          .          .          .           /// `state` corresponds to the current DFA state on which one wants to compute
    .          .          .          .           /// the transition for the input `unit`.
    .          .          .          .           ///
    .          .          .          .           /// `empty_builder` corresponds to the builder allocation to use to produce a
    .          .          .          .           /// complete `StateBuilderNFA` state. If the state is not needed (or is already
    .          .          .          .           /// cached), then it can be cleared and reused without needing to create a new
    .          .          .          .           /// `State`. The `StateBuilderNFA` state returned is final and ready to be
    .          .          .          .           /// turned into a `State` if necessary.
2,398 ( 0.00%) .          .          .           pub(crate) fn next(
    .          .          .          .               nfa: &thompson::NFA,
    .          .          .          .               match_kind: MatchKind,
    .          .          .          .               sparses: &mut SparseSets,
    .          .          .          .               stack: &mut Vec<StateID>,
    .          .          .          .               state: &State,
    .          .          .          .               unit: alphabet::Unit,
    .          .          .          .               empty_builder: StateBuilderEmpty,
    .          .          .          .           ) -> StateBuilderNFA {
-- line 100 ----------------------------------------
-- line 123 ----------------------------------------
    .          .          .          .               });
    .          .          .          .           
    .          .          .          .               // Compute look-ahead assertions originating from the current state. Based
    .          .          .          .               // on the input unit we're transitioning over, some additional set of
    .          .          .          .               // assertions may be true. Thus, we re-compute this state's epsilon closure
    .          .          .          .               // (but only if necessary). Notably, when we build a DFA state initially,
    .          .          .          .               // we don't enable any look-ahead assertions because we don't know whether
    .          .          .          .               // they're true or not at that point.
  872 ( 0.00%) .          .          .               if !state.look_need().is_empty() {
    .          .          .          .                   // Add look-ahead assertions that are now true based on the current
    .          .          .          .                   // input unit.
    .          .          .          .                   let mut look_have = state.look_have();
  320 ( 0.00%) .          .          .                   match unit.as_u8() {
    .          .          .          .                       Some(b'\r') => {
    .          .          .          .                           if !rev || !state.is_half_crlf() {
    .          .          .          .                               look_have = look_have.insert(Look::EndCRLF);
    .          .          .          .                           }
    .          .          .          .                       }
    .          .          .          .                       Some(b'\n') => {
    .          .          .          .                           if rev || !state.is_half_crlf() {
    .          .          .          .                               look_have = look_have.insert(Look::EndCRLF);
-- line 143 ----------------------------------------
-- line 146 ----------------------------------------
    .          .          .          .                       Some(_) => {}
    .          .          .          .                       None => {
    .          .          .          .                           look_have = look_have
    .          .          .          .                               .insert(Look::End)
    .          .          .          .                               .insert(Look::EndLF)
    .          .          .          .                               .insert(Look::EndCRLF);
    .          .          .          .                       }
    .          .          .          .                   }
  160 ( 0.00%) .          .          .                   if unit.is_byte(lookm.get_line_terminator()) {
    .          .          .          .                       look_have = look_have.insert(Look::EndLF);
    .          .          .          .                   }
   40 ( 0.00%) .          .          .                   if state.is_half_crlf()
    .          .          .          .                       && ((rev && !unit.is_byte(b'\r'))
    .          .          .          .                           || (!rev && !unit.is_byte(b'\n')))
    .          .          .          .                   {
    .          .          .          .                       look_have = look_have.insert(Look::StartCRLF);
    .          .          .          .                   }
  240 ( 0.00%) .          .          .                   if state.is_from_word() == unit.is_word_byte() {
    .          .          .          .                       look_have = look_have
    .          .          .          .                           .insert(Look::WordAsciiNegate)
    .          .          .          .                           .insert(Look::WordUnicodeNegate);
    .          .          .          .                   } else {
    .          .          .          .                       look_have =
    .          .          .          .                           look_have.insert(Look::WordAscii).insert(Look::WordUnicode);
    .          .          .          .                   }
   80 ( 0.00%) .          .          .                   if !unit.is_word_byte() {
    .          .          .          .                       look_have = look_have
    .          .          .          .                           .insert(Look::WordEndHalfAscii)
    .          .          .          .                           .insert(Look::WordEndHalfUnicode);
    .          .          .          .                   }
   80 ( 0.00%) .          .          .                   if state.is_from_word() && !unit.is_word_byte() {
    .          .          .          .                       look_have = look_have
    .          .          .          .                           .insert(Look::WordEndAscii)
    .          .          .          .                           .insert(Look::WordEndUnicode);
   80 ( 0.00%) .          .          .                   } else if !state.is_from_word() && unit.is_word_byte() {
    .          .          .          .                       look_have = look_have
    .          .          .          .                           .insert(Look::WordStartAscii)
    .          .          .          .                           .insert(Look::WordStartUnicode);
    .          .          .          .                   }
    .          .          .          .                   // If we have new assertions satisfied that are among the set of
    .          .          .          .                   // assertions that exist in this state (that is, just because we added
    .          .          .          .                   // an EndLF assertion above doesn't mean there is an EndLF conditional
    .          .          .          .                   // epsilon transition in this state), then we re-compute this state's
    .          .          .          .                   // epsilon closure using the updated set of assertions.
    .          .          .          .                   //
    .          .          .          .                   // Note that since our DFA states omit unconditional epsilon
    .          .          .          .                   // transitions, this check is necessary for correctness. If we re-did
    .          .          .          .                   // the epsilon closure below needlessly, it could change based on the
    .          .          .          .                   // fact that we omitted epsilon states originally.
  120 ( 0.00%) .          .          .                   if !look_have
    .          .          .          .                       .subtract(state.look_have())
    .          .          .          .                       .intersect(state.look_need())
    .          .          .          .                       .is_empty()
    .          .          .          .                   {
    .          .          .          .                       for nfa_id in sparses.set1.iter() {
    .          .          .          .                           epsilon_closure(
    .          .          .          .                               nfa,
    .          .          .          .                               nfa_id,
-- line 203 ----------------------------------------
-- line 233 ----------------------------------------
    .          .          .          .               // to a $ and vice versa.)
    .          .          .          .               if nfa.look_set_any().contains_anchor_crlf()
    .          .          .          .                   && ((rev && unit.is_byte(b'\r')) || (!rev && unit.is_byte(b'\n')))
    .          .          .          .               {
    .          .          .          .                   builder.set_look_have(|have| have.insert(Look::StartCRLF));
    .          .          .          .               }
    .          .          .          .               // And also for the start-half word boundary assertions. As long as the
    .          .          .          .               // look-behind byte is not a word char, then the assertions are satisfied.
  218 ( 0.00%) .          .          .               if nfa.look_set_any().contains_word() && !unit.is_word_byte() {
    .          .          .          .                   builder.set_look_have(|have| {
    .          .          .          .                       have.insert(Look::WordStartHalfAscii)
    .          .          .          .                           .insert(Look::WordStartHalfUnicode)
    .          .          .          .                   });
    .          .          .          .               }
    .          .          .          .               for nfa_id in sparses.set1.iter() {
3,952 ( 0.00%) .          .          .                   match *nfa.state(nfa_id) {
    .          .          .          .                       thompson::State::Union { .. }
    .          .          .          .                       | thompson::State::BinaryUnion { .. }
    .          .          .          .                       | thompson::State::Fail
    .          .          .          .                       | thompson::State::Look { .. }
    .          .          .          .                       | thompson::State::Capture { .. } => {}
    3 ( 0.00%) .          .          .                       thompson::State::Match { pattern_id } => {
    .          .          .          .                           // Notice here that we are calling the NEW state a match
    .          .          .          .                           // state if the OLD state we are transitioning from
    .          .          .          .                           // contains an NFA match state. This is precisely how we
    .          .          .          .                           // delay all matches by one byte and also what therefore
    .          .          .          .                           // guarantees that starting states cannot be match states.
    .          .          .          .                           //
    .          .          .          .                           // If we didn't delay matches by one byte, then whether
    .          .          .          .                           // a DFA is a matching state or not would be determined
-- line 262 ----------------------------------------
-- line 275 ----------------------------------------
    .          .          .          .                           //
    .          .          .          .                           // N.B. We delay matches by 1 byte as a way to hack 1-byte
    .          .          .          .                           // look-around into DFA searches. This lets us support ^, $
    .          .          .          .                           // and ASCII-only \b. The delay is also why we need a special
    .          .          .          .                           // "end-of-input" (EOI) sentinel and why we need to follow the
    .          .          .          .                           // EOI sentinel at the end of every search. This final EOI
    .          .          .          .                           // transition is necessary to report matches found at the end
    .          .          .          .                           // of a haystack.
    6 ( 0.00%) .          .          .                           builder.add_match_pattern_id(pattern_id);
   69 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/state.rs:regex_automata::util::determinize::state::StateBuilderMatches::add_match_pattern_id (3x)
    6 ( 0.00%) .          .          .                           if !match_kind.continue_past_first_match() {
    .          .          .          .                               break;
    .          .          .          .                           }
    .          .          .          .                       }
    .          .          .          .                       thompson::State::ByteRange { ref trans } => {
  954 ( 0.00%) .          .          .                           if trans.matches_unit(unit) {
    .          .          .          .                               epsilon_closure(
    .          .          .          .                                   nfa,
    .          .          .          .                                   trans.next,
    .          .          .          .                                   builder.look_have(),
    .          .          .          .                                   stack,
    .          .          .          .                                   &mut sparses.set2,
    .          .          .          .                               );
    .          .          .          .                           }
-- line 297 ----------------------------------------
-- line 332 ----------------------------------------
    .          .          .          .               // a quit byte is seen. Consuming until EOI isn't a correctness problem,
    .          .          .          .               // but a (serious) perf problem. Hitting a quit byte, however, could be a
    .          .          .          .               // correctness problem since it could cause search routines to report an
    .          .          .          .               // error instead of a detected match once the quit state is entered. (The
    .          .          .          .               // search routine could be made to be a bit smarter by reporting a match
    .          .          .          .               // if one was detected once it enters a quit state (and indeed, the search
    .          .          .          .               // routines in this crate do just that), but it seems better to prevent
    .          .          .          .               // these things by construction if possible.)
  654 ( 0.00%) .          .          .               if !sparses.set2.is_empty() {
    .          .          .          .                   if nfa.look_set_any().contains_word() && unit.is_word_byte() {
    .          .          .          .                       builder.set_is_from_word();
    .          .          .          .                   }
  175 ( 0.00%) .          .          .                   if nfa.look_set_any().contains_anchor_crlf()
    .          .          .          .                       && ((rev && unit.is_byte(b'\n')) || (!rev && unit.is_byte(b'\r')))
    .          .          .          .                   {
    .          .          .          .                       builder.set_is_half_crlf();
    .          .          .          .                   }
    .          .          .          .               }
  654 ( 0.00%) .          .          .               let mut builder_nfa = builder.into_nfa();
  218 ( 0.00%) .          .          .               add_nfa_states(nfa, &sparses.set2, &mut builder_nfa);
25,186 ( 0.01%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::add_nfa_states (218x)
  872 ( 0.00%) .          .          .               builder_nfa
1,962 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Compute the epsilon closure for the given NFA state. The epsilon closure
    .          .          .          .           /// consists of all NFA state IDs, including `start_nfa_id`, that can be
    .          .          .          .           /// reached from `start_nfa_id` without consuming any input. These state IDs
    .          .          .          .           /// are written to `set` in the order they are visited, but only if they are
    .          .          .          .           /// not already in `set`. `start_nfa_id` must be a valid state ID for the NFA
    .          .          .          .           /// given.
    .          .          .          .           ///
    .          .          .          .           /// `look_have` consists of the satisfied assertions at the current
    .          .          .          .           /// position. For conditional look-around epsilon transitions, these are
    .          .          .          .           /// only followed if they are satisfied by `look_have`.
    .          .          .          .           ///
    .          .          .          .           /// `stack` must have length 0. It is used as scratch space for depth first
    .          .          .          .           /// traversal. After returning, it is guaranteed that `stack` will have length
    .          .          .          .           /// 0.
1,880 ( 0.00%) .          .          .           pub(crate) fn epsilon_closure(
    .          .          .          .               nfa: &thompson::NFA,
    .          .          .          .               start_nfa_id: StateID,
    .          .          .          .               look_have: LookSet,
    .          .          .          .               stack: &mut Vec<StateID>,
    .          .          .          .               set: &mut SparseSet,
    .          .          .          .           ) {
  470 ( 0.00%) .          .          .               assert!(stack.is_empty());
    .          .          .          .               // If this isn't an epsilon state, then the epsilon closure is always just
    .          .          .          .               // itself, so there's no need to spin up the machinery below to handle it.
    .          .          .          .               if !nfa.state(start_nfa_id).is_epsilon() {
    .          .          .          .                   set.insert(start_nfa_id);
    .          .          .          .                   return;
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               stack.push(start_nfa_id);
-- line 384 ----------------------------------------
-- line 388 ----------------------------------------
    .          .          .          .                   // that state and mush on. We only use the stack when an NFA state
    .          .          .          .                   // introduces multiple new states to visit.
    .          .          .          .                   loop {
    .          .          .          .                       // Insert this NFA state, and if it's already in the set and thus
    .          .          .          .                       // already visited, then we can move on to the next one.
    .          .          .          .                       if !set.insert(id) {
    .          .          .          .                           break;
    .          .          .          .                       }
4,600 ( 0.00%) .          .          .                       match *nfa.state(id) {
    .          .          .          .                           thompson::State::ByteRange { .. }
    .          .          .          .                           | thompson::State::Sparse { .. }
    .          .          .          .                           | thompson::State::Dense { .. }
    .          .          .          .                           | thompson::State::Fail
    .          .          .          .                           | thompson::State::Match { .. } => break,
    .          .          .          .                           thompson::State::Look { look, next } => {
   82 ( 0.00%) .          .          .                               if !look_have.contains(look) {
    .          .          .          .                                   break;
    .          .          .          .                               }
    .          .          .          .                               id = next;
    .          .          .          .                           }
    .          .          .          .                           thompson::State::Union { ref alternates } => {
   68 ( 0.00%) .          .          .                               id = match alternates.get(0) {
    .          .          .          .                                   None => break,
   34 ( 0.00%) .          .          .                                   Some(&id) => id,
    .          .          .          .                               };
    .          .          .          .                               // We need to process our alternates in order to preserve
    .          .          .          .                               // match preferences, so put the earliest alternates closer
    .          .          .          .                               // to the top of the stack.
  136 ( 0.00%) .          .          .                               stack.extend(alternates[1..].iter().rev());
   34 ( 0.00%) .          .          .                           }
  186 ( 0.00%) .          .          .                           thompson::State::BinaryUnion { alt1, alt2 } => {
    .          .          .          .                               id = alt1;
    .          .          .          .                               stack.push(alt2);
    .          .          .          .                           }
    .          .          .          .                           thompson::State::Capture { next, .. } => {
    .          .          .          .                               id = next;
    .          .          .          .                           }
    .          .          .          .                       }
    .          .          .          .                   }
    .          .          .          .               }
1,880 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Add the NFA state IDs in the given `set` to the given DFA builder state.
    .          .          .          .           /// The order in which states are added corresponds to the order in which they
    .          .          .          .           /// were added to `set`.
    .          .          .          .           ///
    .          .          .          .           /// The DFA builder state given should already have its complete set of match
    .          .          .          .           /// pattern IDs added (if any) and any look-behind assertions (StartLF, Start
    .          .          .          .           /// and whether this state is being generated for a transition over a word byte
-- line 436 ----------------------------------------
-- line 440 ----------------------------------------
    .          .          .          .           /// delayed by one byte. The things that should _not_ be set are look-ahead
    .          .          .          .           /// assertions (EndLF, End and whether the next byte is a word byte or not).
    .          .          .          .           /// The builder state should also not have anything in `look_need` set, as this
    .          .          .          .           /// routine will compute that for you.
    .          .          .          .           ///
    .          .          .          .           /// The given NFA should be able to resolve all identifiers in `set` to a
    .          .          .          .           /// particular NFA state. Additionally, `set` must have capacity equivalent
    .          .          .          .           /// to `nfa.len()`.
2,072 ( 0.00%) .          .          .           pub(crate) fn add_nfa_states(
    .          .          .          .               nfa: &thompson::NFA,
    .          .          .          .               set: &SparseSet,
    .          .          .          .               builder: &mut StateBuilderNFA,
    .          .          .          .           ) {
    .          .          .          .               for nfa_id in set.iter() {
6,215 ( 0.00%) .          .          .                   match *nfa.state(nfa_id) {
    .          .          .          .                       thompson::State::ByteRange { .. } => {
    .          .          .          .                           builder.add_nfa_state_id(nfa_id);
    .          .          .          .                       }
    .          .          .          .                       thompson::State::Sparse { .. } => {
    .          .          .          .                           builder.add_nfa_state_id(nfa_id);
    .          .          .          .                       }
    .          .          .          .                       thompson::State::Dense { .. } => {
    .          .          .          .                           builder.add_nfa_state_id(nfa_id);
    .          .          .          .                       }
   41 ( 0.00%) .          .          .                       thompson::State::Look { look, .. } => {
    .          .          .          .                           builder.add_nfa_state_id(nfa_id);
    .          .          .          .                           builder.set_look_need(|need| need.insert(look));
    .          .          .          .                       }
    .          .          .          .                       thompson::State::Union { .. }
    .          .          .          .                       | thompson::State::BinaryUnion { .. } => {
    .          .          .          .                           // Pure epsilon transitions don't need to be tracked as part
    .          .          .          .                           // of the DFA state. Tracking them is actually superfluous;
    .          .          .          .                           // they won't cause any harm other than making determinization
-- line 472 ----------------------------------------
-- line 568 ----------------------------------------
    .          .          .          .                           // match state. See 'next' for how this is handled.
    .          .          .          .                           builder.add_nfa_state_id(nfa_id);
    .          .          .          .                       }
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .               // If we know this state contains no look-around assertions, then
    .          .          .          .               // there's no reason to track which look-around assertions were
    .          .          .          .               // satisfied when this state was created.
  518 ( 0.00%) .          .          .               if builder.look_need().is_empty() {
    .          .          .          .                   builder.set_look_have(|_| LookSet::empty());
    .          .          .          .               }
2,072 ( 0.00%) .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Sets the appropriate look-behind assertions on the given state based on
    .          .          .          .           /// this starting configuration.
   41 ( 0.00%) .          .          .           pub(crate) fn set_lookbehind_from_start(
    .          .          .          .               nfa: &thompson::NFA,
    .          .          .          .               start: &Start,
    .          .          .          .               builder: &mut StateBuilderMatches,
    .          .          .          .           ) {
    .          .          .          .               let rev = nfa.is_reverse();
    .          .          .          .               let lineterm = nfa.look_matcher().get_line_terminator();
    .          .          .          .               let lookset = nfa.look_set_any();
  164 ( 0.00%) .          .          .               match *start {
    .          .          .          .                   Start::NonWordByte => {
    .          .          .          .                       if lookset.contains_word() {
    .          .          .          .                           builder.set_look_have(|have| {
    .          .          .          .                               have.insert(Look::WordStartHalfAscii)
    .          .          .          .                                   .insert(Look::WordStartHalfUnicode)
    .          .          .          .                           });
    .          .          .          .                       }
    .          .          .          .                   }
-- line 599 ----------------------------------------
-- line 674 ----------------------------------------
    .          .          .          .                               builder.set_look_have(|have| {
    .          .          .          .                                   have.insert(Look::WordStartHalfAscii)
    .          .          .          .                                       .insert(Look::WordStartHalfUnicode)
    .          .          .          .                               });
    .          .          .          .                           }
    .          .          .          .                       }
    .          .          .          .                   }
    .          .          .          .               }
   82 ( 0.00%) .          .          .           }

4,243 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 153 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Extractor {
      .          .          .          .               /// Create a new extractor with a default configuration.
      .          .          .          .               ///
      .          .          .          .               /// The extractor can be optionally configured before calling
      .          .          .          .               /// [`Extractor::extract`] to get a literal sequence.
      .          .          .          .               pub fn new() -> Extractor {
    292 ( 0.00%) .          .          .                   Extractor {
      .          .          .          .                       kind: ExtractKind::Prefix,
      .          .          .          .                       limit_class: 10,
      .          .          .          .                       limit_repeat: 10,
      .          .          .          .                       limit_literal_len: 100,
      .          .          .          .                       limit_total: 250,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Execute the extractor and return a sequence of literals.
 32,912 ( 0.01%) .          .          .               pub fn extract(&self, hir: &Hir) -> Seq {
      .          .          .          .                   use crate::hir::HirKind::*;
      .          .          .          .           
 30,350 ( 0.01%) .          .          .                   match *hir.kind() {
      .          .          .          .                       Empty | Look(_) => Seq::singleton(self::Literal::exact(vec![])),
      .          .          .          .                       Literal(hir::Literal(ref bytes)) => {
      .          .          .          .                           let mut seq =
  4,822 ( 0.00%) .          .          .                               Seq::singleton(self::Literal::exact(bytes.to_vec()));
  2,411 ( 0.00%) .          .          .                           self.enforce_literal_len(&mut seq);
      .          .          .          .                           seq
  2,412 ( 0.00%) .          .          .                       }
      .          .          .          .                       Class(hir::Class::Unicode(ref cls)) => {
      .          .          .          .                           self.extract_class_unicode(cls)
      .          .          .          .                       }
      .          .          .          .                       Class(hir::Class::Bytes(ref cls)) => self.extract_class_bytes(cls),
      .          .          .          .                       Repetition(ref rep) => self.extract_repetition(rep),
     78 ( 0.00%) .          .          .                       Capture(hir::Capture { ref sub, .. }) => self.extract(sub),
    422 ( 0.00%) .          .          .                       Concat(ref hirs) => match self.kind {
    182 ( 0.00%) .          .          .                           ExtractKind::Prefix => self.extract_concat(hirs.iter()),
     29 ( 0.00%) .          .          .                           ExtractKind::Suffix => self.extract_concat(hirs.iter().rev()),
      .          .          .          .                       },
      .          .          .          .                       Alternation(ref hirs) => {
      .          .          .          .                           // Unlike concat, we always union starting from the beginning,
      .          .          .          .                           // since the beginning corresponds to the highest preference,
      .          .          .          .                           // which doesn't change based on forwards vs reverse.
      .          .          .          .                           self.extract_alternation(hirs.iter())
      .          .          .          .                       }
      .          .          .          .                   }
 26,928 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the kind of literal sequence to extract from an [`Hir`] expression.
      .          .          .          .               ///
      .          .          .          .               /// The default is to extract prefixes, but suffixes can be selected
      .          .          .          .               /// instead. The contract for prefixes is that every match of the
      .          .          .          .               /// corresponding `Hir` must start with one of the literals in the sequence
      .          .          .          .               /// returned. Moreover, the _order_ of the sequence returned corresponds to
      .          .          .          .               /// the preference order.
-- line 207 ----------------------------------------
-- line 213 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// Remember that a sequence can be infinite. For example, unless the
      .          .          .          .               /// limits are configured to be impractically large, attempting to extract
      .          .          .          .               /// prefixes (or suffixes) for the pattern `[A-Z]` will return an infinite
      .          .          .          .               /// sequence. Generally speaking, if the sequence returned is infinite,
      .          .          .          .               /// then it is presumed to be unwise to do prefix (or suffix) optimizations
      .          .          .          .               /// for the pattern.
      .          .          .          .               pub fn kind(&mut self, kind: ExtractKind) -> &mut Extractor {
    161 ( 0.00%) .          .          .                   self.kind = kind;
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Configure a limit on the length of the sequence that is permitted for
      .          .          .          .               /// a character class. If a character class exceeds this limit, then the
      .          .          .          .               /// sequence returned for it is infinite.
      .          .          .          .               ///
      .          .          .          .               /// This prevents classes like `[A-Z]` or `\pL` from getting turned into
-- line 229 ----------------------------------------
-- line 399 ----------------------------------------
      .          .          .          .                       // product will always be a no-op. Thus, there is nothing else we
      .          .          .          .                       // can add to it and can quit early. Note that this also includes
      .          .          .          .                       // infinite sequences.
      .          .          .          .                       if seq.is_inexact() {
      .          .          .          .                           break;
      .          .          .          .                       }
      .          .          .          .                       // Note that 'cross' also dispatches based on whether we're
      .          .          .          .                       // extracting prefixes or suffixes.
  7,825 ( 0.00%) .          .          .                       seq = self.cross(seq, &mut self.extract(hir));
4,217,038 ( 1.27%) 7,756 ( 0.96%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (111x)
1,800,969 ( 0.54%) 8,499 ( 1.05%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (111x)
      .          .          .          .                   }
    633 ( 0.00%) .          .          .                   seq
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Extract a sequence from the given alternation.
      .          .          .          .               ///
      .          .          .          .               /// This short circuits once the union turns into an infinite sequence.
      .          .          .          .               fn extract_alternation<'a, I: Iterator<Item = &'a Hir>>(
      .          .          .          .                   &self,
      .          .          .          .                   it: I,
      .          .          .          .               ) -> Seq {
      .          .          .          .                   let mut seq = Seq::empty();
  2,258 ( 0.00%) .          .          .                   for hir in it {
      .          .          .          .                       // Once our 'seq' is infinite, every subsequent union
      .          .          .          .                       // operation on it will itself always result in an
      .          .          .          .                       // infinite sequence. Thus, it can never change and we can
      .          .          .          .                       // short-circuit.
      .          .          .          .                       if !seq.is_finite() {
      .          .          .          .                           break;
      .          .          .          .                       }
 40,590 ( 0.01%) .          .          .                       seq = self.union(seq, &mut self.extract(hir));
443,446 ( 0.13%) 1,765 ( 0.22%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (855x)
871,291 ( 0.26%) 274 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::union (855x)
      .          .          .          .                   }
    240 ( 0.00%) .          .          .                   seq
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Extract a sequence of literals from the given repetition. We do our
      .          .          .          .               /// best, Some examples:
      .          .          .          .               ///
      .          .          .          .               ///   'a*'    => [inexact(a), exact("")]
      .          .          .          .               ///   'a*?'   => [exact(""), inexact(a)]
      .          .          .          .               ///   'a+'    => [inexact(a)]
-- line 438 ----------------------------------------
-- line 441 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// The key here really is making sure we get the 'inexact' vs 'exact'
      .          .          .          .               /// attributes correct on each of the literals we add. For example, the
      .          .          .          .               /// fact that 'a*' gives us an inexact 'a' and an exact empty string means
      .          .          .          .               /// that a regex like 'ab*c' will result in [inexact(ab), exact(ac)]
      .          .          .          .               /// literals being extracted, which might actually be a better prefilter
      .          .          .          .               /// than just 'a'.
      .          .          .          .               fn extract_repetition(&self, rep: &hir::Repetition) -> Seq {
  1,477 ( 0.00%) .          .          .                   let mut subseq = self.extract(&rep.sub);
 10,485 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract'2 (9x)
    689 ( 0.00%) .          .          .                   match *rep {
    192 ( 0.00%) .          .          .                       hir::Repetition { min: 0, max, greedy, .. } => {
      .          .          .          .                           // When 'max=1', we can retain exactness, since 'a?' is
      .          .          .          .                           // equivalent to 'a|'. Similarly below, 'a??' is equivalent to
      .          .          .          .                           // '|a'.
    762 ( 0.00%) .          .          .                           if max != Some(1) {
      .          .          .          .                               subseq.make_inexact();
      .          .          .          .                           }
      .          .          .          .                           let mut empty = Seq::singleton(Literal::exact(vec![]));
    384 ( 0.00%) .          .          .                           if !greedy {
      .          .          .          .                               mem::swap(&mut subseq, &mut empty);
      .          .          .          .                           }
  2,304 ( 0.00%) .          .          .                           self.union(subseq, &mut empty)
  1,899 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::union (9x)
      .          .          .          .                       }
      .          .          .          .                       hir::Repetition { min, max: Some(max), .. } if min == max => {
      .          .          .          .                           assert!(min > 0); // handled above
      .          .          .          .                           let limit =
      .          .          .          .                               u32::try_from(self.limit_repeat).unwrap_or(u32::MAX);
      .          .          .          .                           let mut seq = Seq::singleton(Literal::exact(vec![]));
      .          .          .          .                           for _ in 0..cmp::min(min, limit) {
      .          .          .          .                               if seq.is_inexact() {
      .          .          .          .                                   break;
      .          .          .          .                               }
    198 ( 0.00%) .          .          .                               seq = self.cross(seq, &mut subseq.clone());
363,510 ( 0.11%) 1,158 ( 0.14%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (18x)
      .          .          .          .                           }
     48 ( 0.00%) .          .          .                           if usize::try_from(min).is_err() || min > limit {
      .          .          .          .                               seq.make_inexact();
      .          .          .          .                           }
      .          .          .          .                           seq
      .          .          .          .                       }
      .          .          .          .                       hir::Repetition { min, .. } => {
      .          .          .          .                           assert!(min > 0); // handled above
      .          .          .          .                           let limit =
      .          .          .          .                               u32::try_from(self.limit_repeat).unwrap_or(u32::MAX);
      .          .          .          .                           let mut seq = Seq::singleton(Literal::exact(vec![]));
      .          .          .          .                           for _ in 0..cmp::min(min, limit) {
      .          .          .          .                               if seq.is_inexact() {
      .          .          .          .                                   break;
      .          .          .          .                               }
    121 ( 0.00%) .          .          .                               seq = self.cross(seq, &mut subseq.clone());
  7,782 ( 0.00%) 3 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::cross (11x)
      .          .          .          .                           }
      .          .          .          .                           seq.make_inexact();
      .          .          .          .                           seq
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Convert the given Unicode class into a sequence of literals if the
      .          .          .          .               /// class is small enough. If the class is too big, return an infinite
      .          .          .          .               /// sequence.
      .          .          .          .               fn extract_class_unicode(&self, cls: &hir::ClassUnicode) -> Seq {
    187 ( 0.00%) .          .          .                   if self.class_over_limit_unicode(cls) {
      .          .          .          .                       return Seq::infinite();
      .          .          .          .                   }
      .          .          .          .                   let mut seq = Seq::empty();
      .          .          .          .                   for r in cls.iter() {
      .          .          .          .                       for ch in r.start()..=r.end() {
    409 ( 0.00%) .          .          .                           seq.push(Literal::from(ch));
      .          .          .          .                       }
      .          .          .          .                   }
     89 ( 0.00%) .          .          .                   self.enforce_literal_len(&mut seq);
    356 ( 0.00%) .          .          .                   seq
      9 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Convert the given byte class into a sequence of literals if the class
      .          .          .          .               /// is small enough. If the class is too big, return an infinite sequence.
      .          .          .          .               fn extract_class_bytes(&self, cls: &hir::ClassBytes) -> Seq {
      .          .          .          .                   if self.class_over_limit_bytes(cls) {
      .          .          .          .                       return Seq::infinite();
      .          .          .          .                   }
      .          .          .          .                   let mut seq = Seq::empty();
      .          .          .          .                   for r in cls.iter() {
      .          .          .          .                       for b in r.start()..=r.end() {
      .          .          .          .                           seq.push(Literal::from(b));
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   self.enforce_literal_len(&mut seq);
      .          .          .          .                   seq
     89 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if the given Unicode class exceeds the configured limits
      .          .          .          .               /// on this extractor.
      .          .          .          .               fn class_over_limit_unicode(&self, cls: &hir::ClassUnicode) -> bool {
      .          .          .          .                   let mut count = 0;
      .          .          .          .                   for r in cls.iter() {
    608 ( 0.00%) .          .          .                       if count > self.limit_class {
      .          .          .          .                           return true;
      .          .          .          .                       }
    246 ( 0.00%) .          .          .                       count += r.len();
      .          .          .          .                   }
     89 ( 0.00%) .          .          .                   count > self.limit_class
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if the given byte class exceeds the configured limits on
      .          .          .          .               /// this extractor.
      .          .          .          .               fn class_over_limit_bytes(&self, cls: &hir::ClassBytes) -> bool {
      .          .          .          .                   let mut count = 0;
      .          .          .          .                   for r in cls.iter() {
      .          .          .          .                       if count > self.limit_class {
-- line 548 ----------------------------------------
-- line 551 ----------------------------------------
      .          .          .          .                       count += r.len();
      .          .          .          .                   }
      .          .          .          .                   count > self.limit_class
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compute the cross product of the two sequences if the result would be
      .          .          .          .               /// within configured limits. Otherwise, make `seq2` infinite and cross the
      .          .          .          .               /// infinite sequence with `seq1`.
  5,784 ( 0.00%) .          .          .               fn cross(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq {
  3,311 ( 0.00%) .          .          .                   if seq1.max_cross_len(seq2).map_or(false, |len| len > self.limit_total)
      .          .          .          .                   {
      .          .          .          .                       seq2.make_infinite();
      .          .          .          .                   }
  2,410 ( 0.00%) .          .          .                   if let ExtractKind::Suffix = self.kind {
      .          .          .          .                       seq1.cross_reverse(seq2);
      .          .          .          .                   } else {
      .          .          .          .                       seq1.cross_forward(seq2);
      .          .          .          .                   }
    469 ( 0.00%) .          .          .                   assert!(seq1.len().map_or(true, |x| x <= self.limit_total));
    469 ( 0.00%) .          .          .                   self.enforce_literal_len(&mut seq1);
  2,410 ( 0.00%) .          .          .                   seq1
  3,856 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Union the two sequences if the result would be within configured
      .          .          .          .               /// limits. Otherwise, make `seq2` infinite and union the infinite sequence
      .          .          .          .               /// with `seq1`.
 26,917 ( 0.01%) .          .          .               fn union(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq {
 14,682 ( 0.00%) .          .          .                   if seq1.max_union_len(seq2).map_or(false, |len| len > self.limit_total)
      .          .          .          .                   {
      .          .          .          .                       // We try to trim our literal sequences to see if we can make
      .          .          .          .                       // room for more literals. The idea is that we'd rather trim down
      .          .          .          .                       // literals already in our sequence if it means we can add a few
      .          .          .          .                       // more and retain a finite sequence. Otherwise, we'll union with
      .          .          .          .                       // an infinite sequence and that infects everything and effectively
      .          .          .          .                       // stops literal extraction in its tracks.
      .          .          .          .                       //
      .          .          .          .                       // We do we keep 4 bytes here? Well, it's a bit of an abstraction
      .          .          .          .                       // leakage. Downstream, the literals may wind up getting fed to
      .          .          .          .                       // the Teddy algorithm, which supports searching literals up to
      .          .          .          .                       // length 4. So that's why we pick that number here. Arguably this
      .          .          .          .                       // should be a tuneable parameter, but it seems a little tricky to
      .          .          .          .                       // describe. And I'm still unsure if this is the right way to go
      .          .          .          .                       // about culling literal sequences.
      3 ( 0.00%) .          .          .                       match self.kind {
      .          .          .          .                           ExtractKind::Prefix => {
      .          .          .          .                               seq1.keep_first_bytes(4);
      .          .          .          .                               seq2.keep_first_bytes(4);
      .          .          .          .                           }
      .          .          .          .                           ExtractKind::Suffix => {
      .          .          .          .                               seq1.keep_last_bytes(4);
      .          .          .          .                               seq2.keep_last_bytes(4);
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                       seq1.dedup();
      .          .          .          .                       seq2.dedup();
      5 ( 0.00%) .          .          .                       if seq1
      .          .          .          .                           .max_union_len(seq2)
      .          .          .          .                           .map_or(false, |len| len > self.limit_total)
      .          .          .          .                       {
      .          .          .          .                           seq2.make_infinite();
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   seq1.union(seq2);
  2,443 ( 0.00%) .          .          .                   assert!(seq1.len().map_or(true, |x| x <= self.limit_total));
  9,788 ( 0.00%) .          .          .                   seq1
 19,576 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Applies the literal length limit to the given sequence. If none of the
      .          .          .          .               /// literals in the sequence exceed the limit, then this is a no-op.
      .          .          .          .               fn enforce_literal_len(&self, seq: &mut Seq) {
      .          .          .          .                   let len = self.limit_literal_len;
  8,255 ( 0.00%) .          .          .                   match self.kind {
      .          .          .          .                       ExtractKind::Prefix => seq.keep_first_bytes(len),
      .          .          .          .                       ExtractKind::Suffix => seq.keep_last_bytes(len),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Default for Extractor {
      .          .          .          .               fn default() -> Extractor {
-- line 630 ----------------------------------------
-- line 724 ----------------------------------------
      .          .          .          .           /// // not altered by simplifying the set.
      .          .          .          .           /// let expected = Seq::from_iter([
      .          .          .          .           ///     Literal::inexact("far"),
      .          .          .          .           ///     Literal::inexact("app"),
      .          .          .          .           ///     Literal::exact("gap"),
      .          .          .          .           /// ]);
      .          .          .          .           /// assert_eq!(expected, seq);
      .          .          .          .           /// ```
    116 ( 0.00%) .          .          .           #[derive(Clone, Eq, PartialEq)]
      .          .          .          .           pub struct Seq {
      .          .          .          .               /// The members of this seq.
      .          .          .          .               ///
      .          .          .          .               /// When `None`, the seq represents all possible literals. That is, it
      .          .          .          .               /// prevents one from making assumptions about specific literals in the
      .          .          .          .               /// seq, and forces one to treat it as if any literal might be in the seq.
      .          .          .          .               ///
      .          .          .          .               /// Note that `Some(vec![])` is valid and corresponds to the empty seq of
-- line 740 ----------------------------------------
-- line 746 ----------------------------------------
      .          .          .          .           
      .          .          .          .           impl Seq {
      .          .          .          .               /// Returns an empty sequence.
      .          .          .          .               ///
      .          .          .          .               /// An empty sequence matches zero literals, and thus corresponds to a
      .          .          .          .               /// regex that itself can never match.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn empty() -> Seq {
    354 ( 0.00%) .          .          .                   Seq { literals: Some(vec![]) }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a sequence of literals without a finite size and may contain
      .          .          .          .               /// any literal.
      .          .          .          .               ///
      .          .          .          .               /// A sequence without finite size does not reveal anything about the
      .          .          .          .               /// characteristics of the literals in its set. There are no fixed prefixes
      .          .          .          .               /// or suffixes, nor are lower or upper bounds on the length of the literals
-- line 762 ----------------------------------------
-- line 775 ----------------------------------------
      .          .          .          .               #[inline]
      .          .          .          .               pub fn infinite() -> Seq {
      .          .          .          .                   Seq { literals: None }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a sequence containing a single literal.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn singleton(lit: Literal) -> Seq {
 12,095 ( 0.00%) .          .          .                   Seq { literals: Some(vec![lit]) }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a sequence of exact literals from the given byte strings.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn new<I, B>(it: I) -> Seq
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = B>,
      .          .          .          .                   B: AsRef<[u8]>,
-- line 791 ----------------------------------------
-- line 810 ----------------------------------------
      .          .          .          .               /// Similarly, if the most recently added item of this sequence is
      .          .          .          .               /// equivalent to the literal given, then it is not added. This reflects
      .          .          .          .               /// a `Seq`'s "set like" behavior, and represents a practical trade off.
      .          .          .          .               /// Namely, there is never any need to have two adjacent and equivalent
      .          .          .          .               /// literals in the same sequence, _and_ it is easy to detect in some
      .          .          .          .               /// cases.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn push(&mut self, lit: Literal) {
  1,636 ( 0.00%) .          .          .                   let lits = match self.literals {
      .          .          .          .                       None => return,
      .          .          .          .                       Some(ref mut lits) => lits,
      .          .          .          .                   };
    318 ( 0.00%) .          .          .                   if lits.last().map_or(false, |m| m == &lit) {
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .                   lits.push(lit);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Make all of the literals in this sequence inexact.
      .          .          .          .               ///
      .          .          .          .               /// This is a no-op if this sequence is not finite.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn make_inexact(&mut self) {
    125 ( 0.00%) .          .          .                   let lits = match self.literals {
      .          .          .          .                       None => return,
      .          .          .          .                       Some(ref mut lits) => lits,
      .          .          .          .                   };
     53 ( 0.00%) .          .          .                   for lit in lits.iter_mut() {
      .          .          .          .                       lit.make_inexact();
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Converts this sequence to an infinite sequence.
      .          .          .          .               ///
      .          .          .          .               /// This is a no-op if the sequence is already infinite.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn make_infinite(&mut self) {
     94 ( 0.00%) .          .          .                   self.literals = None;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Modify this sequence to contain the cross product between it and the
      .          .          .          .               /// sequence given.
      .          .          .          .               ///
      .          .          .          .               /// The cross product only considers literals in this sequence that are
      .          .          .          .               /// exact. That is, inexact literals are not extended.
      .          .          .          .               ///
-- line 855 ----------------------------------------
-- line 952 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// // seq1 remains unchanged.
      .          .          .          .               /// assert!(!seq1.is_finite());
      .          .          .          .               /// // Even though the literals in seq2 weren't used, it was still drained.
      .          .          .          .               /// assert_eq!(Some(0), seq2.len());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn cross_forward(&mut self, other: &mut Seq) {
    399 ( 0.00%) .          .          .                   let (lits1, lits2) = match self.cross_preamble(other) {
      .          .          .          .                       None => return,
      .          .          .          .                       Some((lits1, lits2)) => (lits1, lits2),
      .          .          .          .                   };
      .          .          .          .                   let newcap = lits1.len().saturating_mul(lits2.len());
  2,946 ( 0.00%) .          .          .                   for selflit in mem::replace(lits1, Vec::with_capacity(newcap)) {
  1,964 ( 0.00%) .          .          .                       if !selflit.is_exact() {
     96 ( 0.00%) .          .          .                           lits1.push(selflit);
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       for otherlit in lits2.iter() {
      .          .          .          .                           let mut newlit = Literal::exact(Vec::with_capacity(
      .          .          .          .                               selflit.len() + otherlit.len(),
      .          .          .          .                           ));
      .          .          .          .                           newlit.extend(&selflit);
  9,256 ( 0.00%) .          .          .                           newlit.extend(&otherlit);
  9,256 ( 0.00%) .          .          .                           if !otherlit.is_exact() {
      .          .          .          .                               newlit.make_inexact();
      .          .          .          .                           }
      .          .          .          .                           lits1.push(newlit);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   lits2.drain(..);
      .          .          .          .                   self.dedup();
      .          .          .          .               }
-- line 984 ----------------------------------------
-- line 1091 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// // seq1 remains unchanged.
      .          .          .          .               /// assert!(!seq1.is_finite());
      .          .          .          .               /// // Even though the literals in seq2 weren't used, it was still drained.
      .          .          .          .               /// assert_eq!(Some(0), seq2.len());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn cross_reverse(&mut self, other: &mut Seq) {
     83 ( 0.00%) .          .          .                   let (lits1, lits2) = match self.cross_preamble(other) {
      .          .          .          .                       None => return,
      .          .          .          .                       Some((lits1, lits2)) => (lits1, lits2),
      .          .          .          .                   };
      .          .          .          .                   // We basically proceed as we do in 'cross_forward' at this point,
      .          .          .          .                   // except that the outer loop is now 'other' and the inner loop is now
      .          .          .          .                   // 'self'. That's because 'self' corresponds to suffixes and 'other'
      .          .          .          .                   // corresponds to the sequence we want to *prepend* to the suffixes.
      .          .          .          .                   let newcap = lits1.len().saturating_mul(lits2.len());
      .          .          .          .                   let selflits = mem::replace(lits1, Vec::with_capacity(newcap));
      .          .          .          .                   for (i, otherlit) in lits2.drain(..).enumerate() {
      .          .          .          .                       for selflit in selflits.iter() {
  4,686 ( 0.00%) .          .          .                           if !selflit.is_exact() {
      .          .          .          .                               // If the suffix isn't exact, then we can't prepend
      .          .          .          .                               // anything to it. However, we still want to keep it. But
      .          .          .          .                               // we only want to keep one of them, to avoid duplication.
      .          .          .          .                               // (The duplication is okay from a correctness perspective,
      .          .          .          .                               // but wasteful.)
      .          .          .          .                               if i == 0 {
      .          .          .          .                                   lits1.push(selflit.clone());
      .          .          .          .                               }
      .          .          .          .                               continue;
      .          .          .          .                           }
      .          .          .          .                           let mut newlit = Literal::exact(Vec::with_capacity(
      .          .          .          .                               otherlit.len() + selflit.len(),
      .          .          .          .                           ));
      .          .          .          .                           newlit.extend(&otherlit);
  4,526 ( 0.00%) .          .          .                           newlit.extend(&selflit);
  4,526 ( 0.00%) .          .          .                           if !otherlit.is_exact() {
      .          .          .          .                               newlit.make_inexact();
      .          .          .          .                           }
      .          .          .          .                           lits1.push(newlit);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   self.dedup();
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// A helper function the corresponds to the subtle preamble for both
      .          .          .          .               /// `cross_forward` and `cross_reverse`. In effect, it handles the cases
      .          .          .          .               /// of infinite sequences for both `self` and `other`, as well as ensuring
      .          .          .          .               /// that literals from `other` are drained even if they aren't used.
  5,302 ( 0.00%) .          .          .               fn cross_preamble<'a>(
      .          .          .          .                   &'a mut self,
      .          .          .          .                   other: &'a mut Seq,
      .          .          .          .               ) -> Option<(&'a mut Vec<Literal>, &'a mut Vec<Literal>)> {
    964 ( 0.00%) .          .          .                   let lits2 = match other.literals {
      .          .          .          .                       None => {
      .          .          .          .                           // If our current seq contains the empty string and the seq
      .          .          .          .                           // we're adding matches any literal, then it follows that the
      .          .          .          .                           // current seq must now also match any literal.
      .          .          .          .                           //
      .          .          .          .                           // Otherwise, we just have to make sure everything in this
      .          .          .          .                           // sequence is inexact.
     60 ( 0.00%) .          .          .                           if self.min_literal_len() == Some(0) {
     26 ( 0.00%) .          .          .                               *self = Seq::infinite();
      .          .          .          .                           } else {
      .          .          .          .                               self.make_inexact();
      .          .          .          .                           }
      .          .          .          .                           return None;
      .          .          .          .                       }
      .          .          .          .                       Some(ref mut lits) => lits,
      .          .          .          .                   };
    422 ( 0.00%) .          .          .                   let lits1 = match self.literals {
      .          .          .          .                       None => {
      .          .          .          .                           // If we aren't going to make it to the end of this routine
      .          .          .          .                           // where lits2 is drained, then we need to do it now.
      .          .          .          .                           lits2.drain(..);
      .          .          .          .                           return None;
      .          .          .          .                       }
      .          .          .          .                       Some(ref mut lits) => lits,
      .          .          .          .                   };
      .          .          .          .                   Some((lits1, lits2))
  4,820 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Unions the `other` sequence into this one.
      .          .          .          .               ///
      .          .          .          .               /// The literals are always drained out of the given `other` sequence,
      .          .          .          .               /// even if they are being unioned into an infinite sequence. This permits
      .          .          .          .               /// the caller to reuse the `other` sequence in another context.
      .          .          .          .               ///
      .          .          .          .               /// Some literal deduping may be performed. If any deduping happens,
-- line 1179 ----------------------------------------
-- line 1212 ----------------------------------------
      .          .          .          .               /// seq1.union(&mut seq2);
      .          .          .          .               ///
      .          .          .          .               /// // seq1 is still infinite and seq2 has been drained.
      .          .          .          .               /// assert_eq!(None, seq1.len());
      .          .          .          .               /// assert_eq!(Some(0), seq2.len());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn union(&mut self, other: &mut Seq) {
  4,950 ( 0.00%) .          .          .                   let lits2 = match other.literals {
      .          .          .          .                       None => {
      .          .          .          .                           // Unioning with an infinite sequence always results in an
      .          .          .          .                           // infinite sequence.
      .          .          .          .                           self.make_infinite();
      4 ( 0.00%) .          .          .                           return;
      .          .          .          .                       }
      .          .          .          .                       Some(ref mut lits) => lits.drain(..),
      .          .          .          .                   };
  4,940 ( 0.00%) .          .          .                   let lits1 = match self.literals {
      .          .          .          .                       None => return,
      .          .          .          .                       Some(ref mut lits) => lits,
      .          .          .          .                   };
 12,377 ( 0.00%) .          .          .                   lits1.extend(lits2);
      .          .          .          .                   self.dedup();
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Unions the `other` sequence into this one by splice the `other`
      .          .          .          .               /// sequence at the position of the first zero-length literal.
      .          .          .          .               ///
      .          .          .          .               /// This is useful for preserving preference order semantics when combining
      .          .          .          .               /// two literal sequences. For example, in the regex `(a||f)+foo`, the
-- line 1241 ----------------------------------------
-- line 1334 ----------------------------------------
      .          .          .          .               ///     Literal::inexact("foo"),
      .          .          .          .               /// ]);
      .          .          .          .               /// seq.dedup();
      .          .          .          .               ///
      .          .          .          .               /// assert_eq!(Seq::from_iter([Literal::inexact("foo")]), seq);
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn dedup(&mut self) {
  6,206 ( 0.00%) .          .          .                   if let Some(ref mut lits) = self.literals {
  8,564 ( 0.00%) .          .          .                       lits.dedup_by(|lit1, lit2| {
201,140 ( 0.06%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::dedup_by (422x)
 58,970 ( 0.02%) .          .          .                           if lit1.as_bytes() != lit2.as_bytes() {
      .          .          .          .                               return false;
      .          .          .          .                           }
      .          .          .          .                           if lit1.is_exact() != lit2.is_exact() {
      .          .          .          .                               lit1.make_inexact();
      .          .          .          .                               lit2.make_inexact();
      .          .          .          .                           }
      .          .          .          .                           true
      .          .          .          .                       });
-- line 1352 ----------------------------------------
-- line 1482 ----------------------------------------
      .          .          .          .               ///     Literal::exact("a"),
      .          .          .          .               ///     Literal::inexact("fo"),
      .          .          .          .               ///     Literal::inexact("qu"),
      .          .          .          .               /// ]);
      .          .          .          .               /// assert_eq!(expected, seq);
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn keep_first_bytes(&mut self, len: usize) {
    220 ( 0.00%) .          .          .                   if let Some(ref mut lits) = self.literals {
      .          .          .          .                       for m in lits.iter_mut() {
      .          .          .          .                           m.keep_first_bytes(len);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Trims all literals in this seq such that only the last `len` bytes
      .          .          .          .               /// remain. If a literal has less than or equal to `len` bytes, then it
-- line 1498 ----------------------------------------
-- line 1510 ----------------------------------------
      .          .          .          .               ///     Literal::exact("a"),
      .          .          .          .               ///     Literal::inexact("oo"),
      .          .          .          .               ///     Literal::inexact("ux"),
      .          .          .          .               /// ]);
      .          .          .          .               /// assert_eq!(expected, seq);
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn keep_last_bytes(&mut self, len: usize) {
    136 ( 0.00%) .          .          .                   if let Some(ref mut lits) = self.literals {
      .          .          .          .                       for m in lits.iter_mut() {
      .          .          .          .                           m.keep_last_bytes(len);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if this sequence is finite.
      .          .          .          .               ///
-- line 1526 ----------------------------------------
-- line 1624 ----------------------------------------
      .          .          .          .               /// assert_eq!(None, seq.longest_common_prefix());
      .          .          .          .               /// let seq = Seq::empty();
      .          .          .          .               /// assert_eq!(None, seq.longest_common_prefix());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn longest_common_prefix(&self) -> Option<&[u8]> {
      .          .          .          .                   // If we match everything or match nothing, then there's no meaningful
      .          .          .          .                   // longest common prefix.
    150 ( 0.00%) .          .          .                   let lits = match self.literals {
      .          .          .          .                       None => return None,
      .          .          .          .                       Some(ref lits) => lits,
      .          .          .          .                   };
    100 ( 0.00%) .          .          .                   if lits.len() == 0 {
      .          .          .          .                       return None;
      .          .          .          .                   }
      .          .          .          .                   let base = lits[0].as_bytes();
      .          .          .          .                   let mut len = base.len();
      .          .          .          .                   for m in lits.iter().skip(1) {
      .          .          .          .                       len = m
      .          .          .          .                           .as_bytes()
      .          .          .          .                           .iter()
      .          .          .          .                           .zip(base[..len].iter())
      .          .          .          .                           .take_while(|&(a, b)| a == b)
      .          .          .          .                           .count();
  1,310 ( 0.00%) .          .          .                       if len == 0 {
      .          .          .          .                           return Some(&[]);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Some(&base[..len])
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the longest common suffix from this seq.
      .          .          .          .               ///
-- line 1656 ----------------------------------------
-- line 1677 ----------------------------------------
      .          .          .          .               /// assert_eq!(None, seq.longest_common_suffix());
      .          .          .          .               /// let seq = Seq::empty();
      .          .          .          .               /// assert_eq!(None, seq.longest_common_suffix());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn longest_common_suffix(&self) -> Option<&[u8]> {
      .          .          .          .                   // If we match everything or match nothing, then there's no meaningful
      .          .          .          .                   // longest common suffix.
     65 ( 0.00%) .          .          .                   let lits = match self.literals {
      .          .          .          .                       None => return None,
      .          .          .          .                       Some(ref lits) => lits,
      .          .          .          .                   };
     24 ( 0.00%) .          .          .                   if lits.len() == 0 {
      .          .          .          .                       return None;
      .          .          .          .                   }
      .          .          .          .                   let base = lits[0].as_bytes();
      .          .          .          .                   let mut len = base.len();
      .          .          .          .                   for m in lits.iter().skip(1) {
      .          .          .          .                       len = m
      .          .          .          .                           .as_bytes()
      .          .          .          .                           .iter()
      .          .          .          .                           .rev()
     36 ( 0.00%) .          .          .                           .zip(base[base.len() - len..].iter().rev())
      .          .          .          .                           .take_while(|&(a, b)| a == b)
      .          .          .          .                           .count();
     96 ( 0.00%) .          .          .                       if len == 0 {
      .          .          .          .                           return Some(&[]);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Some(&base[base.len() - len..])
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Optimizes this seq while treating its literals as prefixes and
      .          .          .          .               /// respecting the preference order of its literals.
-- line 1710 ----------------------------------------
-- line 1812 ----------------------------------------
      .          .          .          .               ///     "sam",
      .          .          .          .               ///     "frodo",
      .          .          .          .               /// ]);
      .          .          .          .               /// seq.optimize_for_prefix_by_preference();
      .          .          .          .               /// assert!(seq.is_finite());
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn optimize_for_prefix_by_preference(&mut self) {
    136 ( 0.00%) .          .          .                   self.optimize_by_preference(true);
5,145,284 ( 1.54%) 17,798 ( 2.20%) 4 ( 1.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Seq::optimize_by_preference (44x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Optimizes this seq while treating its literals as suffixes and
      .          .          .          .               /// respecting the preference order of its literals.
      .          .          .          .               ///
      .          .          .          .               /// Optimization should only be run once extraction is complete.
      .          .          .          .               ///
      .          .          .          .               /// The [`Seq::optimize_for_prefix_by_preference`] does the same thing, but
      .          .          .          .               /// for prefixes. See its documentation for more explanation.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn optimize_for_suffix_by_preference(&mut self) {
     39 ( 0.00%) .          .          .                   self.optimize_by_preference(false);
  4,004 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Seq::optimize_by_preference (13x)
      .          .          .          .               }
      .          .          .          .           
    511 ( 0.00%) .          .          .               fn optimize_by_preference(&mut self, prefix: bool) {
      .          .          .          .                   let origlen = match self.len() {
      .          .          .          .                       None => return,
      .          .          .          .                       Some(len) => len,
      .          .          .          .                   };
      .          .          .          .                   // Just give up now if our sequence contains an empty string.
     71 ( 0.00%) .          .          .                   if self.min_literal_len().map_or(false, |len| len == 0) {
      .          .          .          .                       // We squash the sequence so that nobody else gets any bright
      .          .          .          .                       // ideas to try and use it. An empty string implies a match at
      .          .          .          .                       // every position. A prefilter cannot help you here.
      .          .          .          .                       self.make_infinite();
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .                   // Make sure we start with the smallest sequence possible. We use a
      .          .          .          .                   // special version of preference minimization that retains exactness.
      .          .          .          .                   // This is legal because optimization is only expected to occur once
      .          .          .          .                   // extraction is complete.
    124 ( 0.00%) .          .          .                   if prefix {
      .          .          .          .                       if let Some(ref mut lits) = self.literals {
    150 ( 0.00%) .          .          .                           PreferenceTrie::minimize(lits, true);
2,657,381 ( 0.80%) 8,270 ( 1.02%) 4 ( 1.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::PreferenceTrie::minimize (50x)
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   // Look for a common prefix (or suffix). If we found one of those and
      .          .          .          .                   // it's long enough, then it's a good bet that it will be our fastest
      .          .          .          .                   // possible prefilter since single-substring search is so fast.
      .          .          .          .                   let fix = if prefix {
      .          .          .          .                       self.longest_common_prefix()
-- line 1862 ----------------------------------------
-- line 1889 ----------------------------------------
      .          .          .          .                           self.dedup();
      .          .          .          .                           return;
      .          .          .          .                       }
      .          .          .          .                       // We only strip down to the common prefix/suffix if we think
      .          .          .          .                       // the existing set of literals isn't great, or if the common
      .          .          .          .                       // prefix/suffix is expected to be particularly discriminatory.
      .          .          .          .                       let isfast =
      .          .          .          .                           self.is_exact() && self.len().map_or(false, |len| len <= 16);
     62 ( 0.00%) .          .          .                       let usefix = fix.len() > 4 || (fix.len() > 1 && !isfast);
      .          .          .          .                       if usefix {
      .          .          .          .                           // If we keep exactly the number of bytes equal to the length
      .          .          .          .                           // of the prefix (or suffix), then by the definition of a
      .          .          .          .                           // prefix, every literal in the sequence will be equivalent.
      .          .          .          .                           // Thus, 'dedup' will leave us with one literal.
      .          .          .          .                           //
      .          .          .          .                           // We do it this way to avoid an alloc, but also to make sure
      .          .          .          .                           // the exactness of literals is kept (or not).
-- line 1905 ----------------------------------------
-- line 1945 ----------------------------------------
      .          .          .          .                   //
      .          .          .          .                   // So for example, the pair (3, 500) would mean, "if we have more than
      .          .          .          .                   // 500 literals in our sequence, then truncate all of our literals
      .          .          .          .                   // such that they are at most 3 bytes in length and the minimize the
      .          .          .          .                   // sequence."
      .          .          .          .                   const ATTEMPTS: [(usize, usize); 5] =
      .          .          .          .                       [(5, 10), (4, 10), (3, 64), (2, 64), (1, 10)];
      .          .          .          .                   for (keep, limit) in ATTEMPTS {
    184 ( 0.00%) .          .          .                       let len = match self.len() {
      .          .          .          .                           None => break,
      .          .          .          .                           Some(len) => len,
      .          .          .          .                       };
      .          .          .          .                       if len <= limit {
      .          .          .          .                           break;
      .          .          .          .                       }
    262 ( 0.00%) .          .          .                       if prefix {
      .          .          .          .                           self.keep_first_bytes(keep);
      .          .          .          .                       } else {
      .          .          .          .                           self.keep_last_bytes(keep);
      .          .          .          .                       }
      .          .          .          .                       if prefix {
    254 ( 0.00%) .          .          .                           if let Some(ref mut lits) = self.literals {
    381 ( 0.00%) .          .          .                               PreferenceTrie::minimize(lits, true);
7,085,857 ( 2.13%) 19,825 ( 2.45%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::PreferenceTrie::minimize (127x)
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // Check for a poison literal. A poison literal is one that is short
      .          .          .          .                   // and is believed to have a very high match count. These poisons
      .          .          .          .                   // generally lead to a prefilter with a very high false positive rate,
      .          .          .          .                   // and thus overall worse performance.
      .          .          .          .                   //
      .          .          .          .                   // We do this last because we could have gone from a non-poisonous
      .          .          .          .                   // sequence to a poisonous one. Perhaps we should add some code to
      .          .          .          .                   // prevent such transitions in the first place, but then again, we
      .          .          .          .                   // likely only made the transition in the first place if the sequence
      .          .          .          .                   // was itself huge. And huge sequences are themselves poisonous. So...
     62 ( 0.00%) .          .          .                   if let Some(lits) = self.literals() {
      .          .          .          .                       if lits.iter().any(|lit| lit.is_poisonous()) {
      .          .          .          .                           self.make_infinite();
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // OK, if we had an exact sequence before attempting more optimizations
      .          .          .          .                   // above and our post-optimized sequence sucks for some reason or
      .          .          .          .                   // another, then we go back to the exact sequence.
    186 ( 0.00%) .          .          .                   if let Some(exact) = exact {
      .          .          .          .                       // If optimizing resulted in dropping our literals, then certainly
      .          .          .          .                       // backup and use the exact sequence that we had.
      .          .          .          .                       if !self.is_finite() {
      .          .          .          .                           *self = exact;
      .          .          .          .                           return;
      .          .          .          .                       }
      .          .          .          .                       // If our optimized sequence contains a short literal, then it's
      .          .          .          .                       // *probably* not so great. So throw it away and revert to the
-- line 1997 ----------------------------------------
-- line 2002 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .                       // Finally, if our optimized sequence is "big" (i.e., can't use
      .          .          .          .                       // Teddy), then also don't use it and rely on the exact sequence.
      .          .          .          .                       if self.len().map_or(true, |len| len > 64) {
      .          .          .          .                           *self = exact;
      .          .          .          .                           return;
      .          .          .          .                       }
      .          .          .          .                   }
    584 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl core::fmt::Debug for Seq {
      .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      .          .          .          .                   write!(f, "Seq")?;
      .          .          .          .                   if let Some(lits) = self.literals() {
      .          .          .          .                       f.debug_list().entries(lits.iter()).finish()
      .          .          .          .                   } else {
-- line 2018 ----------------------------------------
-- line 2040 ----------------------------------------
      .          .          .          .           /// literal extracted may not be valid UTF-8. (For example, if an [`Extractor`]
      .          .          .          .           /// limit resulted in trimming a literal in a way that splits a codepoint.)
      .          .          .          .           /// * Whether the literal is "exact" or not. An "exact" literal means that it
      .          .          .          .           /// has not been trimmed, and may continue to be extended. If a literal is
      .          .          .          .           /// "exact" after visiting the entire `Hir` expression, then this implies that
      .          .          .          .           /// the literal leads to a match state. (Although it doesn't necessarily imply
      .          .          .          .           /// all occurrences of the literal correspond to a match of the regex, since
      .          .          .          .           /// literal extraction ignores look-around assertions.)
      8 ( 0.00%) .          .          .           #[derive(Clone, Eq, PartialEq, PartialOrd, Ord)]
      .          .          .          .           pub struct Literal {
      .          .          .          .               bytes: Vec<u8>,
    195 ( 0.00%) .          .          .               exact: bool,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Literal {
      .          .          .          .               /// Returns a new exact literal containing the bytes given.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn exact<B: Into<Vec<u8>>>(bytes: B) -> Literal {
 27,564 ( 0.01%) .          .          .                   Literal { bytes: bytes.into(), exact: true }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a new inexact literal containing the bytes given.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn inexact<B: Into<Vec<u8>>>(bytes: B) -> Literal {
      .          .          .          .                   Literal { bytes: bytes.into(), exact: false }
      .          .          .          .               }
      .          .          .          .           
-- line 2066 ----------------------------------------
-- line 2097 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Marks this literal as inexact.
      .          .          .          .               ///
      .          .          .          .               /// Inexact literals can never be extended. For example,
      .          .          .          .               /// [`Seq::cross_forward`] will not extend inexact literals.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn make_inexact(&mut self) {
  8,732 ( 0.00%) .          .          .                   self.exact = false;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Reverse the bytes in this literal.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn reverse(&mut self) {
      .          .          .          .                   self.bytes.reverse();
      .          .          .          .               }
      .          .          .          .           
-- line 2113 ----------------------------------------
-- line 2122 ----------------------------------------
      .          .          .          .                   self.bytes.extend_from_slice(&lit.bytes);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Trims this literal such that only the first `len` bytes remain. If
      .          .          .          .               /// this literal has fewer than `len` bytes, then it remains unchanged.
      .          .          .          .               /// Otherwise, the literal is marked as inexact.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn keep_first_bytes(&mut self, len: usize) {
 44,376 ( 0.01%) .          .          .                   if len >= self.len() {
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .                   self.make_inexact();
      .          .          .          .                   self.bytes.truncate(len);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Trims this literal such that only the last `len` bytes remain. If this
      .          .          .          .               /// literal has fewer than `len` bytes, then it remains unchanged.
      .          .          .          .               /// Otherwise, the literal is marked as inexact.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn keep_last_bytes(&mut self, len: usize) {
  6,996 ( 0.00%) .          .          .                   if len >= self.len() {
      .          .          .          .                       return;
      .          .          .          .                   }
      .          .          .          .                   self.make_inexact();
      .          .          .          .                   self.bytes.drain(..self.len() - len);
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if it is believe that this literal is likely to match very
      .          .          .          .               /// frequently, and is thus not a good candidate for a prefilter.
      .          .          .          .               fn is_poisonous(&self) -> bool {
  6,306 ( 0.00%) .          .          .                   self.is_empty() || (self.len() == 1 && rank(self.as_bytes()[0]) >= 250)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl From<u8> for Literal {
      .          .          .          .               fn from(byte: u8) -> Literal {
      .          .          .          .                   Literal::exact(vec![byte])
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl From<char> for Literal {
      .          .          .          .               fn from(ch: char) -> Literal {
      .          .          .          .                   use alloc::string::ToString;
    409 ( 0.00%) .          .          .                   Literal::exact(ch.encode_utf8(&mut [0; 4]).to_string())
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl AsRef<[u8]> for Literal {
      .          .          .          .               fn as_ref(&self) -> &[u8] {
      .          .          .          .                   self.as_bytes()
      .          .          .          .               }
      .          .          .          .           }
-- line 2173 ----------------------------------------
-- line 2229 ----------------------------------------
      .          .          .          .               /// order semantics.
      .          .          .          .               ///
      .          .          .          .               /// When `keep_exact` is true, the exactness of every literal retained is
      .          .          .          .               /// kept. This is useful when dealing with a fully extracted `Seq` that
      .          .          .          .               /// only contains exact literals. In that case, we can keep all retained
      .          .          .          .               /// literals as exact because we know we'll never need to match anything
      .          .          .          .               /// after them and because any removed literals are guaranteed to never
      .          .          .          .               /// match.
  1,062 ( 0.00%) .          .          .               fn minimize(literals: &mut Vec<Literal>, keep_exact: bool) {
  1,239 ( 0.00%) .          .          .                   let mut trie = PreferenceTrie {
      .          .          .          .                       states: vec![],
      .          .          .          .                       matches: vec![],
      .          .          .          .                       next_literal_index: 1,
      .          .          .          .                   };
      .          .          .          .                   let mut make_inexact = vec![];
 68,751 ( 0.02%) .          .          .                   literals.retain_mut(|lit| match trie.insert(lit.as_bytes()) {
8,600,407 ( 2.58%) 20,558 ( 2.54%) 4 ( 1.33%) .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::retain_mut (177x)
      .          .          .          .                       Ok(_) => true,
      .          .          .          .                       Err(i) => {
  5,274 ( 0.00%) .          .          .                           if !keep_exact {
      .          .          .          .                               make_inexact.push(i.checked_sub(1).unwrap());
      .          .          .          .                           }
      .          .          .          .                           false
      .          .          .          .                       }
      .          .          .          .                   });
    531 ( 0.00%) .          .          .                   for i in make_inexact {
      .          .          .          .                       literals[i].make_inexact();
      .          .          .          .                   }
    885 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns `Ok` if the given byte string is accepted into this trie and
      .          .          .          .               /// `Err` otherwise. The index for the success case corresponds to the
      .          .          .          .               /// index of the literal added. The index for the error case corresponds to
      .          .          .          .               /// the index of the literal already in the trie that prevented the given
      .          .          .          .               /// byte string from being added. (Which implies it is a prefix of the one
      .          .          .          .               /// given.)
      .          .          .          .               ///
      .          .          .          .               /// In short, the byte string given is accepted into the trie if and only
      .          .          .          .               /// if it is possible for it to match when executing a preference order
      .          .          .          .               /// search.
135,024 ( 0.04%) .          .          .               fn insert(&mut self, bytes: &[u8]) -> Result<usize, usize> {
      .          .          .          .                   let mut prev = self.root();
 67,512 ( 0.02%) .          .          .                   if let Some(idx) = self.matches[prev] {
      .          .          .          .                       return Err(idx.get());
      .          .          .          .                   }
      .          .          .          .                   for &b in bytes.iter() {
      .          .          .          .                       match self.states[prev].trans.binary_search_by_key(&b, |t| t.0) {
      .          .          .          .                           Ok(i) => {
 30,371 ( 0.01%) .          .          .                               prev = self.states[prev].trans[i].1;
126,680 ( 0.04%) .          .          .                               if let Some(idx) = self.matches[prev] {
      .          .          .          .                                   return Err(idx.get());
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                           Err(i) => {
      .          .          .          .                               let next = self.create_state();
 18,991 ( 0.01%) .          .          .                               self.states[prev].trans.insert(i, (b, next));
      .          .          .          .                               prev = next;
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
 14,280 ( 0.00%) .          .          .                   let idx = self.next_literal_index;
 28,560 ( 0.01%) .          .          .                   self.next_literal_index += 1;
 28,560 ( 0.01%) .          .          .                   self.matches[prev] = NonZeroUsize::new(idx);
      .          .          .          .                   Ok(idx)
135,024 ( 0.04%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the root state ID, and if it doesn't exist, creates it.
      .          .          .          .               fn root(&mut self) -> usize {
 50,634 ( 0.02%) .          .          .                   if !self.states.is_empty() {
      .          .          .          .                       0
      .          .          .          .                   } else {
      .          .          .          .                       self.create_state()
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Creates a new empty state and returns its ID.
      .          .          .          .               fn create_state(&mut self) -> usize {
      .          .          .          .                   let id = self.states.len();
      .          .          .          .                   self.states.push(State::default());
    177 ( 0.00%) .          .          .                   self.matches.push(None);
      .          .          .          .                   id
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Returns the "rank" of the given byte.
      .          .          .          .           ///
      .          .          .          .           /// The minimum rank value is `0` and the maximum rank value is `255`.
      .          .          .          .           ///
-- line 2315 ----------------------------------------

 55,523 ( 0.02%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 71 ----------------------------------------
     .          .          .          .               /// Callers must ensure that this is okay to call in the current target for
     .          .          .          .               /// the current CPU.
     .          .          .          .               #[inline(always)]
     .          .          .          .               pub(crate) unsafe fn new(patterns: Arc<Patterns>) -> Slim<V, BYTES> {
     .          .          .          .                   assert!(
     .          .          .          .                       1 <= BYTES && BYTES <= 4,
     .          .          .          .                       "only 1, 2, 3 or 4 bytes are supported"
     .          .          .          .                   );
    90 ( 0.00%) .          .          .                   let teddy = Teddy::new(patterns);
 8,831 ( 0.00%) 35 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (2x)
     .          .          .          .                   let masks = SlimMaskBuilder::from_teddy(&teddy);
   432 ( 0.00%) .          .          .                   Slim { teddy, masks }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the approximate total amount of heap used by this type, in
     .          .          .          .               /// units of bytes.
     .          .          .          .               #[inline(always)]
     .          .          .          .               pub(crate) fn memory_usage(&self) -> usize {
     .          .          .          .                   self.teddy.memory_usage()
     .          .          .          .               }
-- line 89 ----------------------------------------
-- line 243 ----------------------------------------
     .          .          .          .                   start: *const u8,
     .          .          .          .                   end: *const u8,
     .          .          .          .               ) -> Option<Match> {
     .          .          .          .                   let len = end.distance(start);
     .          .          .          .                   debug_assert!(len >= self.minimum_len());
     .          .          .          .                   let mut cur = start.add(2);
     .          .          .          .                   let mut prev0 = V::splat(0xFF);
     .          .          .          .                   let mut prev1 = V::splat(0xFF);
    18 ( 0.00%) .          .          .                   while cur <= end.sub(V::BYTES) {
     .          .          .          .                       if let Some(m) = self.find_one(cur, end, &mut prev0, &mut prev1) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                       cur = cur.add(V::BYTES);
     .          .          .          .                   }
     4 ( 0.00%) .          .          .                   if cur < end {
     .          .          .          .                       cur = end.sub(V::BYTES);
     .          .          .          .                       prev0 = V::splat(0xFF);
     .          .          .          .                       prev1 = V::splat(0xFF);
     .          .          .          .                       if let Some(m) = self.find_one(cur, end, &mut prev0, &mut prev1) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   None
-- line 265 ----------------------------------------
-- line 270 ----------------------------------------
     .          .          .          .               unsafe fn find_one(
     .          .          .          .                   &self,
     .          .          .          .                   cur: *const u8,
     .          .          .          .                   end: *const u8,
     .          .          .          .                   prev0: &mut V,
     .          .          .          .                   prev1: &mut V,
     .          .          .          .               ) -> Option<Match> {
     .          .          .          .                   let c = self.candidate(cur, prev0, prev1);
     7 ( 0.00%) .          .          .                   if !c.is_zero() {
     .          .          .          .                       if let Some(m) = self.teddy.verify(cur.sub(2), end, c) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   None
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// See Slim<V, 1>::candidate.
-- line 286 ----------------------------------------
-- line 287 ----------------------------------------
     .          .          .          .               #[inline(always)]
     .          .          .          .               unsafe fn candidate(
     .          .          .          .                   &self,
     .          .          .          .                   cur: *const u8,
     .          .          .          .                   prev0: &mut V,
     .          .          .          .                   prev1: &mut V,
     .          .          .          .               ) -> V {
     .          .          .          .                   let chunk = V::load_unaligned(cur);
    12 ( 0.00%) .          .          .                   let (res0, res1, res2) = Mask::members3(chunk, self.masks);
     .          .          .          .                   let res0prev0 = res0.shift_in_two_bytes(*prev0);
     .          .          .          .                   let res1prev1 = res1.shift_in_one_byte(*prev1);
     .          .          .          .                   let res = res0prev0.and(res1prev1).and(res2);
     .          .          .          .                   *prev0 = res0;
     .          .          .          .                   *prev1 = res1;
     .          .          .          .                   res
     .          .          .          .               }
     .          .          .          .           }
-- line 303 ----------------------------------------
-- line 404 ----------------------------------------
     .          .          .          .               /// Callers must ensure that this is okay to call in the current target for
     .          .          .          .               /// the current CPU.
     .          .          .          .               #[inline(always)]
     .          .          .          .               pub(crate) unsafe fn new(patterns: Arc<Patterns>) -> Fat<V, BYTES> {
     .          .          .          .                   assert!(
     .          .          .          .                       1 <= BYTES && BYTES <= 4,
     .          .          .          .                       "only 1, 2, 3 or 4 bytes are supported"
     .          .          .          .                   );
    21 ( 0.00%) .          .          .                   let teddy = Teddy::new(patterns);
700,540 ( 0.21%) 2,448 ( 0.30%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs:aho_corasick::packed::teddy::generic::Teddy<_>::new (21x)
     .          .          .          .                   let masks = FatMaskBuilder::from_teddy(&teddy);
    42 ( 0.00%) .          .          .                   Fat { teddy, masks }
 1,365 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (21x)
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the approximate total amount of heap used by this type, in
     .          .          .          .               /// units of bytes.
     .          .          .          .               #[inline(always)]
     .          .          .          .               pub(crate) fn memory_usage(&self) -> usize {
     .          .          .          .                   self.teddy.memory_usage()
     .          .          .          .               }
-- line 422 ----------------------------------------
-- line 576 ----------------------------------------
     .          .          .          .                   start: *const u8,
     .          .          .          .                   end: *const u8,
     .          .          .          .               ) -> Option<Match> {
     .          .          .          .                   let len = end.distance(start);
     .          .          .          .                   debug_assert!(len >= self.minimum_len());
     .          .          .          .                   let mut cur = start.add(2);
     .          .          .          .                   let mut prev0 = V::splat(0xFF);
     .          .          .          .                   let mut prev1 = V::splat(0xFF);
    45 ( 0.00%) .          .          .                   while cur <= end.sub(V::Half::BYTES) {
     .          .          .          .                       if let Some(m) = self.find_one(cur, end, &mut prev0, &mut prev1) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                       cur = cur.add(V::Half::BYTES);
     .          .          .          .                   }
    18 ( 0.00%) .          .          .                   if cur < end {
     .          .          .          .                       cur = end.sub(V::Half::BYTES);
     .          .          .          .                       prev0 = V::splat(0xFF);
     .          .          .          .                       prev1 = V::splat(0xFF);
     .          .          .          .                       if let Some(m) = self.find_one(cur, end, &mut prev0, &mut prev1) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   None
-- line 598 ----------------------------------------
-- line 603 ----------------------------------------
     .          .          .          .               unsafe fn find_one(
     .          .          .          .                   &self,
     .          .          .          .                   cur: *const u8,
     .          .          .          .                   end: *const u8,
     .          .          .          .                   prev0: &mut V,
     .          .          .          .                   prev1: &mut V,
     .          .          .          .               ) -> Option<Match> {
     .          .          .          .                   let c = self.candidate(cur, prev0, prev1);
    26 ( 0.00%) .          .          .                   if !c.is_zero() {
     1 ( 0.00%) .          .          .                       if let Some(m) = self.teddy.verify(cur.sub(2), end, c) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   None
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// See `Fat<V, 1>::candidate`.
     .          .          .          .               #[inline(always)]
     .          .          .          .               unsafe fn candidate(
     .          .          .          .                   &self,
     .          .          .          .                   cur: *const u8,
     .          .          .          .                   prev0: &mut V,
     .          .          .          .                   prev1: &mut V,
     .          .          .          .               ) -> V {
     .          .          .          .                   let chunk = V::load_half_unaligned(cur);
    54 ( 0.00%) .          .          .                   let (res0, res1, res2) = Mask::members3(chunk, self.masks);
     .          .          .          .                   let res0prev0 = res0.half_shift_in_two_bytes(*prev0);
     .          .          .          .                   let res1prev1 = res1.half_shift_in_one_byte(*prev1);
     .          .          .          .                   let res = res0prev0.and(res1prev1).and(res2);
     .          .          .          .                   *prev0 = res0;
     .          .          .          .                   *prev1 = res1;
     .          .          .          .                   res
     .          .          .          .               }
     .          .          .          .           }
-- line 636 ----------------------------------------
-- line 743 ----------------------------------------
     .          .          .          .               //
     .          .          .          .               // One other avenue I haven't explored is some kind of hashing trick
     .          .          .          .               // that let's us do another high-confidence check before launching into
     .          .          .          .               // `memcmp`.
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<const BUCKETS: usize> Teddy<BUCKETS> {
     .          .          .          .               /// Create a new generic data structure for Teddy verification.
   399 ( 0.00%) .          .          .               fn new(patterns: Arc<Patterns>) -> Teddy<BUCKETS> {
   114 ( 0.00%) .          .          .                   assert_ne!(0, patterns.len(), "Teddy requires at least one pattern");
   114 ( 0.00%) .          .          .                   assert_ne!(
     .          .          .          .                       0,
     .          .          .          .                       patterns.minimum_len(),
     .          .          .          .                       "Teddy does not support zero-length patterns"
     .          .          .          .                   );
     .          .          .          .                   assert!(
     .          .          .          .                       BUCKETS == 8 || BUCKETS == 16,
     .          .          .          .                       "Teddy only supports 8 or 16 buckets"
     .          .          .          .                   );
     .          .          .          .                   // MSRV(1.63): Use core::array::from_fn below instead of allocating a
     .          .          .          .                   // superfluous outer Vec. Not a big deal (especially given the BTreeMap
     .          .          .          .                   // allocation below), but nice to not do it.
     .          .          .          .                   let buckets =
     .          .          .          .                       <[Vec<PatternID>; BUCKETS]>::try_from(vec![vec![]; BUCKETS])
     .          .          .          .                           .unwrap();
    57 ( 0.00%) .          .          .                   let mut t = Teddy { patterns, buckets };
     .          .          .          .           
     .          .          .          .                   let mut map: BTreeMap<Box<[u8]>, usize> = BTreeMap::new();
     .          .          .          .                   for (id, pattern) in t.patterns.iter() {
     .          .          .          .                       // We try to be slightly clever in how we assign patterns into
     .          .          .          .                       // buckets. Generally speaking, we want patterns with the same
     .          .          .          .                       // prefix to be in the same bucket, since it minimizes the amount
     .          .          .          .                       // of time we spend churning through buckets in the verification
     .          .          .          .                       // step.
-- line 776 ----------------------------------------
-- line 789 ----------------------------------------
     .          .          .          .                       // and leftmost-longest match semantics. In addition to the fact
     .          .          .          .                       // that `patterns.iter()` iterates in the correct order, this
     .          .          .          .                       // guarantees that all possible ambiguous matches will occur in
     .          .          .          .                       // the same bucket. The verification routine could be adjusted to
     .          .          .          .                       // support correct leftmost match semantics regardless of bucket
     .          .          .          .                       // allocation, but that results in a performance hit. It's much
     .          .          .          .                       // nicer to be able to just stop as soon as a match is found.
     .          .          .          .                       let lonybs = pattern.low_nybbles(t.mask_len());
 3,816 ( 0.00%) .          .          .                       if let Some(&bucket) = map.get(&lonybs) {
 3,390 ( 0.00%) .          .          .                           t.buckets[bucket].push(id);
     .          .          .          .                       } else {
     .          .          .          .                           // N.B. We assign buckets in reverse because it shouldn't have
     .          .          .          .                           // any influence on performance, but it does make it harder to
     .          .          .          .                           // get leftmost match semantics accidentally correct.
   812 ( 0.00%) .          .          .                           let bucket = (BUCKETS - 1) - (id.as_usize() % BUCKETS);
 1,218 ( 0.00%) .          .          .                           t.buckets[bucket].push(id);
 2,842 ( 0.00%) .          .          .                           map.insert(lonybs, bucket);
121,963 ( 0.04%) 8 ( 0.00%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:alloc::collections::btree::map::BTreeMap<K,V,A>::insert (406x)
     .          .          .          .                       }
     .          .          .          .                   }
   285 ( 0.00%) .          .          .                   t
 2,445 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (57x)
   570 ( 0.00%) .          .          .               }
77,240 ( 0.02%) 397 ( 0.05%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::collections::btree::map::BTreeMap<alloc::boxed::Box<[u8]>,usize>> (57x)
     .          .          .          .           
     .          .          .          .               /// Verify whether there are any matches starting at or after `cur` in the
     .          .          .          .               /// haystack. The candidate chunk given should correspond to 8-bit bitsets
     .          .          .          .               /// for N buckets.
     .          .          .          .               ///
     .          .          .          .               /// # Safety
     .          .          .          .               ///
     .          .          .          .               /// The given pointers representing the haystack must be valid to read
-- line 817 ----------------------------------------
-- line 818 ----------------------------------------
     .          .          .          .               /// from.
     .          .          .          .               #[inline(always)]
     .          .          .          .               unsafe fn verify64(
     .          .          .          .                   &self,
     .          .          .          .                   cur: *const u8,
     .          .          .          .                   end: *const u8,
     .          .          .          .                   mut candidate_chunk: u64,
     .          .          .          .               ) -> Option<Match> {
    54 ( 0.00%) .          .          .                   while candidate_chunk != 0 {
     .          .          .          .                       let bit = candidate_chunk.trailing_zeros().as_usize();
    48 ( 0.00%) .          .          .                       candidate_chunk &= !(1 << bit);
     .          .          .          .           
     .          .          .          .                       let cur = cur.add(bit / BUCKETS);
    34 ( 0.00%) .          .          .                       let bucket = bit % BUCKETS;
     .          .          .          .                       if let Some(m) = self.verify_bucket(cur, end, bucket) {
     .          .          .          .                           return Some(m);
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   None
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Verify whether there are any matches starting at `at` in the given
-- line 839 ----------------------------------------
-- line 885 ----------------------------------------
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the approximate total amount of heap used by this type, in
     .          .          .          .               /// units of bytes.
     .          .          .          .               fn memory_usage(&self) -> usize {
     .          .          .          .                   // This is an upper bound rather than a precise accounting. No
     .          .          .          .                   // particular reason, other than it's probably very close to actual
     .          .          .          .                   // memory usage in practice.
    21 ( 0.00%) .          .          .                   self.patterns.len() * core::mem::size_of::<PatternID>()
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl Teddy<8> {
     .          .          .          .               /// Runs the verification routine for "slim" Teddy.
     .          .          .          .               ///
     .          .          .          .               /// The candidate given should be a collection of 8-bit bitsets (one bitset
     .          .          .          .               /// per lane), where the ith bit is set in the jth lane if and only if the
-- line 901 ----------------------------------------
-- line 1169 ----------------------------------------
     .          .          .          .           /// Each byte in the mask corresponds to a 8-bit bitset, where bit `i` is set
     .          .          .          .           /// if and only if the corresponding nybble is in the ith bucket. The index of
     .          .          .          .           /// the byte (0-15, inclusive) corresponds to the nybble.
     .          .          .          .           ///
     .          .          .          .           /// Each mask is used as the target of a shuffle, where the indices for the
     .          .          .          .           /// shuffle are taken from the haystack. AND'ing the shuffles for both the
     .          .          .          .           /// low and high masks together also results in 8-bit bitsets, but where bit
     .          .          .          .           /// `i` is set if and only if the correspond *byte* is in the ith bucket.
    26 ( 0.00%) .          .          .           #[derive(Clone, Default)]
     .          .          .          .           struct SlimMaskBuilder {
     .          .          .          .               lo: [u8; 32],
    52 ( 0.00%) .          .          .               hi: [u8; 32],
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl SlimMaskBuilder {
     .          .          .          .               /// Update this mask by adding the given byte to the given bucket. The
     .          .          .          .               /// given bucket must be in the range 0-7.
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
     .          .          .          .               /// When `bucket >= 8`.
     .          .          .          .               fn add(&mut self, bucket: usize, byte: u8) {
     .          .          .          .                   assert!(bucket < 8);
     .          .          .          .           
     .          .          .          .                   let bucket = u8::try_from(bucket).unwrap();
   606 ( 0.00%) .          .          .                   let byte_lo = usize::from(byte & 0xF);
 1,212 ( 0.00%) .          .          .                   let byte_hi = usize::from((byte >> 4) & 0xF);
     .          .          .          .                   // When using 256-bit vectors, we need to set this bucket assignment in
     .          .          .          .                   // the low and high 128-bit portions of the mask. This allows us to
     .          .          .          .                   // process 32 bytes at a time. Namely, AVX2 shuffles operate on each
     .          .          .          .                   // of the 128-bit lanes, rather than the full 256-bit vector at once.
   606 ( 0.00%) .          .          .                   self.lo[byte_lo] |= 1 << bucket;
   606 ( 0.00%) .          .          .                   self.lo[byte_lo + 16] |= 1 << bucket;
   606 ( 0.00%) .          .          .                   self.hi[byte_hi] |= 1 << bucket;
   606 ( 0.00%) .          .          .                   self.hi[byte_hi + 16] |= 1 << bucket;
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Turn this builder into a vector mask.
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
     .          .          .          .               /// When `V` represents a vector bigger than what `MaskBytes` can contain.
     .          .          .          .               ///
-- line 1211 ----------------------------------------
-- line 1212 ----------------------------------------
     .          .          .          .               /// # Safety
     .          .          .          .               ///
     .          .          .          .               /// Callers must ensure that this is okay to call in the current target for
     .          .          .          .               /// the current CPU.
     .          .          .          .               #[inline(always)]
     .          .          .          .               unsafe fn build<V: Vector>(&self) -> Mask<V> {
     .          .          .          .                   assert!(V::BYTES <= self.lo.len());
     .          .          .          .                   assert!(V::BYTES <= self.hi.len());
     4 ( 0.00%) .          .          .                   Mask {
     .          .          .          .                       lo: V::load_unaligned(self.lo[..].as_ptr()),
     1 ( 0.00%) .          .          .                       hi: V::load_unaligned(self.hi[..].as_ptr()),
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// A convenience function for building `N` vector masks from a slim
     .          .          .          .               /// `Teddy` value.
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
-- line 1230 ----------------------------------------
-- line 1240 ----------------------------------------
     .          .          .          .               ) -> [Mask<V>; BYTES] {
     .          .          .          .                   // MSRV(1.63): Use core::array::from_fn to just build the array here
     .          .          .          .                   // instead of creating a vector and turning it into an array.
     .          .          .          .                   let mut mask_builders = vec![SlimMaskBuilder::default(); BYTES];
     .          .          .          .                   for (bucket_index, bucket) in teddy.buckets.iter().enumerate() {
     .          .          .          .                       for pid in bucket.iter().copied() {
     .          .          .          .                           let pat = teddy.patterns.get(pid);
     .          .          .          .                           for (i, builder) in mask_builders.iter_mut().enumerate() {
 1,818 ( 0.00%) .          .          .                               builder.add(bucket_index, pat.bytes()[i]);
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   let array =
     .          .          .          .                       <[SlimMaskBuilder; BYTES]>::try_from(mask_builders).unwrap();
     .          .          .          .                   array.map(|builder| builder.build())
     .          .          .          .               }
     .          .          .          .           }
-- line 1256 ----------------------------------------
-- line 1296 ----------------------------------------
     .          .          .          .               ///
     .          .          .          .               /// # Panics
     .          .          .          .               ///
     .          .          .          .               /// When `bucket >= 16`.
     .          .          .          .               fn add(&mut self, bucket: usize, byte: u8) {
     .          .          .          .                   assert!(bucket < 16);
     .          .          .          .           
     .          .          .          .                   let bucket = u8::try_from(bucket).unwrap();
 4,932 ( 0.00%) .          .          .                   let byte_lo = usize::from(byte & 0xF);
 2,466 ( 0.00%) .          .          .                   let byte_hi = usize::from((byte >> 4) & 0xF);
     .          .          .          .                   // Unlike slim teddy, fat teddy only works with AVX2. For fat teddy,
     .          .          .          .                   // the high 128 bits of our mask correspond to buckets 8-15, while the
     .          .          .          .                   // low 128 bits correspond to buckets 0-7.
     .          .          .          .                   if bucket < 8 {
     .          .          .          .                       self.lo[byte_lo] |= 1 << bucket;
     .          .          .          .                       self.hi[byte_hi] |= 1 << bucket;
     .          .          .          .                   } else {
     .          .          .          .                       self.lo[byte_lo + 16] |= 1 << (bucket % 8);
-- line 1313 ----------------------------------------
-- line 1352 ----------------------------------------
     .          .          .          .               ) -> [Mask<V>; BYTES] {
     .          .          .          .                   // MSRV(1.63): Use core::array::from_fn to just build the array here
     .          .          .          .                   // instead of creating a vector and turning it into an array.
     .          .          .          .                   let mut mask_builders = vec![FatMaskBuilder::default(); BYTES];
     .          .          .          .                   for (bucket_index, bucket) in teddy.buckets.iter().enumerate() {
     .          .          .          .                       for pid in bucket.iter().copied() {
     .          .          .          .                           let pat = teddy.patterns.get(pid);
     .          .          .          .                           for (i, builder) in mask_builders.iter_mut().enumerate() {
 7,398 ( 0.00%) .          .          .                               builder.add(bucket_index, pat.bytes()[i]);
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .                   let array =
     .          .          .          .                       <[FatMaskBuilder; BYTES]>::try_from(mask_builders).unwrap();
     .          .          .          .                   array.map(|builder| builder.build())
     .          .          .          .               }
     .          .          .          .           }
-- line 1368 ----------------------------------------

16,586 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/generic.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/alphabet.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

      .          .          .          .           use crate::util::int::Usize;
      .          .          .          .           
      .          .          .          .           /// A representation of byte oriented equivalence classes.
      .          .          .          .           ///
      .          .          .          .           /// This is used in finite state machines to reduce the size of the transition
      .          .          .          .           /// table. This can have a particularly large impact not only on the total size
      .          .          .          .           /// of an FSM, but also on FSM build times because it reduces the number of
      .          .          .          .           /// transitions that need to be visited/set.
  1,632 ( 0.00%) .          .          .           #[derive(Clone, Copy)]
      .          .          .          .           pub(crate) struct ByteClasses([u8; 256]);
      .          .          .          .           
      .          .          .          .           impl ByteClasses {
      .          .          .          .               /// Creates a new set of equivalence classes where all bytes are mapped to
      .          .          .          .               /// the same class.
      .          .          .          .               pub(crate) fn empty() -> ByteClasses {
      .          .          .          .                   ByteClasses([0; 256])
      .          .          .          .               }
-- line 17 ----------------------------------------
-- line 18 ----------------------------------------
      .          .          .          .           
      .          .          .          .               /// Creates a new set of equivalence classes where each byte belongs to
      .          .          .          .               /// its own equivalence class.
      .          .          .          .               pub(crate) fn singletons() -> ByteClasses {
      .          .          .          .                   let mut classes = ByteClasses::empty();
      .          .          .          .                   for b in 0..=255 {
      .          .          .          .                       classes.set(b, b);
      .          .          .          .                   }
  1,536 ( 0.00%) .          .          .                   classes
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the equivalence class for the given byte.
      .          .          .          .               #[inline]
      .          .          .          .               pub(crate) fn set(&mut self, byte: u8, class: u8) {
 13,296 ( 0.00%) .          .          .                   self.0[usize::from(byte)] = class;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Get the equivalence class for the given byte.
      .          .          .          .               #[inline]
      .          .          .          .               pub(crate) fn get(&self, byte: u8) -> u8 {
694,406 ( 0.21%) .          .          .                   self.0[usize::from(byte)]
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the total number of elements in the alphabet represented by
      .          .          .          .               /// these equivalence classes. Equivalently, this returns the total number
      .          .          .          .               /// of equivalence classes.
      .          .          .          .               #[inline]
      .          .          .          .               pub(crate) fn alphabet_len(&self) -> usize {
      .          .          .          .                   // Add one since the number of equivalence classes is one bigger than
      .          .          .          .                   // the last one.
  4,876 ( 0.00%) .          .          .                   usize::from(self.0[255]) + 1
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the stride, as a base-2 exponent, required for these
      .          .          .          .               /// equivalence classes.
      .          .          .          .               ///
      .          .          .          .               /// The stride is always the smallest power of 2 that is greater than or
      .          .          .          .               /// equal to the alphabet length. This is done so that converting between
      .          .          .          .               /// state IDs and indices can be done with shifts alone, which is much
-- line 56 ----------------------------------------
-- line 60 ----------------------------------------
      .          .          .          .                   let zeros = self.alphabet_len().next_power_of_two().trailing_zeros();
      .          .          .          .                   usize::try_from(zeros).unwrap()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the stride for these equivalence classes, which corresponds
      .          .          .          .               /// to the smallest power of 2 greater than or equal to the number of
      .          .          .          .               /// equivalence classes.
      .          .          .          .               pub(crate) fn stride(&self) -> usize {
    192 ( 0.00%) .          .          .                   1 << self.stride2()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if every byte in this class maps to its own
      .          .          .          .               /// equivalence class. Equivalently, there are 257 equivalence classes
      .          .          .          .               /// and each class contains exactly one byte (plus the special EOI class).
      .          .          .          .               #[inline]
      .          .          .          .               pub(crate) fn is_singleton(&self) -> bool {
      .          .          .          .                   self.alphabet_len() == 256
-- line 76 ----------------------------------------
-- line 216 ----------------------------------------
      .          .          .          .               /// Create a new set of byte classes where all bytes are part of the same
      .          .          .          .               /// equivalence class.
      .          .          .          .               pub(crate) fn empty() -> Self {
      .          .          .          .                   ByteClassSet(ByteSet::empty())
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Indicate the the range of byte given (inclusive) can discriminate a
      .          .          .          .               /// match between it and all other bytes outside of the range.
  3,680 ( 0.00%) .          .          .               pub(crate) fn set_range(&mut self, start: u8, end: u8) {
      .          .          .          .                   debug_assert!(start <= end);
  7,360 ( 0.00%) .          .          .                   if start > 0 {
  3,680 ( 0.00%) .          .          .                       self.0.add(start - 1);
      .          .          .          .                   }
      .          .          .          .                   self.0.add(end);
  3,680 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Convert this boolean set to a map that maps all byte values to their
      .          .          .          .               /// corresponding equivalence class. The last mapping indicates the largest
      .          .          .          .               /// equivalence class identifier (which is never bigger than 255).
    144 ( 0.00%) .          .          .               pub(crate) fn byte_classes(&self) -> ByteClasses {
      .          .          .          .                   let mut classes = ByteClasses::empty();
      .          .          .          .                   let mut class = 0u8;
      .          .          .          .                   let mut b = 0u8;
      .          .          .          .                   loop {
      .          .          .          .                       classes.set(b, class);
 24,480 ( 0.01%) .          .          .                       if b == 255 {
      .          .          .          .                           break;
      .          .          .          .                       }
 12,240 ( 0.00%) .          .          .                       if self.0.contains(b) {
      .          .          .          .                           class = class.checked_add(1).unwrap();
      .          .          .          .                       }
      .          .          .          .                       b = b.checked_add(1).unwrap();
      .          .          .          .                   }
    144 ( 0.00%) .          .          .                   classes
  1,440 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x)
    192 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A simple set of bytes that is reasonably cheap to copy and allocation free.
      .          .          .          .           #[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
      .          .          .          .           pub(crate) struct ByteSet {
      .          .          .          .               bits: BitSet,
      .          .          .          .           }
      .          .          .          .           
-- line 258 ----------------------------------------
-- line 259 ----------------------------------------
      .          .          .          .           /// The representation of a byte set. Split out so that we can define a
      .          .          .          .           /// convenient Debug impl for it while keeping "ByteSet" in the output.
      .          .          .          .           #[derive(Clone, Copy, Default, Eq, PartialEq)]
      .          .          .          .           struct BitSet([u128; 2]);
      .          .          .          .           
      .          .          .          .           impl ByteSet {
      .          .          .          .               /// Create an empty set of bytes.
      .          .          .          .               pub(crate) fn empty() -> ByteSet {
    192 ( 0.00%) .          .          .                   ByteSet { bits: BitSet([0; 2]) }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add a byte to this set.
      .          .          .          .               ///
      .          .          .          .               /// If the given byte already belongs to this set, then this is a no-op.
      .          .          .          .               pub(crate) fn add(&mut self, byte: u8) {
 14,720 ( 0.00%) .          .          .                   let bucket = byte / 128;
      .          .          .          .                   let bit = byte % 128;
 84,640 ( 0.03%) .          .          .                   self.bits.0[usize::from(bucket)] |= 1 << bit;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return true if and only if the given byte is in this set.
      .          .          .          .               pub(crate) fn contains(&self, byte: u8) -> bool {
 24,576 ( 0.01%) .          .          .                   let bucket = byte / 128;
      .          .          .          .                   let bit = byte % 128;
306,576 ( 0.09%) .          .          .                   self.bits.0[usize::from(bucket)] & (1 << bit) > 0
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl core::fmt::Debug for BitSet {
      .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
      .          .          .          .                   let mut fmtd = f.debug_set();
      .          .          .          .                   for b in 0u8..=255 {
      .          .          .          .                       if (ByteSet { bits: *self }).contains(b) {
-- line 291 ----------------------------------------

  7,360 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/util/alphabet.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 315 ----------------------------------------
     .          .          .          .           
     .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .           impl<I: Iterator> IntoIterator for I {
     .          .          .          .               type Item = I::Item;
     .          .          .          .               type IntoIter = I;
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               fn into_iter(self) -> I {
15,948 ( 0.00%) .          .          .                   self
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Extend a collection with the contents of an iterator.
     .          .          .          .           ///
     .          .          .          .           /// Iterators produce a series of values, and collections can also be thought
     .          .          .          .           /// of as a series of values. The `Extend` trait bridges this gap, allowing you
     .          .          .          .           /// to extend a collection by including the contents of that iterator. When
-- line 331 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/primitives.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 133 ----------------------------------------
      .          .          .          .           ///
      .          .          .          .           /// While a `SmallIndex` is meant to guarantee that its value fits into `usize`
      .          .          .          .           /// without using as much space as a `usize` on all targets, callers must
      .          .          .          .           /// not rely on this property for safety. Callers may choose to rely on this
      .          .          .          .           /// property for correctness however. For example, creating a `SmallIndex` with
      .          .          .          .           /// an invalid value can be done in entirely safe code. This may in turn result
      .          .          .          .           /// in panics or silent logical errors.
      .          .          .          .           #[derive(
 15,941 ( 0.00%) .          .          .               Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord,
      .          .          .          .           )]
      .          .          .          .           #[repr(transparent)]
      .          .          .          .           pub struct SmallIndex(u32);
      .          .          .          .           
      .          .          .          .           impl SmallIndex {
      .          .          .          .               /// The maximum index value.
      .          .          .          .               #[cfg(any(target_pointer_width = "32", target_pointer_width = "64"))]
      .          .          .          .               pub const MAX: SmallIndex =
-- line 149 ----------------------------------------
-- line 181 ----------------------------------------
      .          .          .          .               /// invalid index value is likely to cause panics or possibly even silent
      .          .          .          .               /// logical errors.
      .          .          .          .               ///
      .          .          .          .               /// Callers must never rely on a `SmallIndex` to be within a certain range
      .          .          .          .               /// for memory safety.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn new_unchecked(index: usize) -> SmallIndex {
      .          .          .          .                   // FIXME: Use as_u32() once const functions in traits are stable.
     27 ( 0.00%) .          .          .                   SmallIndex(index as u32)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Like [`SmallIndex::new`], but panics if the given index is not valid.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn must(index: usize) -> SmallIndex {
      .          .          .          .                   SmallIndex::new(index).expect("invalid small index")
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return this small index as a `usize`. This is guaranteed to never
      .          .          .          .               /// overflow `usize`.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn as_usize(&self) -> usize {
      .          .          .          .                   // FIXME: Use as_usize() once const functions in traits are stable.
177,073 ( 0.05%) .          .          .                   self.0 as usize
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return this small index as a `u64`. This is guaranteed to never
      .          .          .          .               /// overflow.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn as_u64(&self) -> u64 {
      .          .          .          .                   // FIXME: Use u64::from() once const functions in traits are stable.
 12,023 ( 0.00%) .          .          .                   self.0 as u64
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the internal `u32` of this small index. This is guaranteed to
      .          .          .          .               /// never overflow `u32`.
      .          .          .          .               #[inline]
      .          .          .          .               pub const fn as_u32(&self) -> u32 {
      .          .          .          .                   self.0
      .          .          .          .               }
-- line 219 ----------------------------------------
-- line 227 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns one more than this small index as a usize.
      .          .          .          .               ///
      .          .          .          .               /// Since a small index has constraints on its maximum value, adding `1` to
      .          .          .          .               /// it will always fit in a `usize`, `u32` and a `i32`.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn one_more(&self) -> usize {
  1,467 ( 0.00%) .          .          .                   self.as_usize() + 1
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Decode this small index from the bytes given using the native endian
      .          .          .          .               /// byte order for the current target.
      .          .          .          .               ///
      .          .          .          .               /// If the decoded integer is not representable as a small index for the
      .          .          .          .               /// current target, then this returns an error.
      .          .          .          .               #[inline]
-- line 243 ----------------------------------------
-- line 319 ----------------------------------------
      .          .          .          .                   Ok(SmallIndex::new_unchecked(index.as_usize()))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl TryFrom<u32> for SmallIndex {
      .          .          .          .               type Error = SmallIndexError;
      .          .          .          .           
      .          .          .          .               fn try_from(index: u32) -> Result<SmallIndex, SmallIndexError> {
  2,322 ( 0.00%) .          .          .                   if index > SmallIndex::MAX.as_u32() {
      .          .          .          .                       return Err(SmallIndexError { attempted: u64::from(index) });
      .          .          .          .                   }
      .          .          .          .                   Ok(SmallIndex::new_unchecked(index.as_usize()))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl TryFrom<u64> for SmallIndex {
      .          .          .          .               type Error = SmallIndexError;
-- line 335 ----------------------------------------
-- line 341 ----------------------------------------
      .          .          .          .                   Ok(SmallIndex::new_unchecked(index.as_usize()))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl TryFrom<usize> for SmallIndex {
      .          .          .          .               type Error = SmallIndexError;
      .          .          .          .           
      .          .          .          .               fn try_from(index: usize) -> Result<SmallIndex, SmallIndexError> {
399,702 ( 0.12%) .          .          .                   if index > SmallIndex::MAX.as_usize() {
      .          .          .          .                       return Err(SmallIndexError { attempted: index.as_u64() });
      .          .          .          .                   }
      .          .          .          .                   Ok(SmallIndex::new_unchecked(index))
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[cfg(test)]
      .          .          .          .           impl quickcheck::Arbitrary for SmallIndex {
-- line 357 ----------------------------------------
-- line 402 ----------------------------------------
      .          .          .          .           pub(crate) struct SmallIndexIter {
      .          .          .          .               rng: core::ops::Range<usize>,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Iterator for SmallIndexIter {
      .          .          .          .               type Item = SmallIndex;
      .          .          .          .           
      .          .          .          .               fn next(&mut self) -> Option<SmallIndex> {
179,572 ( 0.05%) .          .          .                   if self.rng.start >= self.rng.end {
      .          .          .          .                       return None;
      .          .          .          .                   }
      .          .          .          .                   let next_id = self.rng.start + 1;
      .          .          .          .                   let id = core::mem::replace(&mut self.rng.start, next_id);
      .          .          .          .                   // new_unchecked is OK since we asserted that the number of
      .          .          .          .                   // elements in this iterator will fit in an ID at construction.
      .          .          .          .                   Some(SmallIndex::new_unchecked(id))
      .          .          .          .               }
-- line 418 ----------------------------------------
-- line 550 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   impl<T> core::ops::Index<$name> for [T] {
      .          .          .          .                       type Output = T;
      .          .          .          .           
      .          .          .          .                       #[inline]
      .          .          .          .                       fn index(&self, index: $name) -> &T {
243,644 ( 0.07%) .          .          .                           &self[index.as_usize()]
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   impl<T> core::ops::IndexMut<$name> for [T] {
      .          .          .          .                       #[inline]
      .          .          .          .                       fn index_mut(&mut self, index: $name) -> &mut T {
      .          .          .          .                           &mut self[index.as_usize()]
      .          .          .          .                       }
-- line 566 ----------------------------------------
-- line 662 ----------------------------------------
      .          .          .          .                   }
      .          .          .          .           
      .          .          .          .                   #[derive(Clone, Debug)]
      .          .          .          .                   pub(crate) struct $iter(SmallIndexIter);
      .          .          .          .           
      .          .          .          .                   impl $iter {
      .          .          .          .                       fn new(len: usize) -> $iter {
      .          .          .          .                           assert!(
    864 ( 0.00%) .          .          .                               len <= $name::LIMIT,
      .          .          .          .                               "cannot create iterator for {} when number of \
      .          .          .          .                                elements exceed {:?}",
      .          .          .          .                               stringify!($name),
      .          .          .          .                               $name::LIMIT,
      .          .          .          .                           );
      .          .          .          .                           $iter(SmallIndexIter { rng: 0..len })
      .          .          .          .                       }
      .          .          .          .                   }
-- line 678 ----------------------------------------

 34,603 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/primitives.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/state.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 122 ----------------------------------------
    .          .          .          .           impl core::fmt::Debug for State {
    .          .          .          .               fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    .          .          .          .                   f.debug_tuple("State").field(&self.repr()).finish()
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// For docs on these routines, see the internal Repr and ReprVec types below.
    .          .          .          .           impl State {
2,044 ( 0.00%) .          .          .               pub(crate) fn dead() -> State {
    .          .          .          .                   StateBuilderEmpty::new().into_matches().into_nfa().to_state()
2,920 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn is_match(&self) -> bool {
    .          .          .          .                   self.repr().is_match()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn is_from_word(&self) -> bool {
    .          .          .          .                   self.repr().is_from_word()
    .          .          .          .               }
-- line 140 ----------------------------------------
-- line 164 ----------------------------------------
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               #[cfg(all(test, not(miri)))]
    .          .          .          .               pub(crate) fn iter_match_pattern_ids<F: FnMut(PatternID)>(&self, f: F) {
    .          .          .          .                   self.repr().iter_match_pattern_ids(f)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn iter_nfa_state_ids<F: FnMut(StateID)>(&self, f: F) {
  436 ( 0.00%) .          .          .                   self.repr().iter_nfa_state_ids(f)
44,372 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/state.rs:regex_automata::util::determinize::state::Repr::iter_nfa_state_ids (218x)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn memory_usage(&self) -> usize {
    .          .          .          .                   self.0.len()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               fn repr(&self) -> Repr<'_> {
  872 ( 0.00%) .          .          .                   Repr(&self.0)
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// A state builder that represents an empty state.
    .          .          .          .           ///
    .          .          .          .           /// This is a useful "initial condition" for state construction. It has no
    .          .          .          .           /// NFA state IDs, no assertions set and no pattern IDs. No allocations are
    .          .          .          .           /// made when new() is called. Its main use is for being converted into a
    .          .          .          .           /// builder that can capture assertions and pattern IDs.
    .          .          .          .           #[derive(Clone, Debug)]
    .          .          .          .           pub(crate) struct StateBuilderEmpty(Vec<u8>);
    .          .          .          .           
    .          .          .          .           /// For docs on these routines, see the internal Repr and ReprVec types below.
    .          .          .          .           impl StateBuilderEmpty {
    .          .          .          .               pub(crate) fn new() -> StateBuilderEmpty {
  876 ( 0.00%) .          .          .                   StateBuilderEmpty(alloc::vec![])
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn into_matches(mut self) -> StateBuilderMatches {
    .          .          .          .                   self.0.extend_from_slice(&[0, 0, 0, 0, 0, 0, 0, 0, 0]);
1,069 ( 0.00%) .          .          .                   StateBuilderMatches(self.0)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               fn clear(&mut self) {
    .          .          .          .                   self.0.clear();
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn capacity(&self) -> usize {
    .          .          .          .                   self.0.capacity()
-- line 209 ----------------------------------------
-- line 222 ----------------------------------------
    .          .          .          .                   f.debug_tuple("StateBuilderMatches").field(&self.repr()).finish()
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// For docs on these routines, see the internal Repr and ReprVec types below.
    .          .          .          .           impl StateBuilderMatches {
    .          .          .          .               pub(crate) fn into_nfa(mut self) -> StateBuilderNFA {
    .          .          .          .                   self.repr_vec().close_match_pattern_ids();
1,295 ( 0.00%) .          .          .                   StateBuilderNFA { repr: self.0, prev_nfa_state_id: StateID::ZERO }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn set_is_from_word(&mut self) {
    .          .          .          .                   self.repr_vec().set_is_from_word()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn set_is_half_crlf(&mut self) {
    .          .          .          .                   self.repr_vec().set_is_half_crlf()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn look_have(&self) -> LookSet {
  235 ( 0.00%) .          .          .                   LookSet::read_repr(&self.0[1..])
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn set_look_have(
    .          .          .          .                   &mut self,
    .          .          .          .                   set: impl FnMut(LookSet) -> LookSet,
    .          .          .          .               ) {
    .          .          .          .                   self.repr_vec().set_look_have(set)
    .          .          .          .               }
    .          .          .          .           
   15 ( 0.00%) .          .          .               pub(crate) fn add_match_pattern_id(&mut self, pid: PatternID) {
    .          .          .          .                   self.repr_vec().add_match_pattern_id(pid)
   18 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               fn repr(&self) -> Repr<'_> {
    .          .          .          .                   Repr(&self.0)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               fn repr_vec(&mut self) -> ReprVec<'_> {
    .          .          .          .                   ReprVec(&mut self.0)
    .          .          .          .               }
-- line 262 ----------------------------------------
-- line 290 ----------------------------------------
    .          .          .          .           
    .          .          .          .               pub(crate) fn clear(self) -> StateBuilderEmpty {
    .          .          .          .                   let mut builder = StateBuilderEmpty(self.repr);
    .          .          .          .                   builder.clear();
    .          .          .          .                   builder
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn look_need(&self) -> LookSet {
  259 ( 0.00%) .          .          .                   self.repr().look_need()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               pub(crate) fn set_look_have(
    .          .          .          .                   &mut self,
    .          .          .          .                   set: impl FnMut(LookSet) -> LookSet,
    .          .          .          .               ) {
    .          .          .          .                   self.repr_vec().set_look_have(set)
    .          .          .          .               }
-- line 306 ----------------------------------------
-- line 389 ----------------------------------------
    .          .          .          .               /// Returns true if and only if this is a match state.
    .          .          .          .               ///
    .          .          .          .               /// If callers have added pattern IDs to this state, then callers MUST set
    .          .          .          .               /// this state as a match state explicitly. However, as a special case,
    .          .          .          .               /// states that are marked as match states but with no pattern IDs, then
    .          .          .          .               /// the state is treated as if it had a single pattern ID equivalent to
    .          .          .          .               /// PatternID::ZERO.
    .          .          .          .               fn is_match(&self) -> bool {
  879 ( 0.00%) .          .          .                   self.0[0] & (1 << 0) > 0
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns true if and only if this state has had at least one pattern
    .          .          .          .               /// ID added to it.
    .          .          .          .               ///
    .          .          .          .               /// This is an internal-only flag that permits the representation to save
    .          .          .          .               /// space in the common case of an NFA with one pattern in it. In that
    .          .          .          .               /// case, a match state can only ever have exactly one pattern ID:
    .          .          .          .               /// PatternID::ZERO. So there's no need to represent it.
    .          .          .          .               fn has_pattern_ids(&self) -> bool {
1,953 ( 0.00%) .          .          .                   self.0[0] & (1 << 1) > 0
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns true if and only if this state is marked as having been created
    .          .          .          .               /// from a transition over a word byte. This is useful for checking whether
    .          .          .          .               /// a word boundary assertion is true or not, which requires look-behind
    .          .          .          .               /// (whether the current state came from a word byte or not) and look-ahead
    .          .          .          .               /// (whether the transition byte is a word byte or not).
    .          .          .          .               ///
    .          .          .          .               /// Since states with this set are distinct from states that don't have
    .          .          .          .               /// this set (even if they are otherwise equivalent), callers should not
    .          .          .          .               /// set this assertion unless the underlying NFA has at least one word
    .          .          .          .               /// boundary assertion somewhere. Otherwise, a superfluous number of states
    .          .          .          .               /// may be created.
    .          .          .          .               fn is_from_word(&self) -> bool {
   80 ( 0.00%) .          .          .                   self.0[0] & (1 << 2) > 0
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns true if and only if this state is marked as being inside of a
    .          .          .          .               /// CRLF terminator. In the forward direction, this means the state was
    .          .          .          .               /// created after seeing a `\r`. In the reverse direction, this means the
    .          .          .          .               /// state was created after seeing a `\n`.
    .          .          .          .               fn is_half_crlf(&self) -> bool {
   80 ( 0.00%) .          .          .                   self.0[0] & (1 << 3) > 0
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// The set of look-behind assertions that were true in the transition that
    .          .          .          .               /// created this state.
    .          .          .          .               ///
    .          .          .          .               /// Generally, this should be empty if 'look_need' is empty, since there is
    .          .          .          .               /// no reason to track which look-behind assertions are true if the state
    .          .          .          .               /// has no conditional epsilon transitions.
-- line 439 ----------------------------------------
-- line 469 ----------------------------------------
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the pattern ID for this match state at the given index.
    .          .          .          .               ///
    .          .          .          .               /// If the given index is greater than or equal to `match_len()` for this
    .          .          .          .               /// state, then this could panic or return incorrect results.
    .          .          .          .               fn match_pattern(&self, index: usize) -> PatternID {
    5 ( 0.00%) .          .          .                   if !self.has_pattern_ids() {
    .          .          .          .                       PatternID::ZERO
    .          .          .          .                   } else {
    .          .          .          .                       let offset = 13 + index * PatternID::SIZE;
    .          .          .          .                       // This is OK since we only ever serialize valid PatternIDs to
    .          .          .          .                       // states.
    .          .          .          .                       wire::read_pattern_id_unchecked(&self.0[offset..]).0
    .          .          .          .                   }
    .          .          .          .               }
-- line 485 ----------------------------------------
-- line 515 ----------------------------------------
    .          .          .          .                       // This is OK since we only ever serialize valid PatternIDs to
    .          .          .          .                       // states. And since pattern IDs can never exceed a usize, the
    .          .          .          .                       // unwrap is OK.
    .          .          .          .                       f(PatternID::new_unchecked(usize::try_from(pid).unwrap()));
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Calls the given function on every NFA state ID in this state.
1,308 ( 0.00%) .          .          .               fn iter_nfa_state_ids<F: FnMut(StateID)>(&self, mut f: F) {
  436 ( 0.00%) .          .          .                   let mut sids = &self.0[self.pattern_offset_end()..];
    .          .          .          .                   let mut prev = 0i32;
2,194 ( 0.00%) .          .          .                   while !sids.is_empty() {
    .          .          .          .                       let (delta, nr) = read_vari32(sids);
    .          .          .          .                       sids = &sids[nr..];
  988 ( 0.00%) .          .          .                       let sid = prev + delta;
    .          .          .          .                       prev = sid;
    .          .          .          .                       // This is OK since we only ever serialize valid StateIDs to
    .          .          .          .                       // states. And since state IDs can never exceed an isize, they must
    .          .          .          .                       // always be able to fit into a usize, and thus cast is OK.
    .          .          .          .                       f(StateID::new_unchecked(sid.as_usize()))
    .          .          .          .                   }
1,526 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the offset into this state's representation where the pattern
    .          .          .          .               /// IDs end and the NFA state IDs begin.
    .          .          .          .               fn pattern_offset_end(&self) -> usize {
    .          .          .          .                   let encoded = self.encoded_pattern_len();
    .          .          .          .                   if encoded == 0 {
    .          .          .          .                       return 9;
    .          .          .          .                   }
-- line 544 ----------------------------------------
-- line 548 ----------------------------------------
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the total number of *encoded* pattern IDs in this state.
    .          .          .          .               ///
    .          .          .          .               /// This may return 0 even when this is a match state, since the pattern
    .          .          .          .               /// ID `PatternID::ZERO` is not encoded when it's the only pattern ID in
    .          .          .          .               /// the match state (the overwhelming common case).
    .          .          .          .               fn encoded_pattern_len(&self) -> usize {
  218 ( 0.00%) .          .          .                   if !self.has_pattern_ids() {
    .          .          .          .                       return 0;
    .          .          .          .                   }
    .          .          .          .                   // This unwrap is OK since the total number of patterns is always
    .          .          .          .                   // guaranteed to fit into a usize.
    .          .          .          .                   usize::try_from(wire::read_u32(&self.0[9..13])).unwrap()
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
-- line 564 ----------------------------------------
-- line 588 ----------------------------------------
    .          .          .          .           struct ReprVec<'a>(&'a mut Vec<u8>);
    .          .          .          .           
    .          .          .          .           impl<'a> ReprVec<'a> {
    .          .          .          .               /// Set this state as a match state.
    .          .          .          .               ///
    .          .          .          .               /// This should not be exposed explicitly outside of this module. It is
    .          .          .          .               /// set automatically when a pattern ID is added.
    .          .          .          .               fn set_is_match(&mut self) {
    6 ( 0.00%) .          .          .                   self.0[0] |= 1 << 0;
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Set that this state has pattern IDs explicitly written to it.
    .          .          .          .               ///
    .          .          .          .               /// This should not be exposed explicitly outside of this module. This is
    .          .          .          .               /// used internally as a space saving optimization. Namely, if the state
    .          .          .          .               /// is a match state but does not have any pattern IDs written to it,
    .          .          .          .               /// then it is automatically inferred to have a pattern ID of ZERO.
-- line 604 ----------------------------------------
-- line 621 ----------------------------------------
    .          .          .          .               /// In the reverse direction, this should be set when a `\n` has been seen.
    .          .          .          .               fn set_is_half_crlf(&mut self) {
    .          .          .          .                   self.0[0] |= 1 << 3;
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// The set of look-behind assertions that were true in the transition that
    .          .          .          .               /// created this state.
    .          .          .          .               fn look_have(&self) -> LookSet {
   40 ( 0.00%) .          .          .                   self.repr().look_have()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// The set of look-around (both behind and ahead) assertions that appear
    .          .          .          .               /// at least once in this state's set of NFA states.
    .          .          .          .               fn look_need(&self) -> LookSet {
   41 ( 0.00%) .          .          .                   self.repr().look_need()
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Mutate the set of look-behind assertions that were true in the
    .          .          .          .               /// transition that created this state.
    .          .          .          .               fn set_look_have(&mut self, mut set: impl FnMut(LookSet) -> LookSet) {
    .          .          .          .                   set(self.look_have()).write_repr(&mut self.0[1..]);
    .          .          .          .               }
    .          .          .          .           
-- line 643 ----------------------------------------
-- line 660 ----------------------------------------
    .          .          .          .                   // not write either the pattern ID or the number of patterns encoded.
    .          .          .          .                   // Instead, all we do is set the 'is_match' bit on this state. Overall,
    .          .          .          .                   // this saves 8 bytes per match state for the overwhelming majority of
    .          .          .          .                   // match states.
    .          .          .          .                   //
    .          .          .          .                   // In order to know whether pattern IDs need to be explicitly read or
    .          .          .          .                   // not, we use another internal-only bit, 'has_pattern_ids', to
    .          .          .          .                   // indicate whether they have been explicitly written or not.
    6 ( 0.00%) .          .          .                   if !self.repr().has_pattern_ids() {
    3 ( 0.00%) .          .          .                       if pid == PatternID::ZERO {
    .          .          .          .                           self.set_is_match();
    .          .          .          .                           return;
    .          .          .          .                       }
    .          .          .          .                       // Make room for 'close_match_pattern_ids' to write the total
    .          .          .          .                       // number of pattern IDs written.
    .          .          .          .                       self.0.extend(core::iter::repeat(0).take(PatternID::SIZE));
    .          .          .          .                       self.set_has_pattern_ids();
    .          .          .          .                       // If this was already a match state, then the only way that's
-- line 677 ----------------------------------------
-- line 683 ----------------------------------------
    .          .          .          .                       if self.repr().is_match() {
    .          .          .          .                           write_u32(self.0, 0)
    .          .          .          .                       } else {
    .          .          .          .                           // Otherwise, just make sure the 'is_match' bit is set.
    .          .          .          .                           self.set_is_match();
    .          .          .          .                       }
    .          .          .          .                   }
    .          .          .          .                   write_u32(self.0, pid.as_u32());
    3 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Indicate that no more pattern IDs will be added to this state.
    .          .          .          .               ///
    .          .          .          .               /// Once this is called, callers must not call it or 'add_match_pattern_id'
    .          .          .          .               /// again.
    .          .          .          .               ///
    .          .          .          .               /// This should not be exposed explicitly outside of this module. It
    .          .          .          .               /// should be called only when converting a StateBuilderMatches into a
    .          .          .          .               /// StateBuilderNFA.
    .          .          .          .               fn close_match_pattern_ids(&mut self) {
    .          .          .          .                   // If we never wrote any pattern IDs, then there's nothing to do here.
  551 ( 0.00%) .          .          .                   if !self.repr().has_pattern_ids() {
    .          .          .          .                       return;
    .          .          .          .                   }
    .          .          .          .                   let patsize = PatternID::SIZE;
    .          .          .          .                   let pattern_bytes = self.0.len() - 13;
    .          .          .          .                   // Every pattern ID uses 4 bytes, so number of bytes should be
    .          .          .          .                   // divisible by 4.
    .          .          .          .                   assert_eq!(pattern_bytes % patsize, 0);
    .          .          .          .                   // This unwrap is OK since we are guaranteed that the maximum number
-- line 711 ----------------------------------------
-- line 713 ----------------------------------------
    .          .          .          .                   let count32 = u32::try_from(pattern_bytes / patsize).unwrap();
    .          .          .          .                   wire::NE::write_u32(count32, &mut self.0[9..13]);
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Add an NFA state ID to this state. The order in which NFA states are
    .          .          .          .               /// added matters. It is the caller's responsibility to ensure that
    .          .          .          .               /// duplicate NFA state IDs are not added.
    .          .          .          .               fn add_nfa_state_id(&mut self, prev: &mut StateID, sid: StateID) {
1,994 ( 0.00%) .          .          .                   let delta = sid.as_i32() - prev.as_i32();
    .          .          .          .                   write_vari32(self.0, delta);
1,825 ( 0.00%) .          .          .                   *prev = sid;
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Return a read-only view of this state's representation.
    .          .          .          .               fn repr(&self) -> Repr<'_> {
    .          .          .          .                   Repr(self.0.as_slice())
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Write a signed 32-bit integer using zig-zag encoding.
    .          .          .          .           ///
    .          .          .          .           /// https://developers.google.com/protocol-buffers/docs/encoding#varints
    .          .          .          .           fn write_vari32(data: &mut Vec<u8>, n: i32) {
  997 ( 0.00%) .          .          .               let mut un = n.to_bits() << 1;
1,994 ( 0.00%) .          .          .               if n < 0 {
    .          .          .          .                   un = !un;
    .          .          .          .               }
    .          .          .          .               write_varu32(data, un)
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Read a signed 32-bit integer using zig-zag encoding. Also, return the
    .          .          .          .           /// number of bytes read.
    .          .          .          .           ///
    .          .          .          .           /// https://developers.google.com/protocol-buffers/docs/encoding#varints
    .          .          .          .           fn read_vari32(data: &[u8]) -> (i32, usize) {
    .          .          .          .               let (un, i) = read_varu32(data);
1,976 ( 0.00%) .          .          .               let mut n = i32::from_bits(un >> 1);
2,964 ( 0.00%) .          .          .               if un & 1 != 0 {
    .          .          .          .                   n = !n;
    .          .          .          .               }
    .          .          .          .               (n, i)
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Write an unsigned 32-bit integer as a varint. In essence, `n` is written
    .          .          .          .           /// as a sequence of bytes where all bytes except for the last one have the
    .          .          .          .           /// most significant bit set. The least significant 7 bits correspond to the
    .          .          .          .           /// actual bits of `n`. So in the worst case, a varint uses 5 bytes, but in
    .          .          .          .           /// very common cases, it uses fewer than 4.
    .          .          .          .           ///
    .          .          .          .           /// https://developers.google.com/protocol-buffers/docs/encoding#varints
    .          .          .          .           fn write_varu32(data: &mut Vec<u8>, mut n: u32) {
2,968 ( 0.00%) .          .          .               while n >= 0b1000_0000 {
   18 ( 0.00%) .          .          .                   data.push(n.low_u8() | 0b1000_0000);
   18 ( 0.00%) .          .          .                   n >>= 7;
    .          .          .          .               }
    .          .          .          .               data.push(n.low_u8());
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Read an unsigned 32-bit varint. Also, return the number of bytes read.
    .          .          .          .           ///
    .          .          .          .           /// https://developers.google.com/protocol-buffers/docs/encoding#varints
    .          .          .          .           fn read_varu32(data: &[u8]) -> (u32, usize) {
    .          .          .          .               // N.B. We can assume correctness here since we know that all var-u32 are
    .          .          .          .               // written with write_varu32. Hence, the 'as' uses and unchecked arithmetic
    .          .          .          .               // is all okay.
    .          .          .          .               let mut n: u32 = 0;
    .          .          .          .               let mut shift: u32 = 0;
  998 ( 0.00%) .          .          .               for (i, &b) in data.iter().enumerate() {
1,996 ( 0.00%) .          .          .                   if b < 0b1000_0000 {
  988 ( 0.00%) .          .          .                       return (n | (u32::from(b) << shift), i + 1);
    .          .          .          .                   }
   30 ( 0.00%) .          .          .                   n |= (u32::from(b) & 0b0111_1111) << shift;
   10 ( 0.00%) .          .          .                   shift += 7;
    .          .          .          .               }
    .          .          .          .               (0, 0)
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           /// Push a native-endian encoded `n` on to `dst`.
    .          .          .          .           fn write_u32(dst: &mut Vec<u8>, n: u32) {
    .          .          .          .               use crate::util::wire::NE;
    .          .          .          .           
-- line 793 ----------------------------------------

6,111 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/state.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 88 ----------------------------------------
      .          .          .          .           #[inline]
      .          .          .          .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .          .          .          .           pub unsafe fn alloc(layout: Layout) -> *mut u8 {
      .          .          .          .               unsafe {
      .          .          .          .                   // Make sure we don't accidentally allow omitting the allocator shim in
      .          .          .          .                   // stable code until it is actually stabilized.
      .          .          .          .                   core::ptr::read_volatile(&__rust_no_alloc_shim_is_unstable);
      .          .          .          .           
737,525 ( 0.22%) .          .          .                   __rust_alloc(layout.size(), layout.align())
114,223 ( 0.03%) 418 ( 0.05%) .          .           => ???:__rust_alloc (1,386x)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Deallocates memory with the global allocator.
      .          .          .          .           ///
      .          .          .          .           /// This function forwards calls to the [`GlobalAlloc::dealloc`] method
      .          .          .          .           /// of the allocator registered with the `#[global_allocator]` attribute
      .          .          .          .           /// if there is one, or the `std` crates default.
-- line 104 ----------------------------------------
-- line 108 ----------------------------------------
      .          .          .          .           ///
      .          .          .          .           /// # Safety
      .          .          .          .           ///
      .          .          .          .           /// See [`GlobalAlloc::dealloc`].
      .          .          .          .           #[stable(feature = "global_alloc", since = "1.28.0")]
      .          .          .          .           #[inline]
      .          .          .          .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .          .          .          .           pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {
805,151 ( 0.24%) .          .          .               unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }
     90 ( 0.00%) .          .          .           => ???:__rust_dealloc (1x)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Reallocates memory with the global allocator.
      .          .          .          .           ///
      .          .          .          .           /// This function forwards calls to the [`GlobalAlloc::realloc`] method
      .          .          .          .           /// of the allocator registered with the `#[global_allocator]` attribute
      .          .          .          .           /// if there is one, or the `std` crates default.
      .          .          .          .           ///
-- line 124 ----------------------------------------
-- line 128 ----------------------------------------
      .          .          .          .           /// # Safety
      .          .          .          .           ///
      .          .          .          .           /// See [`GlobalAlloc::realloc`].
      .          .          .          .           #[stable(feature = "global_alloc", since = "1.28.0")]
      .          .          .          .           #[must_use = "losing the pointer will leak memory"]
      .          .          .          .           #[inline]
      .          .          .          .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .          .          .          .           pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {
213,769 ( 0.06%) .          .          .               unsafe { __rust_realloc(ptr, layout.size(), layout.align(), new_size) }
276,234 ( 0.08%) 2,906 ( 0.36%) .          .           => ???:__rust_realloc (1,454x)
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// Allocates zero-initialized memory with the global allocator.
      .          .          .          .           ///
      .          .          .          .           /// This function forwards calls to the [`GlobalAlloc::alloc_zeroed`] method
      .          .          .          .           /// of the allocator registered with the `#[global_allocator]` attribute
      .          .          .          .           /// if there is one, or the `std` crates default.
      .          .          .          .           ///
-- line 144 ----------------------------------------
-- line 171 ----------------------------------------
      .          .          .          .           #[inline]
      .          .          .          .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .          .          .          .           pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {
      .          .          .          .               unsafe {
      .          .          .          .                   // Make sure we don't accidentally allow omitting the allocator shim in
      .          .          .          .                   // stable code until it is actually stabilized.
      .          .          .          .                   core::ptr::read_volatile(&__rust_no_alloc_shim_is_unstable);
      .          .          .          .           
  3,957 ( 0.00%) .          .          .                   __rust_alloc_zeroed(layout.size(), layout.align())
283,503 ( 0.09%) 2,432 ( 0.30%) .          .           => ???:__rust_alloc_zeroed (1,084x)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[cfg(not(test))]
      .          .          .          .           impl Global {
      .          .          .          .               #[inline]
      .          .          .          .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .          .          .          .               fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocError> {
  3,520 ( 0.00%) .          .          .                   match layout.size() {
      .          .          .          .                       0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),
      .          .          .          .                       // SAFETY: `layout` is non-zero in size,
      .          .          .          .                       size => unsafe {
  1,780 ( 0.00%) .          .          .                           let raw_ptr = if zeroed { alloc_zeroed(layout) } else { alloc(layout) };
      .          .          .          .                           let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
      .          .          .          .                           Ok(NonNull::slice_from_raw_parts(ptr, size))
      .          .          .          .                       },
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               // SAFETY: Same as `Allocator::grow`
      .          .          .          .               #[inline]
-- line 200 ----------------------------------------
-- line 206 ----------------------------------------
      .          .          .          .                   new_layout: Layout,
      .          .          .          .                   zeroed: bool,
      .          .          .          .               ) -> Result<NonNull<[u8]>, AllocError> {
      .          .          .          .                   debug_assert!(
      .          .          .          .                       new_layout.size() >= old_layout.size(),
      .          .          .          .                       "`new_layout.size()` must be greater than or equal to `old_layout.size()`"
      .          .          .          .                   );
      .          .          .          .           
 88,048 ( 0.03%) .          .          .                   match old_layout.size() {
      .          .          .          .                       0 => self.alloc_impl(new_layout, zeroed),
      .          .          .          .           
      .          .          .          .                       // SAFETY: `new_size` is non-zero as `old_size` is greater than or equal to `new_size`
      .          .          .          .                       // as required by safety conditions. Other conditions must be upheld by the caller
      .          .          .          .                       old_size if old_layout.align() == new_layout.align() => unsafe {
      .          .          .          .                           let new_size = new_layout.size();
      .          .          .          .           
      .          .          .          .                           // `realloc` probably checks for `new_size >= old_layout.size()` or something similar.
-- line 222 ----------------------------------------
-- line 258 ----------------------------------------
      .          .          .          .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .          .          .          .               fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
      .          .          .          .                   self.alloc_impl(layout, true)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline]
      .          .          .          .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .          .          .          .               unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {
  2,904 ( 0.00%) .          .          .                   if layout.size() != 0 {
      .          .          .          .                       // SAFETY: `layout` is non-zero in size,
      .          .          .          .                       // other conditions must be upheld by the caller
      .          .          .          .                       unsafe { dealloc(ptr.as_ptr(), layout) }
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline]
      .          .          .          .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
-- line 274 ----------------------------------------
-- line 339 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// The allocator for unique pointers.
      .          .          .          .           #[cfg(all(not(no_global_oom_handling), not(test)))]
      .          .          .          .           #[lang = "exchange_malloc"]
      .          .          .          .           #[inline]
      .          .          .          .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
    172 ( 0.00%) .          .          .           unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {
      .          .          .          .               let layout = unsafe { Layout::from_size_align_unchecked(size, align) };
349,624 ( 0.10%) .          .          .               match Global.allocate(layout) {
      .          .          .          .                   Ok(ptr) => ptr.as_mut_ptr(),
      .          .          .          .                   Err(_) => handle_alloc_error(layout),
      .          .          .          .               }
    344 ( 0.00%) .          .          .           }
      .          .          .          .           
      .          .          .          .           // # Allocation error handler
      .          .          .          .           
      .          .          .          .           #[cfg(not(no_global_oom_handling))]
      .          .          .          .           extern "Rust" {
      .          .          .          .               // This is the magic symbol to call the global alloc error handler. rustc generates
      .          .          .          .               // it to call `__rg_oom` if there is a `#[alloc_error_handler]`, or to call the
      .          .          .          .               // default implementations below (`__rdl_oom`) otherwise.
-- line 361 ----------------------------------------

173,150 ( 0.05%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 133 ----------------------------------------
        .          .          .          .               /// assert_eq!("oo".chars().count(), 3);
        .          .          .          .               /// ```
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[rustc_const_stable(feature = "const_str_len", since = "1.39.0")]
        .          .          .          .               #[cfg_attr(not(test), rustc_diagnostic_item = "str_len")]
        .          .          .          .               #[must_use]
        .          .          .          .               #[inline]
        .          .          .          .               pub const fn len(&self) -> usize {
    3,608 ( 0.00%) .          .          .                   self.as_bytes().len()
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns `true` if `self` has a length of zero bytes.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
        .          .          .          .               /// ```
        .          .          .          .               /// let s = "";
-- line 149 ----------------------------------------
-- line 187 ----------------------------------------
        .          .          .          .               #[stable(feature = "is_char_boundary", since = "1.9.0")]
        .          .          .          .               #[rustc_const_unstable(feature = "const_is_char_boundary", issue = "131516")]
        .          .          .          .               #[inline]
        .          .          .          .               pub const fn is_char_boundary(&self, index: usize) -> bool {
        .          .          .          .                   // 0 is always ok.
        .          .          .          .                   // Test for 0 explicitly so that it can optimize out the check
        .          .          .          .                   // easily and skip reading string data for that case.
        .          .          .          .                   // Note that optimizing `self.get(..index)` relies on this.
1,179,248 ( 0.35%) .          .          .                   if index == 0 {
        .          .          .          .                       return true;
        .          .          .          .                   }
        .          .          .          .           
1,178,497 ( 0.35%) .          .          .                   if index >= self.len() {
        .          .          .          .                       // For `true` we have two options:
        .          .          .          .                       //
        .          .          .          .                       // - index == self.len()
        .          .          .          .                       //   Empty strings are valid, so return true
        .          .          .          .                       // - index > self.len()
        .          .          .          .                       //   In this case return false
        .          .          .          .                       //
        .          .          .          .                       // The check is placed exactly here, because it improves generated
        .          .          .          .                       // code on higher opt-levels. See PR #84751 for more details.
        .          .          .          .                       index == self.len()
        .          .          .          .                   } else {
       54 ( 0.00%) .          .          .                       self.as_bytes()[index].is_utf8_char_boundary()
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Finds the closest `x` not exceeding `index` where [`is_char_boundary(x)`] is `true`.
        .          .          .          .               ///
        .          .          .          .               /// This method can help you truncate a string so that it's still valid UTF-8, but doesn't
        .          .          .          .               /// exceed a given number of bytes. Note that this is done purely at the character level
        .          .          .          .               /// and can still visually split graphemes, even though the underlying characters aren't
-- line 219 ----------------------------------------
-- line 1144 ----------------------------------------
        .          .          .          .               /// let bananas = "bananas";
        .          .          .          .               ///
        .          .          .          .               /// assert!(bananas.contains("nana"));
        .          .          .          .               /// assert!(!bananas.contains("apples"));
        .          .          .          .               /// ```
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[inline]
        .          .          .          .               pub fn contains<P: Pattern>(&self, pat: P) -> bool {
        4 ( 0.00%) .          .          .                   pat.is_contained_in(self)
       90 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs:<char as core::str::pattern::Pattern>::is_contained_in (1x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns `true` if the given pattern matches a prefix of this
        .          .          .          .               /// string slice.
        .          .          .          .               ///
        .          .          .          .               /// Returns `false` if it does not.
        .          .          .          .               ///
        .          .          .          .               /// The [pattern] can be a `&str`, in which case this function will return true if
-- line 1160 ----------------------------------------
-- line 1525 ----------------------------------------
        .          .          .          .               /// assert_eq!(v, ["ghi", "def", "abc"]);
        .          .          .          .               /// ```
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[inline]
        .          .          .          .               pub fn rsplit<P: Pattern>(&self, pat: P) -> RSplit<'_, P>
        .          .          .          .               where
        .          .          .          .                   for<'a> P::Searcher<'a>: ReverseSearcher<'a>,
        .          .          .          .               {
       10 ( 0.00%) .          .          .                   RSplit(self.split(pat).0)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns an iterator over substrings of the given string slice, separated
        .          .          .          .               /// by characters matched by a pattern.
        .          .          .          .               ///
        .          .          .          .               /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a
        .          .          .          .               /// function or closure that determines if a character matches.
        .          .          .          .               ///
-- line 1541 ----------------------------------------
-- line 1980 ----------------------------------------
        .          .          .          .               /// assert!(Some('') == s.trim_start().chars().next());
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[must_use = "this returns the trimmed string as a new slice, \
        .          .          .          .                             without modifying the original"]
        .          .          .          .               #[stable(feature = "trim_direction", since = "1.30.0")]
        .          .          .          .               #[cfg_attr(not(test), rustc_diagnostic_item = "str_trim_start")]
        .          .          .          .               pub fn trim_start(&self) -> &str {
      168 ( 0.00%) .          .          .                   self.trim_start_matches(|c: char| c.is_whitespace())
    1,654 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs:core::str::<impl str>::trim_start_matches (56x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns a string slice with trailing whitespace removed.
        .          .          .          .               ///
        .          .          .          .               /// 'Whitespace' is defined according to the terms of the Unicode Derived
        .          .          .          .               /// Core Property `White_Space`, which includes newlines.
        .          .          .          .               ///
        .          .          .          .               /// # Text directionality
-- line 1996 ----------------------------------------
-- line 2131 ----------------------------------------
        .          .          .          .               /// A more complex pattern, using a closure:
        .          .          .          .               ///
        .          .          .          .               /// ```
        .          .          .          .               /// assert_eq!("1foo1barXX".trim_matches(|c| c == '1' || c == 'X'), "foo1bar");
        .          .          .          .               /// ```
        .          .          .          .               #[must_use = "this returns the trimmed string as a new slice, \
        .          .          .          .                             without modifying the original"]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        4 ( 0.00%) .          .          .               pub fn trim_matches<P: Pattern>(&self, pat: P) -> &str
        .          .          .          .               where
        .          .          .          .                   for<'a> P::Searcher<'a>: DoubleEndedSearcher<'a>,
        .          .          .          .               {
        .          .          .          .                   let mut i = 0;
        .          .          .          .                   let mut j = 0;
        .          .          .          .                   let mut matcher = pat.into_searcher(self);
        1 ( 0.00%) .          .          .                   if let Some((a, b)) = matcher.next_reject() {
        .          .          .          .                       i = a;
        .          .          .          .                       j = b; // Remember earliest known match, correct it below if
        .          .          .          .                       // last match is different
        .          .          .          .                   }
        .          .          .          .                   if let Some((_, b)) = matcher.next_reject_back() {
        .          .          .          .                       j = b;
        .          .          .          .                   }
        .          .          .          .                   // SAFETY: `Searcher` is known to return valid indices.
        .          .          .          .                   unsafe { self.get_unchecked(i..j) }
        4 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns a string slice with all prefixes that match a pattern
        .          .          .          .               /// repeatedly removed.
        .          .          .          .               ///
        .          .          .          .               /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a
        .          .          .          .               /// function or closure that determines if a character matches.
        .          .          .          .               ///
        .          .          .          .               /// [`char`]: prim@char
-- line 2164 ----------------------------------------
-- line 2178 ----------------------------------------
        .          .          .          .               /// assert_eq!("123foo1bar123".trim_start_matches(char::is_numeric), "foo1bar123");
        .          .          .          .               ///
        .          .          .          .               /// let x: &[_] = &['1', '2'];
        .          .          .          .               /// assert_eq!("12foo1bar12".trim_start_matches(x), "foo1bar12");
        .          .          .          .               /// ```
        .          .          .          .               #[must_use = "this returns the trimmed string as a new slice, \
        .          .          .          .                             without modifying the original"]
        .          .          .          .               #[stable(feature = "trim_direction", since = "1.30.0")]
      124 ( 0.00%) .          .          .               pub fn trim_start_matches<P: Pattern>(&self, pat: P) -> &str {
        .          .          .          .                   let mut i = self.len();
        .          .          .          .                   let mut matcher = pat.into_searcher(self);
        .          .          .          .                   if let Some((a, _)) = matcher.next_reject() {
        .          .          .          .                       i = a;
        .          .          .          .                   }
        .          .          .          .                   // SAFETY: `Searcher` is known to return valid indices.
        .          .          .          .                   unsafe { self.get_unchecked(i..self.len()) }
       62 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns a string slice with the prefix removed.
        .          .          .          .               ///
        .          .          .          .               /// If the string starts with the pattern `prefix`, returns the substring after the prefix,
        .          .          .          .               /// wrapped in `Some`. Unlike [`trim_start_matches`], this method removes the prefix exactly once.
        .          .          .          .               ///
        .          .          .          .               /// If the string does not start with `prefix`, returns `None`.
        .          .          .          .               ///
-- line 2202 ----------------------------------------

        4 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 600 ----------------------------------------
        .          .          .          .               /// let x: Option<u32> = None;
        .          .          .          .               /// assert_eq!(x.is_some(), false);
        .          .          .          .               /// ```
        .          .          .          .               #[must_use = "if you intended to assert that this has a value, consider `.unwrap()` instead"]
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[rustc_const_stable(feature = "const_option_basics", since = "1.48.0")]
        .          .          .          .               pub const fn is_some(&self) -> bool {
      877 ( 0.00%) .          .          .                   matches!(*self, Some(_))
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns `true` if the option is a [`Some`] and the value inside of it matches a predicate.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
        .          .          .          .               /// ```
        .          .          .          .               /// let x: Option<u32> = Some(2);
-- line 616 ----------------------------------------
-- line 699 ----------------------------------------
        .          .          .          .               /// // then consume *that* with `map`, leaving `text` on the stack.
        .          .          .          .               /// let text_length: Option<usize> = text.as_ref().map(|s| s.len());
        .          .          .          .               /// println!("still can print text: {text:?}");
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[rustc_const_stable(feature = "const_option_basics", since = "1.48.0")]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub const fn as_ref(&self) -> Option<&T> {
   32,333 ( 0.01%) .          .          .                   match *self {
        .          .          .          .                       Some(ref x) => Some(x),
        .          .          .          .                       None => None,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Converts from `&mut Option<T>` to `Option<&mut T>`.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
-- line 715 ----------------------------------------
-- line 721 ----------------------------------------
        .          .          .          .               ///     None => {},
        .          .          .          .               /// }
        .          .          .          .               /// assert_eq!(x, Some(42));
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[rustc_const_stable(feature = "const_option", since = "1.83.0")]
        .          .          .          .               pub const fn as_mut(&mut self) -> Option<&mut T> {
      900 ( 0.00%) .          .          .                   match *self {
        .          .          .          .                       Some(ref mut x) => Some(x),
        .          .          .          .                       None => None,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Converts from <code>[Pin]<[&]Option\<T>></code> to <code>Option<[Pin]<[&]T>></code>.
        .          .          .          .               ///
        .          .          .          .               /// [&]: reference "shared reference"
-- line 737 ----------------------------------------
-- line 923 ----------------------------------------
        .          .          .          .               /// Styles"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[cfg_attr(not(test), rustc_diagnostic_item = "option_expect")]
        .          .          .          .               #[rustc_allow_const_fn_unstable(const_precise_live_drops)]
        .          .          .          .               #[rustc_const_stable(feature = "const_option", since = "1.83.0")]
        .          .          .          .               pub const fn expect(self, msg: &str) -> T {
    3,905 ( 0.00%) .          .          .                   match self {
      403 ( 0.00%) .          .          .                       Some(val) => val,
        .          .          .          .                       None => expect_failed(msg),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the contained [`Some`] value, consuming the `self` value.
        .          .          .          .               ///
        .          .          .          .               /// Because this function may panic, its use is generally discouraged.
        .          .          .          .               /// Panics are meant for unrecoverable errors, and
-- line 940 ----------------------------------------
-- line 968 ----------------------------------------
        .          .          .          .               /// ```
        .          .          .          .               #[inline(always)]
        .          .          .          .               #[track_caller]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[cfg_attr(not(test), rustc_diagnostic_item = "option_unwrap")]
        .          .          .          .               #[rustc_allow_const_fn_unstable(const_precise_live_drops)]
        .          .          .          .               #[rustc_const_stable(feature = "const_option", since = "1.83.0")]
        .          .          .          .               pub const fn unwrap(self) -> T {
  101,777 ( 0.03%) .          .          .                   match self {
  328,069 ( 0.10%) .          .          .                       Some(val) => val,
        .          .          .          .                       None => unwrap_failed(),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the contained [`Some`] value or a provided default.
        .          .          .          .               ///
        .          .          .          .               /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing
        .          .          .          .               /// the result of a function call, it is recommended to use [`unwrap_or_else`],
-- line 985 ----------------------------------------
-- line 991 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// ```
        .          .          .          .               /// assert_eq!(Some("car").unwrap_or("bike"), "car");
        .          .          .          .               /// assert_eq!(None.unwrap_or("bike"), "bike");
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub fn unwrap_or(self, default: T) -> T {
  386,283 ( 0.12%) .          .          .                   match self {
        .          .          .          .                       Some(x) => x,
      350 ( 0.00%) .          .          .                       None => default,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the contained [`Some`] value or computes it from a closure.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
        .          .          .          .               /// ```
-- line 1009 ----------------------------------------
-- line 1013 ----------------------------------------
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub fn unwrap_or_else<F>(self, f: F) -> T
        .          .          .          .               where
        .          .          .          .                   F: FnOnce() -> T,
        .          .          .          .               {
       71 ( 0.00%) .          .          .                   match self {
       19 ( 0.00%) .          .          .                       Some(x) => x,
        3 ( 0.00%) .          .          .                       None => f(),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the contained [`Some`] value or a default.
        .          .          .          .               ///
        .          .          .          .               /// Consumes the `self` argument then, if [`Some`], returns the contained
        .          .          .          .               /// value, otherwise if [`None`], returns the [default value] for that
        .          .          .          .               /// type.
-- line 1031 ----------------------------------------
-- line 1044 ----------------------------------------
        .          .          .          .               /// [`parse`]: str::parse
        .          .          .          .               /// [`FromStr`]: crate::str::FromStr
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub fn unwrap_or_default(self) -> T
        .          .          .          .               where
        .          .          .          .                   T: Default,
        .          .          .          .               {
       29 ( 0.00%) .          .          .                   match self {
        4 ( 0.00%) .          .          .                       Some(x) => x,
        .          .          .          .                       None => T::default(),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the contained [`Some`] value, consuming the `self` value,
        .          .          .          .               /// without checking that the value is not [`None`].
        .          .          .          .               ///
        .          .          .          .               /// # Safety
-- line 1061 ----------------------------------------
-- line 1110 ----------------------------------------
        .          .          .          .               /// assert_eq!(x.map(|s| s.len()), None);
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub fn map<U, F>(self, f: F) -> Option<U>
        .          .          .          .               where
        .          .          .          .                   F: FnOnce(T) -> U,
        .          .          .          .               {
    8,558 ( 0.00%) .          .          .                   match self {
  249,386 ( 0.07%) .          .          .                       Some(x) => Some(f(x)),
      367 ( 0.00%) .          .          .                       None => None,
        .          .          .          .                   }
      175 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Calls a function with a reference to the contained value if [`Some`].
        .          .          .          .               ///
        .          .          .          .               /// Returns the original option.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
        .          .          .          .               /// ```
-- line 1130 ----------------------------------------
-- line 1169 ----------------------------------------
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[must_use = "if you don't need the returned value, use `if let` instead"]
        .          .          .          .               pub fn map_or<U, F>(self, default: U, f: F) -> U
        .          .          .          .               where
        .          .          .          .                   F: FnOnce(T) -> U,
        .          .          .          .               {
  724,355 ( 0.22%) .          .          .                   match self {
    7,742 ( 0.00%) .          .          .                       Some(t) => f(t),
        .          .          .          .                       None => default,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Computes a default function result (if none), or
        .          .          .          .               /// applies a different function to the contained value (if any).
        .          .          .          .               ///
        .          .          .          .               /// # Basic examples
-- line 1186 ----------------------------------------
-- line 1273 ----------------------------------------
        .          .          .          .               /// assert_eq!(x.ok_or_else(|| 0), Err(0));
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E>
        .          .          .          .               where
        .          .          .          .                   F: FnOnce() -> E,
        .          .          .          .               {
       31 ( 0.00%) .          .          .                   match self {
        .          .          .          .                       Some(v) => Ok(v),
        .          .          .          .                       None => Err(err()),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.
        .          .          .          .               ///
        .          .          .          .               /// Leaves the original Option in-place, creating a new one with a reference
-- line 1289 ----------------------------------------
-- line 1443 ----------------------------------------
        .          .          .          .               #[doc(alias = "flatmap")]
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[rustc_confusables("flat_map", "flatmap")]
        .          .          .          .               pub fn and_then<U, F>(self, f: F) -> Option<U>
        .          .          .          .               where
        .          .          .          .                   F: FnOnce(T) -> Option<U>,
        .          .          .          .               {
   31,231 ( 0.01%) .          .          .                   match self {
        .          .          .          .                       Some(x) => f(x),
        9 ( 0.00%) .          .          .                       None => None,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns [`None`] if the option is [`None`], otherwise calls `predicate`
        .          .          .          .               /// with the wrapped value and returns:
        .          .          .          .               ///
        .          .          .          .               /// - [`Some(t)`] if `predicate` returns `true` (where `t` is the wrapped
        .          .          .          .               ///   value), and
-- line 1461 ----------------------------------------
-- line 1479 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// [`Some(t)`]: Some
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "option_filter", since = "1.27.0")]
        .          .          .          .               pub fn filter<P>(self, predicate: P) -> Self
        .          .          .          .               where
        .          .          .          .                   P: FnOnce(&T) -> bool,
        .          .          .          .               {
       27 ( 0.00%) .          .          .                   if let Some(x) = self {
       16 ( 0.00%) .          .          .                       if predicate(&x) {
        .          .          .          .                           return Some(x);
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .                   None
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the option if it contains a value, otherwise returns `optb`.
        .          .          .          .               ///
-- line 1496 ----------------------------------------
-- line 1517 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// let x: Option<u32> = None;
        .          .          .          .               /// let y = None;
        .          .          .          .               /// assert_eq!(x.or(y), None);
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub fn or(self, optb: Option<T>) -> Option<T> {
   17,294 ( 0.01%) .          .          .                   match self {
        .          .          .          .                       x @ Some(_) => x,
        .          .          .          .                       None => optb,
        .          .          .          .                   }
      875 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the option if it contains a value, otherwise calls `f` and
        .          .          .          .               /// returns the result.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
        .          .          .          .               /// ```
        .          .          .          .               /// fn nobody() -> Option<&'static str> { None }
-- line 1537 ----------------------------------------
-- line 1542 ----------------------------------------
        .          .          .          .               /// assert_eq!(None.or_else(nobody), None);
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub fn or_else<F>(self, f: F) -> Option<T>
        .          .          .          .               where
        .          .          .          .                   F: FnOnce() -> Option<T>,
        .          .          .          .               {
    1,073 ( 0.00%) .          .          .                   match self {
    1,348 ( 0.00%) .          .          .                       x @ Some(_) => x,
        .          .          .          .                       None => f(),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns [`Some`] if exactly one of `self`, `optb` is [`Some`], otherwise returns [`None`].
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
-- line 1559 ----------------------------------------
-- line 1606 ----------------------------------------
        .          .          .          .               /// assert_eq!(*val, 2);
        .          .          .          .               /// *val = 3;
        .          .          .          .               /// assert_eq!(opt.unwrap(), 3);
        .          .          .          .               /// ```
        .          .          .          .               #[must_use = "if you intended to set a value, consider assignment instead"]
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "option_insert", since = "1.53.0")]
        .          .          .          .               pub fn insert(&mut self, value: T) -> &mut T {
      146 ( 0.00%) .          .          .                   *self = Some(value);
        .          .          .          .           
        .          .          .          .                   // SAFETY: the code above just filled the option
        .          .          .          .                   unsafe { self.as_mut().unwrap_unchecked() }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Inserts `value` into the option if it is [`None`], then
        .          .          .          .               /// returns a mutable reference to the contained value.
        .          .          .          .               ///
-- line 1622 ----------------------------------------
-- line 1687 ----------------------------------------
        .          .          .          .               /// assert_eq!(x, Some(7));
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "option_entry", since = "1.20.0")]
        .          .          .          .               pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T
        .          .          .          .               where
        .          .          .          .                   F: FnOnce() -> T,
        .          .          .          .               {
      137 ( 0.00%) .          .          .                   if let None = self {
      166 ( 0.00%) .          .          .                       *self = Some(f());
       30 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (1x)
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   // SAFETY: a `None` variant for `self` would have been replaced by a `Some`
        .          .          .          .                   // variant in the code above.
        .          .          .          .                   unsafe { self.as_mut().unwrap_unchecked() }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /////////////////////////////////////////////////////////////////////////
-- line 1704 ----------------------------------------
-- line 1890 ----------------------------------------
        .          .          .          .               #[stable(feature = "copied", since = "1.35.0")]
        .          .          .          .               #[rustc_const_stable(feature = "const_option", since = "1.83.0")]
        .          .          .          .               pub const fn copied(self) -> Option<T>
        .          .          .          .               where
        .          .          .          .                   T: Copy,
        .          .          .          .               {
        .          .          .          .                   // FIXME(const-hack): this implementation, which sidesteps using `Option::map` since it's not const
        .          .          .          .                   // ready yet, should be reverted when possible to avoid code repetition
       65 ( 0.00%) .          .          .                   match self {
    3,518 ( 0.00%) .          .          .                       Some(&v) => Some(v),
        .          .          .          .                       None => None,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the
        .          .          .          .               /// option.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
-- line 1907 ----------------------------------------
-- line 2030 ----------------------------------------
        .          .          .          .           
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           impl<T> Clone for Option<T>
        .          .          .          .           where
        .          .          .          .               T: Clone,
        .          .          .          .           {
        .          .          .          .               #[inline]
        .          .          .          .               fn clone(&self) -> Self {
   15,157 ( 0.00%) .          .          .                   match self {
      280 ( 0.00%) .          .          .                       Some(x) => Some(x.clone()),
   32,132 ( 0.01%) 208 ( 0.03%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::clone::Clone>::clone (20x)
       10 ( 0.00%) .          .          .                       None => None,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn clone_from(&mut self, source: &Self) {
        .          .          .          .                   match (self, source) {
        .          .          .          .                       (Some(to), Some(from)) => to.clone_from(from),
        .          .          .          .                       (to, from) => *to = from.clone(),
-- line 2048 ----------------------------------------
-- line 2181 ----------------------------------------
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           impl<T> crate::marker::StructuralPartialEq for Option<T> {}
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           impl<T: PartialEq> PartialEq for Option<T> {
        .          .          .          .               #[inline]
        .          .          .          .               fn eq(&self, other: &Self) -> bool {
        .          .          .          .                   // Spelling out the cases explicitly optimizes better than
        .          .          .          .                   // `_ => false`
2,852,325 ( 0.86%) .          .          .                   match (self, other) {
        .          .          .          .                       (Some(l), Some(r)) => *l == *r,
        .          .          .          .                       (Some(_), None) => false,
        .          .          .          .                       (None, Some(_)) => false,
        .          .          .          .                       (None, None) => true,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
-- line 2197 ----------------------------------------
-- line 2479 ----------------------------------------
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn from_output(output: Self::Output) -> Self {
        .          .          .          .                   Some(output)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
  114,872 ( 0.03%) .          .          .                   match self {
  370,050 ( 0.11%) .          .          .                       Some(v) => ControlFlow::Continue(v),
        .          .          .          .                       None => ControlFlow::Break(None),
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[unstable(feature = "try_trait_v2", issue = "84277")]
        .          .          .          .           // Note: manually specifying the residual type instead of using the default to work around
        .          .          .          .           // https://github.com/rust-lang/rust/issues/99940
        .          .          .          .           impl<T> ops::FromResidual<Option<convert::Infallible>> for Option<T> {
        .          .          .          .               #[inline]
        .          .          .          .               fn from_residual(residual: Option<convert::Infallible>) -> Self {
        .          .          .          .                   match residual {
       17 ( 0.00%) .          .          .                       None => None,
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[diagnostic::do_not_recommend]
        .          .          .          .           #[unstable(feature = "try_trait_v2_yeet", issue = "96374")]
        .          .          .          .           impl<T> ops::FromResidual<ops::Yeet<()>> for Option<T> {
        .          .          .          .               #[inline]
-- line 2509 ----------------------------------------

  298,015 ( 0.09%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 137 ----------------------------------------
     .          .          .          .                       }
     .          .          .          .                       let mut vec = Vec::with_capacity_in(s.len(), alloc);
     .          .          .          .                       let mut guard = DropGuard { vec: &mut vec, num_init: 0 };
     .          .          .          .                       let slots = guard.vec.spare_capacity_mut();
     .          .          .          .                       // .take(slots.len()) is necessary for LLVM to remove bounds checks
     .          .          .          .                       // and has better codegen than zip.
     .          .          .          .                       for (i, b) in s.iter().enumerate().take(slots.len()) {
     .          .          .          .                           guard.num_init = i;
 2,788 ( 0.00%) .          .          .                           slots[i].write(b.clone());
     .          .          .          .                       }
     .          .          .          .                       core::mem::forget(guard);
     .          .          .          .                       // SAFETY:
     .          .          .          .                       // the vec was allocated and initialized above to at least this length.
     .          .          .          .                       unsafe {
     .          .          .          .                           vec.set_len(s.len());
     .          .          .          .                       }
   216 ( 0.00%) .          .          .                       vec
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[cfg(not(no_global_oom_handling))]
     .          .          .          .               impl<T: Copy> ConvertVec for T {
     .          .          .          .                   #[inline]
     .          .          .          .                   fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A> {
     .          .          .          .                       let mut v = Vec::with_capacity_in(s.len(), alloc);
     .          .          .          .                       // SAFETY:
     .          .          .          .                       // allocated above with the capacity of `s`, and initialize to `s.len()` in
     .          .          .          .                       // ptr::copy_to_non_overlapping below.
     .          .          .          .                       unsafe {
     .          .          .          .                           s.as_ptr().copy_to_nonoverlapping(v.as_mut_ptr(), s.len());
     .          .          .          .                           v.set_len(s.len());
     .          .          .          .                       }
   144 ( 0.00%) .          .          .                       v
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[cfg(not(test))]
     .          .          .          .           impl<T> [T] {
     .          .          .          .               /// Sorts the slice, preserving initial order of equal elements.
     .          .          .          .               ///
-- line 177 ----------------------------------------

33,587 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 405 ----------------------------------------
      .          .          .          .           
      .          .          .          .               /// Returns this lazy DFA's configuration.
      .          .          .          .               pub fn get_config(&self) -> &Config {
      .          .          .          .                   &self.config
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a reference to the underlying NFA.
      .          .          .          .               pub fn get_nfa(&self) -> &thompson::NFA {
    341 ( 0.00%) .          .          .                   &self.nfa
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the stride, as a base-2 exponent, required for these
      .          .          .          .               /// equivalence classes.
      .          .          .          .               ///
      .          .          .          .               /// The stride is always the smallest power of 2 that is greater than or
      .          .          .          .               /// equal to the alphabet length. This is done so that converting between
      .          .          .          .               /// state IDs and indices can be done with shifts alone, which is much
      .          .          .          .               /// faster than integer division.
      .          .          .          .               fn stride2(&self) -> usize {
 24,964 ( 0.01%) .          .          .                   self.stride2
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the total stride for every state in this lazy DFA. This
      .          .          .          .               /// corresponds to the total number of transitions used by each state in
      .          .          .          .               /// this DFA's transition table.
      .          .          .          .               fn stride(&self) -> usize {
  2,700 ( 0.00%) .          .          .                   1 << self.stride2()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the memory usage, in bytes, of this lazy DFA.
      .          .          .          .               ///
      .          .          .          .               /// This does **not** include the stack size used up by this lazy DFA. To
      .          .          .          .               /// compute that, use `std::mem::size_of::<DFA>()`. This also does not
      .          .          .          .               /// include the size of the `Cache` used.
      .          .          .          .               ///
-- line 439 ----------------------------------------
-- line 586 ----------------------------------------
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               #[inline]
      .          .          .          .               pub fn try_search_fwd(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   input: &Input<'_>,
      .          .          .          .               ) -> Result<Option<HalfMatch>, MatchError> {
     90 ( 0.00%) .          .          .                   let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
    270 ( 0.00%) .          .          .                   let hm = match search::find_fwd(self, cache, input)? {
640,621 ( 0.19%) 597 ( 0.07%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/search.rs:regex_automata::hybrid::search::find_fwd (45x)
      .          .          .          .                       None => return Ok(None),
     15 ( 0.00%) .          .          .                       Some(hm) if !utf8empty => return Ok(Some(hm)),
      .          .          .          .                       Some(hm) => hm,
      .          .          .          .                   };
      .          .          .          .                   // We get to this point when we know our DFA can match the empty string
      .          .          .          .                   // AND when UTF-8 mode is enabled. In this case, we skip any matches
      .          .          .          .                   // whose offset splits a codepoint. Such a match is necessarily a
      .          .          .          .                   // zero-width match, because UTF-8 mode requires the underlying NFA
      .          .          .          .                   // to be built such that all non-empty matches span valid UTF-8.
      .          .          .          .                   // Therefore, any match that ends in the middle of a codepoint cannot
-- line 605 ----------------------------------------
-- line 1214 ----------------------------------------
      .          .          .          .               #[inline]
      .          .          .          .               pub fn next_state(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &mut Cache,
      .          .          .          .                   current: LazyStateID,
      .          .          .          .                   input: u8,
      .          .          .          .               ) -> Result<LazyStateID, CacheError> {
      .          .          .          .                   let class = usize::from(self.classes.get(input));
    221 ( 0.00%) .          .          .                   let offset = current.as_usize_untagged() + class;
    221 ( 0.00%) .          .          .                   let sid = cache.trans[offset];
    224 ( 0.00%) .          .          .                   if !sid.is_unknown() {
      .          .          .          .                       return Ok(sid);
      .          .          .          .                   }
      .          .          .          .                   let unit = alphabet::Unit::u8(input);
    654 ( 0.00%) .          .          .                   Lazy::new(self, cache).cache_next_state(current, unit)
496,637 ( 0.15%) 490 ( 0.06%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_next_state (218x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Transitions from the current state to the next state, given the next
      .          .          .          .               /// byte of input and a state ID that is not tagged.
      .          .          .          .               ///
      .          .          .          .               /// The only reason to use this routine is performance. In particular, the
      .          .          .          .               /// `next_state` method needs to do some additional checks, among them is
      .          .          .          .               /// to account for identifiers to states that are not yet computed. In
-- line 1236 ----------------------------------------
-- line 1415 ----------------------------------------
      .          .          .          .               pub unsafe fn next_state_untagged_unchecked(
      .          .          .          .                   &self,
      .          .          .          .                   cache: &Cache,
      .          .          .          .                   current: LazyStateID,
      .          .          .          .                   input: u8,
      .          .          .          .               ) -> LazyStateID {
      .          .          .          .                   debug_assert!(!current.is_tagged());
      .          .          .          .                   let class = usize::from(self.classes.get(input));
    280 ( 0.00%) .          .          .                   let offset = current.as_usize_unchecked() + class;
    313 ( 0.00%) .          .          .                   *cache.trans.get_unchecked(offset)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Transitions from the current state to the next state for the special
      .          .          .          .               /// EOI symbol.
      .          .          .          .               ///
      .          .          .          .               /// The given cache is used to either reuse pre-computed state
      .          .          .          .               /// transitions, or to store this newly computed transition for future
      .          .          .          .               /// reuse. Thus, this routine guarantees that it will never return a state
-- line 1432 ----------------------------------------
-- line 1563 ----------------------------------------
      .          .          .          .                       Some(byte) => {
      .          .          .          .                           if !self.quitset.is_empty() && self.quitset.contains(byte) {
      .          .          .          .                               return Err(StartError::quit(byte));
      .          .          .          .                           }
      .          .          .          .                           self.start_map.get(byte)
      .          .          .          .                       }
      .          .          .          .                   };
      .          .          .          .                   let start_id = lazy.get_cached_start_id(anchored, start)?;
     45 ( 0.00%) .          .          .                   if !start_id.is_unknown() {
      .          .          .          .                       return Ok(start_id);
      .          .          .          .                   }
    449 ( 0.00%) .          .          .                   Lazy::new(self, cache).cache_start_group(anchored, start)
122,412 ( 0.04%) 107 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::cache_start_group (41x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the ID of the start state for this lazy DFA when executing a
      .          .          .          .               /// forward search.
      .          .          .          .               ///
      .          .          .          .               /// This is a convenience routine for calling [`DFA::start_state`] that
      .          .          .          .               /// converts the given [`Input`] to a [start configuration](start::Config).
      .          .          .          .               /// Additionally, if an error occurs, it is converted from a [`StartError`]
-- line 1582 ----------------------------------------
-- line 1744 ----------------------------------------
      .          .          .          .                   id: LazyStateID,
      .          .          .          .                   match_index: usize,
      .          .          .          .               ) -> PatternID {
      .          .          .          .                   // This is an optimization for the very common case of a DFA with a
      .          .          .          .                   // single pattern. This conditional avoids a somewhat more costly path
      .          .          .          .                   // that finds the pattern ID from the corresponding `State`, which
      .          .          .          .                   // requires a bit of slicing/pointer-chasing. This optimization tends
      .          .          .          .                   // to only matter when matches are frequent.
     10 ( 0.00%) .          .          .                   if self.pattern_len() == 1 {
      .          .          .          .                       return PatternID::ZERO;
      .          .          .          .                   }
      .          .          .          .                   LazyRef::new(self, cache)
      .          .          .          .                       .get_cached_state(id)
      .          .          .          .                       .match_pattern(match_index)
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
-- line 1760 ----------------------------------------
-- line 1868 ----------------------------------------
      .          .          .          .           
      .          .          .          .           impl Cache {
      .          .          .          .               /// Create a new cache for the given lazy DFA.
      .          .          .          .               ///
      .          .          .          .               /// The cache returned should only be used for searches for the given DFA.
      .          .          .          .               /// If you want to reuse the cache for another DFA, then you must call
      .          .          .          .               /// [`Cache::reset`] with that DFA.
      .          .          .          .               pub fn new(dfa: &DFA) -> Cache {
  2,861 ( 0.00%) .          .          .                   let mut cache = Cache {
      .          .          .          .                       trans: alloc::vec![],
      .          .          .          .                       starts: alloc::vec![],
      .          .          .          .                       states: alloc::vec![],
      .          .          .          .                       states_to_id: StateMap::new(),
    117 ( 0.00%) .          .          .                       sparses: SparseSets::new(dfa.get_nfa().states().len()),
  9,007 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/sparse_set.rs:regex_automata::util::sparse_set::SparseSets::new (11x)
      .          .          .          .                       stack: alloc::vec![],
      .          .          .          .                       scratch_state_builder: StateBuilderEmpty::new(),
      .          .          .          .                       state_saver: StateSaver::none(),
      .          .          .          .                       memory_usage_state: 0,
      .          .          .          .                       clear_count: 0,
      .          .          .          .                       bytes_searched: 0,
      .          .          .          .                       progress: None,
      .          .          .          .                   };
      .          .          .          .                   debug!("pre-init lazy DFA cache size: {}", cache.memory_usage());
    585 ( 0.00%) .          .          .                   Lazy { dfa, cache: &mut cache }.init_cache();
138,574 ( 0.04%) 139 ( 0.02%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::init_cache (11x)
      .          .          .          .                   debug!("post-init lazy DFA cache size: {}", cache.memory_usage());
    532 ( 0.00%) .          .          .                   cache
    715 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (11x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Reset this cache such that it can be used for searching with the given
      .          .          .          .               /// lazy DFA (and only that DFA).
      .          .          .          .               ///
      .          .          .          .               /// A cache reset permits reusing memory already allocated in this cache
      .          .          .          .               /// with a different lazy DFA.
      .          .          .          .               ///
-- line 1901 ----------------------------------------
-- line 1949 ----------------------------------------
      .          .          .          .               /// Note that keeping track of search progress is _not necessary_
      .          .          .          .               /// for correct implementations of search using a lazy DFA. Keeping
      .          .          .          .               /// track of search progress is only necessary if you want the
      .          .          .          .               /// [`Config::minimum_bytes_per_state`] configuration knob to work.
      .          .          .          .               #[inline]
      .          .          .          .               pub fn search_start(&mut self, at: usize) {
      .          .          .          .                   // If a previous search wasn't marked as finished, then finish it
      .          .          .          .                   // now automatically.
     88 ( 0.00%) .          .          .                   if let Some(p) = self.progress.take() {
      .          .          .          .                       self.bytes_searched += p.len();
      .          .          .          .                   }
    132 ( 0.00%) .          .          .                   self.progress = Some(SearchProgress { start: at, at });
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Updates the current search to indicate that it has search to the
      .          .          .          .               /// current position.
      .          .          .          .               ///
      .          .          .          .               /// No special care needs to be taken for reverse searches. Namely, the
      .          .          .          .               /// position given may be _less than_ the starting position of the search.
      .          .          .          .               ///
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// This panics if no search has been started by [`Cache::search_start`].
      .          .          .          .               #[inline]
      .          .          .          .               pub fn search_update(&mut self, at: usize) {
      .          .          .          .                   let p =
      .          .          .          .                       self.progress.as_mut().expect("no in-progress search to update");
    221 ( 0.00%) .          .          .                   p.at = at;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Indicates that a search has finished at the given position.
      .          .          .          .               ///
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// This panics if no search has been started by [`Cache::search_start`].
      .          .          .          .               #[inline]
      .          .          .          .               pub fn search_finish(&mut self, at: usize) {
      .          .          .          .                   let mut p =
      .          .          .          .                       self.progress.take().expect("no in-progress search to finish");
      .          .          .          .                   p.at = at;
     87 ( 0.00%) .          .          .                   self.bytes_searched += p.len();
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the total number of bytes that have been searched since this
      .          .          .          .               /// cache was last cleared.
      .          .          .          .               ///
      .          .          .          .               /// This is useful for determining the efficiency of the cache. For
      .          .          .          .               /// example, the lazy DFA uses this value in conjunction with the
      .          .          .          .               /// [`Config::minimum_bytes_per_state`] knob to help determine whether it
-- line 1997 ----------------------------------------
-- line 2020 ----------------------------------------
      .          .          .          .               /// compute that, use `std::mem::size_of::<Cache>()`.
      .          .          .          .               pub fn memory_usage(&self) -> usize {
      .          .          .          .                   const ID_SIZE: usize = size_of::<LazyStateID>();
      .          .          .          .                   const STATE_SIZE: usize = size_of::<State>();
      .          .          .          .           
      .          .          .          .                   // NOTE: If you make changes to the below, then
      .          .          .          .                   // 'minimum_cache_capacity' should be updated correspondingly.
      .          .          .          .           
  3,487 ( 0.00%) .          .          .                   self.trans.len() * ID_SIZE
      .          .          .          .                   + self.starts.len() * ID_SIZE
  1,568 ( 0.00%) .          .          .                   + self.states.len() * STATE_SIZE
      .          .          .          .                   // Maps likely use more memory than this, but it's probably close.
    784 ( 0.00%) .          .          .                   + self.states_to_id.len() * (STATE_SIZE + ID_SIZE)
      .          .          .          .                   + self.sparses.memory_usage()
      .          .          .          .                   + self.stack.capacity() * ID_SIZE
      .          .          .          .                   + self.scratch_state_builder.capacity()
      .          .          .          .                   // Heap memory used by 'State' in both 'states' and 'states_to_id'.
      .          .          .          .                   + self.memory_usage_state
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
-- line 2040 ----------------------------------------
-- line 2051 ----------------------------------------
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl SearchProgress {
      .          .          .          .               /// Returns the length, in bytes, of this search so far.
      .          .          .          .               ///
      .          .          .          .               /// This automatically handles the case of a reverse search, where `at`
      .          .          .          .               /// is likely to be less than `start`.
      .          .          .          .               fn len(&self) -> usize {
    220 ( 0.00%) .          .          .                   if self.start <= self.at {
      .          .          .          .                       self.at - self.start
      .          .          .          .                   } else {
      .          .          .          .                       self.start - self.at
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A map from states to state identifiers. When using std, we use a standard
-- line 2067 ----------------------------------------
-- line 2081 ----------------------------------------
      .          .          .          .           struct Lazy<'i, 'c> {
      .          .          .          .               dfa: &'i DFA,
      .          .          .          .               cache: &'c mut Cache,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'i, 'c> Lazy<'i, 'c> {
      .          .          .          .               /// Creates a new 'Lazy' wrapper for a DFA and its corresponding cache.
      .          .          .          .               fn new(dfa: &'i DFA, cache: &'c mut Cache) -> Lazy<'i, 'c> {
    804 ( 0.00%) .          .          .                   Lazy { dfa, cache }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return an immutable view by downgrading a writable cache to a read-only
      .          .          .          .               /// cache.
      .          .          .          .               fn as_ref<'a>(&'a self) -> LazyRef<'i, 'a> {
      .          .          .          .                   LazyRef::new(self.dfa, self.cache)
      .          .          .          .               }
      .          .          .          .           
-- line 2097 ----------------------------------------
-- line 2111 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// Where 'all-codepoints-utf8-100x' is the UTF-8 encoding of every
      .          .          .          .               /// codepoint, in sequence, repeated 100 times.
      .          .          .          .               ///
      .          .          .          .               /// With 'inline(never)' hyperfine reports 1.1s per run. With
      .          .          .          .               /// 'inline(always)', hyperfine reports 1.23s. So that's a 10% improvement.
      .          .          .          .               #[cold]
      .          .          .          .               #[inline(never)]
  1,744 ( 0.00%) .          .          .               fn cache_next_state(
      .          .          .          .                   &mut self,
      .          .          .          .                   mut current: LazyStateID,
      .          .          .          .                   unit: alphabet::Unit,
      .          .          .          .               ) -> Result<LazyStateID, CacheError> {
    218 ( 0.00%) .          .          .                   let stride2 = self.dfa.stride2();
      .          .          .          .                   let empty_builder = self.get_state_builder();
  1,526 ( 0.00%) .          .          .                   let builder = determinize::next(
148,471 ( 0.04%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::next (218x)
      .          .          .          .                       self.dfa.get_nfa(),
      .          .          .          .                       self.dfa.get_config().get_match_kind(),
    218 ( 0.00%) .          .          .                       &mut self.cache.sparses,
    218 ( 0.00%) .          .          .                       &mut self.cache.stack,
    436 ( 0.00%) .          .          .                       &self.cache.states[current.as_usize_untagged() >> stride2],
      .          .          .          .                       unit,
      .          .          .          .                       empty_builder,
      .          .          .          .                   );
    218 ( 0.00%) .          .          .                   let save_state = !self.as_ref().state_builder_fits_in_cache(&builder);
    218 ( 0.00%) .          .          .                   if save_state {
      .          .          .          .                       self.save_state(current);
      .          .          .          .                   }
    654 ( 0.00%) .          .          .                   let next = self.add_builder_state(builder, |sid| sid)?;
    218 ( 0.00%) .          .          .                   if save_state {
      .          .          .          .                       current = self.saved_state_id();
      .          .          .          .                   }
      .          .          .          .                   // This is the payoff. The next time 'next_state' is called with this
      .          .          .          .                   // state and alphabet unit, it will find this transition and avoid
      .          .          .          .                   // having to re-determinize this transition.
  1,308 ( 0.00%) .          .          .                   self.set_transition(current, unit, next);
  6,976 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::set_transition (218x)
      .          .          .          .                   Ok(next)
  2,180 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compute and cache the starting state for the given pattern ID (if
      .          .          .          .               /// present) and the starting configuration.
      .          .          .          .               ///
      .          .          .          .               /// This panics if a pattern ID is given and the DFA isn't configured to
      .          .          .          .               /// build anchored start states for each pattern.
      .          .          .          .               ///
      .          .          .          .               /// This will never return an unknown lazy state ID.
      .          .          .          .               ///
      .          .          .          .               /// If caching this state would otherwise result in a cache that has been
      .          .          .          .               /// cleared too many times, then an error is returned.
      .          .          .          .               #[cold]
      .          .          .          .               #[inline(never)]
    369 ( 0.00%) .          .          .               fn cache_start_group(
      .          .          .          .                   &mut self,
      .          .          .          .                   anchored: Anchored,
      .          .          .          .                   start: Start,
      .          .          .          .               ) -> Result<LazyStateID, StartError> {
     82 ( 0.00%) .          .          .                   let nfa_start_id = match anchored {
      .          .          .          .                       Anchored::No => self.dfa.get_nfa().start_unanchored(),
      .          .          .          .                       Anchored::Yes => self.dfa.get_nfa().start_anchored(),
      .          .          .          .                       Anchored::Pattern(pid) => {
      .          .          .          .                           if !self.dfa.get_config().get_starts_for_each_pattern() {
      .          .          .          .                               return Err(StartError::unsupported_anchored(anchored));
      .          .          .          .                           }
      .          .          .          .                           match self.dfa.get_nfa().start_pattern(pid) {
      .          .          .          .                               None => return Ok(self.as_ref().dead_id()),
-- line 2175 ----------------------------------------
-- line 2178 ----------------------------------------
      .          .          .          .                       }
      .          .          .          .                   };
      .          .          .          .           
      .          .          .          .                   let id = self
      .          .          .          .                       .cache_start_one(nfa_start_id, start)
      .          .          .          .                       .map_err(StartError::cache)?;
      .          .          .          .                   self.set_start_state(anchored, start, id);
      .          .          .          .                   Ok(id)
    451 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Compute and cache the starting state for the given NFA state ID and the
      .          .          .          .               /// starting configuration. The NFA state ID might be one of the following:
      .          .          .          .               ///
      .          .          .          .               /// 1) An unanchored start state to match any pattern.
      .          .          .          .               /// 2) An anchored start state to match any pattern.
      .          .          .          .               /// 3) An anchored start state for a particular pattern.
      .          .          .          .               ///
-- line 2194 ----------------------------------------
-- line 2197 ----------------------------------------
      .          .          .          .               /// If caching this state would otherwise result in a cache that has been
      .          .          .          .               /// cleared too many times, then an error is returned.
      .          .          .          .               fn cache_start_one(
      .          .          .          .                   &mut self,
      .          .          .          .                   nfa_start_id: NFAStateID,
      .          .          .          .                   start: Start,
      .          .          .          .               ) -> Result<LazyStateID, CacheError> {
      .          .          .          .                   let mut builder_matches = self.get_state_builder().into_matches();
     82 ( 0.00%) .          .          .                   determinize::set_lookbehind_from_start(
  1,378 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::set_lookbehind_from_start (41x)
      .          .          .          .                       self.dfa.get_nfa(),
      .          .          .          .                       &start,
      .          .          .          .                       &mut builder_matches,
      .          .          .          .                   );
      .          .          .          .                   self.cache.sparses.set1.clear();
    164 ( 0.00%) .          .          .                   determinize::epsilon_closure(
 36,676 ( 0.01%) 14 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::epsilon_closure (41x)
      .          .          .          .                       self.dfa.get_nfa(),
      .          .          .          .                       nfa_start_id,
      .          .          .          .                       builder_matches.look_have(),
     41 ( 0.00%) .          .          .                       &mut self.cache.stack,
     41 ( 0.00%) .          .          .                       &mut self.cache.sparses.set1,
      .          .          .          .                   );
    123 ( 0.00%) .          .          .                   let mut builder = builder_matches.into_nfa();
    123 ( 0.00%) .          .          .                   determinize::add_nfa_states(
 37,576 ( 0.01%) 52 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/mod.rs:regex_automata::util::determinize::add_nfa_states (41x)
      .          .          .          .                       &self.dfa.get_nfa(),
      .          .          .          .                       &self.cache.sparses.set1,
      .          .          .          .                       &mut builder,
      .          .          .          .                   );
      .          .          .          .                   let tag_starts = self.dfa.get_config().get_specialize_start_states();
    164 ( 0.00%) .          .          .                   self.add_builder_state(builder, |id| {
    205 ( 0.00%) .          .          .                       if tag_starts {
      .          .          .          .                           id.to_start()
      .          .          .          .                       } else {
      .          .          .          .                           id
      .          .          .          .                       }
      .          .          .          .                   })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Either add the given builder state to this cache, or return an ID to an
-- line 2234 ----------------------------------------
-- line 2242 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// If caching this state would otherwise result in a cache that has been
      .          .          .          .               /// cleared too many times, then an error is returned.
      .          .          .          .               fn add_builder_state(
      .          .          .          .                   &mut self,
      .          .          .          .                   builder: StateBuilderNFA,
      .          .          .          .                   idmap: impl Fn(LazyStateID) -> LazyStateID,
      .          .          .          .               ) -> Result<LazyStateID, CacheError> {
     44 ( 0.00%) .          .          .                   if let Some(&cached_id) =
      .          .          .          .                       self.cache.states_to_id.get(builder.as_bytes())
      .          .          .          .                   {
      .          .          .          .                       // Since we have a cached state, put the constructed state's
      .          .          .          .                       // memory back into our scratch space, so that it can be reused.
      .          .          .          .                       self.put_state_builder(builder);
      .          .          .          .                       return Ok(cached_id);
      .          .          .          .                   }
      .          .          .          .                   let result = self.add_state(builder.to_state(), idmap);
-- line 2258 ----------------------------------------
-- line 2270 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// If caching this state would otherwise result in a cache that has been
      .          .          .          .               /// cleared too many times, then an error is returned.
      .          .          .          .               fn add_state(
      .          .          .          .                   &mut self,
      .          .          .          .                   state: State,
      .          .          .          .                   idmap: impl Fn(LazyStateID) -> LazyStateID,
      .          .          .          .               ) -> Result<LazyStateID, CacheError> {
    566 ( 0.00%) .          .          .                   if !self.as_ref().state_fits_in_cache(&state) {
      .          .          .          .                       self.try_clear_cache()?;
      .          .          .          .                   }
      .          .          .          .                   // It's important for this to come second, since the above may clear
      .          .          .          .                   // the cache. If we clear the cache after ID generation, then the ID
      .          .          .          .                   // is likely bunk since it would have been generated based on a larger
      .          .          .          .                   // transition table.
      .          .          .          .                   let mut id = idmap(self.next_state_id()?);
  1,287 ( 0.00%) .          .          .                   if state.is_match() {
      .          .          .          .                       id = id.to_match();
      .          .          .          .                   }
      .          .          .          .                   // Add room in the transition table. Since this is a fresh state, all
      .          .          .          .                   // of its transitions are unknown.
      .          .          .          .                   self.cache.trans.extend(
      .          .          .          .                       iter::repeat(self.as_ref().unknown_id()).take(self.dfa.stride()),
      .          .          .          .                   );
      .          .          .          .                   // When we add a sentinel state, we never want to set any quit
      .          .          .          .                   // transitions. Technically, this is harmless, since sentinel states
      .          .          .          .                   // have all of their transitions set to loop back to themselves. But
      .          .          .          .                   // when creating sentinel states before the quit sentinel state,
      .          .          .          .                   // this will try to call 'set_transition' on a state ID that doesn't
      .          .          .          .                   // actually exist yet, which isn't allowed. So we just skip doing so
      .          .          .          .                   // entirely.
    566 ( 0.00%) .          .          .                   if !self.dfa.quitset.is_empty() && !self.as_ref().is_sentinel(id) {
      .          .          .          .                       let quit_id = self.as_ref().quit_id();
      .          .          .          .                       for b in self.dfa.quitset.iter() {
      .          .          .          .                           self.set_transition(id, alphabet::Unit::u8(b), quit_id);
      .          .          .          .                       }
      .          .          .          .                   }
    566 ( 0.00%) .          .          .                   self.cache.memory_usage_state += state.memory_usage();
    268 ( 0.00%) .          .          .                   self.cache.states.push(state.clone());
      .          .          .          .                   self.cache.states_to_id.insert(state, id);
      .          .          .          .                   Ok(id)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Allocate a new state ID.
      .          .          .          .               ///
      .          .          .          .               /// This will never return an unknown lazy state ID.
      .          .          .          .               ///
-- line 2316 ----------------------------------------
-- line 2497 ----------------------------------------
      .          .          .          .               /// Initialize this cache from emptiness to a place where it can be used
      .          .          .          .               /// for search.
      .          .          .          .               ///
      .          .          .          .               /// This is called both at cache creation time and after the cache has been
      .          .          .          .               /// cleared.
      .          .          .          .               ///
      .          .          .          .               /// Primarily, this adds the three sentinel states and allocates some
      .          .          .          .               /// initial memory.
    936 ( 0.00%) .          .          .               fn init_cache(&mut self) {
      .          .          .          .                   // Why multiply by 2 here? Because we make room for both the unanchored
      .          .          .          .                   // and anchored start states. Unanchored is first and then anchored.
      .          .          .          .                   let mut starts_len = Start::len().checked_mul(2).unwrap();
      .          .          .          .                   // ... but if we also want start states for every pattern, we make room
      .          .          .          .                   // for that too.
    351 ( 0.00%) .          .          .                   if self.dfa.get_config().get_starts_for_each_pattern() {
    212 ( 0.00%) .          .          .                       starts_len += Start::len() * self.dfa.pattern_len();
      .          .          .          .                   }
    117 ( 0.00%) .          .          .                   self.cache
      .          .          .          .                       .starts
      .          .          .          .                       .extend(iter::repeat(self.as_ref().unknown_id()).take(starts_len));
      .          .          .          .                   // This is the set of NFA states that corresponds to each of our three
      .          .          .          .                   // sentinel states: the empty set.
    117 ( 0.00%) .          .          .                   let dead = State::dead();
 44,553 ( 0.01%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/state.rs:regex_automata::util::determinize::state::State::dead (117x)
      .          .          .          .                   // This sets up some states that we use as sentinels that are present
      .          .          .          .                   // in every DFA. While it would be technically possible to implement
      .          .          .          .                   // this DFA without explicitly putting these states in the transition
      .          .          .          .                   // table, this is convenient to do to make `next_state` correct for all
      .          .          .          .                   // valid state IDs without needing explicit conditionals to special
      .          .          .          .                   // case these sentinel states.
      .          .          .          .                   //
      .          .          .          .                   // All three of these states are "dead" states. That is, all of
      .          .          .          .                   // them transition only to themselves. So once you enter one of
      .          .          .          .                   // these states, it's impossible to leave them. Thus, any correct
      .          .          .          .                   // search routine must explicitly check for these state types. (Sans
      .          .          .          .                   // `unknown`, since that is only used internally to represent missing
      .          .          .          .                   // states.)
      .          .          .          .                   let unk_id =
    117 ( 0.00%) .          .          .                       self.add_state(dead.clone(), |id| id.to_unknown()).unwrap();
    117 ( 0.00%) .          .          .                   let dead_id = self.add_state(dead.clone(), |id| id.to_dead()).unwrap();
    117 ( 0.00%) .          .          .                   let quit_id = self.add_state(dead.clone(), |id| id.to_quit()).unwrap();
    234 ( 0.00%) .          .          .                   assert_eq!(unk_id, self.as_ref().unknown_id());
    234 ( 0.00%) .          .          .                   assert_eq!(dead_id, self.as_ref().dead_id());
    234 ( 0.00%) .          .          .                   assert_eq!(quit_id, self.as_ref().quit_id());
      .          .          .          .                   // The idea here is that if you start in an unknown/dead/quit state and
      .          .          .          .                   // try to transition on them, then you should end up where you started.
      .          .          .          .                   self.set_all_transitions(unk_id, unk_id);
      .          .          .          .                   self.set_all_transitions(dead_id, dead_id);
      .          .          .          .                   self.set_all_transitions(quit_id, quit_id);
      .          .          .          .                   // All of these states are technically equivalent from the FSM
      .          .          .          .                   // perspective, so putting all three of them in the cache isn't
      .          .          .          .                   // possible. (They are distinct merely because we use their
-- line 2547 ----------------------------------------
-- line 2578 ----------------------------------------
      .          .          .          .                       .state_saver
      .          .          .          .                       .take_saved()
      .          .          .          .                       .expect("state saver does not have saved state ID")
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set all transitions on the state 'from' to 'to'.
      .          .          .          .               fn set_all_transitions(&mut self, from: LazyStateID, to: LazyStateID) {
      .          .          .          .                   for unit in self.dfa.classes.representatives(..) {
112,065 ( 0.03%) .          .          .                       self.set_transition(from, unit, to);
716,865 ( 0.22%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs:regex_automata::hybrid::dfa::Lazy::set_transition (22,413x)
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the transition on 'from' for 'unit' to 'to'.
      .          .          .          .               ///
      .          .          .          .               /// This panics if either 'from' or 'to' is invalid.
      .          .          .          .               ///
      .          .          .          .               /// All unit values are OK.
 67,893 ( 0.02%) .          .          .               fn set_transition(
      .          .          .          .                   &mut self,
      .          .          .          .                   from: LazyStateID,
      .          .          .          .                   unit: alphabet::Unit,
      .          .          .          .                   to: LazyStateID,
      .          .          .          .               ) {
 22,631 ( 0.01%) .          .          .                   assert!(self.as_ref().is_valid(from), "invalid 'from' id: {from:?}");
      .          .          .          .                   assert!(self.as_ref().is_valid(to), "invalid 'to' id: {to:?}");
      .          .          .          .                   let offset =
 22,631 ( 0.01%) .          .          .                       from.as_usize_untagged() + self.dfa.classes.get_by_unit(unit);
 22,631 ( 0.01%) .          .          .                   self.cache.trans[offset] = to;
 45,262 ( 0.01%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the start ID for the given pattern ID (if given) and starting
      .          .          .          .               /// configuration to the ID given.
      .          .          .          .               ///
      .          .          .          .               /// This panics if 'id' is not valid or if a pattern ID is given and
      .          .          .          .               /// 'starts_for_each_pattern' is not enabled.
      .          .          .          .               fn set_start_state(
      .          .          .          .                   &mut self,
      .          .          .          .                   anchored: Anchored,
      .          .          .          .                   start: Start,
      .          .          .          .                   id: LazyStateID,
      .          .          .          .               ) {
     41 ( 0.00%) .          .          .                   assert!(self.as_ref().is_valid(id));
      .          .          .          .                   let start_index = start.as_usize();
     82 ( 0.00%) .          .          .                   let index = match anchored {
      .          .          .          .                       Anchored::No => start_index,
      .          .          .          .                       Anchored::Yes => Start::len() + start_index,
      .          .          .          .                       Anchored::Pattern(pid) => {
      .          .          .          .                           assert!(
      .          .          .          .                               self.dfa.get_config().get_starts_for_each_pattern(),
      .          .          .          .                               "attempted to search for a specific pattern \
      .          .          .          .                                without enabling starts_for_each_pattern",
      .          .          .          .                           );
      .          .          .          .                           let pid = pid.as_usize();
      .          .          .          .                           (2 * Start::len()) + (Start::len() * pid) + start_index
      .          .          .          .                       }
      .          .          .          .                   };
     41 ( 0.00%) .          .          .                   self.cache.starts[index] = id;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns a state builder from this DFA that might have existing
      .          .          .          .               /// capacity. This helps avoid allocs in cases where a state is built that
      .          .          .          .               /// turns out to already be cached.
      .          .          .          .               ///
      .          .          .          .               /// Callers must put the state builder back with 'put_state_builder',
      .          .          .          .               /// otherwise the allocation reuse won't work.
      .          .          .          .               fn get_state_builder(&mut self) -> StateBuilderEmpty {
      .          .          .          .                   core::mem::replace(
    259 ( 0.00%) .          .          .                       &mut self.cache.scratch_state_builder,
      .          .          .          .                       StateBuilderEmpty::new(),
      .          .          .          .                   )
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Puts the given state builder back into this DFA for reuse.
      .          .          .          .               ///
      .          .          .          .               /// Note that building a 'State' from a builder always creates a new alloc,
      .          .          .          .               /// so callers should always put the builder back.
-- line 2653 ----------------------------------------
-- line 2665 ----------------------------------------
      .          .          .          .           struct LazyRef<'i, 'c> {
      .          .          .          .               dfa: &'i DFA,
      .          .          .          .               cache: &'c Cache,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'i, 'c> LazyRef<'i, 'c> {
      .          .          .          .               /// Creates a new 'Lazy' wrapper for a DFA and its corresponding cache.
      .          .          .          .               fn new(dfa: &'i DFA, cache: &'c Cache) -> LazyRef<'i, 'c> {
    129 ( 0.00%) .          .          .                   LazyRef { dfa, cache }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the ID of the start state for the given configuration.
      .          .          .          .               ///
      .          .          .          .               /// If the start state has not yet been computed, then this returns an
      .          .          .          .               /// unknown lazy state ID.
      .          .          .          .               #[cfg_attr(feature = "perf-inline", inline(always))]
      .          .          .          .               fn get_cached_start_id(
      .          .          .          .                   &self,
      .          .          .          .                   anchored: Anchored,
      .          .          .          .                   start: Start,
      .          .          .          .               ) -> Result<LazyStateID, StartError> {
      .          .          .          .                   let start_index = start.as_usize();
    129 ( 0.00%) .          .          .                   let index = match anchored {
      .          .          .          .                       Anchored::No => start_index,
      .          .          .          .                       Anchored::Yes => Start::len() + start_index,
      .          .          .          .                       Anchored::Pattern(pid) => {
      .          .          .          .                           if !self.dfa.get_config().get_starts_for_each_pattern() {
      .          .          .          .                               return Err(StartError::unsupported_anchored(anchored));
      .          .          .          .                           }
      .          .          .          .                           if pid.as_usize() >= self.dfa.pattern_len() {
      .          .          .          .                               return Ok(self.dead_id());
      .          .          .          .                           }
      .          .          .          .                           (2 * Start::len())
      .          .          .          .                               + (Start::len() * pid.as_usize())
      .          .          .          .                               + start_index
      .          .          .          .                       }
      .          .          .          .                   };
     47 ( 0.00%) .          .          .                   Ok(self.cache.starts[index])
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the cached NFA/DFA powerset state for the given ID.
      .          .          .          .               ///
      .          .          .          .               /// This panics if the given ID does not address a valid state.
      .          .          .          .               fn get_cached_state(&self, sid: LazyStateID) -> &State {
      .          .          .          .                   let index = sid.as_usize_untagged() >> self.dfa.stride2();
      .          .          .          .                   &self.cache.states[index]
-- line 2710 ----------------------------------------
-- line 2730 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the ID of the dead state for this lazy DFA.
      .          .          .          .               fn dead_id(&self) -> LazyStateID {
      .          .          .          .                   // This unwrap is OK since the maximum value here is 1 * 512 = 512,
      .          .          .          .                   // which is <= 2047 (the maximum state ID on 16-bit systems). Where
      .          .          .          .                   // 512 is the worst case for our equivalence classes (every byte is a
      .          .          .          .                   // distinct class).
    351 ( 0.00%) .          .          .                   LazyStateID::new(1 << self.dfa.stride2()).unwrap().to_dead()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the ID of the quit state for this lazy DFA.
      .          .          .          .               fn quit_id(&self) -> LazyStateID {
      .          .          .          .                   // This unwrap is OK since the maximum value here is 2 * 512 = 1024,
      .          .          .          .                   // which is <= 2047 (the maximum state ID on 16-bit systems). Where
      .          .          .          .                   // 512 is the worst case for our equivalence classes (every byte is a
      .          .          .          .                   // distinct class).
    117 ( 0.00%) .          .          .                   LazyStateID::new(2 << self.dfa.stride2()).unwrap().to_quit()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if and only if the given ID is valid.
      .          .          .          .               ///
      .          .          .          .               /// An ID is valid if it is both a valid index into the transition table
      .          .          .          .               /// and is a multiple of the DFA's stride.
      .          .          .          .               fn is_valid(&self, id: LazyStateID) -> bool {
      .          .          .          .                   let id = id.as_usize_untagged();
181,253 ( 0.05%) .          .          .                   id < self.cache.trans.len() && id % self.dfa.stride() == 0
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if adding the state given would fit in this cache.
      .          .          .          .               fn state_fits_in_cache(&self, state: &State) -> bool {
    781 ( 0.00%) .          .          .                   let needed = self.cache.memory_usage()
      .          .          .          .                       + self.memory_usage_for_one_more_state(state.memory_usage());
      .          .          .          .                   trace!(
      .          .          .          .                       "lazy DFA cache capacity check: {:?} ?<=? {:?}",
      .          .          .          .                       needed,
      .          .          .          .                       self.dfa.cache_capacity
      .          .          .          .                   );
  1,151 ( 0.00%) .          .          .                   needed <= self.dfa.cache_capacity
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns true if adding the state to be built by the given builder would
      .          .          .          .               /// fit in this cache.
      .          .          .          .               fn state_builder_fits_in_cache(&self, state: &StateBuilderNFA) -> bool {
    654 ( 0.00%) .          .          .                   let needed = self.cache.memory_usage()
      .          .          .          .                       + self.memory_usage_for_one_more_state(state.as_bytes().len());
    654 ( 0.00%) .          .          .                   needed <= self.dfa.cache_capacity
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the additional memory usage, in bytes, required to add one more
      .          .          .          .               /// state to this cache. The given size should be the heap size, in bytes,
      .          .          .          .               /// that would be used by the new state being added.
      .          .          .          .               fn memory_usage_for_one_more_state(
      .          .          .          .                   &self,
      .          .          .          .                   state_heap_size: usize,
      .          .          .          .               ) -> usize {
      .          .          .          .                   const ID_SIZE: usize = size_of::<LazyStateID>();
      .          .          .          .                   const STATE_SIZE: usize = size_of::<State>();
      .          .          .          .           
  3,120 ( 0.00%) .          .          .                   self.dfa.stride() * ID_SIZE // additional space needed in trans table
      .          .          .          .                   + STATE_SIZE // space in cache.states
      .          .          .          .                   + (STATE_SIZE + ID_SIZE) // space in cache.states_to_id
      .          .          .          .                   + state_heap_size // heap memory used by state itself
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A simple type that encapsulates the saving of a state ID through a cache
      .          .          .          .           /// clearing.
-- line 2797 ----------------------------------------
-- line 2854 ----------------------------------------
      .          .          .          .           ///
      .          .          .          .           /// A lazy DFA configuration is a simple data object that is typically used
      .          .          .          .           /// with [`Builder::configure`].
      .          .          .          .           ///
      .          .          .          .           /// The default configuration guarantees that a search will never return a
      .          .          .          .           /// "gave up" or "quit" error, although it is possible for a search to fail
      .          .          .          .           /// if [`Config::starts_for_each_pattern`] wasn't enabled (which it is not by
      .          .          .          .           /// default) and an [`Anchored::Pattern`] mode is requested via [`Input`].
  1,944 ( 0.00%) .          .          .           #[derive(Clone, Debug, Default)]
      .          .          .          .           pub struct Config {
      .          .          .          .               // As with other configuration types in this crate, we put all our knobs
      .          .          .          .               // in options so that we can distinguish between "default" and "not set."
      .          .          .          .               // This makes it possible to easily combine multiple configurations
      .          .          .          .               // without default values overwriting explicitly specified values. See the
      .          .          .          .               // 'overwrite' method.
      .          .          .          .               //
      .          .          .          .               // For docs on the fields below, see the corresponding method setters.
-- line 2870 ----------------------------------------
-- line 2992 ----------------------------------------
      .          .          .          .               /// let got_rev = dfa_rev.try_search_rev(&mut cache_rev, &input)?.unwrap();
      .          .          .          .               /// assert_eq!(expected_fwd, got_fwd);
      .          .          .          .               /// assert_eq!(expected_rev, got_rev);
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn match_kind(mut self, kind: MatchKind) -> Config {
      .          .          .          .                   self.match_kind = Some(kind);
  1,944 ( 0.00%) .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set a prefilter to be used whenever a start state is entered.
      .          .          .          .               ///
      .          .          .          .               /// A [`Prefilter`] in this context is meant to accelerate searches by
      .          .          .          .               /// looking for literal prefixes that every match for the corresponding
      .          .          .          .               /// pattern (or patterns) must start with. Once a prefilter produces a
      .          .          .          .               /// match, the underlying search routine continues on to try and confirm
-- line 3008 ----------------------------------------
-- line 3067 ----------------------------------------
      .          .          .          .               ///     // No match reported even though there clearly is one!
      .          .          .          .               ///     None,
      .          .          .          .               ///     re.try_search_fwd(&mut cache, &input)?,
      .          .          .          .               /// );
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn prefilter(mut self, pre: Option<Prefilter>) -> Config {
  1,377 ( 0.00%) .          .          .                   self.pre = Some(pre);
    162 ( 0.00%) .          .          .                   if self.specialize_start_states.is_none() {
     81 ( 0.00%) .          .          .                       self.specialize_start_states =
      .          .          .          .                           Some(self.get_prefilter().is_some());
      .          .          .          .                   }
  1,053 ( 0.00%) .          .          .                   self
  4,860 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (162x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Whether to compile a separate start state for each pattern in the
      .          .          .          .               /// lazy DFA.
      .          .          .          .               ///
      .          .          .          .               /// When enabled, a separate **anchored** start state is added for each
      .          .          .          .               /// pattern in the lazy DFA. When this start state is used, then the DFA
      .          .          .          .               /// will only search for matches for the pattern specified, even if there
-- line 3088 ----------------------------------------
-- line 3147 ----------------------------------------
      .          .          .          .               ///     .range(4..)
      .          .          .          .               ///     .anchored(Anchored::Pattern(PatternID::must(1)));
      .          .          .          .               /// assert_eq!(Some(expected), dfa.try_search_fwd(&mut cache, &input)?);
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn starts_for_each_pattern(mut self, yes: bool) -> Config {
      .          .          .          .                   self.starts_for_each_pattern = Some(yes);
  1,296 ( 0.00%) .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Whether to attempt to shrink the size of the lazy DFA's alphabet or
      .          .          .          .               /// not.
      .          .          .          .               ///
      .          .          .          .               /// This option is enabled by default and should never be disabled unless
      .          .          .          .               /// one is debugging the lazy DFA.
      .          .          .          .               ///
-- line 3163 ----------------------------------------
-- line 3442 ----------------------------------------
      .          .          .          .               /// // Start states are not tagged in the default configuration!
      .          .          .          .               /// assert!(!sid.is_tagged());
      .          .          .          .               /// assert!(!sid.is_start());
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn specialize_start_states(mut self, yes: bool) -> Config {
      .          .          .          .                   self.specialize_start_states = Some(yes);
    162 ( 0.00%) .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets the maximum amount of heap memory, in bytes, to allocate to the
      .          .          .          .               /// cache for use during a lazy DFA search. If the lazy DFA would otherwise
      .          .          .          .               /// use more heap memory, then, depending on other configuration knobs,
      .          .          .          .               /// either stop the search and return an error or clear the cache and
      .          .          .          .               /// continue the search.
      .          .          .          .               ///
-- line 3458 ----------------------------------------
-- line 3500 ----------------------------------------
      .          .          .          .               /// let expected = Some(HalfMatch::must(0, 2000));
      .          .          .          .               /// let got = dfa.try_search_fwd(&mut cache, &Input::new(&haystack))?;
      .          .          .          .               /// assert_eq!(expected, got);
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
      .          .          .          .               pub fn cache_capacity(mut self, bytes: usize) -> Config {
      .          .          .          .                   self.cache_capacity = Some(bytes);
  1,377 ( 0.00%) .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Configures construction of a lazy DFA to use the minimum cache capacity
      .          .          .          .               /// if the configured capacity is otherwise too small for the provided NFA.
      .          .          .          .               ///
      .          .          .          .               /// This is useful if you never want lazy DFA construction to fail because
      .          .          .          .               /// of a capacity that is too small.
      .          .          .          .               ///
-- line 3516 ----------------------------------------
-- line 3703 ----------------------------------------
      .          .          .          .               /// called.
      .          .          .          .               /// * Call [`Cache::search_finish`] before completing a search. (It is
      .          .          .          .               /// not strictly necessary to call this when an error is returned, as
      .          .          .          .               /// `Cache::search_start` will automatically finish the previous search
      .          .          .          .               /// for you. But calling it where possible before returning helps improve
      .          .          .          .               /// the accuracy of how many bytes have actually been searched.)
      .          .          .          .               pub fn minimum_bytes_per_state(mut self, min: Option<usize>) -> Config {
      .          .          .          .                   self.minimum_bytes_per_state = Some(min);
    992 ( 0.00%) .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the match semantics set in this configuration.
      .          .          .          .               pub fn get_match_kind(&self) -> MatchKind {
    218 ( 0.00%) .          .          .                   self.match_kind.unwrap_or(MatchKind::LeftmostFirst)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the prefilter set in this configuration, if one at all.
      .          .          .          .               pub fn get_prefilter(&self) -> Option<&Prefilter> {
      .          .          .          .                   self.pre.as_ref().unwrap_or(&None).as_ref()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns whether this configuration has enabled anchored starting states
      .          .          .          .               /// for every pattern in the DFA.
      .          .          .          .               pub fn get_starts_for_each_pattern(&self) -> bool {
    117 ( 0.00%) .          .          .                   self.starts_for_each_pattern.unwrap_or(false)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns whether this configuration has enabled byte classes or not.
      .          .          .          .               /// This is typically a debugging oriented option, as disabling it confers
      .          .          .          .               /// no speed benefit.
      .          .          .          .               pub fn get_byte_classes(&self) -> bool {
      .          .          .          .                   self.byte_classes.unwrap_or(true)
      .          .          .          .               }
-- line 3735 ----------------------------------------
-- line 3750 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns whether this configuration will instruct the lazy DFA to
      .          .          .          .               /// "specialize" start states. When enabled, the lazy DFA will tag start
      .          .          .          .               /// states so that search routines using the lazy DFA can detect when
      .          .          .          .               /// it's in a start state and do some kind of optimization (like run a
      .          .          .          .               /// prefilter).
      .          .          .          .               pub fn get_specialize_start_states(&self) -> bool {
     82 ( 0.00%) .          .          .                   self.specialize_start_states.unwrap_or(false)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the cache capacity set on this configuration.
      .          .          .          .               pub fn get_cache_capacity(&self) -> usize {
    350 ( 0.00%) .          .          .                   self.cache_capacity.unwrap_or(2 * (1 << 20))
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns whether the cache capacity check should be skipped.
      .          .          .          .               pub fn get_skip_cache_capacity_check(&self) -> bool {
      .          .          .          .                   self.skip_cache_capacity_check.unwrap_or(false)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns, if set, the minimum number of times the cache must be cleared
-- line 3771 ----------------------------------------
-- line 3812 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// If byte classes are disabled on this configuration, then a map is
      .          .          .          .               /// returned that puts each byte in its own equivalent class.
      .          .          .          .               fn byte_classes_from_nfa(
      .          .          .          .                   &self,
      .          .          .          .                   nfa: &thompson::NFA,
      .          .          .          .                   quit: &ByteSet,
      .          .          .          .               ) -> ByteClasses {
    350 ( 0.00%) .          .          .                   if !self.get_byte_classes() {
      .          .          .          .                       // The lazy DFA will always use the equivalence class map, but
      .          .          .          .                       // enabling this option is useful for debugging. Namely, this will
      .          .          .          .                       // cause all transitions to be defined over their actual bytes
      .          .          .          .                       // instead of an opaque equivalence class identifier. The former is
      .          .          .          .                       // much easier to grok as a human.
      .          .          .          .                       ByteClasses::singletons()
      .          .          .          .                   } else {
      .          .          .          .                       let mut set = nfa.byte_class_set().clone();
-- line 3828 ----------------------------------------
-- line 3829 ----------------------------------------
      .          .          .          .                       // It is important to distinguish any "quit" bytes from all other
      .          .          .          .                       // bytes. Otherwise, a non-quit byte may end up in the same class
      .          .          .          .                       // as a quit byte, and thus cause the DFA stop when it shouldn't.
      .          .          .          .                       //
      .          .          .          .                       // Test case:
      .          .          .          .                       //
      .          .          .          .                       //   regex-cli find match hybrid --unicode-word-boundary \
      .          .          .          .                       //     -p '^#' -p '\b10\.55\.182\.100\b' -y @conn.json.1000x.log
    175 ( 0.00%) .          .          .                       if !quit.is_empty() {
      .          .          .          .                           set.add_set(&quit);
      .          .          .          .                       }
      .          .          .          .                       set.byte_classes()
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the quit set for this configuration and the given NFA.
      .          .          .          .               ///
-- line 3845 ----------------------------------------
-- line 3864 ----------------------------------------
      .          .          .          .                           // we need for heuristic support to work.
      .          .          .          .                           if !quit.contains_range(0x80, 0xFF) {
      .          .          .          .                               return Err(
      .          .          .          .                                   BuildError::unsupported_dfa_word_boundary_unicode(),
      .          .          .          .                               );
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
    525 ( 0.00%) .          .          .                   Ok(quit)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Overwrite the default configuration such that the options in `o` are
      .          .          .          .               /// always used. If an option in `o` is not set, then the corresponding
      .          .          .          .               /// option in `self` is used. If it's not set in `self` either, then it
      .          .          .          .               /// remains not set.
      .          .          .          .               fn overwrite(&self, o: Config) -> Config {
      .          .          .          .                   Config {
    175 ( 0.00%) .          .          .                       match_kind: o.match_kind.or(self.match_kind),
    525 ( 0.00%) .          .          .                       pre: o.pre.or_else(|| self.pre.clone()),
    175 ( 0.00%) .          .          .                       starts_for_each_pattern: o
      .          .          .          .                           .starts_for_each_pattern
      .          .          .          .                           .or(self.starts_for_each_pattern),
    175 ( 0.00%) .          .          .                       byte_classes: o.byte_classes.or(self.byte_classes),
    175 ( 0.00%) .          .          .                       unicode_word_boundary: o
      .          .          .          .                           .unicode_word_boundary
      .          .          .          .                           .or(self.unicode_word_boundary),
  1,225 ( 0.00%) .          .          .                       quitset: o.quitset.or(self.quitset),
    175 ( 0.00%) .          .          .                       specialize_start_states: o
      .          .          .          .                           .specialize_start_states
      .          .          .          .                           .or(self.specialize_start_states),
    175 ( 0.00%) .          .          .                       cache_capacity: o.cache_capacity.or(self.cache_capacity),
    175 ( 0.00%) .          .          .                       skip_cache_capacity_check: o
      .          .          .          .                           .skip_cache_capacity_check
      .          .          .          .                           .or(self.skip_cache_capacity_check),
    175 ( 0.00%) .          .          .                       minimum_cache_clear_count: o
      .          .          .          .                           .minimum_cache_clear_count
      .          .          .          .                           .or(self.minimum_cache_clear_count),
    175 ( 0.00%) .          .          .                       minimum_bytes_per_state: o
      .          .          .          .                           .minimum_bytes_per_state
      .          .          .          .                           .or(self.minimum_bytes_per_state),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           /// A builder for constructing a lazy deterministic finite automaton from
      .          .          .          .           /// regular expressions.
-- line 3909 ----------------------------------------
-- line 3975 ----------------------------------------
      .          .          .          .               config: Config,
      .          .          .          .               #[cfg(feature = "syntax")]
      .          .          .          .               thompson: thompson::Compiler,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Builder {
      .          .          .          .               /// Create a new lazy DFA builder with the default configuration.
      .          .          .          .               pub fn new() -> Builder {
  1,899 ( 0.00%) .          .          .                   Builder {
      .          .          .          .                       config: Config::default(),
      .          .          .          .                       #[cfg(feature = "syntax")]
      .          .          .          .                       thompson: thompson::Compiler::new(),
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Build a lazy DFA from the given pattern.
      .          .          .          .               ///
-- line 3991 ----------------------------------------
-- line 4047 ----------------------------------------
      .          .          .          .               /// let dfa = DFA::builder().build_from_nfa(nfa)?;
      .          .          .          .               /// let mut cache = dfa.create_cache();
      .          .          .          .               /// let expected = Some(HalfMatch::must(0, 6));
      .          .          .          .               /// let got = dfa.try_search_fwd(&mut cache, &Input::new(haystack))?;
      .          .          .          .               /// assert_eq!(expected, got);
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
  1,575 ( 0.00%) .          .          .               pub fn build_from_nfa(
      .          .          .          .                   &self,
      .          .          .          .                   nfa: thompson::NFA,
      .          .          .          .               ) -> Result<DFA, BuildError> {
    525 ( 0.00%) .          .          .                   let quitset = self.config.quit_set_from_nfa(&nfa)?;
    175 ( 0.00%) .          .          .                   let classes = self.config.byte_classes_from_nfa(&nfa, &quitset);
      .          .          .          .                   // Check that we can fit at least a few states into our cache,
      .          .          .          .                   // otherwise it's pretty senseless to use the lazy DFA. This does have
      .          .          .          .                   // a possible failure mode though. This assumes the maximum size of a
      .          .          .          .                   // state in powerset space (so, the total number of NFA states), which
      .          .          .          .                   // may never actually materialize, and could be quite a bit larger
      .          .          .          .                   // than the actual biggest state. If this turns out to be a problem,
      .          .          .          .                   // we could expose a knob that disables this check. But if so, we have
      .          .          .          .                   // to be careful not to panic in other areas of the code (the cache
      .          .          .          .                   // clearing and init code) that tend to assume some minimum useful
      .          .          .          .                   // cache capacity.
    350 ( 0.00%) .          .          .                   let min_cache = minimum_cache_capacity(
      .          .          .          .                       &nfa,
      .          .          .          .                       &classes,
      .          .          .          .                       self.config.get_starts_for_each_pattern(),
      .          .          .          .                   );
      .          .          .          .                   let mut cache_capacity = self.config.get_cache_capacity();
    350 ( 0.00%) .          .          .                   if cache_capacity < min_cache {
      .          .          .          .                       // When the caller has asked us to skip the cache capacity check,
      .          .          .          .                       // then we simply force the cache capacity to its minimum amount
      .          .          .          .                       // and mush on.
      .          .          .          .                       if self.config.get_skip_cache_capacity_check() {
      .          .          .          .                           debug!(
      .          .          .          .                               "given capacity ({cache_capacity}) is too small, \
      .          .          .          .                                since skip_cache_capacity_check is enabled, \
      .          .          .          .                                setting cache capacity to minimum ({min_cache})",
-- line 4085 ----------------------------------------
-- line 4096 ----------------------------------------
      .          .          .          .                   // of states in our state ID space. This is unlikely to trigger in
      .          .          .          .                   // >=32-bit systems, but 16-bit systems have a pretty small state ID
      .          .          .          .                   // space since a number of bits are used up as sentinels.
      .          .          .          .                   if let Err(err) = minimum_lazy_state_id(&classes) {
      .          .          .          .                       return Err(BuildError::insufficient_state_id_capacity(err));
      .          .          .          .                   }
      .          .          .          .                   let stride2 = classes.stride2();
      .          .          .          .                   let start_map = StartByteMap::new(nfa.look_matcher());
 13,475 ( 0.00%) .          .          .                   Ok(DFA {
  5,250 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x)
      .          .          .          .                       config: self.config.clone(),
      .          .          .          .                       nfa,
      .          .          .          .                       stride2,
      .          .          .          .                       start_map,
      .          .          .          .                       classes,
      .          .          .          .                       quitset,
      .          .          .          .                       cache_capacity,
      .          .          .          .                   })
  1,575 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Apply the given lazy DFA configuration options to this builder.
  1,225 ( 0.00%) .          .          .               pub fn configure(&mut self, config: Config) -> &mut Builder {
  5,775 ( 0.00%) .          .          .                   self.config = self.config.overwrite(config);
      .          .          .          .                   self
  1,575 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the syntax configuration for this builder using
      .          .          .          .               /// [`syntax::Config`](crate::util::syntax::Config).
      .          .          .          .               ///
      .          .          .          .               /// This permits setting things like case insensitivity, Unicode and multi
      .          .          .          .               /// line mode.
      .          .          .          .               ///
      .          .          .          .               /// These settings only apply when constructing a lazy DFA directly from a
-- line 4127 ----------------------------------------
-- line 4321 ----------------------------------------
      .          .          .          .               starts_for_each_pattern: bool,
      .          .          .          .           ) -> usize {
      .          .          .          .               const ID_SIZE: usize = size_of::<LazyStateID>();
      .          .          .          .               const STATE_SIZE: usize = size_of::<State>();
      .          .          .          .           
      .          .          .          .               let stride = 1 << classes.stride2();
      .          .          .          .               let states_len = nfa.states().len();
      .          .          .          .               let sparses = 2 * states_len * NFAStateID::SIZE;
    525 ( 0.00%) .          .          .               let trans = MIN_STATES * stride * ID_SIZE;
      .          .          .          .           
      .          .          .          .               let mut starts = Start::len() * ID_SIZE;
    350 ( 0.00%) .          .          .               if starts_for_each_pattern {
    324 ( 0.00%) .          .          .                   starts += (Start::len() * nfa.pattern_len()) * ID_SIZE;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               // The min number of states HAS to be at least 4: we have 3 sentinel states
      .          .          .          .               // and then we need space for one more when we save a state after clearing
      .          .          .          .               // the cache. We also need space for one more, otherwise we get stuck in a
      .          .          .          .               // loop where we try to add a 5th state, which gets rejected, which clears
      .          .          .          .               // the cache, which adds back a saved state (4th total state) which then
      .          .          .          .               // tries to add the 5th state again.
-- line 4341 ----------------------------------------
-- line 4349 ----------------------------------------
      .          .          .          .               // Every `State` has 5 bytes for flags, 4 bytes (max) for the number of
      .          .          .          .               // patterns, followed by 32-bit encodings of patterns and then delta
      .          .          .          .               // varint encodings of NFA state IDs. We use the worst case (which isn't
      .          .          .          .               // technically possible) of 5 bytes for each NFA state ID.
      .          .          .          .               //
      .          .          .          .               // HOWEVER, three of the states needed by a lazy DFA are just the sentinel
      .          .          .          .               // unknown, dead and quit states. Those states have a known size and it is
      .          .          .          .               // small.
    700 ( 0.00%) .          .          .               let dead_state_size = State::dead().memory_usage();
 66,651 ( 0.02%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/determinize/state.rs:regex_automata::util::determinize::state::State::dead (175x)
    700 ( 0.00%) .          .          .               let max_state_size = 5 + 4 + (nfa.pattern_len() * 4) + (states_len * 5);
    175 ( 0.00%) .          .          .               let states = (SENTINEL_STATES * (STATE_SIZE + dead_state_size))
      .          .          .          .                   + (non_sentinel * (STATE_SIZE + max_state_size));
      .          .          .          .               // NOTE: We don't double count heap memory used by State for this map since
      .          .          .          .               // we use reference counting to avoid doubling memory usage. (This tends to
      .          .          .          .               // be where most memory is allocated in the cache.)
      .          .          .          .               let states_to_sid = (MIN_STATES * STATE_SIZE) + (MIN_STATES * ID_SIZE);
      .          .          .          .               let stack = states_len * NFAStateID::SIZE;
      .          .          .          .               let scratch_state_builder = max_state_size;
      .          .          .          .           
  1,225 ( 0.00%) .          .          .               trans
      .          .          .          .                   + starts
      .          .          .          .                   + states
      .          .          .          .                   + states_to_sid
      .          .          .          .                   + sparses
      .          .          .          .                   + stack
      .          .          .          .                   + scratch_state_builder
      .          .          .          .           }
      .          .          .          .           
-- line 4376 ----------------------------------------

143,441 ( 0.04%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/hybrid/dfa.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 45 ----------------------------------------
     .          .          .          .           /// The idea here is that the prefilter returned can be used to find candidate
     .          .          .          .           /// matches. And then the HIR returned can be used to build a reverse regex
     .          .          .          .           /// matcher, which will find the start of the candidate match. Finally, the
     .          .          .          .           /// match still has to be confirmed with a normal anchored forward scan to find
     .          .          .          .           /// the end position of the match.
     .          .          .          .           ///
     .          .          .          .           /// Note that this assumes leftmost-first match semantics, so callers must
     .          .          .          .           /// not call this otherwise.
    91 ( 0.00%) .          .          .           pub(crate) fn extract(hirs: &[&Hir]) -> Option<(Hir, Prefilter)> {
    26 ( 0.00%) .          .          .               if hirs.len() != 1 {
     .          .          .          .                   debug!(
     .          .          .          .                       "skipping reverse inner optimization since it only \
     .          .          .          .           		 	 supports 1 pattern, {} were given",
     .          .          .          .                       hirs.len(),
     .          .          .          .                   );
     .          .          .          .                   return None;
     .          .          .          .               }
    91 ( 0.00%) .          .          .               let mut concat = match top_concat(hirs[0]) {
     .          .          .          .                   Some(concat) => concat,
     .          .          .          .                   None => {
     .          .          .          .                       debug!(
     .          .          .          .                           "skipping reverse inner optimization because a top-level \
     .          .          .          .           		 	     concatenation could not found",
     .          .          .          .                       );
     .          .          .          .                       return None;
     .          .          .          .                   }
     .          .          .          .               };
     .          .          .          .               // We skip the first HIR because if it did have a prefix prefilter in it,
     .          .          .          .               // we probably wouldn't be here looking for an inner prefilter.
     .          .          .          .               for i in 1..concat.len() {
     .          .          .          .                   let hir = &concat[i];
   155 ( 0.00%) .          .          .                   let pre = match prefilter(hir) {
16,427,227 ( 4.93%) 21,922 ( 2.71%) 9 ( 2.99%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::prefilter (31x)
     .          .          .          .                       None => continue,
    88 ( 0.00%) .          .          .                       Some(pre) => pre,
     .          .          .          .                   };
     .          .          .          .                   // Even if we got a prefilter, if it isn't consider "fast," then we
     .          .          .          .                   // probably don't want to bother with it. Namely, since the reverse
     .          .          .          .                   // inner optimization requires some overhead, it likely only makes
     .          .          .          .                   // sense if the prefilter scan itself is (believed) to be much faster
     .          .          .          .                   // than the regex engine.
    44 ( 0.00%) .          .          .                   if !pre.is_fast() {
     .          .          .          .                       debug!(
     .          .          .          .                           "skipping extracted inner prefilter because \
     .          .          .          .           				 it probably isn't fast"
     .          .          .          .                       );
     .          .          .          .                       continue;
     .          .          .          .                   }
    65 ( 0.00%) .          .          .                   let concat_suffix = Hir::concat(concat.split_off(i));
109,968 ( 0.03%) 101 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (13x)
    91 ( 0.00%) .          .          .                   let concat_prefix = Hir::concat(concat);
17,818 ( 0.01%) 26 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (13x)
     .          .          .          .                   // Look for a prefilter again. Why? Because above we only looked for
     .          .          .          .                   // a prefilter on the individual 'hir', but we might be able to find
     .          .          .          .                   // something better and more discriminatory by looking at the entire
     .          .          .          .                   // suffix. We don't do this above to avoid making this loop worst case
     .          .          .          .                   // quadratic in the length of 'concat'.
    52 ( 0.00%) .          .          .                   let pre2 = match prefilter(&concat_suffix) {
12,202,198 ( 3.66%) 21,454 ( 2.65%) 6 ( 1.99%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::prefilter (13x)
     .          .          .          .                       None => pre,
    52 ( 0.00%) .          .          .                       Some(pre2) => {
    39 ( 0.00%) .          .          .                           if pre2.is_fast() {
    52 ( 0.00%) .          .          .                               pre2
     .          .          .          .                           } else {
     .          .          .          .                               pre
     .          .          .          .                           }
     .          .          .          .                       }
     .          .          .          .                   };
   169 ( 0.00%) .          .          .                   return Some((concat_prefix, pre2));
     .          .          .          .               }
     .          .          .          .               debug!(
     .          .          .          .                   "skipping reverse inner optimization because a top-level \
     .          .          .          .           	     sub-expression with a fast prefilter could not be found"
     .          .          .          .               );
     .          .          .          .               None
   117 ( 0.00%) .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Attempt to extract a prefilter from an HIR expression.
     .          .          .          .           ///
     .          .          .          .           /// We do a little massaging here to do our best that the prefilter we get out
     .          .          .          .           /// of this is *probably* fast. Basically, the false positive rate has a much
     .          .          .          .           /// higher impact for things like the reverse inner optimization because more
     .          .          .          .           /// work needs to potentially be done for each candidate match.
     .          .          .          .           ///
     .          .          .          .           /// Note that this assumes leftmost-first match semantics, so callers must
     .          .          .          .           /// not call this otherwise.
   484 ( 0.00%) .          .          .           fn prefilter(hir: &Hir) -> Option<Prefilter> {
     .          .          .          .               let mut extractor = literal::Extractor::new();
     .          .          .          .               extractor.kind(literal::ExtractKind::Prefix);
    44 ( 0.00%) .          .          .               let mut prefixes = extractor.extract(hir);
3,077,754 ( 0.92%) 6,643 ( 0.82%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/literal.rs:regex_syntax::hir::literal::Extractor::extract (44x)
     .          .          .          .               debug!(
     .          .          .          .                   "inner prefixes (len={:?}) extracted before optimization: {:?}",
     .          .          .          .                   prefixes.len(),
     .          .          .          .                   prefixes
     .          .          .          .               );
     .          .          .          .               // Since these are inner literals, we know they cannot be exact. But the
     .          .          .          .               // extractor doesn't know this. We mark them as inexact because this might
     .          .          .          .               // impact literal optimization. Namely, optimization weights "all literals
-- line 138 ----------------------------------------
-- line 146 ----------------------------------------
     .          .          .          .               debug!(
     .          .          .          .                   "inner prefixes (len={:?}) extracted after optimization: {:?}",
     .          .          .          .                   prefixes.len(),
     .          .          .          .                   prefixes
     .          .          .          .               );
     .          .          .          .               prefixes
     .          .          .          .                   .literals()
     .          .          .          .                   .and_then(|lits| Prefilter::new(MatchKind::LeftmostFirst, lits))
   308 ( 0.00%) .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Looks for a "top level" HirKind::Concat item in the given HIR. This will
     .          .          .          .           /// try to return one even if it's embedded in a capturing group, but is
     .          .          .          .           /// otherwise pretty conservative in what is returned.
     .          .          .          .           ///
     .          .          .          .           /// The HIR returned is a complete copy of the concat with all capturing
     .          .          .          .           /// groups removed. In effect, the concat returned is "flattened" with respect
     .          .          .          .           /// to capturing groups. This makes the detection logic above for prefixes
     .          .          .          .           /// a bit simpler, and it works because 1) capturing groups never influence
     .          .          .          .           /// whether a match occurs or not and 2) capturing groups are not used when
     .          .          .          .           /// doing the reverse inner search to find the start of the match.
     .          .          .          .           fn top_concat(mut hir: &Hir) -> Option<Vec<Hir>> {
     .          .          .          .               loop {
   117 ( 0.00%) .          .          .                   hir = match hir.kind() {
     .          .          .          .                       HirKind::Empty
     .          .          .          .                       | HirKind::Literal(_)
     .          .          .          .                       | HirKind::Class(_)
     .          .          .          .                       | HirKind::Look(_)
     .          .          .          .                       | HirKind::Repetition(_)
     .          .          .          .                       | HirKind::Alternation(_) => return None,
     .          .          .          .                       HirKind::Capture(hir::Capture { ref sub, .. }) => sub,
     .          .          .          .                       HirKind::Concat(ref subs) => {
     .          .          .          .                           // We are careful to only do the flattening/copy when we know
     .          .          .          .                           // we have a "top level" concat we can inspect. This avoids
     .          .          .          .                           // doing extra work in cases where we definitely won't use it.
     .          .          .          .                           // (This might still be wasted work if we can't go on to find
     .          .          .          .                           // some literals to extract.)
     .          .          .          .                           let concat =
   438 ( 0.00%) .          .          .                               Hir::concat(subs.iter().map(|h| flatten(h)).collect());
2,474,378 ( 0.74%) 7,953 ( 0.98%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten (193x)
123,741 ( 0.04%) 114 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (13x)
    52 ( 0.00%) .          .          .                           return match concat.into_kind() {
 2,163 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::into_kind (13x)
    13 ( 0.00%) .          .          .                               HirKind::Concat(xs) => Some(xs),
     .          .          .          .                               // It is actually possible for this case to occur, because
     .          .          .          .                               // 'Hir::concat' might simplify the expression to the point
     .          .          .          .                               // that concatenations are actually removed. One wonders
     .          .          .          .                               // whether this leads to other cases where we should be
     .          .          .          .                               // extracting literals, but in theory, I believe if we do
     .          .          .          .                               // get here, then it means that a "real" prefilter failed
     .          .          .          .                               // to be extracted and we should probably leave well enough
     .          .          .          .                               // alone. (A "real" prefilter is unbothered by "top-level
-- line 193 ----------------------------------------
-- line 195 ----------------------------------------
     .          .          .          .                               _ => return None,
     .          .          .          .                           };
     .          .          .          .                       }
     .          .          .          .                   };
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Returns a copy of the given HIR but with all capturing groups removed.
24,350 ( 0.01%) .          .          .           fn flatten(hir: &Hir) -> Hir {
22,563 ( 0.01%) .          .          .               match hir.kind() {
     .          .          .          .                   HirKind::Empty => Hir::empty(),
 1,912 ( 0.00%) .          .          .                   HirKind::Literal(hir::Literal(ref x)) => Hir::literal(x.clone()),
     .          .          .          .                   HirKind::Class(ref x) => Hir::class(x.clone()),
     .          .          .          .                   HirKind::Look(ref x) => Hir::look(x.clone()),
 1,834 ( 0.00%) .          .          .                   HirKind::Repetition(ref x) => Hir::repetition(x.with(flatten(&x.sub))),
88,859 ( 0.03%) 248 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (75x)
10,981 ( 0.00%) 38 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Repetition::with (75x)
     .          .          .          .                   // This is the interesting case. We just drop the group information
     .          .          .          .                   // entirely and use the child HIR itself.
   216 ( 0.00%) .          .          .                   HirKind::Capture(hir::Capture { ref sub, .. }) => flatten(sub),
     .          .          .          .                   HirKind::Alternation(ref xs) => {
 3,962 ( 0.00%) .          .          .                       Hir::alternation(xs.iter().map(|x| flatten(x)).collect())
1,059,954 ( 0.32%) 5,313 ( 0.66%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (1,446x)
591,079 ( 0.18%) 248 ( 0.03%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::alternation (55x)
     .          .          .          .                   }
     .          .          .          .                   HirKind::Concat(ref xs) => {
   940 ( 0.00%) .          .          .                       Hir::concat(xs.iter().map(|x| flatten(x)).collect())
448,083 ( 0.13%) 1,656 ( 0.20%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs:regex_automata::meta::reverse_inner::flatten'2 (68x)
45,502 ( 0.01%) 76 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/hir/mod.rs:regex_syntax::hir::Hir::concat (29x)
     .          .          .          .                   }
     .          .          .          .               }
21,915 ( 0.01%) .          .          .           }

 2,719 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/meta/reverse_inner.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 163 ----------------------------------------
      .          .          .          .               /// failure transitions everywhere, such that failure transitions are no
      .          .          .          .               /// longer used at search time. This, combined with its uniformly dense
      .          .          .          .               /// representation, are the two most important factors in why it's faster
      .          .          .          .               /// than the NFAs in this crate.
      .          .          .          .               const DEAD: StateID = StateID::new_unchecked(0);
      .          .          .          .           
      .          .          .          .               /// Adds the given pattern IDs as matches to the given state and also
      .          .          .          .               /// records the added memory usage.
 16,515 ( 0.00%) .          .          .               fn set_matches(
      .          .          .          .                   &mut self,
      .          .          .          .                   sid: StateID,
      .          .          .          .                   pids: impl Iterator<Item = PatternID>,
      .          .          .          .               ) {
  3,670 ( 0.00%) .          .          .                   let index = (sid.as_usize() >> self.stride2).checked_sub(2).unwrap();
      .          .          .          .                   let mut at_least_one = false;
      .          .          .          .                   for pid in pids {
      .          .          .          .                       self.matches[index].push(pid);
  1,835 ( 0.00%) .          .          .                       self.matches_memory_usage += PatternID::SIZE;
      .          .          .          .                       at_least_one = true;
      .          .          .          .                   }
      .          .          .          .                   assert!(at_least_one, "match state must have non-empty pids");
 14,680 ( 0.00%) .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           // SAFETY: 'start_state' always returns a valid state ID, 'next_state' always
      .          .          .          .           // returns a valid state ID given a valid state ID. We otherwise claim that
      .          .          .          .           // all other methods are correct as well.
      .          .          .          .           unsafe impl Automaton for DFA {
      .          .          .          .               #[inline(always)]
      .          .          .          .               fn start_state(&self, anchored: Anchored) -> Result<StateID, MatchError> {
-- line 192 ----------------------------------------
-- line 389 ----------------------------------------
      .          .          .          .           pub struct Builder {
      .          .          .          .               noncontiguous: noncontiguous::Builder,
      .          .          .          .               start_kind: StartKind,
      .          .          .          .               byte_classes: bool,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Default for Builder {
      .          .          .          .               fn default() -> Builder {
     78 ( 0.00%) .          .          .                   Builder {
      .          .          .          .                       noncontiguous: noncontiguous::Builder::new(),
      .          .          .          .                       start_kind: StartKind::Unanchored,
      .          .          .          .                       byte_classes: true,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Builder {
-- line 405 ----------------------------------------
-- line 411 ----------------------------------------
      .          .          .          .               /// Build an Aho-Corasick DFA from the given iterator of patterns.
      .          .          .          .               ///
      .          .          .          .               /// A builder may be reused to create more DFAs.
      .          .          .          .               pub fn build<I, P>(&self, patterns: I) -> Result<DFA, BuildError>
      .          .          .          .               where
      .          .          .          .                   I: IntoIterator<Item = P>,
      .          .          .          .                   P: AsRef<[u8]>,
      .          .          .          .               {
    468 ( 0.00%) .          .          .                   let nnfa = self.noncontiguous.build(patterns)?;
7,102,762 ( 2.13%) 3,524 ( 0.44%) 7 ( 2.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/nfa/noncontiguous.rs:aho_corasick::nfa::noncontiguous::Builder::build (39x)
     78 ( 0.00%) .          .          .                   self.build_from_noncontiguous(&nnfa)
8,985,446 ( 2.70%) 1,084 ( 0.13%) 4 ( 1.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::Builder::build_from_noncontiguous (39x)
     78 ( 0.00%) .          .          .               }
 35,610 ( 0.01%) 275 ( 0.03%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<aho_corasick::nfa::noncontiguous::NFA> (39x)
      .          .          .          .           
      .          .          .          .               /// Build an Aho-Corasick DFA from the given noncontiguous NFA.
      .          .          .          .               ///
      .          .          .          .               /// Note that when this method is used, only the `start_kind` and
      .          .          .          .               /// `byte_classes` settings on this builder are respected. The other
      .          .          .          .               /// settings only apply to the initial construction of the Aho-Corasick
      .          .          .          .               /// automaton. Since using this method requires that initial construction
      .          .          .          .               /// has already completed, all settings impacting only initial construction
      .          .          .          .               /// are no longer relevant.
    384 ( 0.00%) .          .          .               pub fn build_from_noncontiguous(
      .          .          .          .                   &self,
      .          .          .          .                   nnfa: &noncontiguous::NFA,
      .          .          .          .               ) -> Result<DFA, BuildError> {
      .          .          .          .                   debug!("building DFA");
     96 ( 0.00%) .          .          .                   let byte_classes = if self.byte_classes {
      .          .          .          .                       nnfa.byte_classes().clone()
      .          .          .          .                   } else {
      .          .          .          .                       ByteClasses::singletons()
      .          .          .          .                   };
    240 ( 0.00%) .          .          .                   let state_len = match self.start_kind {
      .          .          .          .                       StartKind::Unanchored | StartKind::Anchored => nnfa.states().len(),
      .          .          .          .                       StartKind::Both => {
      .          .          .          .                           // These unwraps are OK because we know that the number of
      .          .          .          .                           // NFA states is < StateID::LIMIT which is in turn less than
      .          .          .          .                           // i32::MAX. Thus, there is always room to multiply by 2.
      .          .          .          .                           // Finally, the number of states is always at least 4 in the
      .          .          .          .                           // NFA (DEAD, FAIL, START-UNANCHORED, START-ANCHORED), so the
      .          .          .          .                           // subtraction of 4 is okay.
-- line 449 ----------------------------------------
-- line 471 ----------------------------------------
      .          .          .          .                       };
      .          .          .          .                   StateID::new(trans_len.checked_sub(byte_classes.stride()).unwrap())
      .          .          .          .                       .map_err(|e| {
      .          .          .          .                           BuildError::state_id_overflow(
      .          .          .          .                               StateID::MAX.as_u64(),
      .          .          .          .                               e.attempted(),
      .          .          .          .                           )
      .          .          .          .                       })?;
     48 ( 0.00%) .          .          .                   let num_match_states = match self.start_kind {
      .          .          .          .                       StartKind::Unanchored | StartKind::Anchored => {
     78 ( 0.00%) .          .          .                           nnfa.special().max_match_id.as_usize().checked_sub(1).unwrap()
      .          .          .          .                       }
      .          .          .          .                       StartKind::Both => nnfa
      .          .          .          .                           .special()
      .          .          .          .                           .max_match_id
      .          .          .          .                           .as_usize()
      .          .          .          .                           .checked_sub(1)
      .          .          .          .                           .unwrap()
      .          .          .          .                           .checked_mul(2)
      .          .          .          .                           .unwrap(),
      .          .          .          .                   };
  1,200 ( 0.00%) .          .          .                   let mut dfa = DFA {
      .          .          .          .                       trans: vec![DFA::DEAD; trans_len],
      .          .          .          .                       matches: vec![vec![]; num_match_states],
      .          .          .          .                       matches_memory_usage: 0,
     48 ( 0.00%) .          .          .                       pattern_lens: nnfa.pattern_lens_raw().to_vec(),
      .          .          .          .                       prefilter: nnfa.prefilter().map(|p| p.clone()),
      .          .          .          .                       match_kind: nnfa.match_kind(),
      .          .          .          .                       state_len,
      .          .          .          .                       alphabet_len: byte_classes.alphabet_len(),
      .          .          .          .                       stride2: byte_classes.stride2(),
  1,920 ( 0.00%) .          .          .                       byte_classes,
      .          .          .          .                       min_pattern_len: nnfa.min_pattern_len(),
      .          .          .          .                       max_pattern_len: nnfa.max_pattern_len(),
      .          .          .          .                       // The special state IDs are set later.
      .          .          .          .                       special: Special::zero(),
      .          .          .          .                   };
    174 ( 0.00%) .          .          .                   match self.start_kind {
      .          .          .          .                       StartKind::Both => {
      .          .          .          .                           self.finish_build_both_starts(nnfa, &mut dfa);
      .          .          .          .                       }
      .          .          .          .                       StartKind::Unanchored => {
      .          .          .          .                           self.finish_build_one_start(Anchored::No, nnfa, &mut dfa);
      .          .          .          .                       }
      .          .          .          .                       StartKind::Anchored => {
     39 ( 0.00%) .          .          .                           self.finish_build_one_start(Anchored::Yes, nnfa, &mut dfa)
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   debug!(
      .          .          .          .                       "DFA built, <states: {:?}, size: {:?}, \
      .          .          .          .                        alphabet len: {:?}, stride: {:?}>",
      .          .          .          .                       dfa.state_len,
      .          .          .          .                       dfa.memory_usage(),
      .          .          .          .                       dfa.byte_classes.alphabet_len(),
-- line 524 ----------------------------------------
-- line 531 ----------------------------------------
      .          .          .          .                   dfa.pattern_lens.shrink_to_fit();
      .          .          .          .                   dfa.matches.shrink_to_fit();
      .          .          .          .                   // TODO: We might also want to shrink each Vec inside of `dfa.matches`,
      .          .          .          .                   // or even better, convert it to one contiguous allocation. But I think
      .          .          .          .                   // I went with nested allocs for good reason (can't remember), so this
      .          .          .          .                   // may be tricky to do. I decided not to shrink them here because it
      .          .          .          .                   // might require a fair bit of work to do. It's unclear whether it's
      .          .          .          .                   // worth it.
    144 ( 0.00%) .          .          .                   Ok(dfa)
  3,696 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (48x)
    432 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Finishes building a DFA for either unanchored or anchored searches,
      .          .          .          .               /// but NOT both.
    351 ( 0.00%) .          .          .               fn finish_build_one_start(
      .          .          .          .                   &self,
      .          .          .          .                   anchored: Anchored,
      .          .          .          .                   nnfa: &noncontiguous::NFA,
      .          .          .          .                   dfa: &mut DFA,
      .          .          .          .               ) {
      .          .          .          .                   // This function always succeeds because we check above that all of the
      .          .          .          .                   // states in the NFA can be mapped to DFA state IDs.
     39 ( 0.00%) .          .          .                   let stride2 = dfa.stride2;
      .          .          .          .                   let old2new = |oldsid: StateID| {
 11,840 ( 0.00%) .          .          .                       StateID::new_unchecked(oldsid.as_usize() << stride2)
      .          .          .          .                   };
      .          .          .          .                   for (oldsid, state) in nnfa.states().iter().with_state_ids() {
      .          .          .          .                       let newsid = old2new(oldsid);
  2,129 ( 0.00%) .          .          .                       if state.is_match() {
  3,812 ( 0.00%) .          .          .                           dfa.set_matches(newsid, nnfa.iter_matches(oldsid));
255,384 ( 0.08%) 862 ( 0.11%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::DFA::set_matches (953x)
      .          .          .          .                       }
      .          .          .          .                       sparse_iter(
      .          .          .          .                           nnfa,
      .          .          .          .                           oldsid,
      .          .          .          .                           &dfa.byte_classes,
      .          .          .          .                           |byte, class, mut oldnextsid| {
 26,875 ( 0.01%) .          .          .                               if oldnextsid == noncontiguous::NFA::FAIL {
      .          .          .          .                                   if anchored.is_anchored() {
      .          .          .          .                                       oldnextsid = noncontiguous::NFA::DEAD;
      .          .          .          .                                   } else if state.fail() == noncontiguous::NFA::DEAD {
      .          .          .          .                                       // This is a special case that avoids following
      .          .          .          .                                       // DEAD transitions in a non-contiguous NFA.
      .          .          .          .                                       // Following these transitions is pretty slow
      .          .          .          .                                       // because the non-contiguous NFA will always use
      .          .          .          .                                       // a sparse representation for it (because the
-- line 574 ----------------------------------------
-- line 581 ----------------------------------------
      .          .          .          .                                   } else {
      .          .          .          .                                       oldnextsid = nnfa.next_state(
      .          .          .          .                                           Anchored::No,
      .          .          .          .                                           state.fail(),
      .          .          .          .                                           byte,
      .          .          .          .                                       );
      .          .          .          .                                   }
      .          .          .          .                               }
280,791 ( 0.08%) .          .          .                               dfa.trans[newsid.as_usize() + usize::from(class)] =
      .          .          .          .                                   old2new(oldnextsid);
      .          .          .          .                           },
      .          .          .          .                       );
      .          .          .          .                   }
      .          .          .          .                   // Now that we've remapped all the IDs in our states, all that's left
      .          .          .          .                   // is remapping the special state IDs.
      .          .          .          .                   let old = nnfa.special();
      .          .          .          .                   let new = &mut dfa.special;
     39 ( 0.00%) .          .          .                   new.max_special_id = old2new(old.max_special_id);
     39 ( 0.00%) .          .          .                   new.max_match_id = old2new(old.max_match_id);
    312 ( 0.00%) .          .          .                   if anchored.is_anchored() {
      .          .          .          .                       new.start_unanchored_id = DFA::DEAD;
      .          .          .          .                       new.start_anchored_id = old2new(old.start_anchored_id);
      .          .          .          .                   } else {
      .          .          .          .                       new.start_unanchored_id = old2new(old.start_unanchored_id);
      .          .          .          .                       new.start_anchored_id = DFA::DEAD;
      .          .          .          .                   }
    312 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Finishes building a DFA that supports BOTH unanchored and anchored
      .          .          .          .               /// searches. It works by inter-leaving unanchored states with anchored
      .          .          .          .               /// states in the same transition table. This way, we avoid needing to
      .          .          .          .               /// re-shuffle states afterward to ensure that our states still look like
      .          .          .          .               /// DEAD, MATCH, ..., START-UNANCHORED, START-ANCHORED, NON-MATCH, ...
      .          .          .          .               ///
      .          .          .          .               /// Honestly this is pretty inscrutable... Simplifications are most
      .          .          .          .               /// welcome.
      .          .          .          .               fn finish_build_both_starts(
      .          .          .          .                   &self,
      .          .          .          .                   nnfa: &noncontiguous::NFA,
      .          .          .          .                   dfa: &mut DFA,
      .          .          .          .               ) {
      .          .          .          .                   let stride2 = dfa.stride2;
     18 ( 0.00%) .          .          .                   let stride = 1 << stride2;
      .          .          .          .                   let mut remap_unanchored = vec![DFA::DEAD; nnfa.states().len()];
      .          .          .          .                   let mut remap_anchored = vec![DFA::DEAD; nnfa.states().len()];
      .          .          .          .                   let mut is_anchored = vec![false; dfa.state_len];
      .          .          .          .                   let mut newsid = DFA::DEAD;
      .          .          .          .                   let next_dfa_id =
      .          .          .          .                       |sid: StateID| StateID::new_unchecked(sid.as_usize() + stride);
      .          .          .          .                   for (oldsid, state) in nnfa.states().iter().with_state_ids() {
  1,485 ( 0.00%) .          .          .                       if oldsid == noncontiguous::NFA::DEAD
      .          .          .          .                           || oldsid == noncontiguous::NFA::FAIL
      .          .          .          .                       {
     18 ( 0.00%) .          .          .                           remap_unanchored[oldsid] = newsid;
     18 ( 0.00%) .          .          .                           remap_anchored[oldsid] = newsid;
      .          .          .          .                           newsid = next_dfa_id(newsid);
    954 ( 0.00%) .          .          .                       } else if oldsid == nnfa.special().start_unanchored_id
      .          .          .          .                           || oldsid == nnfa.special().start_anchored_id
      .          .          .          .                       {
     27 ( 0.00%) .          .          .                           if oldsid == nnfa.special().start_unanchored_id {
      9 ( 0.00%) .          .          .                               remap_unanchored[oldsid] = newsid;
      9 ( 0.00%) .          .          .                               remap_anchored[oldsid] = DFA::DEAD;
      .          .          .          .                           } else {
      9 ( 0.00%) .          .          .                               remap_unanchored[oldsid] = DFA::DEAD;
      9 ( 0.00%) .          .          .                               remap_anchored[oldsid] = newsid;
     18 ( 0.00%) .          .          .                               is_anchored[newsid.as_usize() >> stride2] = true;
      .          .          .          .                           }
     18 ( 0.00%) .          .          .                           if state.is_match() {
      .          .          .          .                               dfa.set_matches(newsid, nnfa.iter_matches(oldsid));
      .          .          .          .                           }
      .          .          .          .                           sparse_iter(
      .          .          .          .                               nnfa,
      .          .          .          .                               oldsid,
      .          .          .          .                               &dfa.byte_classes,
      .          .          .          .                               |_, class, oldnextsid| {
      .          .          .          .                                   let class = usize::from(class);
    252 ( 0.00%) .          .          .                                   if oldnextsid == noncontiguous::NFA::FAIL {
      .          .          .          .                                       dfa.trans[newsid.as_usize() + class] = DFA::DEAD;
      .          .          .          .                                   } else {
      .          .          .          .                                       dfa.trans[newsid.as_usize() + class] = oldnextsid;
      .          .          .          .                                   }
      .          .          .          .                               },
      .          .          .          .                           );
      .          .          .          .                           newsid = next_dfa_id(newsid);
      .          .          .          .                       } else {
      .          .          .          .                           let unewsid = newsid;
      .          .          .          .                           newsid = next_dfa_id(newsid);
      .          .          .          .                           let anewsid = newsid;
      .          .          .          .                           newsid = next_dfa_id(newsid);
      .          .          .          .           
    459 ( 0.00%) .          .          .                           remap_unanchored[oldsid] = unewsid;
    459 ( 0.00%) .          .          .                           remap_anchored[oldsid] = anewsid;
    918 ( 0.00%) .          .          .                           is_anchored[anewsid.as_usize() >> stride2] = true;
    459 ( 0.00%) .          .          .                           if state.is_match() {
    441 ( 0.00%) .          .          .                               dfa.set_matches(unewsid, nnfa.iter_matches(oldsid));
153,366 ( 0.05%) 814 ( 0.10%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::DFA::set_matches (441x)
  3,087 ( 0.00%) .          .          .                               dfa.set_matches(anewsid, nnfa.iter_matches(oldsid));
154,126 ( 0.05%) 828 ( 0.10%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs:aho_corasick::dfa::DFA::set_matches (441x)
      .          .          .          .                           }
      .          .          .          .                           sparse_iter(
      .          .          .          .                               nnfa,
      .          .          .          .                               oldsid,
      .          .          .          .                               &dfa.byte_classes,
      .          .          .          .                               |byte, class, oldnextsid| {
      .          .          .          .                                   let class = usize::from(class);
    360 ( 0.00%) .          .          .                                   if oldnextsid == noncontiguous::NFA::FAIL {
      .          .          .          .                                       let oldnextsid =
  6,066 ( 0.00%) .          .          .                                           if state.fail() == noncontiguous::NFA::DEAD {
      .          .          .          .                                               noncontiguous::NFA::DEAD
      .          .          .          .                                           } else {
      .          .          .          .                                               nnfa.next_state(
      .          .          .          .                                                   Anchored::No,
      .          .          .          .                                                   state.fail(),
      .          .          .          .                                                   byte,
      .          .          .          .                                               )
      .          .          .          .                                           };
  6,066 ( 0.00%) .          .          .                                       dfa.trans[unewsid.as_usize() + class] = oldnextsid;
      .          .          .          .                                   } else {
    720 ( 0.00%) .          .          .                                       dfa.trans[unewsid.as_usize() + class] = oldnextsid;
    360 ( 0.00%) .          .          .                                       dfa.trans[anewsid.as_usize() + class] = oldnextsid;
      .          .          .          .                                   }
      .          .          .          .                               },
      .          .          .          .                           );
      .          .          .          .                       }
      .          .          .          .                   }
     54 ( 0.00%) .          .          .                   for i in 0..dfa.state_len {
  2,862 ( 0.00%) .          .          .                       let sid = i << stride2;
  1,908 ( 0.00%) .          .          .                       if is_anchored[i] {
      .          .          .          .                           for next in dfa.trans[sid..][..stride].iter_mut() {
 22,464 ( 0.01%) .          .          .                               *next = remap_anchored[*next];
      .          .          .          .                           }
      .          .          .          .                       } else {
      .          .          .          .                           for next in dfa.trans[sid..][..stride].iter_mut() {
 23,328 ( 0.01%) .          .          .                               *next = remap_unanchored[*next];
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // Now that we've remapped all the IDs in our states, all that's left
      .          .          .          .                   // is remapping the special state IDs.
      .          .          .          .                   let old = nnfa.special();
      .          .          .          .                   let new = &mut dfa.special;
     27 ( 0.00%) .          .          .                   new.max_special_id = remap_anchored[old.max_special_id];
     18 ( 0.00%) .          .          .                   new.max_match_id = remap_anchored[old.max_match_id];
     18 ( 0.00%) .          .          .                   new.start_unanchored_id = remap_unanchored[old.start_unanchored_id];
     18 ( 0.00%) .          .          .                   new.start_anchored_id = remap_anchored[old.start_anchored_id];
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set the desired match semantics.
      .          .          .          .               ///
      .          .          .          .               /// This only applies when using [`Builder::build`] and not
      .          .          .          .               /// [`Builder::build_from_noncontiguous`].
      .          .          .          .               ///
      .          .          .          .               /// See
-- line 731 ----------------------------------------
-- line 763 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Sets the starting state configuration for the automaton.
      .          .          .          .               ///
      .          .          .          .               /// See
      .          .          .          .               /// [`AhoCorasickBuilder::start_kind`](crate::AhoCorasickBuilder::start_kind)
      .          .          .          .               /// for more documentation and examples.
      .          .          .          .               pub fn start_kind(&mut self, kind: StartKind) -> &mut Builder {
     48 ( 0.00%) .          .          .                   self.start_kind = kind;
      .          .          .          .                   self
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// A debug setting for whether to attempt to shrink the size of the
      .          .          .          .               /// automaton's alphabet or not.
      .          .          .          .               ///
      .          .          .          .               /// This should never be enabled unless you're debugging an automaton.
      .          .          .          .               /// Namely, disabling byte classes makes transitions easier to reason
-- line 779 ----------------------------------------
-- line 802 ----------------------------------------
      .          .          .          .               nnfa: &noncontiguous::NFA,
      .          .          .          .               oldsid: StateID,
      .          .          .          .               classes: &ByteClasses,
      .          .          .          .               mut f: F,
      .          .          .          .           ) {
      .          .          .          .               let mut prev_class = None;
      .          .          .          .               let mut byte = 0usize;
      .          .          .          .               for t in nnfa.iter_trans(oldsid) {
321,928 ( 0.10%) .          .          .                   while byte < usize::from(t.byte()) {
      .          .          .          .                       let rep = byte.as_u8();
      .          .          .          .                       let class = classes.get(rep);
      .          .          .          .                       byte += 1;
      .          .          .          .                       if prev_class != Some(class) {
      .          .          .          .                           f(rep, class, noncontiguous::NFA::FAIL);
      .          .          .          .                           prev_class = Some(class);
      .          .          .          .                       }
      .          .          .          .                   }
-- line 818 ----------------------------------------

500,798 ( 0.15%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/dfa.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/api.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 18 ----------------------------------------
    .          .          .          .           /// and instead only supports leftmost-first or leftmost-longest. Namely,
    .          .          .          .           /// "standard" semantics cannot be easily supported by packed searchers.
    .          .          .          .           ///
    .          .          .          .           /// For more information on the distinction between leftmost-first and
    .          .          .          .           /// leftmost-longest, see the docs on the top-level `MatchKind` type.
    .          .          .          .           ///
    .          .          .          .           /// Unlike the top-level `MatchKind` type, the default match semantics for this
    .          .          .          .           /// type are leftmost-first.
   48 ( 0.00%) .          .          .           #[derive(Clone, Copy, Debug, Eq, PartialEq)]
    .          .          .          .           #[non_exhaustive]
    .          .          .          .           pub enum MatchKind {
    .          .          .          .               /// Use leftmost-first match semantics, which reports leftmost matches.
    .          .          .          .               /// When there are multiple possible leftmost matches, the match
    .          .          .          .               /// corresponding to the pattern that appeared earlier when constructing
    .          .          .          .               /// the automaton is reported.
    .          .          .          .               ///
    .          .          .          .               /// This is the default.
-- line 34 ----------------------------------------
-- line 78 ----------------------------------------
    .          .          .          .           /// # if cfg!(all(feature = "std", any(
    .          .          .          .           /// #     target_arch = "x86_64", target_arch = "aarch64",
    .          .          .          .           /// # ))) {
    .          .          .          .           /// #     example().unwrap()
    .          .          .          .           /// # } else {
    .          .          .          .           /// #     assert!(example().is_none());
    .          .          .          .           /// # }
    .          .          .          .           /// ```
  144 ( 0.00%) .          .          .           #[derive(Clone, Debug)]
    .          .          .          .           pub struct Config {
    .          .          .          .               kind: MatchKind,
    .          .          .          .               force: Option<ForceAlgorithm>,
    .          .          .          .               only_teddy_fat: Option<bool>,
    .          .          .          .               only_teddy_256bit: Option<bool>,
    .          .          .          .               heuristic_pattern_limits: bool,
    .          .          .          .           }
    .          .          .          .           
-- line 94 ----------------------------------------
-- line 108 ----------------------------------------
    .          .          .          .                   Config::new()
    .          .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl Config {
    .          .          .          .               /// Create a new default configuration. A default configuration uses
    .          .          .          .               /// leftmost-first match semantics.
    .          .          .          .               pub fn new() -> Config {
   48 ( 0.00%) .          .          .                   Config {
    .          .          .          .                       kind: MatchKind::LeftmostFirst,
    .          .          .          .                       force: None,
    .          .          .          .                       only_teddy_fat: None,
    .          .          .          .                       only_teddy_256bit: None,
    .          .          .          .                       heuristic_pattern_limits: true,
    .          .          .          .                   }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Create a packed builder from this configuration. The builder can be
    .          .          .          .               /// used to accumulate patterns and create a [`Searcher`] from them.
   48 ( 0.00%) .          .          .               pub fn builder(&self) -> Builder {
    .          .          .          .                   Builder::from_config(self.clone())
   48 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Set the match semantics for this configuration.
    .          .          .          .               pub fn match_kind(&mut self, kind: MatchKind) -> &mut Config {
   48 ( 0.00%) .          .          .                   self.kind = kind;
    .          .          .          .                   self
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// An undocumented method for forcing the use of the Teddy algorithm.
    .          .          .          .               ///
    .          .          .          .               /// This is only exposed for more precise testing and benchmarks. Callers
    .          .          .          .               /// should not use it as it is not part of the API stability guarantees of
    .          .          .          .               /// this crate.
-- line 141 ----------------------------------------
-- line 241 ----------------------------------------
    .          .          .          .           impl Builder {
    .          .          .          .               /// Create a new builder for constructing a multi-pattern searcher. This
    .          .          .          .               /// constructor uses the default configuration.
    .          .          .          .               pub fn new() -> Builder {
    .          .          .          .                   Builder::from_config(Config::new())
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               fn from_config(config: Config) -> Builder {
  768 ( 0.00%) .          .          .                   Builder { config, inert: false, patterns: Patterns::new() }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Build a searcher from the patterns added to this builder so far.
  864 ( 0.00%) .          .          .               pub fn build(&self) -> Option<Searcher> {
  384 ( 0.00%) .          .          .                   if self.inert || self.patterns.is_empty() {
   48 ( 0.00%) .          .          .                       return None;
    .          .          .          .                   }
    .          .          .          .                   let mut patterns = self.patterns.clone();
   48 ( 0.00%) .          .          .                   patterns.set_match_kind(self.config.kind);
  480 ( 0.00%) .          .          .                   let patterns = Arc::new(patterns);
   48 ( 0.00%) .          .          .                   let rabinkarp = RabinKarp::new(&patterns);
435,886 ( 0.13%) 1,120 ( 0.14%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/rabinkarp.rs:aho_corasick::packed::rabinkarp::RabinKarp::new (48x)
    .          .          .          .                   // Effectively, we only want to return a searcher if we can use Teddy,
    .          .          .          .                   // since Teddy is our only fast packed searcher at the moment.
    .          .          .          .                   // Rabin-Karp is only used when searching haystacks smaller than what
    .          .          .          .                   // Teddy can support. Thus, the only way to get a Rabin-Karp searcher
    .          .          .          .                   // is to force it using undocumented APIs (for tests/benchmarks).
   96 ( 0.00%) .          .          .                   let (search_kind, minimum_len) = match self.config.force {
    .          .          .          .                       None | Some(ForceAlgorithm::Teddy) => {
    .          .          .          .                           debug!("trying to build Teddy packed matcher");
  144 ( 0.00%) .          .          .                           let teddy = match self.build_teddy(Arc::clone(&patterns)) {
    9 ( 0.00%) .          .          .                               None => return None,
  117 ( 0.00%) .          .          .                               Some(teddy) => teddy,
    .          .          .          .                           };
    .          .          .          .                           let minimum_len = teddy.minimum_len();
    .          .          .          .                           (SearchKind::Teddy(teddy), minimum_len)
    .          .          .          .                       }
    .          .          .          .                       Some(ForceAlgorithm::RabinKarp) => {
    .          .          .          .                           debug!("using Rabin-Karp packed matcher");
    .          .          .          .                           (SearchKind::RabinKarp, 0)
    .          .          .          .                       }
    .          .          .          .                   };
  507 ( 0.00%) .          .          .                   Some(Searcher { patterns, rabinkarp, search_kind, minimum_len })
  864 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               fn build_teddy(&self, patterns: Arc<Patterns>) -> Option<teddy::Searcher> {
   96 ( 0.00%) .          .          .                   teddy::Builder::new()
1,001,372 ( 0.30%) 3,436 ( 0.42%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/teddy/builder.rs:aho_corasick::packed::teddy::builder::Builder::build (48x)
   48 ( 0.00%) .          .          .                       .only_256bit(self.config.only_teddy_256bit)
   48 ( 0.00%) .          .          .                       .only_fat(self.config.only_teddy_fat)
   48 ( 0.00%) .          .          .                       .heuristic_pattern_limits(self.config.heuristic_pattern_limits)
    .          .          .          .                       .build(patterns)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Add the given pattern to this set to match.
    .          .          .          .               ///
    .          .          .          .               /// The order in which patterns are added is significant. Namely, when
    .          .          .          .               /// using leftmost-first match semantics, then when multiple patterns can
    .          .          .          .               /// match at a particular location, the pattern that was added first is
    .          .          .          .               /// used as the match.
    .          .          .          .               ///
    .          .          .          .               /// If the number of patterns added exceeds the amount supported by packed
    .          .          .          .               /// searchers, then the builder will stop accumulating patterns and render
    .          .          .          .               /// itself inert. At this point, constructing a searcher will always return
    .          .          .          .               /// `None`.
    .          .          .          .               pub fn add<P: AsRef<[u8]>>(&mut self, pattern: P) -> &mut Builder {
3,028 ( 0.00%) .          .          .                   if self.inert {
    .          .          .          .                       return self;
2,788 ( 0.00%) .          .          .                   } else if self.patterns.len() >= PATTERN_LIMIT {
    .          .          .          .                       self.inert = true;
    .          .          .          .                       self.patterns.reset();
    .          .          .          .                       return self;
    .          .          .          .                   }
    .          .          .          .                   // Just in case PATTERN_LIMIT increases beyond u16::MAX.
    .          .          .          .                   assert!(self.patterns.len() <= core::u16::MAX as usize);
    .          .          .          .           
    .          .          .          .                   let pattern = pattern.as_ref();
2,788 ( 0.00%) .          .          .                   if pattern.is_empty() {
    .          .          .          .                       self.inert = true;
    .          .          .          .                       self.patterns.reset();
    .          .          .          .                       return self;
    .          .          .          .                   }
2,788 ( 0.00%) .          .          .                   self.patterns.add(pattern);
634,469 ( 0.19%) 3,133 ( 0.39%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/pattern.rs:aho_corasick::packed::pattern::Patterns::add (1,394x)
    .          .          .          .                   self
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Add the given iterator of patterns to this set to match.
    .          .          .          .               ///
    .          .          .          .               /// The iterator must yield elements that can be converted into a `&[u8]`.
    .          .          .          .               ///
    .          .          .          .               /// The order in which patterns are added is significant. Namely, when
-- line 328 ----------------------------------------
-- line 527 ----------------------------------------
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn find_in<B: AsRef<[u8]>>(
    .          .          .          .                   &self,
    .          .          .          .                   haystack: B,
    .          .          .          .                   span: Span,
    .          .          .          .               ) -> Option<Match> {
    .          .          .          .                   let haystack = haystack.as_ref();
   39 ( 0.00%) .          .          .                   match self.search_kind {
    .          .          .          .                       SearchKind::Teddy(ref teddy) => {
   26 ( 0.00%) .          .          .                           if haystack[span].len() < teddy.minimum_len() {
    1 ( 0.00%) .          .          .                               return self.find_in_slow(haystack, span);
  180 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/api.rs:aho_corasick::packed::api::Searcher::find_in_slow (1x)
    .          .          .          .                           }
    .          .          .          .                           teddy.find(&haystack[..span.end], span.start)
    .          .          .          .                       }
    .          .          .          .                       SearchKind::RabinKarp => {
    .          .          .          .                           self.rabinkarp.find_at(&haystack[..span.end], span.start)
    .          .          .          .                       }
    .          .          .          .                   }
    .          .          .          .               }
-- line 546 ----------------------------------------
-- line 638 ----------------------------------------
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Use a slow (non-packed) searcher.
    .          .          .          .               ///
    .          .          .          .               /// This is useful when a packed searcher could be constructed, but could
    .          .          .          .               /// not be used to search a specific haystack. For example, if Teddy was
    .          .          .          .               /// built but the haystack is smaller than ~34 bytes, then Teddy might not
    .          .          .          .               /// be able to run.
    1 ( 0.00%) .          .          .               fn find_in_slow(&self, haystack: &[u8], span: Span) -> Option<Match> {
    2 ( 0.00%) .          .          .                   self.rabinkarp.find_at(&haystack[..span.end], span.start)
  171 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/rabinkarp.rs:aho_corasick::packed::rabinkarp::RabinKarp::find_at (1x)
    3 ( 0.00%) .          .          .               }
    .          .          .          .           }
    .          .          .          .           
    .          .          .          .           impl SearchKind {
    .          .          .          .               fn memory_usage(&self) -> usize {
    .          .          .          .                   match *self {
    .          .          .          .                       SearchKind::Teddy(ref ted) => ted.memory_usage(),
    .          .          .          .                       SearchKind::RabinKarp => 0,
    .          .          .          .                   }
-- line 656 ----------------------------------------

1,635 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aho-corasick-1.1.3/src/packed/api.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/captures.rs
--------------------------------------------------------------------------------
Ir             Ge sysCount sysTime 

-- line 209 ----------------------------------------
    .          .          .          .               /// assert_eq!(None, caps.get_group_by_name("lower"));
    .          .          .          .               /// assert_eq!(Some(Span::from(0..3)), caps.get_group_by_name("upper"));
    .          .          .          .               /// assert_eq!(Some(Span::from(3..6)), caps.get_group_by_name("digits"));
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               pub fn all(group_info: GroupInfo) -> Captures {
    .          .          .          .                   let slots = group_info.slot_len();
  278 ( 0.00%) .          .          .                   Captures { group_info, pid: None, slots: vec![None; slots] }
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Create new storage for only the full match spans of a pattern. This
    .          .          .          .               /// does not include any capturing group offsets.
    .          .          .          .               ///
    .          .          .          .               /// It is unspecified behavior to use the returned `Captures` value in a
    .          .          .          .               /// search with a `GroupInfo` other than the one that is provided to this
    .          .          .          .               /// constructor.
-- line 225 ----------------------------------------
-- line 362 ----------------------------------------
    .          .          .          .               /// // Recall that offsets are only available when using a non-empty
    .          .          .          .               /// // Captures value. So even though a match occurred, this returns None!
    .          .          .          .               /// assert_eq!(None, caps.get_match());
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn pattern(&self) -> Option<PatternID> {
   65 ( 0.00%) .          .          .                   self.pid
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the pattern ID and the span of the match, if one occurred.
    .          .          .          .               ///
    .          .          .          .               /// This always returns `None` when `Captures` was created with
    .          .          .          .               /// [`Captures::empty`], even if a match was found.
    .          .          .          .               ///
    .          .          .          .               /// If this routine returns a non-`None` value, then `is_match` is
-- line 378 ----------------------------------------
-- line 451 ----------------------------------------
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn get_group(&self, index: usize) -> Option<Span> {
    .          .          .          .                   let pid = self.pattern()?;
    .          .          .          .                   // There's a little bit of work needed to map captures to slots in the
    .          .          .          .                   // fully general case. But in the overwhelming common case of a single
    .          .          .          .                   // pattern, we can just do some simple arithmetic.
  130 ( 0.00%) .          .          .                   let (slot_start, slot_end) = if self.group_info().pattern_len() == 1 {
    .          .          .          .                       (index.checked_mul(2)?, index.checked_mul(2)?.checked_add(1)?)
    .          .          .          .                   } else {
    .          .          .          .                       self.group_info().slots(pid, index)?
    .          .          .          .                   };
  260 ( 0.00%) .          .          .                   let start = self.slots.get(slot_start).copied()??;
   65 ( 0.00%) .          .          .                   let end = self.slots.get(slot_end).copied()??;
  260 ( 0.00%) .          .          .                   Some(Span { start: start.get(), end: end.get() })
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the span of a capturing group match corresponding to the group
    .          .          .          .               /// name given, only if both the overall pattern matched and the capturing
    .          .          .          .               /// group participated in that match.
    .          .          .          .               ///
    .          .          .          .               /// This returns `None` if `name` does not correspond to a valid capturing
    .          .          .          .               /// group for the pattern that matched.
-- line 474 ----------------------------------------
-- line 499 ----------------------------------------
    .          .          .          .               /// assert_eq!(Some(Match::must(0, 0..17)), caps.get_match());
    .          .          .          .               /// assert_eq!(Some(Span::from(0..5)), caps.get_group_by_name("first"));
    .          .          .          .               /// assert_eq!(Some(Span::from(6..17)), caps.get_group_by_name("last"));
    .          .          .          .               /// // Looking for a non-existent capturing group will return None:
    .          .          .          .               /// assert_eq!(None, caps.get_group_by_name("middle"));
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
  520 ( 0.00%) .          .          .               pub fn get_group_by_name(&self, name: &str) -> Option<Span> {
   65 ( 0.00%) .          .          .                   let index = self.group_info().to_index(self.pattern()?, name)?;
    .          .          .          .                   self.get_group(index)
  520 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns an iterator of possible spans for every capturing group in the
    .          .          .          .               /// matching pattern.
    .          .          .          .               ///
    .          .          .          .               /// If this `Captures` value does not correspond to a match, then the
    .          .          .          .               /// iterator returned yields no elements.
    .          .          .          .               ///
    .          .          .          .               /// Note that the iterator returned yields elements of type `Option<Span>`.
-- line 518 ----------------------------------------
-- line 1127 ----------------------------------------
    .          .          .          .               ///     Some(6),
    .          .          .          .               ///     Some(17),
    .          .          .          .               /// ]);
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn set_pattern(&mut self, pid: Option<PatternID>) {
  202 ( 0.00%) .          .          .                   self.pid = pid;
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the underlying slots, where each slot stores a single offset.
    .          .          .          .               ///
    .          .          .          .               /// Every matching capturing group generally corresponds to two slots: one
    .          .          .          .               /// slot for the starting position and another for the ending position.
    .          .          .          .               /// Typically, either both are present or neither are. (The weasel word
    .          .          .          .               /// "typically" is used here because it really depends on the regex engine
-- line 1143 ----------------------------------------
-- line 1561 ----------------------------------------
    .          .          .          .               /// ]).is_ok());
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               ///
    .          .          .          .               /// There are other ways for building a `GroupInfo` to fail but are
    .          .          .          .               /// difficult to show. For example, if the number of patterns given would
    .          .          .          .               /// overflow `PatternID`.
1,400 ( 0.00%) .          .          .               pub fn new<P, G, N>(pattern_groups: P) -> Result<GroupInfo, GroupInfoError>
    .          .          .          .               where
    .          .          .          .                   P: IntoIterator<Item = G>,
    .          .          .          .                   G: IntoIterator<Item = Option<N>>,
    .          .          .          .                   N: AsRef<str>,
    .          .          .          .               {
1,575 ( 0.00%) .          .          .                   let mut group_info = GroupInfoInner {
    .          .          .          .                       slot_ranges: vec![],
    .          .          .          .                       name_to_index: vec![],
    .          .          .          .                       index_to_name: vec![],
    .          .          .          .                       memory_extra: 0,
    .          .          .          .                   };
  849 ( 0.00%) .          .          .                   for (pattern_index, groups) in pattern_groups.into_iter().enumerate() {
    .          .          .          .                       // If we can't convert the pattern index to an ID, then the caller
    .          .          .          .                       // tried to build capture info for too many patterns.
    .          .          .          .                       let pid = PatternID::new(pattern_index)
    .          .          .          .                           .map_err(GroupInfoError::too_many_patterns)?;
    .          .          .          .           
    .          .          .          .                       let mut groups_iter = groups.into_iter().enumerate();
   81 ( 0.00%) .          .          .                       match groups_iter.next() {
    .          .          .          .                           None => return Err(GroupInfoError::missing_groups(pid)),
    .          .          .          .                           Some((_, Some(_))) => {
    .          .          .          .                               return Err(GroupInfoError::first_must_be_unnamed(pid))
    .          .          .          .                           }
    .          .          .          .                           Some((_, None)) => {}
    .          .          .          .                       }
  162 ( 0.00%) .          .          .                       group_info.add_first_group(pid);
70,180 ( 0.02%) 268 ( 0.03%) 2 ( 0.66%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/captures.rs:regex_automata::util::captures::GroupInfoInner::add_first_group (81x)
    .          .          .          .                       // Now iterate over the rest, which correspond to all of the
    .          .          .          .                       // (conventionally) explicit capture groups in a regex pattern.
    .          .          .          .                       for (group_index, maybe_name) in groups_iter {
    .          .          .          .                           // Just like for patterns, if the group index can't be
    .          .          .          .                           // converted to a "small" index, then the caller has given too
    .          .          .          .                           // many groups for a particular pattern.
    .          .          .          .                           let group = SmallIndex::new(group_index).map_err(|_| {
    .          .          .          .                               GroupInfoError::too_many_groups(pid, group_index)
-- line 1603 ----------------------------------------
-- line 1604 ----------------------------------------
    .          .          .          .                           })?;
    .          .          .          .                           group_info.add_explicit_group(pid, group, maybe_name)?;
    .          .          .          .                       }
    .          .          .          .                   }
    .          .          .          .                   group_info.fixup_slot_ranges()?;
    .          .          .          .                   group_info.slot_ranges.shrink_to_fit();
    .          .          .          .                   group_info.name_to_index.shrink_to_fit();
    .          .          .          .                   group_info.index_to_name.shrink_to_fit();
2,625 ( 0.00%) .          .          .                   Ok(GroupInfo(Arc::new(group_info)))
1,400 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// This creates an empty `GroupInfo`.
    .          .          .          .               ///
    .          .          .          .               /// This is a convenience routine for calling `GroupInfo::new` with an
    .          .          .          .               /// iterator that yields no elements.
    .          .          .          .               ///
    .          .          .          .               /// # Example
    .          .          .          .               ///
-- line 1621 ----------------------------------------
-- line 1900 ----------------------------------------
    .          .          .          .               ///     nfa.group_info().slot(PatternID::must(0), 0),
    .          .          .          .               ///     nfa.group_info().slot(PatternID::must(1), 0),
    .          .          .          .               /// );
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn slot(&self, pid: PatternID, group_index: usize) -> Option<usize> {
3,096 ( 0.00%) .          .          .                   if group_index >= self.group_len(pid) {
    .          .          .          .                       return None;
    .          .          .          .                   }
    .          .          .          .                   // At this point, we know that 'pid' refers to a real pattern and that
    .          .          .          .                   // 'group_index' refers to a real group. We therefore also know that
    .          .          .          .                   // the pattern and group can be combined to return a correct slot.
    .          .          .          .                   // That's why we don't need to use checked arithmetic below.
6,192 ( 0.00%) .          .          .                   if group_index == 0 {
    .          .          .          .                       Some(pid.as_usize() * 2)
    .          .          .          .                   } else {
    .          .          .          .                       // As above, we don't need to check that our slot is less than the
    .          .          .          .                       // end of our range since we already know the group index is a
    .          .          .          .                       // valid index for the given pattern.
    .          .          .          .                       let (start, _) = self.0.slot_ranges[pid];
    .          .          .          .                       Some(start.as_usize() + ((group_index - 1) * 2))
    .          .          .          .                   }
-- line 1923 ----------------------------------------
-- line 1985 ----------------------------------------
    .          .          .          .               /// // We disabled capturing groups, so there are none, even if there are
    .          .          .          .               /// // explicit groups in the concrete syntax.
    .          .          .          .               /// assert_eq!(0, nfa.group_info().group_len(PatternID::ZERO));
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn group_len(&self, pid: PatternID) -> usize {
1,548 ( 0.00%) .          .          .                   self.0.group_len(pid)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Return the total number of capture groups across all patterns.
    .          .          .          .               ///
    .          .          .          .               /// This includes implicit groups that represent the entire match of a
    .          .          .          .               /// pattern.
    .          .          .          .               ///
    .          .          .          .               /// # Example
-- line 2001 ----------------------------------------
-- line 2095 ----------------------------------------
    .          .          .          .               /// assert_eq!(2, info.implicit_slot_len());
    .          .          .          .               /// // 2 explicit capturing groups gives us 2*2=4 explicit slots.
    .          .          .          .               /// assert_eq!(4, info.explicit_slot_len());
    .          .          .          .               ///
    .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
    .          .          .          .               /// ```
    .          .          .          .               #[inline]
    .          .          .          .               pub fn implicit_slot_len(&self) -> usize {
  152 ( 0.00%) .          .          .                   self.pattern_len() * 2
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Returns the total number of slots for explicit capturing groups.
    .          .          .          .               ///
    .          .          .          .               /// This is like [`GroupInfo::slot_len`], except it doesn't include the
    .          .          .          .               /// implicit slots for each pattern. (There are always 2 implicit slots for
    .          .          .          .               /// each pattern.)
    .          .          .          .               ///
-- line 2111 ----------------------------------------
-- line 2187 ----------------------------------------
    .          .          .          .               /// This adds the first unnamed group for the given pattern ID. The given
    .          .          .          .               /// pattern ID must be zero if this is the first time this method is
    .          .          .          .               /// called, or must be exactly one more than the pattern ID supplied to the
    .          .          .          .               /// previous call to this method. (This method panics if this rule is
    .          .          .          .               /// violated.)
    .          .          .          .               ///
    .          .          .          .               /// This can be thought of as initializing the GroupInfo state for the
    .          .          .          .               /// given pattern and closing off the state for any previous pattern.
  486 ( 0.00%) .          .          .               fn add_first_group(&mut self, pid: PatternID) {
  162 ( 0.00%) .          .          .                   assert_eq!(pid.as_usize(), self.slot_ranges.len());
  162 ( 0.00%) .          .          .                   assert_eq!(pid.as_usize(), self.name_to_index.len());
  162 ( 0.00%) .          .          .                   assert_eq!(pid.as_usize(), self.index_to_name.len());
    .          .          .          .                   // This is the start of our slots for the explicit capturing groups.
    .          .          .          .                   // Note that since the slots for the 0th group for every pattern appear
    .          .          .          .                   // before any slots for the nth group (where n > 0) in any pattern, we
    .          .          .          .                   // will have to fix up the slot ranges once we know how many patterns
    .          .          .          .                   // we've added capture groups for.
    .          .          .          .                   let slot_start = self.small_slot_len();
    .          .          .          .                   self.slot_ranges.push((slot_start, slot_start));
    .          .          .          .                   self.name_to_index.push(CaptureNameMap::new());
  162 ( 0.00%) .          .          .                   self.index_to_name.push(vec![None]);
   81 ( 0.00%) .          .          .                   self.memory_extra += core::mem::size_of::<Option<Arc<str>>>();
  567 ( 0.00%) .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Add an explicit capturing group for the given pattern with the given
    .          .          .          .               /// index. If the group has a name, then that must be given as well.
    .          .          .          .               ///
    .          .          .          .               /// Note that every capturing group except for the first or zeroth group is
    .          .          .          .               /// explicit.
    .          .          .          .               ///
    .          .          .          .               /// This returns an error if adding this group would result in overflowing
-- line 2217 ----------------------------------------
-- line 2225 ----------------------------------------
    .          .          .          .               ) -> Result<(), GroupInfoError> {
    .          .          .          .                   // We also need to check that the slot index generated for
    .          .          .          .                   // this group is also valid. Although, this is a little weird
    .          .          .          .                   // because we offset these indices below, at which point, we'll
    .          .          .          .                   // have to recheck them. Gosh this is annoying. Note that
    .          .          .          .                   // the '+2' below is OK because 'end' is guaranteed to be less
    .          .          .          .                   // than isize::MAX.
    .          .          .          .                   let end = &mut self.slot_ranges[pid].1;
  693 ( 0.00%) .          .          .                   *end = SmallIndex::new(end.as_usize() + 2).map_err(|_| {
    .          .          .          .                       GroupInfoError::too_many_groups(pid, group.as_usize())
    .          .          .          .                   })?;
  693 ( 0.00%) .          .          .                   if let Some(name) = maybe_name {
1,172 ( 0.00%) .          .          .                       let name = Arc::<str>::from(name.as_ref());
    .          .          .          .                       if self.name_to_index[pid].contains_key(&*name) {
    .          .          .          .                           return Err(GroupInfoError::duplicate(pid, &name));
    .          .          .          .                       }
    .          .          .          .                       let len = name.len();
    .          .          .          .                       self.name_to_index[pid].insert(Arc::clone(&name), group);
    .          .          .          .                       self.index_to_name[pid].push(Some(name));
    .          .          .          .                       // Adds the memory used by the Arc<str> in both maps.
    .          .          .          .                       self.memory_extra +=
    .          .          .          .                           2 * (len + core::mem::size_of::<Option<Arc<str>>>());
    .          .          .          .                       // And also the value entry for the 'name_to_index' map.
    .          .          .          .                       // This is probably an underestimate for 'name_to_index' since
    .          .          .          .                       // hashmaps/btrees likely have some non-zero overhead, but we
    .          .          .          .                       // assume here that they have zero overhead.
2,344 ( 0.00%) .          .          .                       self.memory_extra += core::mem::size_of::<SmallIndex>();
    .          .          .          .                   } else {
    .          .          .          .                       self.index_to_name[pid].push(None);
  321 ( 0.00%) .          .          .                       self.memory_extra += core::mem::size_of::<Option<Arc<str>>>();
    .          .          .          .                   }
    .          .          .          .                   // This is a sanity assert that checks that our group index
    .          .          .          .                   // is in line with the number of groups added so far for this
    .          .          .          .                   // pattern.
2,079 ( 0.00%) .          .          .                   assert_eq!(group.one_more(), self.group_len(pid));
    .          .          .          .                   // And is also in line with the 'index_to_name' map.
1,386 ( 0.00%) .          .          .                   assert_eq!(group.one_more(), self.index_to_name[pid].len());
    .          .          .          .                   Ok(())
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// This corrects the slot ranges to account for the slots corresponding
    .          .          .          .               /// to the zeroth group of each pattern. That is, every slot range is
    .          .          .          .               /// offset by 'pattern_len() * 2', since each pattern uses two slots to
    .          .          .          .               /// represent the zeroth group.
    .          .          .          .               fn fixup_slot_ranges(&mut self) -> Result<(), GroupInfoError> {
-- line 2269 ----------------------------------------
-- line 2279 ----------------------------------------
    .          .          .          .                       let new_end = match end.as_usize().checked_add(offset) {
    .          .          .          .                           Some(new_end) => new_end,
    .          .          .          .                           None => {
    .          .          .          .                               return Err(GroupInfoError::too_many_groups(
    .          .          .          .                                   pid, group_len,
    .          .          .          .                               ))
    .          .          .          .                           }
    .          .          .          .                       };
   81 ( 0.00%) .          .          .                       *end = SmallIndex::new(new_end).map_err(|_| {
    .          .          .          .                           GroupInfoError::too_many_groups(pid, group_len)
    .          .          .          .                       })?;
    .          .          .          .                       // Since start <= end, if end is valid then start must be too.
  162 ( 0.00%) .          .          .                       *start = SmallIndex::new(start.as_usize() + offset).unwrap();
    .          .          .          .                   }
    .          .          .          .                   Ok(())
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Return the total number of patterns represented by this capture slot
    .          .          .          .               /// info.
    .          .          .          .               fn pattern_len(&self) -> usize {
    .          .          .          .                   self.slot_ranges.len()
-- line 2299 ----------------------------------------
-- line 2306 ----------------------------------------
    .          .          .          .                   let (start, end) = match self.slot_ranges.get(pid.as_usize()) {
    .          .          .          .                       None => return 0,
    .          .          .          .                       Some(range) => range,
    .          .          .          .                   };
    .          .          .          .                   // The difference between any two SmallIndex values always fits in a
    .          .          .          .                   // usize since we know that SmallIndex::MAX <= isize::MAX-1. We also
    .          .          .          .                   // know that start<=end by construction and that the number of groups
    .          .          .          .                   // never exceeds SmallIndex and thus never overflows usize.
5,175 ( 0.00%) .          .          .                   1 + ((end.as_usize() - start.as_usize()) / 2)
    .          .          .          .               }
    .          .          .          .           
    .          .          .          .               /// Return the total number of slots in this capture slot info as a
    .          .          .          .               /// "small index."
    .          .          .          .               fn small_slot_len(&self) -> SmallIndex {
    .          .          .          .                   // Since slots are allocated in order of pattern (starting at 0) and
    .          .          .          .                   // then in order of capture group, it follows that the number of slots
    .          .          .          .                   // is the end of the range of slots for the last pattern. This is
-- line 2322 ----------------------------------------

6,550 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/util/captures.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/mod.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 356 ----------------------------------------
     .          .          .          .               /// [`Hasher::write_length_prefix`] before sequences that need it.
     .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .               fn write(&mut self, bytes: &[u8]);
     .          .          .          .           
     .          .          .          .               /// Writes a single `u8` into this hasher.
     .          .          .          .               #[inline]
     .          .          .          .               #[stable(feature = "hasher_write", since = "1.3.0")]
     .          .          .          .               fn write_u8(&mut self, i: u8) {
 8,185 ( 0.00%) .          .          .                   self.write(&[i])
57,495 ( 0.02%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/sip.rs:<core::hash::sip::Hasher<S> as core::hash::Hasher>::write (1,637x)
     .          .          .          .               }
     .          .          .          .               /// Writes a single `u16` into this hasher.
     .          .          .          .               #[inline]
     .          .          .          .               #[stable(feature = "hasher_write", since = "1.3.0")]
     .          .          .          .               fn write_u16(&mut self, i: u16) {
     .          .          .          .                   self.write(&i.to_ne_bytes())
     .          .          .          .               }
     .          .          .          .               /// Writes a single `u32` into this hasher.
-- line 372 ----------------------------------------
-- line 686 ----------------------------------------
     .          .          .          .               ///     bh.hash_one(OrderAmbivalentPair(2, 1))
     .          .          .          .               /// );
     .          .          .          .               /// assert_eq!(
     .          .          .          .               ///     bh.hash_one(OrderAmbivalentPair(10, 2)),
     .          .          .          .               ///     bh.hash_one(&OrderAmbivalentPair(2, 10))
     .          .          .          .               /// );
     .          .          .          .               /// ```
     .          .          .          .               #[stable(feature = "build_hasher_simple_hash_one", since = "1.71.0")]
 8,628 ( 0.00%) .          .          .               fn hash_one<T: Hash>(&self, x: T) -> u64
     .          .          .          .               where
     .          .          .          .                   Self: Sized,
     .          .          .          .                   Self::Hasher: Hasher,
     .          .          .          .               {
 2,916 ( 0.00%) .          .          .                   let mut hasher = self.build_hasher();
     .          .          .          .                   x.hash(&mut hasher);
     .          .          .          .                   hasher.finish()
10,966 ( 0.00%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           /// Used to create a default [`BuildHasher`] instance for types that implement
     .          .          .          .           /// [`Hasher`] and [`Default`].
     .          .          .          .           ///
     .          .          .          .           /// `BuildHasherDefault<H>` can be used when a type `H` implements [`Hasher`] and
     .          .          .          .           /// [`Default`], and you need a corresponding [`BuildHasher`] instance, but none is
     .          .          .          .           /// defined.
-- line 710 ----------------------------------------
-- line 942 ----------------------------------------
     .          .          .          .                       Hash::hash_slice(self, state)
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .               impl<T: ?Sized + Hash> Hash for &T {
     .          .          .          .                   #[inline]
     .          .          .          .                   fn hash<H: Hasher>(&self, state: &mut H) {
 4,050 ( 0.00%) .          .          .                       (**self).hash(state);
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .               impl<T: ?Sized + Hash> Hash for &mut T {
     .          .          .          .                   #[inline]
     .          .          .          .                   fn hash<H: Hasher>(&self, state: &mut H) {
     .          .          .          .                       (**self).hash(state);
-- line 958 ----------------------------------------

    34 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/set_len_on_drop.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 6 ----------------------------------------
      .          .          .          .           pub(super) struct SetLenOnDrop<'a> {
      .          .          .          .               len: &'a mut usize,
      .          .          .          .               local_len: usize,
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl<'a> SetLenOnDrop<'a> {
      .          .          .          .               #[inline]
      .          .          .          .               pub(super) fn new(len: &'a mut usize) -> Self {
  3,521 ( 0.00%) .          .          .                   SetLenOnDrop { local_len: *len, len }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline]
      .          .          .          .               pub(super) fn increment_len(&mut self, increment: usize) {
109,850 ( 0.03%) .          .          .                   self.local_len += increment;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               #[inline]
      .          .          .          .               pub(super) fn current_len(&self) -> usize {
      .          .          .          .                   self.local_len
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl Drop for SetLenOnDrop<'_> {
      .          .          .          .               #[inline]
      .          .          .          .               fn drop(&mut self) {
 22,127 ( 0.01%) .          .          .                   *self.len = self.local_len;
      .          .          .          .               }
      .          .          .          .           }

  1,352 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/set_len_on_drop.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 525 ----------------------------------------
        .          .          .          .               #[must_use = "returns a new pointer rather than modifying its argument"]
        .          .          .          .               #[rustc_const_stable(feature = "const_ptr_offset", since = "1.61.0")]
        .          .          .          .               #[inline(always)]
        .          .          .          .               pub const fn wrapping_offset(self, count: isize) -> *mut T
        .          .          .          .               where
        .          .          .          .                   T: Sized,
        .          .          .          .               {
        .          .          .          .                   // SAFETY: the `arith_offset` intrinsic has no prerequisites to be called.
       80 ( 0.00%) .          .          .                   unsafe { intrinsics::arith_offset(self, count) as *mut T }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Adds a signed offset in bytes to a pointer using wrapping arithmetic.
        .          .          .          .               ///
        .          .          .          .               /// `count` is in units of **bytes**.
        .          .          .          .               ///
        .          .          .          .               /// This is purely a convenience for casting to a `u8` pointer and
        .          .          .          .               /// using [wrapping_offset][pointer::wrapping_offset] on it. See that method
-- line 541 ----------------------------------------
-- line 1049 ----------------------------------------
        .          .          .          .                       (
        .          .          .          .                           this: *const () = self as *const (),
        .          .          .          .                           count: usize = count,
        .          .          .          .                           size: usize = size_of::<T>(),
        .          .          .          .                       ) => runtime_add_nowrap(this, count, size)
        .          .          .          .                   );
        .          .          .          .           
        .          .          .          .                   // SAFETY: the caller must uphold the safety contract for `offset`.
1,870,295 ( 0.56%) .          .          .                   unsafe { intrinsics::offset(self, count) }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Adds an unsigned offset in bytes to a pointer.
        .          .          .          .               ///
        .          .          .          .               /// `count` is in units of bytes.
        .          .          .          .               ///
        .          .          .          .               /// This is purely a convenience for casting to a `u8` pointer and
        .          .          .          .               /// using [add][pointer::add] on it. See that method for documentation
-- line 1065 ----------------------------------------
-- line 1160 ----------------------------------------
        .          .          .          .           
        .          .          .          .                   if T::IS_ZST {
        .          .          .          .                       // Pointer arithmetic does nothing when the pointee is a ZST.
        .          .          .          .                       self
        .          .          .          .                   } else {
        .          .          .          .                       // SAFETY: the caller must uphold the safety contract for `offset`.
        .          .          .          .                       // Because the pointee is *not* a ZST, that means that `count` is
        .          .          .          .                       // at most `isize::MAX`, and thus the negation cannot overflow.
    8,583 ( 0.00%) .          .          .                       unsafe { intrinsics::offset(self, intrinsics::unchecked_sub(0, count as isize)) }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Subtracts an unsigned offset in bytes from a pointer.
        .          .          .          .               ///
        .          .          .          .               /// `count` is in units of bytes.
        .          .          .          .               ///
        .          .          .          .               /// This is purely a convenience for casting to a `u8` pointer and
-- line 1176 ----------------------------------------
-- line 1484 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// See [`ptr::drop_in_place`] for safety concerns and examples.
        .          .          .          .               ///
        .          .          .          .               /// [`ptr::drop_in_place`]: crate::ptr::drop_in_place()
        .          .          .          .               #[stable(feature = "pointer_methods", since = "1.26.0")]
        .          .          .          .               #[inline(always)]
        .          .          .          .               pub unsafe fn drop_in_place(self) {
        .          .          .          .                   // SAFETY: the caller must uphold the safety contract for `drop_in_place`.
        2 ( 0.00%) .          .          .                   unsafe { drop_in_place(self) }
      982 ( 0.00%) 13 ( 0.00%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<(usize,s4lib::readers::summary::Summary)> (1x)
       20 ( 0.00%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<(usize,s4lib::common::FileProcessingResult<std::io::error::Error>)> (1x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Overwrites a memory location with the given value without reading or
        .          .          .          .               /// dropping the old value.
        .          .          .          .               ///
        .          .          .          .               /// See [`ptr::write`] for safety concerns and examples.
        .          .          .          .               ///
        .          .          .          .               /// [`ptr::write`]: crate::ptr::write()
-- line 1500 ----------------------------------------

  108,771 ( 0.03%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 152 ----------------------------------------
     .          .          .          .                   self.as_slice().is_sorted_by(|a, b| compare(&a, &b))
     .          .          .          .               }
     .          .          .          .           }}
     .          .          .          .           
     .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .           impl<T> Clone for Iter<'_, T> {
     .          .          .          .               #[inline]
     .          .          .          .               fn clone(&self) -> Self {
     2 ( 0.00%) .          .          .                   Iter { ptr: self.ptr, end_or_len: self.end_or_len, _marker: self._marker }
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[stable(feature = "slice_iter_as_ref", since = "1.13.0")]
     .          .          .          .           impl<T> AsRef<[T]> for Iter<'_, T> {
     .          .          .          .               #[inline]
     .          .          .          .               fn as_ref(&self) -> &[T] {
     .          .          .          .                   self.as_slice()
-- line 168 ----------------------------------------
-- line 1351 ----------------------------------------
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
     .          .          .          .           impl<'a, T> Iterator for Windows<'a, T> {
     .          .          .          .               type Item = &'a [T];
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               fn next(&mut self) -> Option<&'a [T]> {
29,566 ( 0.01%) .          .          .                   if self.size.get() > self.v.len() {
     .          .          .          .                       None
     .          .          .          .                   } else {
     .          .          .          .                       let ret = Some(&self.v[..self.size.get()]);
     .          .          .          .                       self.v = &self.v[1..];
     .          .          .          .                       ret
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
-- line 1367 ----------------------------------------
-- line 1861 ----------------------------------------
     .          .          .          .               v: &'a [T],
     .          .          .          .               rem: &'a [T],
     .          .          .          .               chunk_size: usize,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<'a, T> ChunksExact<'a, T> {
     .          .          .          .               #[inline]
     .          .          .          .               pub(super) fn new(slice: &'a [T], chunk_size: usize) -> Self {
    11 ( 0.00%) .          .          .                   let rem = slice.len() % chunk_size;
     1 ( 0.00%) .          .          .                   let fst_len = slice.len() - rem;
     .          .          .          .                   // SAFETY: 0 <= fst_len <= slice.len() by construction above
     .          .          .          .                   let (fst, snd) = unsafe { slice.split_at_unchecked(fst_len) };
     .          .          .          .                   Self { v: fst, rem: snd, chunk_size }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the remainder of the original slice that is not going to be
     .          .          .          .               /// returned by the iterator. The returned slice has at most `chunk_size-1`
     .          .          .          .               /// elements.
-- line 1878 ----------------------------------------
-- line 1906 ----------------------------------------
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[stable(feature = "chunks_exact", since = "1.31.0")]
     .          .          .          .           impl<'a, T> Iterator for ChunksExact<'a, T> {
     .          .          .          .               type Item = &'a [T];
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               fn next(&mut self) -> Option<&'a [T]> {
    32 ( 0.00%) .          .          .                   if self.v.len() < self.chunk_size {
     .          .          .          .                       None
     .          .          .          .                   } else {
     .          .          .          .                       let (fst, snd) = self.v.split_at(self.chunk_size);
     .          .          .          .                       self.v = snd;
     .          .          .          .                       Some(fst)
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               fn size_hint(&self) -> (usize, Option<usize>) {
     7 ( 0.00%) .          .          .                   let n = self.v.len() / self.chunk_size;
     .          .          .          .                   (n, Some(n))
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               fn count(self) -> usize {
     .          .          .          .                   self.len()
     .          .          .          .               }
     .          .          .          .           
-- line 1933 ----------------------------------------

    16 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/convert.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 238 ----------------------------------------
     .          .          .          .               // The XOR with 0xD800 permutes the ranges such that 0xD800..0xE000 is
     .          .          .          .               // mapped to 0x0000..0x0800, while keeping all the high bits outside 0xFFFF the same.
     .          .          .          .               // In particular, numbers >= 0x110000 stay in this range.
     .          .          .          .               //
     .          .          .          .               // Subtracting 0x800 causes 0x0000..0x0800 to wrap, meaning that a single
     .          .          .          .               // unsigned comparison against 0x110000 - 0x800 will detect both the wrapped
     .          .          .          .               // surrogate range as well as the numbers originally larger than 0x110000.
     .          .          .          .               //
24,780 ( 0.01%) .          .          .               if (i ^ 0xD800).wrapping_sub(0x800) >= 0x110000 - 0x800 {
     .          .          .          .                   Err(CharTryFromError(()))
     .          .          .          .               } else {
     .          .          .          .                   // SAFETY: checked that it's a legal unicode value
     .          .          .          .                   Ok(unsafe { transmute(i) })
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           #[stable(feature = "try_from", since = "1.34.0")]
-- line 254 ----------------------------------------

 6,284 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/convert.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_extend.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 20 ----------------------------------------
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>
     .          .          .          .           where
     .          .          .          .               I: TrustedLen<Item = T>,
     .          .          .          .           {
     .          .          .          .               #[track_caller]
19,760 ( 0.01%) .          .          .               default fn spec_extend(&mut self, iterator: I) {
     .          .          .          .                   self.extend_trusted(iterator)
19,760 ( 0.01%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<T, A: Allocator> SpecExtend<T, IntoIter<T>> for Vec<T, A> {
     .          .          .          .               #[track_caller]
     .          .          .          .               fn spec_extend(&mut self, mut iterator: IntoIter<T>) {
     .          .          .          .                   unsafe {
     .          .          .          .                       self.append_elements(iterator.as_slice() as _);
     .          .          .          .                   }
-- line 38 ----------------------------------------
-- line 41 ----------------------------------------
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<'a, T: 'a, I, A: Allocator> SpecExtend<&'a T, I> for Vec<T, A>
     .          .          .          .           where
     .          .          .          .               I: Iterator<Item = &'a T>,
     .          .          .          .               T: Clone,
     .          .          .          .           {
     .          .          .          .               #[track_caller]
    21 ( 0.00%) .          .          .               default fn spec_extend(&mut self, iterator: I) {
     .          .          .          .                   self.spec_extend(iterator.cloned())
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl<'a, T: 'a, A: Allocator> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T, A>
     .          .          .          .           where
     .          .          .          .               T: Copy,
     .          .          .          .           {
-- line 57 ----------------------------------------

   154 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_extend.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/utf8.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 107 ----------------------------------------
     .          .          .          .           
     .          .          .          .           impl Utf8Sequence {
     .          .          .          .               /// Creates a new UTF-8 sequence from the encoded bytes of a scalar value
     .          .          .          .               /// range.
     .          .          .          .               ///
     .          .          .          .               /// This assumes that `start` and `end` have the same length.
     .          .          .          .               fn from_encoded_range(start: &[u8], end: &[u8]) -> Self {
     .          .          .          .                   assert_eq!(start.len(), end.len());
 7,023 ( 0.00%) .          .          .                   match start.len() {
     .          .          .          .                       2 => Utf8Sequence::Two([
     .          .          .          .                           Utf8Range::new(start[0], end[0]),
     .          .          .          .                           Utf8Range::new(start[1], end[1]),
     .          .          .          .                       ]),
 6,314 ( 0.00%) .          .          .                       3 => Utf8Sequence::Three([
     .          .          .          .                           Utf8Range::new(start[0], end[0]),
     .          .          .          .                           Utf8Range::new(start[1], end[1]),
     .          .          .          .                           Utf8Range::new(start[2], end[2]),
   902 ( 0.00%) .          .          .                       ]),
 6,381 ( 0.00%) .          .          .                       4 => Utf8Sequence::Four([
     .          .          .          .                           Utf8Range::new(start[0], end[0]),
     .          .          .          .                           Utf8Range::new(start[1], end[1]),
     .          .          .          .                           Utf8Range::new(start[2], end[2]),
     .          .          .          .                           Utf8Range::new(start[3], end[3]),
     .          .          .          .                       ]),
     .          .          .          .                       n => unreachable!("invalid encoded length: {}", n),
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the underlying sequence of byte ranges as a slice.
     .          .          .          .               pub fn as_slice(&self) -> &[Utf8Range] {
     .          .          .          .                   use self::Utf8Sequence::*;
11,390 ( 0.00%) .          .          .                   match *self {
     .          .          .          .                       One(ref r) => slice::from_ref(r),
     .          .          .          .                       Two(ref r) => &r[..],
     .          .          .          .                       Three(ref r) => &r[..],
     .          .          .          .                       Four(ref r) => &r[..],
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// Returns the number of byte ranges in this sequence.
-- line 146 ----------------------------------------
-- line 296 ----------------------------------------
     .          .          .          .           #[derive(Debug)]
     .          .          .          .           pub struct Utf8Sequences {
     .          .          .          .               range_stack: Vec<ScalarRange>,
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl Utf8Sequences {
     .          .          .          .               /// Create a new iterator over UTF-8 byte ranges for the scalar value range
     .          .          .          .               /// given.
 8,316 ( 0.00%) .          .          .               pub fn new(start: char, end: char) -> Self {
     .          .          .          .                   let range =
     .          .          .          .                       ScalarRange { start: u32::from(start), end: u32::from(end) };
 6,930 ( 0.00%) .          .          .                   Utf8Sequences { range_stack: vec![range] }
 6,930 ( 0.00%) .          .          .               }
     .          .          .          .           
     .          .          .          .               /// reset resets the scalar value range.
     .          .          .          .               /// Any existing state is cleared, but resources may be reused.
     .          .          .          .               ///
     .          .          .          .               /// N.B. Benchmarks say that this method is dubious.
     .          .          .          .               #[doc(hidden)]
     .          .          .          .               pub fn reset(&mut self, start: char, end: char) {
     .          .          .          .                   self.range_stack.clear();
-- line 316 ----------------------------------------
-- line 331 ----------------------------------------
     .          .          .          .               fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
     .          .          .          .                   write!(f, "ScalarRange({:X}, {:X})", self.start, self.end)
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl Iterator for Utf8Sequences {
     .          .          .          .               type Item = Utf8Sequence;
     .          .          .          .           
30,048 ( 0.01%) .          .          .               fn next(&mut self) -> Option<Self::Item> {
     .          .          .          .                   'TOP: while let Some(mut r) = self.range_stack.pop() {
     .          .          .          .                       'INNER: loop {
     .          .          .          .                           if let Some((r1, r2)) = r.split() {
     .          .          .          .                               self.push(r2.start, r2.end);
     .          .          .          .                               r.start = r1.start;
     .          .          .          .                               r.end = r1.end;
     .          .          .          .                               continue 'INNER;
     .          .          .          .                           }
 3,231 ( 0.00%) .          .          .                           if !r.is_valid() {
     .          .          .          .                               continue 'TOP;
     .          .          .          .                           }
     .          .          .          .                           for i in 1..MAX_UTF8_BYTES {
     .          .          .          .                               let max = max_scalar_value(i);
16,649 ( 0.00%) .          .          .                               if r.start <= max && max < r.end {
     .          .          .          .                                   self.push(max + 1, r.end);
     .          .          .          .                                   r.end = max;
     .          .          .          .                                   continue 'INNER;
     .          .          .          .                               }
     .          .          .          .                           }
 2,862 ( 0.00%) .          .          .                           if let Some(ascii_range) = r.as_ascii() {
 1,698 ( 0.00%) .          .          .                               return Some(Utf8Sequence::One(ascii_range));
     .          .          .          .                           }
     .          .          .          .                           for i in 1..MAX_UTF8_BYTES {
     .          .          .          .                               let m = (1 << (6 * i)) - 1;
26,568 ( 0.01%) .          .          .                               if (r.start & !m) != (r.end & !m) {
 2,952 ( 0.00%) .          .          .                                   if (r.start & m) != 0 {
   492 ( 0.00%) .          .          .                                       self.push((r.start | m) + 1, r.end);
     .          .          .          .                                       r.end = r.start | m;
     .          .          .          .                                       continue 'INNER;
     .          .          .          .                                   }
10,947 ( 0.00%) .          .          .                                   if (r.end & m) != m {
     .          .          .          .                                       self.push(r.end & !m, r.end);
   246 ( 0.00%) .          .          .                                       r.end = (r.end & !m) - 1;
     .          .          .          .                                       continue 'INNER;
     .          .          .          .                                   }
     .          .          .          .                               }
     .          .          .          .                           }
     .          .          .          .                           let mut start = [0; MAX_UTF8_BYTES];
     .          .          .          .                           let mut end = [0; MAX_UTF8_BYTES];
     .          .          .          .                           let n = r.encode(&mut start, &mut end);
30,668 ( 0.01%) .          .          .                           return Some(Utf8Sequence::from_encoded_range(
     .          .          .          .                               &start[0..n],
     .          .          .          .                               &end[0..n],
     .          .          .          .                           ));
     .          .          .          .                       }
     .          .          .          .                   }
 2,772 ( 0.00%) .          .          .                   None
30,048 ( 0.01%) .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           impl FusedIterator for Utf8Sequences {}
     .          .          .          .           
     .          .          .          .           impl ScalarRange {
     .          .          .          .               /// split splits this range if it overlaps with a surrogate codepoint.
     .          .          .          .               ///
     .          .          .          .               /// Either or both ranges may be invalid.
     .          .          .          .               fn split(&self) -> Option<(ScalarRange, ScalarRange)> {
 7,640 ( 0.00%) .          .          .                   if self.start < 0xE000 && self.end > 0xD7FF {
     .          .          .          .                       Some((
     .          .          .          .                           ScalarRange { start: self.start, end: 0xD7FF },
     .          .          .          .                           ScalarRange { start: 0xE000, end: self.end },
     .          .          .          .                       ))
     .          .          .          .                   } else {
     .          .          .          .                       None
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// is_valid returns true if and only if start <= end.
     .          .          .          .               fn is_valid(&self) -> bool {
 3,231 ( 0.00%) .          .          .                   self.start <= self.end
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               /// as_ascii returns this range as a Utf8Range if and only if all scalar
     .          .          .          .               /// values in this range can be encoded as a single byte.
     .          .          .          .               fn as_ascii(&self) -> Option<Utf8Range> {
     .          .          .          .                   if self.is_ascii() {
     .          .          .          .                       let start = u8::try_from(self.start).unwrap();
     .          .          .          .                       let end = u8::try_from(self.end).unwrap();
-- line 417 ----------------------------------------
-- line 432 ----------------------------------------
     .          .          .          .               /// bytes written.
     .          .          .          .               ///
     .          .          .          .               /// The slices should have room for at least `MAX_UTF8_BYTES`.
     .          .          .          .               fn encode(&self, start: &mut [u8], end: &mut [u8]) -> usize {
     .          .          .          .                   let cs = char::from_u32(self.start).unwrap();
     .          .          .          .                   let ce = char::from_u32(self.end).unwrap();
     .          .          .          .                   let ss = cs.encode_utf8(start);
     .          .          .          .                   let se = ce.encode_utf8(end);
 3,608 ( 0.00%) .          .          .                   assert_eq!(ss.len(), se.len());
     .          .          .          .                   ss.len()
     .          .          .          .               }
     .          .          .          .           }
     .          .          .          .           
     .          .          .          .           fn max_scalar_value(nbytes: usize) -> u32 {
     .          .          .          .               match nbytes {
     .          .          .          .                   1 => 0x007F,
     .          .          .          .                   2 => 0x07FF,
-- line 448 ----------------------------------------

46,533 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-syntax-0.8.5/src/utf8.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs
--------------------------------------------------------------------------------
Ir                 Ge sysCount sysTime 

-- line 415 ----------------------------------------
        .          .          .          .               /// let mut vec: Vec<i32> = Vec::new();
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[rustc_const_stable(feature = "const_vec_new", since = "1.39.0")]
        .          .          .          .               #[cfg_attr(not(test), rustc_diagnostic_item = "vec_new")]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[must_use]
        .          .          .          .               pub const fn new() -> Self {
  121,017 ( 0.04%) .          .          .                   Vec { buf: RawVec::new(), len: 0 }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Constructs a new, empty `Vec<T>` with at least the specified capacity.
        .          .          .          .               ///
        .          .          .          .               /// The vector will be able to hold at least `capacity` elements without
        .          .          .          .               /// reallocating. This method is allowed to allocate for more elements than
        .          .          .          .               /// `capacity`. If `capacity` is zero, the vector will not allocate.
        .          .          .          .               ///
-- line 431 ----------------------------------------
-- line 795 ----------------------------------------
        .          .          .          .               /// let vec_units = Vec::<(), System>::with_capacity_in(10, System);
        .          .          .          .               /// assert_eq!(vec_units.capacity(), usize::MAX);
        .          .          .          .               /// ```
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[inline]
        .          .          .          .               #[unstable(feature = "allocator_api", issue = "32838")]
        .          .          .          .               #[track_caller]
        .          .          .          .               pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {
   18,455 ( 0.01%) .          .          .                   Vec { buf: RawVec::with_capacity_in(capacity, alloc), len: 0 }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Constructs a new, empty `Vec<T, A>` with at least the specified capacity
        .          .          .          .               /// with the provided allocator.
        .          .          .          .               ///
        .          .          .          .               /// The vector will be able to hold at least `capacity` elements without
        .          .          .          .               /// reallocating. This method is allowed to allocate for more elements than
        .          .          .          .               /// `capacity`. If `capacity` is zero, the vector will not allocate.
-- line 811 ----------------------------------------
-- line 927 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               ///     assert_eq!(vec, &[1_000_000]);
        .          .          .          .               ///     assert_eq!(vec.capacity(), 16);
        .          .          .          .               /// }
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[unstable(feature = "allocator_api", issue = "32838")]
        .          .          .          .               pub unsafe fn from_raw_parts_in(ptr: *mut T, length: usize, capacity: usize, alloc: A) -> Self {
    7,946 ( 0.00%) .          .          .                   unsafe { Vec { buf: RawVec::from_raw_parts_in(ptr, capacity, alloc), len: length } }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[doc(alias = "from_non_null_parts_in")]
        .          .          .          .               /// Creates a `Vec<T, A>` directly from a `NonNull` pointer, a length, a capacity,
        .          .          .          .               /// and an allocator.
        .          .          .          .               ///
        .          .          .          .               /// # Safety
        .          .          .          .               ///
-- line 943 ----------------------------------------
-- line 1043 ----------------------------------------
        .          .          .          .               ///     assert_eq!(vec, &[1_000_000]);
        .          .          .          .               ///     assert_eq!(vec.capacity(), 16);
        .          .          .          .               /// }
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[unstable(feature = "allocator_api", reason = "new API", issue = "32838")]
        .          .          .          .               // #[unstable(feature = "box_vec_non_null", issue = "130364")]
        .          .          .          .               pub unsafe fn from_parts_in(ptr: NonNull<T>, length: usize, capacity: usize, alloc: A) -> Self {
   11,961 ( 0.00%) .          .          .                   unsafe { Vec { buf: RawVec::from_nonnull_in(ptr, capacity, alloc), len: length } }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Decomposes a `Vec<T>` into its raw components: `(pointer, length, capacity)`.
        .          .          .          .               ///
        .          .          .          .               /// Returns the raw pointer to the underlying data, the length of
        .          .          .          .               /// the vector (in elements), and the allocated capacity of the
        .          .          .          .               /// data (in elements). These are the same arguments in the same
        .          .          .          .               /// order as the arguments to [`from_raw_parts`].
-- line 1059 ----------------------------------------
-- line 1263 ----------------------------------------
        .          .          .          .               /// let mut vec = vec![1];
        .          .          .          .               /// vec.reserve(10);
        .          .          .          .               /// assert!(vec.capacity() >= 11);
        .          .          .          .               /// ```
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[track_caller]
        .          .          .          .               pub fn reserve(&mut self, additional: usize) {
   53,494 ( 0.02%) .          .          .                   self.buf.reserve(self.len, additional);
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Reserves the minimum capacity for at least `additional` more elements to
        .          .          .          .               /// be inserted in the given `Vec<T>`. Unlike [`reserve`], this will not
        .          .          .          .               /// deliberately over-allocate to speculatively avoid frequent allocations.
        .          .          .          .               /// After calling `reserve_exact`, capacity will be greater than or equal to
        .          .          .          .               /// `self.len() + additional`. Does nothing if the capacity is already
        .          .          .          .               /// sufficient.
-- line 1279 ----------------------------------------
-- line 1402 ----------------------------------------
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[track_caller]
        .          .          .          .               #[inline]
        .          .          .          .               pub fn shrink_to_fit(&mut self) {
        .          .          .          .                   // The capacity is never less than the length, and there's nothing to do when
        .          .          .          .                   // they are equal, so we can avoid the panic case in `RawVec::shrink_to_fit`
        .          .          .          .                   // by only calling it with a greater capacity.
   87,418 ( 0.03%) .          .          .                   if self.capacity() > self.len {
        .          .          .          .                       self.buf.shrink_to_fit(self.len);
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Shrinks the capacity of the vector with a lower bound.
        .          .          .          .               ///
        .          .          .          .               /// The capacity will remain at least as large as both the length
        .          .          .          .               /// and the supplied value.
-- line 1418 ----------------------------------------
-- line 1465 ----------------------------------------
        .          .          .          .               /// assert_eq!(slice.into_vec().capacity(), 3);
        .          .          .          .               /// ```
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[track_caller]
        .          .          .          .               pub fn into_boxed_slice(mut self) -> Box<[T], A> {
        .          .          .          .                   unsafe {
        .          .          .          .                       self.shrink_to_fit();
   15,992 ( 0.00%) .          .          .                       let me = ManuallyDrop::new(self);
        .          .          .          .                       let buf = ptr::read(&me.buf);
        .          .          .          .                       let len = me.len();
        .          .          .          .                       buf.into_box(len).assume_init()
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Shortens the vector, keeping the first `len` elements and dropping
        .          .          .          .               /// the rest.
-- line 1481 ----------------------------------------
-- line 1527 ----------------------------------------
        .          .          .          .                   //   case avoids creating an invalid slice, and
        .          .          .          .                   // * the `len` of the vector is shrunk before calling `drop_in_place`,
        .          .          .          .                   //   such that no value will be dropped twice in case `drop_in_place`
        .          .          .          .                   //   were to panic once (if it panics twice, the program aborts).
        .          .          .          .                   unsafe {
        .          .          .          .                       // Note: It's intentional that this is `>` and not `>=`.
        .          .          .          .                       //       Changing it to `>=` has negative performance
        .          .          .          .                       //       implications in some cases. See #78884 for more.
       15 ( 0.00%) .          .          .                       if len > self.len {
        .          .          .          .                           return;
        .          .          .          .                       }
        .          .          .          .                       let remaining_len = self.len - len;
        .          .          .          .                       let s = ptr::slice_from_raw_parts_mut(self.as_mut_ptr().add(len), remaining_len);
    5,946 ( 0.00%) .          .          .                       self.len = len;
        .          .          .          .                       ptr::drop_in_place(s);
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Extracts a slice containing the entire vector.
        .          .          .          .               ///
        .          .          .          .               /// Equivalent to `&s[..]`.
        .          .          .          .               ///
-- line 1548 ----------------------------------------
-- line 1566 ----------------------------------------
        .          .          .          .                   // * Vec API guarantees that self.buf:
        .          .          .          .                   //      * contains only properly-initialized items within 0..len
        .          .          .          .                   //      * is aligned, contiguous, and valid for `len` reads
        .          .          .          .                   //      * obeys size and address-wrapping constraints
        .          .          .          .                   //
        .          .          .          .                   // * We only construct `&mut` references to `self.buf` through `&mut self` methods; borrow-
        .          .          .          .                   //   check ensures that it is not possible to mutably alias `self.buf` within the
        .          .          .          .                   //   returned lifetime.
  493,855 ( 0.15%) .          .          .                   unsafe { slice::from_raw_parts(self.as_ptr(), self.len) }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Extracts a mutable slice of the entire vector.
        .          .          .          .               ///
        .          .          .          .               /// Equivalent to `&mut s[..]`.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
-- line 1582 ----------------------------------------
-- line 1598 ----------------------------------------
        .          .          .          .                   // * Vec API guarantees that self.buf:
        .          .          .          .                   //      * contains only properly-initialized items within 0..len
        .          .          .          .                   //      * is aligned, contiguous, and valid for `len` reads
        .          .          .          .                   //      * obeys size and address-wrapping constraints
        .          .          .          .                   //
        .          .          .          .                   // * We only construct references to `self.buf` through `&self` and `&mut self` methods;
        .          .          .          .                   //   borrow-check ensures that it is not possible to construct a reference to `self.buf`
        .          .          .          .                   //   within the returned lifetime.
  341,948 ( 0.10%) .          .          .                   unsafe { slice::from_raw_parts_mut(self.as_mut_ptr(), self.len) }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns a raw pointer to the vector's buffer, or a dangling raw pointer
        .          .          .          .               /// valid for zero sized reads if the vector didn't allocate.
        .          .          .          .               ///
        .          .          .          .               /// The caller must ensure that the vector outlives the pointer this
        .          .          .          .               /// function returns, or else it will end up dangling.
        .          .          .          .               /// Modifying the vector may cause its buffer to be reallocated,
-- line 1614 ----------------------------------------
-- line 1889 ----------------------------------------
        .          .          .          .               /// the contents and thus not leak memory.
        .          .          .          .               ///
        .          .          .          .               /// [`spare_capacity_mut()`]: Vec::spare_capacity_mut
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               pub unsafe fn set_len(&mut self, new_len: usize) {
        .          .          .          .                   debug_assert!(new_len <= self.capacity());
        .          .          .          .           
  169,725 ( 0.05%) .          .          .                   self.len = new_len;
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Removes an element from the vector and returns it.
        .          .          .          .               ///
        .          .          .          .               /// The removed element is replaced by the last element of the vector.
        .          .          .          .               ///
        .          .          .          .               /// This does not preserve ordering of the remaining elements, but is *O*(1).
        .          .          .          .               /// If you need to preserve the element order, use [`remove`] instead.
-- line 1905 ----------------------------------------
-- line 1978 ----------------------------------------
        .          .          .          .                   #[cfg_attr(not(feature = "panic_immediate_abort"), inline(never))]
        .          .          .          .                   #[track_caller]
        .          .          .          .                   #[optimize(size)]
        .          .          .          .                   fn assert_failed(index: usize, len: usize) -> ! {
        .          .          .          .                       panic!("insertion index (is {index}) should be <= len (is {len})");
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   let len = self.len();
  120,756 ( 0.04%) .          .          .                   if index > len {
        .          .          .          .                       assert_failed(index, len);
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   // space for the new element
  120,766 ( 0.04%) .          .          .                   if len == self.buf.capacity() {
  133,962 ( 0.04%) .          .          .                       self.buf.grow_one();
   57,190 ( 0.02%) 164 ( 0.02%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (162x)
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   unsafe {
        .          .          .          .                       // infallible
        .          .          .          .                       // The spot to put the new value
        .          .          .          .                       {
        .          .          .          .                           let p = self.as_mut_ptr().add(index);
  181,139 ( 0.05%) .          .          .                           if index < len {
        .          .          .          .                               // Shift everything over to make space. (Duplicating the
        .          .          .          .                               // `index`th element into two consecutive places.)
        .          .          .          .                               ptr::copy(p, p.add(1), len - index);
        .          .          .          .                           }
        .          .          .          .                           // Write it in, overwriting the first copy of the `index`th
        .          .          .          .                           // element.
        .          .          .          .                           ptr::write(p, element);
        .          .          .          .                       }
   60,383 ( 0.02%) .          .          .                       self.set_len(len + 1);
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Removes and returns the element at position `index` within the vector,
        .          .          .          .               /// shifting all elements after it to the left.
        .          .          .          .               ///
        .          .          .          .               /// Note: Because this shifts over the remaining elements, it has a
        .          .          .          .               /// worst-case performance of *O*(*n*). If you don't need the order of elements
-- line 2017 ----------------------------------------
-- line 2041 ----------------------------------------
        .          .          .          .                   #[cfg_attr(not(feature = "panic_immediate_abort"), inline(never))]
        .          .          .          .                   #[track_caller]
        .          .          .          .                   #[optimize(size)]
        .          .          .          .                   fn assert_failed(index: usize, len: usize) -> ! {
        .          .          .          .                       panic!("removal index (is {index}) should be < len (is {len})");
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   let len = self.len();
       94 ( 0.00%) .          .          .                   if index >= len {
        .          .          .          .                       assert_failed(index, len);
        .          .          .          .                   }
        .          .          .          .                   unsafe {
        .          .          .          .                       // infallible
        .          .          .          .                       let ret;
        .          .          .          .                       {
        .          .          .          .                           // the place we are taking from.
        .          .          .          .                           let ptr = self.as_mut_ptr().add(index);
        .          .          .          .                           // copy it out, unsafely having a copy of the value on
        .          .          .          .                           // the stack and in the vector at the same time.
        .          .          .          .                           ret = ptr::read(ptr);
        .          .          .          .           
        .          .          .          .                           // Shift everything down to fill in that spot.
       76 ( 0.00%) .          .          .                           ptr::copy(ptr.add(1), ptr, len - index - 1);
        .          .          .          .                       }
       38 ( 0.00%) .          .          .                       self.set_len(len - 1);
        .          .          .          .                       ret
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Retains only the elements specified by the predicate.
        .          .          .          .               ///
        .          .          .          .               /// In other words, remove all elements `e` for which `f(&e)` returns `false`.
        .          .          .          .               /// This method operates in place, visiting each element exactly once in the
-- line 2073 ----------------------------------------
-- line 2113 ----------------------------------------
        .          .          .          .               ///     *x += 1;
        .          .          .          .               ///     true
        .          .          .          .               /// } else {
        .          .          .          .               ///     false
        .          .          .          .               /// });
        .          .          .          .               /// assert_eq!(vec, [2, 3, 4]);
        .          .          .          .               /// ```
        .          .          .          .               #[stable(feature = "vec_retain_mut", since = "1.61.0")]
    1,239 ( 0.00%) .          .          .               pub fn retain_mut<F>(&mut self, mut f: F)
        .          .          .          .               where
        .          .          .          .                   F: FnMut(&mut T) -> bool,
        .          .          .          .               {
        .          .          .          .                   let original_len = self.len();
        .          .          .          .           
      354 ( 0.00%) .          .          .                   if original_len == 0 {
        .          .          .          .                       // Empty case: explicit return allows better optimization, vs letting compiler infer it
        .          .          .          .                       return;
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   // Avoid double drop if the drop guard is not executed,
        .          .          .          .                   // since we may make some holes during the process.
        .          .          .          .                   unsafe { self.set_len(0) };
        .          .          .          .           
-- line 2135 ----------------------------------------
-- line 2160 ----------------------------------------
        .          .          .          .                                       self.v.as_ptr().add(self.processed_len),
        .          .          .          .                                       self.v.as_mut_ptr().add(self.processed_len - self.deleted_cnt),
        .          .          .          .                                       self.original_len - self.processed_len,
        .          .          .          .                                   );
        .          .          .          .                               }
        .          .          .          .                           }
        .          .          .          .                           // SAFETY: After filling holes, all items are in contiguous memory.
        .          .          .          .                           unsafe {
      177 ( 0.00%) .          .          .                               self.v.set_len(self.original_len - self.deleted_cnt);
        .          .          .          .                           }
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   let mut g = BackshiftOnDrop { v: self, processed_len: 0, deleted_cnt: 0, original_len };
        .          .          .          .           
        .          .          .          .                   fn process_loop<F, T, A: Allocator, const DELETED: bool>(
        .          .          .          .                       original_len: usize,
        .          .          .          .                       f: &mut F,
        .          .          .          .                       g: &mut BackshiftOnDrop<'_, T, A>,
        .          .          .          .                   ) where
        .          .          .          .                       F: FnMut(&mut T) -> bool,
        .          .          .          .                   {
   64,816 ( 0.02%) .          .          .                       while g.processed_len != original_len {
        .          .          .          .                           // SAFETY: Unchecked element must be valid.
        .          .          .          .                           let cur = unsafe { &mut *g.v.as_mut_ptr().add(g.processed_len) };
   33,756 ( 0.01%) .          .          .                           if !f(cur) {
        .          .          .          .                               // Advance early to avoid double drop if `drop_in_place` panicked.
        .          .          .          .                               g.processed_len += 1;
    2,559 ( 0.00%) .          .          .                               g.deleted_cnt += 1;
        .          .          .          .                               // SAFETY: We never touch this element again after dropped.
        .          .          .          .                               unsafe { ptr::drop_in_place(cur) };
        .          .          .          .                               // We already advanced the counter.
        .          .          .          .                               if DELETED {
        .          .          .          .                                   continue;
        .          .          .          .                               } else {
        .          .          .          .                                   break;
        .          .          .          .                               }
-- line 2196 ----------------------------------------
-- line 2210 ----------------------------------------
        .          .          .          .                   // Stage 1: Nothing was deleted.
        .          .          .          .                   process_loop::<F, T, A, false>(original_len, &mut f, &mut g);
        .          .          .          .           
        .          .          .          .                   // Stage 2: Some elements were deleted.
        .          .          .          .                   process_loop::<F, T, A, true>(original_len, &mut f, &mut g);
        .          .          .          .           
        .          .          .          .                   // All item are processed. This can be optimized to `set_len` by LLVM.
        .          .          .          .                   drop(g);
    1,416 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Removes all but the first of consecutive elements in the vector that resolve to the same
        .          .          .          .               /// key.
        .          .          .          .               ///
        .          .          .          .               /// If the vector is sorted, this removes all duplicates.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
        .          .          .          .               ///
-- line 2226 ----------------------------------------
-- line 2255 ----------------------------------------
        .          .          .          .               /// ```
        .          .          .          .               /// let mut vec = vec!["foo", "bar", "Bar", "baz", "bar"];
        .          .          .          .               ///
        .          .          .          .               /// vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));
        .          .          .          .               ///
        .          .          .          .               /// assert_eq!(vec, ["foo", "bar", "baz", "bar"]);
        .          .          .          .               /// ```
        .          .          .          .               #[stable(feature = "dedup_by", since = "1.16.0")]
   20,258 ( 0.01%) .          .          .               pub fn dedup_by<F>(&mut self, mut same_bucket: F)
        .          .          .          .               where
        .          .          .          .                   F: FnMut(&mut T, &mut T) -> bool,
        .          .          .          .               {
        .          .          .          .                   let len = self.len();
    5,788 ( 0.00%) .          .          .                   if len <= 1 {
        .          .          .          .                       return;
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   // Check if we ever want to remove anything.
        .          .          .          .                   // This allows to use copy_non_overlapping in next cycle.
        .          .          .          .                   // And avoids any memory writes if we don't need to remove anything.
        .          .          .          .                   let mut first_duplicate_idx: usize = 1;
        .          .          .          .                   let start = self.as_mut_ptr();
  263,616 ( 0.08%) .          .          .                   while first_duplicate_idx != len {
        .          .          .          .                       let found_duplicate = unsafe {
        .          .          .          .                           // SAFETY: first_duplicate always in range [1..len)
        .          .          .          .                           // Note that we start iteration from 1 so we never overflow.
        .          .          .          .                           let prev = start.add(first_duplicate_idx.wrapping_sub(1));
        .          .          .          .                           let current = start.add(first_duplicate_idx);
        .          .          .          .                           // We explicitly say in docs that references are reversed.
        .          .          .          .                           same_bucket(&mut *current, &mut *prev)
        .          .          .          .                       };
        .          .          .          .                       if found_duplicate {
        .          .          .          .                           break;
        .          .          .          .                       }
   85,192 ( 0.03%) .          .          .                       first_duplicate_idx += 1;
        .          .          .          .                   }
        .          .          .          .                   // Don't need to remove anything.
        .          .          .          .                   // We cannot get bigger than len.
        .          .          .          .                   if first_duplicate_idx == len {
        .          .          .          .                       return;
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   /* INVARIANT: vec.len() > read > write > write-1 >= 0 */
-- line 2297 ----------------------------------------
-- line 2381 ----------------------------------------
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       /* Technically we could let `gap` clean up with its Drop, but
        .          .          .          .                        * when `same_bucket` is guaranteed to not panic, this bloats a little
        .          .          .          .                        * the codegen, so we just do it manually */
        .          .          .          .                       gap.vec.set_len(gap.write);
        .          .          .          .                       mem::forget(gap);
        .          .          .          .                   }
   23,152 ( 0.01%) .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Appends an element to the back of a collection.
        .          .          .          .               ///
        .          .          .          .               /// # Panics
        .          .          .          .               ///
        .          .          .          .               /// Panics if the new capacity exceeds `isize::MAX` _bytes_.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
-- line 2397 ----------------------------------------
-- line 2410 ----------------------------------------
        .          .          .          .               /// offset by the *capacity* *O*(1) insertions it allows.
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[rustc_confusables("push_back", "put", "append")]
        .          .          .          .               #[track_caller]
        .          .          .          .               pub fn push(&mut self, value: T) {
        .          .          .          .                   // Inform codegen that the length does not change across grow_one().
  464,279 ( 0.14%) .          .          .                   let len = self.len;
        .          .          .          .                   // This will panic or abort if we would allocate > isize::MAX bytes
        .          .          .          .                   // or if the length increment would overflow for zero-sized types.
1,734,801 ( 0.52%) .          .          .                   if len == self.buf.capacity() {
  556,137 ( 0.17%) .          .          .                       self.buf.grow_one();
   49,737 ( 0.01%) 229 ( 0.03%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (123x)
        .          .          .          .                   }
        .          .          .          .                   unsafe {
        .          .          .          .                       let end = self.as_mut_ptr().add(len);
        .          .          .          .                       ptr::write(end, value);
1,875,470 ( 0.56%) .          .          .                       self.len = len + 1;
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Appends an element if there is sufficient spare capacity, otherwise an error is returned
        .          .          .          .               /// with the element.
        .          .          .          .               ///
        .          .          .          .               /// Unlike [`push`] this method will not reallocate when there's insufficient capacity.
        .          .          .          .               /// The caller should use [`reserve`] or [`try_reserve`] to ensure that there is enough capacity.
-- line 2435 ----------------------------------------
-- line 2495 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// # Time complexity
        .          .          .          .               ///
        .          .          .          .               /// Takes *O*(1) time.
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[cfg_attr(not(test), rustc_diagnostic_item = "vec_pop")]
        .          .          .          .               pub fn pop(&mut self) -> Option<T> {
1,141,944 ( 0.34%) .          .          .                   if self.len == 0 {
        .          .          .          .                       None
        .          .          .          .                   } else {
        .          .          .          .                       unsafe {
  753,376 ( 0.23%) .          .          .                           self.len -= 1;
        .          .          .          .                           core::hint::assert_unchecked(self.len < self.capacity());
    4,294 ( 0.00%) .          .          .                           Some(ptr::read(self.as_ptr().add(self.len())))
   15,360 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (512x)
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Removes and returns the last element in a vector if the predicate
        .          .          .          .               /// returns `true`, or [`None`] if the predicate returns false or the vector
        .          .          .          .               /// is empty.
        .          .          .          .               ///
-- line 2517 ----------------------------------------
-- line 2566 ----------------------------------------
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
        .          .          .          .               unsafe fn append_elements(&mut self, other: *const [T]) {
        .          .          .          .                   let count = unsafe { (*other).len() };
        .          .          .          .                   self.reserve(count);
        .          .          .          .                   let len = self.len();
        .          .          .          .                   unsafe { ptr::copy_nonoverlapping(other as *const T, self.as_mut_ptr().add(len), count) };
   99,899 ( 0.03%) .          .          .                   self.len += count;
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Removes the specified range from the vector in bulk, returning all
        .          .          .          .               /// removed elements as an iterator. If the iterator is dropped before
        .          .          .          .               /// being fully consumed, it drops the remaining removed elements.
        .          .          .          .               ///
        .          .          .          .               /// The returned iterator keeps a mutable borrow on the vector to optimize
        .          .          .          .               /// its implementation.
-- line 2582 ----------------------------------------
-- line 2656 ----------------------------------------
        .          .          .          .           
        .          .          .          .                   // SAFETY:
        .          .          .          .                   // - `elems` comes directly from `as_mut_slice` and is therefore valid.
        .          .          .          .                   // - Setting `self.len` before calling `drop_in_place` means that,
        .          .          .          .                   //   if an element's `Drop` impl panics, the vector's `Drop` impl will
        .          .          .          .                   //   do nothing (leaking the rest of the elements) instead of dropping
        .          .          .          .                   //   some twice.
        .          .          .          .                   unsafe {
    2,462 ( 0.00%) .          .          .                       self.len = 0;
        .          .          .          .                       ptr::drop_in_place(elems);
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Returns the number of elements in the vector, also referred to
        .          .          .          .               /// as its 'length'.
        .          .          .          .               ///
        .          .          .          .               /// # Examples
-- line 2672 ----------------------------------------
-- line 2675 ----------------------------------------
        .          .          .          .               /// let a = vec![1, 2, 3];
        .          .          .          .               /// assert_eq!(a.len(), 3);
        .          .          .          .               /// ```
        .          .          .          .               #[inline]
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[rustc_const_unstable(feature = "const_vec_string_slice", issue = "129041")]
        .          .          .          .               #[rustc_confusables("length", "size")]
        .          .          .          .               pub const fn len(&self) -> usize {
  591,174 ( 0.18%) .          .          .                   let len = self.len;
        .          .          .          .           
        .          .          .          .                   // SAFETY: The maximum capacity of `Vec<T>` is `isize::MAX` bytes, so the maximum value can
        .          .          .          .                   // be returned is `usize::checked_div(mem::size_of::<T>()).unwrap_or(usize::MAX)`, which
        .          .          .          .                   // matches the definition of `T::MAX_SLICE_LEN`.
        .          .          .          .                   unsafe { intrinsics::assume(len <= T::MAX_SLICE_LEN) };
        .          .          .          .           
        .          .          .          .                   len
        .          .          .          .               }
-- line 2691 ----------------------------------------
-- line 2700 ----------------------------------------
        .          .          .          .               ///
        .          .          .          .               /// v.push(1);
        .          .          .          .               /// assert!(!v.is_empty());
        .          .          .          .               /// ```
        .          .          .          .               #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .               #[cfg_attr(not(test), rustc_diagnostic_item = "vec_is_empty")]
        .          .          .          .               #[rustc_const_unstable(feature = "const_vec_string_slice", issue = "129041")]
        .          .          .          .               pub const fn is_empty(&self) -> bool {
    5,892 ( 0.00%) .          .          .                   self.len() == 0
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Splits the collection into two at the given index.
        .          .          .          .               ///
        .          .          .          .               /// Returns a newly allocated vector containing the elements in the range
        .          .          .          .               /// `[at, len)`. After the call, the original vector will be left containing
        .          .          .          .               /// the elements `[0, at)` with its previous capacity unchanged.
        .          .          .          .               ///
-- line 2716 ----------------------------------------
-- line 2744 ----------------------------------------
        .          .          .          .                   #[cold]
        .          .          .          .                   #[cfg_attr(not(feature = "panic_immediate_abort"), inline(never))]
        .          .          .          .                   #[track_caller]
        .          .          .          .                   #[optimize(size)]
        .          .          .          .                   fn assert_failed(at: usize, len: usize) -> ! {
        .          .          .          .                       panic!("`at` split index (is {at}) should be <= len (is {len})");
        .          .          .          .                   }
        .          .          .          .           
       15 ( 0.00%) .          .          .                   if at > self.len() {
        .          .          .          .                       assert_failed(at, self.len());
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   let other_len = self.len - at;
        .          .          .          .                   let mut other = Vec::with_capacity_in(other_len, self.allocator().clone());
        .          .          .          .           
        .          .          .          .                   // Unsafely `set_len` and copy items to `other`.
        .          .          .          .                   unsafe {
        .          .          .          .                       self.set_len(at);
        .          .          .          .                       other.set_len(other_len);
        .          .          .          .           
        .          .          .          .                       ptr::copy_nonoverlapping(self.as_ptr().add(at), other.as_mut_ptr(), other.len());
        .          .          .          .                   }
       54 ( 0.00%) .          .          .                   other
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.
        .          .          .          .               ///
        .          .          .          .               /// If `new_len` is greater than `len`, the `Vec` is extended by the
        .          .          .          .               /// difference, with each additional slot filled with the result of
        .          .          .          .               /// calling the closure `f`. The return values from `f` will end up
        .          .          .          .               /// in the `Vec` in the order they have been generated.
-- line 2774 ----------------------------------------
-- line 2999 ----------------------------------------
        .          .          .          .               /// assert_eq!(vec, ['a', 'b']);
        .          .          .          .               /// ```
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[stable(feature = "vec_resize", since = "1.5.0")]
        .          .          .          .               #[track_caller]
        .          .          .          .               pub fn resize(&mut self, new_len: usize, value: T) {
        .          .          .          .                   let len = self.len();
        .          .          .          .           
    4,584 ( 0.00%) .          .          .                   if new_len > len {
        .          .          .          .                       self.extend_with(new_len - len, value)
        .          .          .          .                   } else {
        .          .          .          .                       self.truncate(new_len);
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               /// Clones and appends all elements in a slice to the `Vec`.
        .          .          .          .               ///
-- line 3015 ----------------------------------------
-- line 3121 ----------------------------------------
        .          .          .          .                   unsafe { Vec::<T, A>::from_raw_parts_in(ptr.cast(), new_len, new_cap, alloc) }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<T: Clone, A: Allocator> Vec<T, A> {
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[track_caller]
        .          .          .          .               /// Extend the vector by `n` clones of value.
      536 ( 0.00%) .          .          .               fn extend_with(&mut self, n: usize, value: T) {
        .          .          .          .                   self.reserve(n);
        .          .          .          .           
        .          .          .          .                   unsafe {
        .          .          .          .                       let mut ptr = self.as_mut_ptr().add(self.len());
        .          .          .          .                       // Use SetLenOnDrop to work around bug where compiler
        .          .          .          .                       // might not realize the store through `ptr` through self.set_len()
        .          .          .          .                       // don't alias.
        .          .          .          .                       let mut local_len = SetLenOnDrop::new(&mut self.len);
        .          .          .          .           
        .          .          .          .                       // Write all elements except the last one
        .          .          .          .                       for _ in 1..n {
      288 ( 0.00%) .          .          .                           ptr::write(ptr, value.clone());
        .          .          .          .                           ptr = ptr.add(1);
        .          .          .          .                           // Increment the length in every step in case clone() panics
        .          .          .          .                           local_len.increment_len(1);
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       if n > 0 {
        .          .          .          .                           // We can write the last element directly without cloning needlessly
        .          .          .          .                           ptr::write(ptr, value);
        .          .          .          .                           local_len.increment_len(1);
        .          .          .          .                       }
        .          .          .          .           
        .          .          .          .                       // len set by scope guard
        .          .          .          .                   }
      536 ( 0.00%) .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           impl<T: PartialEq, A: Allocator> Vec<T, A> {
        .          .          .          .               /// Removes consecutive repeated elements in the vector according to the
        .          .          .          .               /// [`PartialEq`] trait implementation.
        .          .          .          .               ///
        .          .          .          .               /// If the vector is sorted, this removes all duplicates.
        .          .          .          .               ///
-- line 3163 ----------------------------------------
-- line 3182 ----------------------------------------
        .          .          .          .           ////////////////////////////////////////////////////////////////////////////////
        .          .          .          .           
        .          .          .          .           #[doc(hidden)]
        .          .          .          .           #[cfg(not(no_global_oom_handling))]
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           #[cfg_attr(not(test), rustc_diagnostic_item = "vec_from_elem")]
        .          .          .          .           #[track_caller]
        .          .          .          .           pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {
      765 ( 0.00%) .          .          .               <T as SpecFromElem>::from_elem(elem, n, Global)
  156,688 ( 0.05%) 274 ( 0.03%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_elem.rs:<T as alloc::vec::spec_from_elem::SpecFromElem>::from_elem (48x)
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[doc(hidden)]
        .          .          .          .           #[cfg(not(no_global_oom_handling))]
        .          .          .          .           #[unstable(feature = "allocator_api", issue = "32838")]
        .          .          .          .           #[track_caller]
        .          .          .          .           pub fn from_elem_in<T: Clone, A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {
        .          .          .          .               <T as SpecFromElem>::from_elem(elem, n, alloc)
-- line 3198 ----------------------------------------
-- line 3281 ----------------------------------------
        .          .          .          .           #[unstable(feature = "deref_pure_trait", issue = "87121")]
        .          .          .          .           unsafe impl<T, A: Allocator> ops::DerefPure for Vec<T, A> {}
        .          .          .          .           
        .          .          .          .           #[cfg(not(no_global_oom_handling))]
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           impl<T: Clone, A: Allocator + Clone> Clone for Vec<T, A> {
        .          .          .          .               #[cfg(not(test))]
        .          .          .          .               #[track_caller]
      476 ( 0.00%) .          .          .               fn clone(&self) -> Self {
        .          .          .          .                   let alloc = self.allocator().clone();
      444 ( 0.00%) .          .          .                   <[T]>::to_vec_in(&**self, alloc)
      612 ( 0.00%) .          .          .               }
        .          .          .          .           
        .          .          .          .               // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is
        .          .          .          .               // required for this method definition, is not available. Instead use the
        .          .          .          .               // `slice::to_vec` function which is only available with cfg(test)
        .          .          .          .               // NB see the slice::hack module in slice.rs for more information
        .          .          .          .               #[cfg(test)]
        .          .          .          .               fn clone(&self) -> Self {
        .          .          .          .                   let alloc = self.allocator().clone();
-- line 3300 ----------------------------------------
-- line 3419 ----------------------------------------
        .          .          .          .           /// }
        .          .          .          .           /// ```
        .          .          .          .           #[cfg(not(no_global_oom_handling))]
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           impl<T> FromIterator<T> for Vec<T> {
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
        .          .          .          .               fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Vec<T> {
   12,653 ( 0.00%) .          .          .                   <Self as SpecFromIter<T, I::IntoIter>>::from_iter(iter.into_iter())
   34,740 ( 0.01%) .          .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,alloc::vec::into_iter::IntoIter<T>>>::from_iter (1,158x)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           impl<T, A: Allocator> IntoIterator for Vec<T, A> {
        .          .          .          .               type Item = T;
        .          .          .          .               type IntoIter = IntoIter<T, A>;
        .          .          .          .           
-- line 3435 ----------------------------------------
-- line 3457 ----------------------------------------
        .          .          .          .                       let buf = me.buf.non_null();
        .          .          .          .                       let begin = buf.as_ptr();
        .          .          .          .                       let end = if T::IS_ZST {
        .          .          .          .                           begin.wrapping_byte_add(me.len())
        .          .          .          .                       } else {
        .          .          .          .                           begin.add(me.len()) as *const T
        .          .          .          .                       };
        .          .          .          .                       let cap = me.buf.capacity();
       12 ( 0.00%) .          .          .                       IntoIter { buf, phantom: PhantomData, cap, alloc, ptr: buf, end }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           impl<'a, T, A: Allocator> IntoIterator for &'a Vec<T, A> {
        .          .          .          .               type Item = &'a T;
        .          .          .          .               type IntoIter = slice::Iter<'a, T>;
-- line 3473 ----------------------------------------
-- line 3488 ----------------------------------------
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[cfg(not(no_global_oom_handling))]
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           impl<T, A: Allocator> Extend<T> for Vec<T, A> {
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
        .          .          .          .               fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
   12,323 ( 0.00%) .          .          .                   <Self as SpecExtend<T, I::IntoIter>>::spec_extend(self, iter.into_iter())
  575,612 ( 0.17%) 1,100 ( 0.14%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_extend.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend (2,443x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
        .          .          .          .               fn extend_one(&mut self, item: T) {
        .          .          .          .                   self.push(item);
        .          .          .          .               }
        .          .          .          .           
-- line 3504 ----------------------------------------
-- line 3527 ----------------------------------------
        .          .          .          .               fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {
        .          .          .          .                   // This is the case for a general iterator.
        .          .          .          .                   //
        .          .          .          .                   // This function should be the moral equivalent of:
        .          .          .          .                   //
        .          .          .          .                   //      for item in iterator {
        .          .          .          .                   //          self.push(item);
        .          .          .          .                   //      }
      116 ( 0.00%) .          .          .                   while let Some(element) = iterator.next() {
      135 ( 0.00%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/clap_builder-4.5.48/src/parser/matches/arg_matches.rs:<clap_builder::parser::matches::arg_matches::Values<T> as core::iter::traits::iterator::Iterator>::next (1x)
        .          .          .          .                       let len = self.len();
    2,138 ( 0.00%) .          .          .                       if len == self.capacity() {
        2 ( 0.00%) .          .          .                           let (lower, _) = iterator.size_hint();
        .          .          .          .                           self.reserve(lower.saturating_add(1));
        .          .          .          .                       }
        .          .          .          .                       unsafe {
        .          .          .          .                           ptr::write(self.as_mut_ptr().add(len), element);
        .          .          .          .                           // Since next() executes user code which can panic we have to bump the length
        .          .          .          .                           // after each step.
        .          .          .          .                           // NB can't overflow since we would have had to alloc the address space
    1,069 ( 0.00%) .          .          .                           self.set_len(len + 1);
        .          .          .          .                       }
        .          .          .          .                   }
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               // specific extend for `TrustedLen` iterators, called both by the specializations
        .          .          .          .               // and internal places where resolving specialization makes compilation slower
        .          .          .          .               #[cfg(not(no_global_oom_handling))]
        .          .          .          .               #[track_caller]
-- line 3554 ----------------------------------------
-- line 3560 ----------------------------------------
        .          .          .          .                           additional,
        .          .          .          .                           "TrustedLen iterator's size hint is not exact: {:?}",
        .          .          .          .                           (low, high)
        .          .          .          .                       );
        .          .          .          .                       self.reserve(additional);
        .          .          .          .                       unsafe {
        .          .          .          .                           let ptr = self.as_mut_ptr();
        .          .          .          .                           let mut local_len = SetLenOnDrop::new(&mut self.len);
  102,244 ( 0.03%) .          .          .                           iterator.for_each(move |element| {
        .          .          .          .                               ptr::write(ptr.add(local_len.current_len()), element);
        .          .          .          .                               // Since the loop executes user code which can panic we have to update
        .          .          .          .                               // the length every step to correctly drop what we've written.
        .          .          .          .                               // NB can't overflow since we would have had to alloc the address space
        .          .          .          .                               local_len.increment_len(1);
        .          .          .          .                           });
        .          .          .          .                       }
        .          .          .          .                   } else {
-- line 3576 ----------------------------------------
-- line 3712 ----------------------------------------
        .          .          .          .           /// append the entire slice at once.
        .          .          .          .           ///
        .          .          .          .           /// [`copy_from_slice`]: slice::copy_from_slice
        .          .          .          .           #[cfg(not(no_global_oom_handling))]
        .          .          .          .           #[stable(feature = "extend_ref", since = "1.2.0")]
        .          .          .          .           impl<'a, T: Copy + 'a, A: Allocator> Extend<&'a T> for Vec<T, A> {
        .          .          .          .               #[track_caller]
        .          .          .          .               fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {
       12 ( 0.00%) .          .          .                   self.spec_extend(iter.into_iter())
    4,416 ( 0.00%) 6 ( 0.00%) .          .           => /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_extend.rs:<alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<&T,I>>::spec_extend (3x)
        .          .          .          .               }
        .          .          .          .           
        .          .          .          .               #[inline]
        .          .          .          .               #[track_caller]
        .          .          .          .               fn extend_one(&mut self, &item: &'a T) {
        .          .          .          .                   self.push(item);
        .          .          .          .               }
        .          .          .          .           
-- line 3728 ----------------------------------------
-- line 3766 ----------------------------------------
        .          .          .          .               #[inline]
        .          .          .          .               fn cmp(&self, other: &Self) -> Ordering {
        .          .          .          .                   Ord::cmp(&**self, &**other)
        .          .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           unsafe impl<#[may_dangle] T, A: Allocator> Drop for Vec<T, A> {
    5,801 ( 0.00%) .          .          .               fn drop(&mut self) {
        .          .          .          .                   unsafe {
        .          .          .          .                       // use drop for [T]
        .          .          .          .                       // use a raw slice to refer to the elements of the vector as weakest necessary type;
        .          .          .          .                       // could avoid questions of validity in certain cases
   35,743 ( 0.01%) .          .          .                       ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))
        .          .          .          .                   }
        .          .          .          .                   // RawVec handles deallocation
    7,564 ( 0.00%) .          .          .               }
        .          .          .          .           }
        .          .          .          .           
        .          .          .          .           #[stable(feature = "rust1", since = "1.0.0")]
        .          .          .          .           impl<T> Default for Vec<T> {
        .          .          .          .               /// Creates an empty `Vec<T>`.
        .          .          .          .               ///
        .          .          .          .               /// The vector will not allocate until elements are pushed onto it.
        .          .          .          .               fn default() -> Vec<T> {
-- line 3790 ----------------------------------------
-- line 4039 ----------------------------------------
        .          .          .          .               /// let mut v = String::from("hello world").into_bytes();
        .          .          .          .               /// v.sort();
        .          .          .          .               /// v.truncate(2);
        .          .          .          .               /// let [a, b]: [_; 2] = v.try_into().unwrap();
        .          .          .          .               /// assert_eq!(a, b' ');
        .          .          .          .               /// assert_eq!(b, b'd');
        .          .          .          .               /// ```
        .          .          .          .               fn try_from(mut vec: Vec<T, A>) -> Result<[T; N], Vec<T, A>> {
      114 ( 0.00%) .          .          .                   if vec.len() != N {
        .          .          .          .                       return Err(vec);
        .          .          .          .                   }
        .          .          .          .           
        .          .          .          .                   // SAFETY: `.set_len(0)` is always sound.
        .          .          .          .                   unsafe { vec.set_len(0) };
        .          .          .          .           
        .          .          .          .                   // SAFETY: A `Vec`'s pointer is always aligned properly, and
        .          .          .          .                   // the alignment the array needs is the same as the items.
-- line 4055 ----------------------------------------

  655,654 ( 0.20%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/lib.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 


25,845 ( 0.01%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/lib.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/take.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 29 ----------------------------------------
     .          .          .          .           impl<I> Iterator for Take<I>
     .          .          .          .           where
     .          .          .          .               I: Iterator,
     .          .          .          .           {
     .          .          .          .               type Item = <I as Iterator>::Item;
     .          .          .          .           
     .          .          .          .               #[inline]
     .          .          .          .               fn next(&mut self) -> Option<<I as Iterator>::Item> {
16,768 ( 0.01%) .          .          .                   if self.n != 0 {
     .          .          .          .                       self.n -= 1;
     .          .          .          .                       self.iter.next()
     .          .          .          .                   } else {
     .          .          .          .                       None
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
-- line 45 ----------------------------------------
-- line 80 ----------------------------------------
     .          .          .          .                   Fold: FnMut(Acc, Self::Item) -> R,
     .          .          .          .                   R: Try<Output = Acc>,
     .          .          .          .               {
     .          .          .          .                   fn check<'a, T, Acc, R: Try<Output = Acc>>(
     .          .          .          .                       n: &'a mut usize,
     .          .          .          .                       mut fold: impl FnMut(Acc, T) -> R + 'a,
     .          .          .          .                   ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {
     .          .          .          .                       move |acc, x| {
     9 ( 0.00%) .          .          .                           *n -= 1;
     .          .          .          .                           let r = fold(acc, x);
    47 ( 0.00%) .          .          .                           if *n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .           
     4 ( 0.00%) .          .          .                   if self.n == 0 {
     .          .          .          .                       try { init }
     .          .          .          .                   } else {
     .          .          .          .                       let n = &mut self.n;
     .          .          .          .                       self.iter.try_fold(init, check(n, fold)).into_try()
     .          .          .          .                   }
     .          .          .          .               }
     .          .          .          .           
     .          .          .          .               #[inline]
-- line 102 ----------------------------------------

 6,003 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/take.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs
--------------------------------------------------------------------------------
Ir               Ge sysCount sysTime 

-- line 126 ----------------------------------------
      .          .          .          .               /// to the pattern's index (starting at 0).
      .          .          .          .               Match { pattern_id: PatternID },
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           impl State {
      .          .          .          .               /// If this state is an unconditional epsilon transition, then this returns
      .          .          .          .               /// the target of the transition.
      .          .          .          .               fn goto(&self) -> Option<StateID> {
366,650 ( 0.11%) .          .          .                   match *self {
  7,812 ( 0.00%) .          .          .                       State::Empty { next } => Some(next),
      .          .          .          .                       State::Union { ref alternates } if alternates.len() == 1 => {
      .          .          .          .                           Some(alternates[0])
      .          .          .          .                       }
      .          .          .          .                       State::UnionReverse { ref alternates }
      .          .          .          .                           if alternates.len() == 1 =>
      .          .          .          .                       {
      .          .          .          .                           Some(alternates[0])
      .          .          .          .                       }
      .          .          .          .                       _ => None,
      .          .          .          .                   }
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the heap memory usage, in bytes, of this state.
      .          .          .          .               fn memory_usage(&self) -> usize {
446,285 ( 0.13%) .          .          .                   match *self {
      .          .          .          .                       State::Empty { .. }
      .          .          .          .                       | State::ByteRange { .. }
      .          .          .          .                       | State::Look { .. }
      .          .          .          .                       | State::CaptureStart { .. }
      .          .          .          .                       | State::CaptureEnd { .. }
      .          .          .          .                       | State::Fail
      .          .          .          .                       | State::Match { .. } => 0,
      .          .          .          .                       State::Sparse { ref transitions } => {
-- line 158 ----------------------------------------
-- line 363 ----------------------------------------
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Clear this builder.
      .          .          .          .               ///
      .          .          .          .               /// Clearing removes all state associated with building an NFA, but does
      .          .          .          .               /// not reset configuration (such as size limits and whether the NFA
      .          .          .          .               /// should only match UTF-8). After clearing, the builder can be reused to
      .          .          .          .               /// assemble an entirely new NFA.
  1,400 ( 0.00%) .          .          .               pub fn clear(&mut self) {
    175 ( 0.00%) .          .          .                   self.pattern_id = None;
      .          .          .          .                   self.states.clear();
      .          .          .          .                   self.start_pattern.clear();
      .          .          .          .                   self.captures.clear();
    175 ( 0.00%) .          .          .                   self.memory_states = 0;
  1,400 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Assemble a [`NFA`] from the states added so far.
      .          .          .          .               ///
      .          .          .          .               /// After building an NFA, more states may be added and `build` may be
      .          .          .          .               /// called again. To reuse a builder to produce an entirely new NFA from
      .          .          .          .               /// scratch, call the [`clear`](Builder::clear) method first.
      .          .          .          .               ///
      .          .          .          .               /// `start_anchored` refers to the ID of the starting state that anchored
-- line 385 ----------------------------------------
-- line 402 ----------------------------------------
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// If `start_pattern` was called, then `finish_pattern` must be called
      .          .          .          .               /// before `build`, otherwise this panics.
      .          .          .          .               ///
      .          .          .          .               /// This may panic for other invalid uses of a builder. For example, if
      .          .          .          .               /// a "start capture" state was added without a corresponding "end capture"
      .          .          .          .               /// state.
  1,400 ( 0.00%) .          .          .               pub fn build(
      .          .          .          .                   &self,
      .          .          .          .                   start_anchored: StateID,
      .          .          .          .                   start_unanchored: StateID,
      .          .          .          .               ) -> Result<NFA, BuildError> {
    175 ( 0.00%) .          .          .                   assert!(self.pattern_id.is_none(), "must call 'finish_pattern' first");
      .          .          .          .                   debug!(
      .          .          .          .                       "intermediate NFA compilation via builder is complete, \
      .          .          .          .                        intermediate NFA size: {} states, {} bytes on heap",
      .          .          .          .                       self.states.len(),
      .          .          .          .                       self.memory_usage(),
      .          .          .          .                   );
      .          .          .          .           
      .          .          .          .                   let mut nfa = nfa::Inner::default();
    175 ( 0.00%) .          .          .                   nfa.set_utf8(self.utf8);
    175 ( 0.00%) .          .          .                   nfa.set_reverse(self.reverse);
      .          .          .          .                   nfa.set_look_matcher(self.look_matcher.clone());
      .          .          .          .                   // A set of compiler internal state IDs that correspond to states
      .          .          .          .                   // that are exclusively epsilon transitions, i.e., goto instructions,
      .          .          .          .                   // combined with the state that they point to. This is used to
      .          .          .          .                   // record said states while transforming the compiler's internal NFA
      .          .          .          .                   // representation to the external form.
      .          .          .          .                   let mut empties = vec![];
      .          .          .          .                   // A map used to re-map state IDs when translating this builder's
-- line 433 ----------------------------------------
-- line 438 ----------------------------------------
      .          .          .          .                   nfa.set_starts(start_anchored, start_unanchored, &self.start_pattern);
      .          .          .          .                   nfa.set_captures(&self.captures).map_err(BuildError::captures)?;
      .          .          .          .                   // The idea here is to convert our intermediate states to their final
      .          .          .          .                   // form. The only real complexity here is the process of converting
      .          .          .          .                   // transitions, which are expressed in terms of state IDs. The new
      .          .          .          .                   // set of states will be smaller because of partial epsilon removal,
      .          .          .          .                   // so the state IDs will not be the same.
      .          .          .          .                   for (sid, state) in self.states.iter().with_state_ids() {
446,285 ( 0.13%) .          .          .                       match *state {
 10,258 ( 0.00%) .          .          .                           State::Empty { next } => {
      .          .          .          .                               // Since we're removing empty states, we need to handle
      .          .          .          .                               // them later since we don't yet know which new state this
      .          .          .          .                               // empty state will be mapped to.
      .          .          .          .                               empties.push((sid, next));
      .          .          .          .                           }
 42,560 ( 0.01%) .          .          .                           State::ByteRange { trans } => {
212,800 ( 0.06%) .          .          .                               remap[sid] = nfa.add(nfa::State::ByteRange { trans });
3,744,497 ( 1.12%) 2,091 ( 0.26%) 3 ( 1.00%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (42,560x)
      .          .          .          .                           }
      .          .          .          .                           State::Sparse { ref transitions } => {
 53,112 ( 0.02%) .          .          .                               remap[sid] = match transitions.len() {
      .          .          .          .                                   0 => nfa.add(nfa::State::Fail),
  8,652 ( 0.00%) .          .          .                                   1 => nfa.add(nfa::State::ByteRange {
  2,884 ( 0.00%) .          .          .                                       trans: transitions[0],
      .          .          .          .                                   }),
      .          .          .          .                                   _ => {
      .          .          .          .                                       let transitions =
      .          .          .          .                                           transitions.to_vec().into_boxed_slice();
      .          .          .          .                                       let sparse = SparseTransitions { transitions };
 31,182 ( 0.01%) .          .          .                                       nfa.add(nfa::State::Sparse(sparse))
      .          .          .          .                                   }
      .          .          .          .                               }
      .          .          .          .                           }
    245 ( 0.00%) .          .          .                           State::Look { look, next } => {
  1,225 ( 0.00%) .          .          .                               remap[sid] = nfa.add(nfa::State::Look { look, next });
 51,064 ( 0.02%) 32 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (245x)
      .          .          .          .                           }
    774 ( 0.00%) .          .          .                           State::CaptureStart { pattern_id, group_index, next } => {
      .          .          .          .                               // We can't remove this empty state because of the side
      .          .          .          .                               // effect of capturing an offset for this capture slot.
    774 ( 0.00%) .          .          .                               let slot = nfa
      .          .          .          .                                   .group_info()
      .          .          .          .                                   .slot(pattern_id, group_index.as_usize())
      .          .          .          .                                   .expect("invalid capture index");
      .          .          .          .                               let slot =
      .          .          .          .                                   SmallIndex::new(slot).expect("a small enough slot");
  6,192 ( 0.00%) .          .          .                               remap[sid] = nfa.add(nfa::State::Capture {
 49,446 ( 0.01%) 50 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (774x)
      .          .          .          .                                   next,
      .          .          .          .                                   pattern_id,
      .          .          .          .                                   group_index,
      .          .          .          .                                   slot,
      .          .          .          .                               });
      .          .          .          .                           }
    774 ( 0.00%) .          .          .                           State::CaptureEnd { pattern_id, group_index, next } => {
      .          .          .          .                               // We can't remove this empty state because of the side
      .          .          .          .                               // effect of capturing an offset for this capture slot.
      .          .          .          .                               // Also, this always succeeds because we check that all
      .          .          .          .                               // slot indices are valid for all capture indices when they
      .          .          .          .                               // are initially added.
    774 ( 0.00%) .          .          .                               let slot = nfa
      .          .          .          .                                   .group_info()
      .          .          .          .                                   .slot(pattern_id, group_index.as_usize())
      .          .          .          .                                   .expect("invalid capture index")
      .          .          .          .                                   .checked_add(1)
      .          .          .          .                                   .unwrap();
      .          .          .          .                               let slot =
      .          .          .          .                                   SmallIndex::new(slot).expect("a small enough slot");
  6,192 ( 0.00%) .          .          .                               remap[sid] = nfa.add(nfa::State::Capture {
 41,765 ( 0.01%) 76 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (774x)
      .          .          .          .                                   next,
      .          .          .          .                                   pattern_id,
      .          .          .          .                                   group_index,
      .          .          .          .                                   slot,
      .          .          .          .                               });
      .          .          .          .                           }
      .          .          .          .                           State::Union { ref alternates } => {
114,084 ( 0.03%) .          .          .                               if alternates.is_empty() {
      .          .          .          .                                   remap[sid] = nfa.add(nfa::State::Fail);
      .          .          .          .                               } else if alternates.len() == 1 {
 14,585 ( 0.00%) .          .          .                                   empties.push((sid, alternates[0]));
      .          .          .          .                                   remap[sid] = alternates[0];
      .          .          .          .                               } else if alternates.len() == 2 {
 25,190 ( 0.01%) .          .          .                                   remap[sid] = nfa.add(nfa::State::BinaryUnion {
368,208 ( 0.11%) 557 ( 0.07%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (5,038x)
  5,038 ( 0.00%) .          .          .                                       alt1: alternates[0],
      .          .          .          .                                       alt2: alternates[1],
      .          .          .          .                                   });
      .          .          .          .                               } else {
      .          .          .          .                                   let alternates =
      .          .          .          .                                       alternates.to_vec().into_boxed_slice();
  8,760 ( 0.00%) .          .          .                                   remap[sid] = nfa.add(nfa::State::Union { alternates });
104,664 ( 0.03%) 70 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (1,460x)
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                           State::UnionReverse { ref alternates } => {
    660 ( 0.00%) .          .          .                               if alternates.is_empty() {
      .          .          .          .                                   remap[sid] = nfa.add(nfa::State::Fail);
      .          .          .          .                               } else if alternates.len() == 1 {
      .          .          .          .                                   empties.push((sid, alternates[0]));
      .          .          .          .                                   remap[sid] = alternates[0];
      .          .          .          .                               } else if alternates.len() == 2 {
    660 ( 0.00%) .          .          .                                   remap[sid] = nfa.add(nfa::State::BinaryUnion {
 18,974 ( 0.01%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (110x)
      .          .          .          .                                       alt1: alternates[1],
    110 ( 0.00%) .          .          .                                       alt2: alternates[0],
      .          .          .          .                                   });
      .          .          .          .                               } else {
      .          .          .          .                                   let mut alternates =
      .          .          .          .                                       alternates.to_vec().into_boxed_slice();
      .          .          .          .                                   alternates.reverse();
      .          .          .          .                                   remap[sid] = nfa.add(nfa::State::Union { alternates });
      .          .          .          .                               }
      .          .          .          .                           }
      .          .          .          .                           State::Fail => {
      .          .          .          .                               remap[sid] = nfa.add(nfa::State::Fail);
      .          .          .          .                           }
    175 ( 0.00%) .          .          .                           State::Match { pattern_id } => {
    875 ( 0.00%) .          .          .                               remap[sid] = nfa.add(nfa::State::Match { pattern_id });
  8,979 ( 0.00%) 2 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::add (175x)
      .          .          .          .                           }
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // Some of the new states still point to empty state IDs, so we need to
      .          .          .          .                   // follow each of them and remap the empty state IDs to their non-empty
      .          .          .          .                   // state IDs.
      .          .          .          .                   //
      .          .          .          .                   // We also keep track of which states we've already mapped. This helps
      .          .          .          .                   // avoid quadratic behavior in a long chain of empty states. For
      .          .          .          .                   // example, in 'a{0}{50000}'.
      .          .          .          .                   let mut remapped = vec![false; self.states.len()];
 25,193 ( 0.01%) .          .          .                   for &(empty_id, empty_next) in empties.iter() {
 49,686 ( 0.01%) .          .          .                       if remapped[empty_id] {
      .          .          .          .                           continue;
      .          .          .          .                       }
      .          .          .          .                       // empty states can point to other empty states, forming a chain.
      .          .          .          .                       // So we must follow the chain until the end, which must end at
      .          .          .          .                       // a non-empty state, and therefore, a state that is correctly
      .          .          .          .                       // remapped. We are guaranteed to terminate because our compiler
      .          .          .          .                       // never builds a loop among only empty states.
      .          .          .          .                       let mut new_next = empty_next;
      .          .          .          .                       while let Some(next) = self.states[new_next].goto() {
      .          .          .          .                           new_next = next;
      .          .          .          .                       }
 47,708 ( 0.01%) .          .          .                       remap[empty_id] = remap[new_next];
 47,708 ( 0.01%) .          .          .                       remapped[empty_id] = true;
      .          .          .          .           
      .          .          .          .                       // Now that we've remapped the main 'empty_id' above, we re-follow
      .          .          .          .                       // the chain from above and remap every empty state we found along
      .          .          .          .                       // the way to our ultimate non-empty target. We are careful to set
      .          .          .          .                       // 'remapped' to true for each such state. We thus will not need
      .          .          .          .                       // to re-compute this chain for any subsequent empty states in
      .          .          .          .                       // 'empties' that are part of this chain.
      .          .          .          .                       let mut next2 = empty_next;
      .          .          .          .                       while let Some(next) = self.states[next2].goto() {
  5,694 ( 0.00%) .          .          .                           remap[next2] = remap[new_next];
  2,847 ( 0.00%) .          .          .                           remapped[next2] = true;
      .          .          .          .                           next2 = next;
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // Finally remap all of the state IDs.
    700 ( 0.00%) .          .          .                   nfa.remap(&remap);
1,236,667 ( 0.37%) .          .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::remap (175x)
  1,050 ( 0.00%) .          .          .                   let final_nfa = nfa.into_nfa();
1,694,769 ( 0.51%) 1,802 ( 0.22%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/nfa.rs:regex_automata::nfa::thompson::nfa::Inner::into_nfa (175x)
 11,375 ( 0.00%) .          .          .           => ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (175x)
      .          .          .          .                   debug!(
      .          .          .          .                       "NFA compilation via builder complete, \
      .          .          .          .                        final NFA size: {} states, {} bytes on heap, \
      .          .          .          .                        has empty? {:?}, utf8? {:?}",
      .          .          .          .                       final_nfa.states().len(),
      .          .          .          .                       final_nfa.memory_usage(),
      .          .          .          .                       final_nfa.has_empty(),
      .          .          .          .                       final_nfa.is_utf8(),
      .          .          .          .                   );
    700 ( 0.00%) .          .          .                   Ok(final_nfa)
  1,575 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Start the assembly of a pattern in this NFA.
      .          .          .          .               ///
      .          .          .          .               /// Upon success, this returns the identifier for the new pattern.
      .          .          .          .               /// Identifiers start at `0` and are incremented by 1 for each new pattern.
      .          .          .          .               ///
      .          .          .          .               /// It is necessary to call this routine before adding capturing states.
      .          .          .          .               /// Otherwise, any other NFA state may be added before starting a pattern.
-- line 611 ----------------------------------------
-- line 615 ----------------------------------------
      .          .          .          .               /// If the pattern identifier space is exhausted, then this returns an
      .          .          .          .               /// error.
      .          .          .          .               ///
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// If this is called while assembling another pattern (i.e., before
      .          .          .          .               /// `finish_pattern` is called), then this panics.
      .          .          .          .               pub fn start_pattern(&mut self) -> Result<PatternID, BuildError> {
    175 ( 0.00%) .          .          .                   assert!(self.pattern_id.is_none(), "must call 'finish_pattern' first");
      .          .          .          .           
      .          .          .          .                   let proposed = self.start_pattern.len();
      .          .          .          .                   let pid = PatternID::new(proposed)
      .          .          .          .                       .map_err(|_| BuildError::too_many_patterns(proposed))?;
    350 ( 0.00%) .          .          .                   self.pattern_id = Some(pid);
      .          .          .          .                   // This gets filled in when 'finish_pattern' is called.
      .          .          .          .                   self.start_pattern.push(StateID::ZERO);
      .          .          .          .                   Ok(pid)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Finish the assembly of a pattern in this NFA.
      .          .          .          .               ///
      .          .          .          .               /// Upon success, this returns the identifier for the new pattern.
-- line 636 ----------------------------------------
-- line 650 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// If this is called without a corresponding `start_pattern` call, then
      .          .          .          .               /// this panics.
      .          .          .          .               pub fn finish_pattern(
      .          .          .          .                   &mut self,
      .          .          .          .                   start_id: StateID,
      .          .          .          .               ) -> Result<PatternID, BuildError> {
      .          .          .          .                   let pid = self.current_pattern_id();
    175 ( 0.00%) .          .          .                   self.start_pattern[pid] = start_id;
    175 ( 0.00%) .          .          .                   self.pattern_id = None;
      .          .          .          .                   Ok(pid)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the pattern identifier of the current pattern.
      .          .          .          .               ///
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// If this doesn't occur after a `start_pattern` call and before the
      .          .          .          .               /// corresponding `finish_pattern` call, then this panics.
      .          .          .          .               pub fn current_pattern_id(&self) -> PatternID {
  1,124 ( 0.00%) .          .          .                   self.pattern_id.expect("must call 'start_pattern' first")
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the number of patterns added to this builder so far.
      .          .          .          .               ///
      .          .          .          .               /// This only includes patterns that have had `finish_pattern` called
      .          .          .          .               /// for them.
      .          .          .          .               pub fn pattern_len(&self) -> usize {
      .          .          .          .                   self.start_pattern.len()
-- line 678 ----------------------------------------
-- line 685 ----------------------------------------
      .          .          .          .               /// building the final [`NFA`] (which has no such "empty" states), but they
      .          .          .          .               /// can be quite useful in the construction process of an NFA.
      .          .          .          .               ///
      .          .          .          .               /// # Errors
      .          .          .          .               ///
      .          .          .          .               /// This returns an error if the state identifier space is exhausted, or if
      .          .          .          .               /// the configured heap size limit has been exceeded.
      .          .          .          .               pub fn add_empty(&mut self) -> Result<StateID, BuildError> {
 51,054 ( 0.02%) .          .          .                   self.add(State::Empty { next: StateID::ZERO })
 34,740 ( 0.01%) 84 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (539x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add a "union" NFA state.
      .          .          .          .               ///
      .          .          .          .               /// A "union" NFA state that contains zero or more unconditional epsilon
      .          .          .          .               /// transitions to other NFA states. The order of these transitions
      .          .          .          .               /// reflects a priority order where earlier transitions are preferred over
      .          .          .          .               /// later transitions.
-- line 701 ----------------------------------------
-- line 709 ----------------------------------------
      .          .          .          .               /// # Errors
      .          .          .          .               ///
      .          .          .          .               /// This returns an error if the state identifier space is exhausted, or if
      .          .          .          .               /// the configured heap size limit has been exceeded.
      .          .          .          .               pub fn add_union(
      .          .          .          .                   &mut self,
      .          .          .          .                   alternates: Vec<StateID>,
      .          .          .          .               ) -> Result<StateID, BuildError> {
107,413 ( 0.03%) .          .          .                   self.add(State::Union { alternates })
 41,299 ( 0.01%) 94 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (539x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add a "reverse union" NFA state.
      .          .          .          .               ///
      .          .          .          .               /// A "reverse union" NFA state contains zero or more unconditional epsilon
      .          .          .          .               /// transitions to other NFA states. The order of these transitions
      .          .          .          .               /// reflects a priority order where later transitions are preferred
      .          .          .          .               /// over earlier transitions. This is an inverted priority order when
-- line 725 ----------------------------------------
-- line 735 ----------------------------------------
      .          .          .          .               /// # Errors
      .          .          .          .               ///
      .          .          .          .               /// This returns an error if the state identifier space is exhausted, or if
      .          .          .          .               /// the configured heap size limit has been exceeded.
      .          .          .          .               pub fn add_union_reverse(
      .          .          .          .                   &mut self,
      .          .          .          .                   alternates: Vec<StateID>,
      .          .          .          .               ) -> Result<StateID, BuildError> {
    440 ( 0.00%) .          .          .                   self.add(State::UnionReverse { alternates })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add a "range" NFA state.
      .          .          .          .               ///
      .          .          .          .               /// A "range" NFA state is a state with one outgoing transition to another
      .          .          .          .               /// state, where that transition may only be followed if the current input
      .          .          .          .               /// byte falls between a range of bytes given.
      .          .          .          .               ///
-- line 751 ----------------------------------------
-- line 752 ----------------------------------------
      .          .          .          .               /// # Errors
      .          .          .          .               ///
      .          .          .          .               /// This returns an error if the state identifier space is exhausted, or if
      .          .          .          .               /// the configured heap size limit has been exceeded.
      .          .          .          .               pub fn add_range(
      .          .          .          .                   &mut self,
      .          .          .          .                   trans: Transition,
      .          .          .          .               ) -> Result<StateID, BuildError> {
215,002 ( 0.06%) .          .          .                   self.add(State::ByteRange { trans })
2,512,403 ( 0.75%) 1,849 ( 0.23%) 1 ( 0.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (32,051x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add a "sparse" NFA state.
      .          .          .          .               ///
      .          .          .          .               /// A "sparse" NFA state contains zero or more outgoing transitions, where
      .          .          .          .               /// the transition to be followed (if any) is chosen based on whether the
      .          .          .          .               /// current input byte falls in the range of one such transition. The
      .          .          .          .               /// transitions given *must* be non-overlapping and in ascending order. (A
-- line 768 ----------------------------------------
-- line 789 ----------------------------------------
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// This routine _may_ panic if the transitions given overlap or are not
      .          .          .          .               /// in ascending order.
      .          .          .          .               pub fn add_sparse(
      .          .          .          .                   &mut self,
      .          .          .          .                   transitions: Vec<Transition>,
      .          .          .          .               ) -> Result<StateID, BuildError> {
 62,593 ( 0.02%) .          .          .                   self.add(State::Sparse { transitions })
 78,526 ( 0.02%) 66 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (773x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add a "look" NFA state.
      .          .          .          .               ///
      .          .          .          .               /// A "look" NFA state corresponds to a state with exactly one
      .          .          .          .               /// *conditional* epsilon transition to another NFA state. Namely, it
      .          .          .          .               /// represents one of a small set of simplistic look-around operators.
      .          .          .          .               ///
-- line 805 ----------------------------------------
-- line 810 ----------------------------------------
      .          .          .          .               ///
      .          .          .          .               /// This returns an error if the state identifier space is exhausted, or if
      .          .          .          .               /// the configured heap size limit has been exceeded.
      .          .          .          .               pub fn add_look(
      .          .          .          .                   &mut self,
      .          .          .          .                   next: StateID,
      .          .          .          .                   look: Look,
      .          .          .          .               ) -> Result<StateID, BuildError> {
    490 ( 0.00%) .          .          .                   self.add(State::Look { look, next })
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add a "start capture" NFA state.
      .          .          .          .               ///
      .          .          .          .               /// A "start capture" NFA state corresponds to a state with exactly one
      .          .          .          .               /// outgoing unconditional epsilon transition to another state. Unlike
      .          .          .          .               /// "empty" states, a "start capture" state also carries with it an
      .          .          .          .               /// instruction for saving the current position of input to a particular
-- line 826 ----------------------------------------
-- line 983 ----------------------------------------
      .          .          .          .               /// assert_eq!(Some(PatternID::must(1)), caps[3].pattern());
      .          .          .          .               /// assert_eq!(Some(Span::from(7..8)), caps[3].get_group_by_name("foo"));
      .          .          .          .               ///
      .          .          .          .               /// assert_eq!(Some(PatternID::must(1)), caps[4].pattern());
      .          .          .          .               /// assert_eq!(Some(Span::from(8..9)), caps[4].get_group_by_name("foo"));
      .          .          .          .               ///
      .          .          .          .               /// # Ok::<(), Box<dyn std::error::Error>>(())
      .          .          .          .               /// ```
  6,966 ( 0.00%) .          .          .               pub fn add_capture_start(
      .          .          .          .                   &mut self,
      .          .          .          .                   next: StateID,
      .          .          .          .                   group_index: u32,
      .          .          .          .                   name: Option<Arc<str>>,
      .          .          .          .               ) -> Result<StateID, BuildError> {
      .          .          .          .                   let pid = self.current_pattern_id();
    774 ( 0.00%) .          .          .                   let group_index = match SmallIndex::try_from(group_index) {
      .          .          .          .                       Err(_) => {
      .          .          .          .                           return Err(BuildError::invalid_capture_index(group_index))
      .          .          .          .                       }
      .          .          .          .                       Ok(group_index) => group_index,
      .          .          .          .                   };
      .          .          .          .                   // Make sure we have space to insert our (pid,index)|-->name mapping.
  1,548 ( 0.00%) .          .          .                   if pid.as_usize() >= self.captures.len() {
      .          .          .          .                       for _ in 0..=(pid.as_usize() - self.captures.len()) {
      .          .          .          .                           self.captures.push(vec![]);
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   // In the case where 'group_index < self.captures[pid].len()', it means
      .          .          .          .                   // that we are adding a duplicate capture group. This is somewhat
      .          .          .          .                   // weird, but permissible because the capture group itself can be
      .          .          .          .                   // repeated in the syntax. For example, '([a-z]){4}' will produce 4
      .          .          .          .                   // capture groups. In practice, only the last will be set at search
      .          .          .          .                   // time when a match occurs. For duplicates, we don't need to push
      .          .          .          .                   // anything other than a CaptureStart NFA state.
  2,322 ( 0.00%) .          .          .                   if group_index.as_usize() >= self.captures[pid].len() {
      .          .          .          .                       // For discontiguous indices, push placeholders for earlier capture
      .          .          .          .                       // groups that weren't explicitly added.
      .          .          .          .                       for _ in 0..(group_index.as_usize() - self.captures[pid].len()) {
      .          .          .          .                           self.captures[pid].push(None);
      .          .          .          .                       }
  1,548 ( 0.00%) .          .          .                       self.captures[pid].push(name);
      .          .          .          .                   }
  8,514 ( 0.00%) .          .          .                   self.add(State::CaptureStart { pattern_id: pid, group_index, next })
 51,420 ( 0.02%) 52 ( 0.01%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (774x)
  6,966 ( 0.00%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add a "end capture" NFA state.
      .          .          .          .               ///
      .          .          .          .               /// A "end capture" NFA state corresponds to a state with exactly one
      .          .          .          .               /// outgoing unconditional epsilon transition to another state. Unlike
      .          .          .          .               /// "empty" states, a "end capture" state also carries with it an
      .          .          .          .               /// instruction for saving the current position of input to a particular
      .          .          .          .               /// location in memory. NFA simulations, like the Pike VM, may use this
-- line 1034 ----------------------------------------
-- line 1062 ----------------------------------------
      .          .          .          .               ) -> Result<StateID, BuildError> {
      .          .          .          .                   let pid = self.current_pattern_id();
      .          .          .          .                   let group_index = match SmallIndex::try_from(group_index) {
      .          .          .          .                       Err(_) => {
      .          .          .          .                           return Err(BuildError::invalid_capture_index(group_index))
      .          .          .          .                       }
      .          .          .          .                       Ok(group_index) => group_index,
      .          .          .          .                   };
  6,192 ( 0.00%) .          .          .                   self.add(State::CaptureEnd { pattern_id: pid, group_index, next })
  7,431 ( 0.00%) 12 ( 0.00%) .          .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (81x)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Adds a "fail" NFA state.
      .          .          .          .               ///
      .          .          .          .               /// A "fail" state is simply a state that has no outgoing transitions. It
      .          .          .          .               /// acts as a way to cause a search to stop without reporting a match.
      .          .          .          .               /// For example, one way to represent an NFA with zero patterns is with a
      .          .          .          .               /// single "fail" state.
-- line 1078 ----------------------------------------
-- line 1099 ----------------------------------------
      .          .          .          .               /// the configured heap size limit has been exceeded.
      .          .          .          .               ///
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// This must be called after a `start_pattern` call but before the
      .          .          .          .               /// corresponding `finish_pattern` call. Otherwise, it panics.
      .          .          .          .               pub fn add_match(&mut self) -> Result<StateID, BuildError> {
      .          .          .          .                   let pattern_id = self.current_pattern_id();
  1,050 ( 0.00%) .          .          .                   let sid = self.add(State::Match { pattern_id })?;
 10,318 ( 0.00%) 12 ( 0.00%) 1 ( 0.33%) .           => /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs:regex_automata::nfa::thompson::builder::Builder::add (175x)
      .          .          .          .                   Ok(sid)
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// The common implementation of "add a state." It handles the common
      .          .          .          .               /// error cases of state ID exhausting (by owning state ID allocation) and
      .          .          .          .               /// whether the size limit has been exceeded.
446,285 ( 0.13%) .          .          .               fn add(&mut self, state: State) -> Result<StateID, BuildError> {
      .          .          .          .                   let id = StateID::new(self.states.len())
      .          .          .          .                       .map_err(|_| BuildError::too_many_states(self.states.len()))?;
 89,257 ( 0.03%) .          .          .                   self.memory_states += state.memory_usage();
      .          .          .          .                   self.states.push(state);
      .          .          .          .                   self.check_size_limit()?;
357,028 ( 0.11%) .          .          .                   Ok(id)
535,542 ( 0.16%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Add a transition from one state to another.
      .          .          .          .               ///
      .          .          .          .               /// This routine is called "patch" since it is very common to add the
      .          .          .          .               /// states you want, typically with "dummy" state ID transitions, and then
      .          .          .          .               /// "patch" in the real state IDs later. This is because you don't always
      .          .          .          .               /// know all of the necessary state IDs to add because they might not
      .          .          .          .               /// exist yet.
-- line 1129 ----------------------------------------
-- line 1135 ----------------------------------------
      .          .          .          .               /// new transition (as in the case of a "union" state).
      .          .          .          .               ///
      .          .          .          .               /// # Panics
      .          .          .          .               ///
      .          .          .          .               /// This panics if `from` corresponds to a "sparse" state. When "sparse"
      .          .          .          .               /// states are added, there is no way to patch them after-the-fact. (If you
      .          .          .          .               /// have a use case where this would be helpful, please file an issue. It
      .          .          .          .               /// will likely require a new API.)
420,357 ( 0.13%) .          .          .               pub fn patch(
      .          .          .          .                   &mut self,
      .          .          .          .                   from: StateID,
      .          .          .          .                   to: StateID,
      .          .          .          .               ) -> Result<(), BuildError> {
      .          .          .          .                   let old_memory_states = self.memory_states;
300,255 ( 0.09%) .          .          .                   match self.states[from] {
      .          .          .          .                       State::Empty { ref mut next } => {
      .          .          .          .                           *next = to;
      .          .          .          .                       }
      .          .          .          .                       State::ByteRange { ref mut trans } => {
      .          .          .          .                           trans.next = to;
      .          .          .          .                       }
      .          .          .          .                       State::Sparse { .. } => {
      .          .          .          .                           panic!("cannot patch from a sparse NFA state")
-- line 1157 ----------------------------------------
-- line 1174 ----------------------------------------
      .          .          .          .                           *next = to;
      .          .          .          .                       }
      .          .          .          .                       State::Fail => {}
      .          .          .          .                       State::Match { .. } => {}
      .          .          .          .                   }
      .          .          .          .                   if old_memory_states != self.memory_states {
      .          .          .          .                       self.check_size_limit()?;
      .          .          .          .                   }
120,102 ( 0.04%) .          .          .                   Ok(())
540,459 ( 0.16%) .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Set whether the NFA produced by this builder should only match UTF-8.
      .          .          .          .               ///
      .          .          .          .               /// This should be set when both of the following are true:
      .          .          .          .               ///
      .          .          .          .               /// 1. The caller guarantees that the NFA created by this build will only
      .          .          .          .               /// report non-empty matches with spans that are valid UTF-8.
      .          .          .          .               /// 2. The caller desires regex engines using this NFA to avoid reporting
-- line 1191 ----------------------------------------
-- line 1212 ----------------------------------------
      .          .          .          .               /// UTF-8, you almost certainly do not want to enable this option.
      .          .          .          .               /// Similarly, if you are running the NFA on strings that *are* guaranteed
      .          .          .          .               /// to be valid UTF-8, then you almost certainly want to enable this option
      .          .          .          .               /// unless you can guarantee that your NFA will never produce a zero-width
      .          .          .          .               /// match.
      .          .          .          .               ///
      .          .          .          .               /// It is disabled by default.
      .          .          .          .               pub fn set_utf8(&mut self, yes: bool) {
    175 ( 0.00%) .          .          .                   self.utf8 = yes;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns whether UTF-8 mode is enabled for this builder.
      .          .          .          .               ///
      .          .          .          .               /// See [`Builder::set_utf8`] for more details about what "UTF-8 mode" is.
      .          .          .          .               pub fn get_utf8(&self) -> bool {
      .          .          .          .                   self.utf8
      .          .          .          .               }
-- line 1228 ----------------------------------------
-- line 1232 ----------------------------------------
      .          .          .          .               /// should be matched by moving backwards through a haystack, from a higher
      .          .          .          .               /// memory address to a lower memory address.
      .          .          .          .               ///
      .          .          .          .               /// See also [`NFA::is_reverse`] for more details.
      .          .          .          .               ///
      .          .          .          .               /// This is disabled by default, which means NFAs are by default matched
      .          .          .          .               /// in the forward direction.
      .          .          .          .               pub fn set_reverse(&mut self, yes: bool) {
    350 ( 0.00%) .          .          .                   self.reverse = yes;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns whether reverse mode is enabled for this builder.
      .          .          .          .               ///
      .          .          .          .               /// See [`Builder::set_reverse`] for more details about what "reverse mode"
      .          .          .          .               /// is.
      .          .          .          .               pub fn get_reverse(&self) -> bool {
      .          .          .          .                   self.reverse
-- line 1248 ----------------------------------------
-- line 1250 ----------------------------------------
      .          .          .          .           
      .          .          .          .               /// Sets the look-around matcher that should be used for the resulting NFA.
      .          .          .          .               ///
      .          .          .          .               /// A look-around matcher can be used to configure how look-around
      .          .          .          .               /// assertions are matched. For example, a matcher might carry
      .          .          .          .               /// configuration that changes the line terminator used for `(?m:^)` and
      .          .          .          .               /// `(?m:$)` assertions.
      .          .          .          .               pub fn set_look_matcher(&mut self, m: LookMatcher) {
    175 ( 0.00%) .          .          .                   self.look_matcher = m;
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Returns the look-around matcher used for this builder.
      .          .          .          .               ///
      .          .          .          .               /// If a matcher was not explicitly set, then `LookMatcher::default()` is
      .          .          .          .               /// returned.
      .          .          .          .               pub fn get_look_matcher(&self) -> &LookMatcher {
      .          .          .          .                   &self.look_matcher
-- line 1266 ----------------------------------------
-- line 1272 ----------------------------------------
      .          .          .          .               /// fits within the given size limit. If it doesn't, then an error is
      .          .          .          .               /// returned.
      .          .          .          .               ///
      .          .          .          .               /// By default, there is no configured size limit.
      .          .          .          .               pub fn set_size_limit(
      .          .          .          .                   &mut self,
      .          .          .          .                   limit: Option<usize>,
      .          .          .          .               ) -> Result<(), BuildError> {
    350 ( 0.00%) .          .          .                   self.size_limit = limit;
      .          .          .          .                   self.check_size_limit()
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               /// Return the currently configured size limit.
      .          .          .          .               ///
      .          .          .          .               /// By default, this returns `None`, which corresponds to no configured
      .          .          .          .               /// size limit.
      .          .          .          .               pub fn get_size_limit(&self) -> Option<usize> {
-- line 1288 ----------------------------------------
-- line 1292 ----------------------------------------
      .          .          .          .               /// Returns the heap memory usage, in bytes, used by the NFA states added
      .          .          .          .               /// so far.
      .          .          .          .               ///
      .          .          .          .               /// Note that this is an approximation of how big the final NFA will be.
      .          .          .          .               /// In practice, the final NFA will likely be a bit smaller because of
      .          .          .          .               /// its simpler state representation. (For example, using things like
      .          .          .          .               /// `Box<[StateID]>` instead of `Vec<StateID>`.)
      .          .          .          .               pub fn memory_usage(&self) -> usize {
210,762 ( 0.06%) .          .          .                   self.states.len() * mem::size_of::<State>() + self.memory_states
      .          .          .          .               }
      .          .          .          .           
      .          .          .          .               fn check_size_limit(&self) -> Result<(), BuildError> {
315,968 ( 0.09%) .          .          .                   if let Some(limit) = self.size_limit {
210,762 ( 0.06%) .          .          .                       if self.memory_usage() > limit {
      .          .          .          .                           return Err(BuildError::exceeded_size_limit(limit));
      .          .          .          .                       }
      .          .          .          .                   }
      .          .          .          .                   Ok(())
      .          .          .          .               }
      .          .          .          .           }
      .          .          .          .           
      .          .          .          .           #[cfg(test)]
-- line 1313 ----------------------------------------

882,133 ( 0.26%) .          .          .           <counts for unidentified lines in /home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/regex-automata-0.4.11/src/nfa/thompson/builder.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/accum.rs
--------------------------------------------------------------------------------
Ir              Ge sysCount sysTime 

-- line 45 ----------------------------------------
     .          .          .          .           macro_rules! integer_sum_product {
     .          .          .          .               (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(
     .          .          .          .                   #[$attr]
     .          .          .          .                   impl Sum for $a {
     .          .          .          .                       fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
     .          .          .          .                           iter.fold(
     .          .          .          .                               $zero,
     .          .          .          .                               #[rustc_inherit_overflow_checks]
33,718 ( 0.01%) .          .          .                               |a, b| a + b,
     .          .          .          .                           )
     .          .          .          .                       }
     .          .          .          .                   }
     .          .          .          .           
     .          .          .          .                   #[$attr]
     .          .          .          .                   impl Product for $a {
     .          .          .          .                       fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
     .          .          .          .                           iter.fold(
-- line 61 ----------------------------------------

   528 ( 0.00%) .          .          .           <counts for unidentified lines in /home/.rustup/toolchains/1.85.0-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/accum.rs>

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/../sysdeps/generic/dl-new-hash.h
  ./elf/../sysdeps/x86_64/dl-machine.h
  ./elf/./elf/dl-lookup.c
  ./elf/./elf/dl-reloc.c
  ./elf/./elf/dl-tunables.c
  ./elf/./elf/do-rel.h
  ./malloc/../string/bits/string_fortified.h
  ./malloc/./malloc/arena.c
  ./malloc/./malloc/malloc.c
  ./stdio-common/./stdio-common/vfscanf-internal.c
  ./stdlib/../stdlib/strtol_l.c
  ./string/../sysdeps/x86_64/multiarch/../multiarch/strcmp-sse2.S
  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
  /rust/deps/hashbrown-0.15.2/src/control/bitmask.rs
  /rust/deps/hashbrown-0.15.2/src/control/tag.rs
  /rust/deps/hashbrown-0.15.2/src/map.rs
  /rust/deps/hashbrown-0.15.2/src/raw/mod.rs
  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/raw_vec.rs
  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/alloc/src/string.rs
  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/alloc/layout.rs
  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/fmt/mod.rs
  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/num/uint_macros.rs
  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/slice/iter/macros.rs
  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/str/converts.rs
  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/str/validations.rs
  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/alloc.rs
  /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/sys/alloc/unix.rs

--------------------------------------------------------------------------------
Ir                   Ge sysCount sysTime 
--------------------------------------------------------------------------------
146,271,967 (43.91%) .          .          .           events annotated

